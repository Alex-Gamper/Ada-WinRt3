--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.UI.Text.Core;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Data.Text is

   package IAsyncOperation_GenericObject is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.GenericObject);
   package AsyncOperationCompletedHandler_GenericObject is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.GenericObject);

   package IAsyncOperation_HString is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.HString);
   package AsyncOperationCompletedHandler_HString is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.HString);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AlternateWordForm

   procedure Initialize (this : in out AlternateWordForm) is
   begin
      null;
   end;

   procedure Finalize (this : in out AlternateWordForm) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAlternateWordForm, IAlternateWordForm_Ptr);
   begin
      if this.m_IAlternateWordForm /= null then
         if this.m_IAlternateWordForm.all /= null then
            RefCount := this.m_IAlternateWordForm.all.Release;
            Free (this.m_IAlternateWordForm);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AlternateWordForm

   function get_SourceTextSegment
   (
      this : in out AlternateWordForm
   )
   return WinRt.Windows.Data.Text.TextSegment is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Data.Text.TextSegment;
   begin
      Hr := this.m_IAlternateWordForm.all.get_SourceTextSegment (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AlternateText
   (
      this : in out AlternateWordForm
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAlternateWordForm.all.get_AlternateText (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_NormalizationFormat
   (
      this : in out AlternateWordForm
   )
   return WinRt.Windows.Data.Text.AlternateNormalizationFormat is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Data.Text.AlternateNormalizationFormat;
   begin
      Hr := this.m_IAlternateWordForm.all.get_NormalizationFormat (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectableWordSegment

   procedure Initialize (this : in out SelectableWordSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectableWordSegment) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectableWordSegment, ISelectableWordSegment_Ptr);
   begin
      if this.m_ISelectableWordSegment /= null then
         if this.m_ISelectableWordSegment.all /= null then
            RefCount := this.m_ISelectableWordSegment.all.Release;
            Free (this.m_ISelectableWordSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectableWordSegment

   function get_Text
   (
      this : in out SelectableWordSegment
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISelectableWordSegment.all.get_Text (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SourceTextSegment
   (
      this : in out SelectableWordSegment
   )
   return WinRt.Windows.Data.Text.TextSegment is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Data.Text.TextSegment;
   begin
      Hr := this.m_ISelectableWordSegment.all.get_SourceTextSegment (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SelectableWordSegmentsTokenizingHandler

   function Invoke
   (
      this : access SelectableWordSegmentsTokenizingHandler_Delegate;
      precedingWords : GenericObject;
      words : GenericObject
   )
   return WinRt.Hresult is
      Hr : WinRt.HResult := S_OK;
   begin
      this.Callback (precedingWords, words);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectableWordsSegmenter

   procedure Initialize (this : in out SelectableWordsSegmenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectableWordsSegmenter) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectableWordsSegmenter, ISelectableWordsSegmenter_Ptr);
   begin
      if this.m_ISelectableWordsSegmenter /= null then
         if this.m_ISelectableWordsSegmenter.all /= null then
            RefCount := this.m_ISelectableWordsSegmenter.all.Release;
            Free (this.m_ISelectableWordsSegmenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SelectableWordsSegmenter

   function Constructor
   (
      language : WinRt.WString
   )
   return SelectableWordsSegmenter is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Data.Text.SelectableWordsSegmenter");
      m_Factory    : access ISelectableWordsSegmenterFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Data.Text.ISelectableWordsSegmenter;
      HStr_language : WinRt.HString := To_HString (language);
   begin
      return RetVal : SelectableWordsSegmenter do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectableWordsSegmenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithLanguage (HStr_language, m_ComRetVal'Access);
            Retval.m_ISelectableWordsSegmenter := new Windows.Data.Text.ISelectableWordsSegmenter;
            Retval.m_ISelectableWordsSegmenter.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_language);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectableWordsSegmenter

   function get_ResolvedLanguage
   (
      this : in out SelectableWordsSegmenter
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISelectableWordsSegmenter.all.get_ResolvedLanguage (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetTokenAt
   (
      this : in out SelectableWordsSegmenter;
      text : WinRt.WString;
      startIndex : WinRt.UInt32
   )
   return WinRt.Windows.Data.Text.SelectableWordSegment'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Data.Text.ISelectableWordSegment;
      HStr_text : WinRt.HString := To_HString (text);
   begin
      return RetVal : WinRt.Windows.Data.Text.SelectableWordSegment do
         Hr := this.m_ISelectableWordsSegmenter.all.GetTokenAt (HStr_text, startIndex, m_ComRetVal'Access);
         Retval.m_ISelectableWordSegment := new Windows.Data.Text.ISelectableWordSegment;
         Retval.m_ISelectableWordSegment.all := m_ComRetVal;
         Hr := WindowsDeleteString (HStr_text);
      end return;
   end;

   function GetTokens
   (
      this : in out SelectableWordsSegmenter;
      text : WinRt.WString
   )
   return IVectorView_ISelectableWordSegment.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ISelectableWordSegment.Kind;
      HStr_text : WinRt.HString := To_HString (text);
   begin
      Hr := this.m_ISelectableWordsSegmenter.all.GetTokens (HStr_text, m_ComRetVal'Access);
      Hr := WindowsDeleteString (HStr_text);
      m_GenericRetVal := QInterface_IVectorView_ISelectableWordSegment (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure Tokenize
   (
      this : in out SelectableWordsSegmenter;
      text : WinRt.WString;
      startIndex : WinRt.UInt32;
      handler : Windows.Data.Text.SelectableWordSegmentsTokenizingHandler
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_text : WinRt.HString := To_HString (text);
   begin
      Hr := this.m_ISelectableWordsSegmenter.all.Tokenize (HStr_text, startIndex, handler);
      Hr := WindowsDeleteString (HStr_text);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SemanticTextQuery

   procedure Initialize (this : in out SemanticTextQuery) is
   begin
      null;
   end;

   procedure Finalize (this : in out SemanticTextQuery) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISemanticTextQuery, ISemanticTextQuery_Ptr);
   begin
      if this.m_ISemanticTextQuery /= null then
         if this.m_ISemanticTextQuery.all /= null then
            RefCount := this.m_ISemanticTextQuery.all.Release;
            Free (this.m_ISemanticTextQuery);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SemanticTextQuery

   function Constructor
   (
      aqsFilter : WinRt.WString
   )
   return SemanticTextQuery is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Data.Text.SemanticTextQuery");
      m_Factory    : access ISemanticTextQueryFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Data.Text.ISemanticTextQuery;
      HStr_aqsFilter : WinRt.HString := To_HString (aqsFilter);
   begin
      return RetVal : SemanticTextQuery do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticTextQueryFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (HStr_aqsFilter, m_ComRetVal'Access);
            Retval.m_ISemanticTextQuery := new Windows.Data.Text.ISemanticTextQuery;
            Retval.m_ISemanticTextQuery.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_aqsFilter);
      end return;
   end;

   function Constructor
   (
      aqsFilter : WinRt.WString;
      filterLanguage : WinRt.WString
   )
   return SemanticTextQuery is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Data.Text.SemanticTextQuery");
      m_Factory    : access ISemanticTextQueryFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Data.Text.ISemanticTextQuery;
      HStr_aqsFilter : WinRt.HString := To_HString (aqsFilter);
      HStr_filterLanguage : WinRt.HString := To_HString (filterLanguage);
   begin
      return RetVal : SemanticTextQuery do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticTextQueryFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithLanguage (HStr_aqsFilter, HStr_filterLanguage, m_ComRetVal'Access);
            Retval.m_ISemanticTextQuery := new Windows.Data.Text.ISemanticTextQuery;
            Retval.m_ISemanticTextQuery.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_aqsFilter);
         Hr := WindowsDeleteString (HStr_filterLanguage);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SemanticTextQuery

   function Find
   (
      this : in out SemanticTextQuery;
      content : WinRt.WString
   )
   return IVectorView_TextSegment.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_TextSegment.Kind;
      HStr_content : WinRt.HString := To_HString (content);
   begin
      Hr := this.m_ISemanticTextQuery.all.Find (HStr_content, m_ComRetVal'Access);
      Hr := WindowsDeleteString (HStr_content);
      m_GenericRetVal := QInterface_IVectorView_TextSegment (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function FindInProperty
   (
      this : in out SemanticTextQuery;
      propertyContent : WinRt.WString;
      propertyName : WinRt.WString
   )
   return IVectorView_TextSegment.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_TextSegment.Kind;
      HStr_propertyContent : WinRt.HString := To_HString (propertyContent);
      HStr_propertyName : WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ISemanticTextQuery.all.FindInProperty (HStr_propertyContent, HStr_propertyName, m_ComRetVal'Access);
      Hr := WindowsDeleteString (HStr_propertyContent);
      Hr := WindowsDeleteString (HStr_propertyName);
      m_GenericRetVal := QInterface_IVectorView_TextSegment (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextConversionGenerator

   procedure Initialize (this : in out TextConversionGenerator) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextConversionGenerator) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextConversionGenerator, ITextConversionGenerator_Ptr);
   begin
      if this.m_ITextConversionGenerator /= null then
         if this.m_ITextConversionGenerator.all /= null then
            RefCount := this.m_ITextConversionGenerator.all.Release;
            Free (this.m_ITextConversionGenerator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextConversionGenerator

   function Constructor
   (
      languageTag : WinRt.WString
   )
   return TextConversionGenerator is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Data.Text.TextConversionGenerator");
      m_Factory    : access ITextConversionGeneratorFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Data.Text.ITextConversionGenerator;
      HStr_languageTag : WinRt.HString := To_HString (languageTag);
   begin
      return RetVal : TextConversionGenerator do
         Hr := RoGetActivationFactory (m_hString, IID_ITextConversionGeneratorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (HStr_languageTag, m_ComRetVal'Access);
            Retval.m_ITextConversionGenerator := new Windows.Data.Text.ITextConversionGenerator;
            Retval.m_ITextConversionGenerator.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_languageTag);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextConversionGenerator

   function get_ResolvedLanguage
   (
      this : in out TextConversionGenerator
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextConversionGenerator.all.get_ResolvedLanguage (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_LanguageAvailableButNotInstalled
   (
      this : in out TextConversionGenerator
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ITextConversionGenerator.all.get_LanguageAvailableButNotInstalled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function GetCandidatesAsync
   (
      this : in out TextConversionGenerator;
      input : WinRt.WString
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_input : WinRt.HString := To_HString (input);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITextConversionGenerator.all.GetCandidatesAsync (HStr_input, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_input);
      return m_RetVal;
   end;

   function GetCandidatesAsync
   (
      this : in out TextConversionGenerator;
      input : WinRt.WString;
      maxCandidates : WinRt.UInt32
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_input : WinRt.HString := To_HString (input);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITextConversionGenerator.all.GetCandidatesAsync (HStr_input, maxCandidates, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_input);
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextPhoneme

   procedure Initialize (this : in out TextPhoneme) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextPhoneme) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextPhoneme, ITextPhoneme_Ptr);
   begin
      if this.m_ITextPhoneme /= null then
         if this.m_ITextPhoneme.all /= null then
            RefCount := this.m_ITextPhoneme.all.Release;
            Free (this.m_ITextPhoneme);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextPhoneme

   function get_DisplayText
   (
      this : in out TextPhoneme
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextPhoneme.all.get_DisplayText (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ReadingText
   (
      this : in out TextPhoneme
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextPhoneme.all.get_ReadingText (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextPredictionGenerator

   procedure Initialize (this : in out TextPredictionGenerator) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextPredictionGenerator) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextPredictionGenerator, ITextPredictionGenerator_Ptr);
   begin
      if this.m_ITextPredictionGenerator /= null then
         if this.m_ITextPredictionGenerator.all /= null then
            RefCount := this.m_ITextPredictionGenerator.all.Release;
            Free (this.m_ITextPredictionGenerator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextPredictionGenerator

   function Constructor
   (
      languageTag : WinRt.WString
   )
   return TextPredictionGenerator is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Data.Text.TextPredictionGenerator");
      m_Factory    : access ITextPredictionGeneratorFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Data.Text.ITextPredictionGenerator;
      HStr_languageTag : WinRt.HString := To_HString (languageTag);
   begin
      return RetVal : TextPredictionGenerator do
         Hr := RoGetActivationFactory (m_hString, IID_ITextPredictionGeneratorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (HStr_languageTag, m_ComRetVal'Access);
            Retval.m_ITextPredictionGenerator := new Windows.Data.Text.ITextPredictionGenerator;
            Retval.m_ITextPredictionGenerator.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_languageTag);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextPredictionGenerator

   function get_ResolvedLanguage
   (
      this : in out TextPredictionGenerator
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextPredictionGenerator.all.get_ResolvedLanguage (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_LanguageAvailableButNotInstalled
   (
      this : in out TextPredictionGenerator
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ITextPredictionGenerator.all.get_LanguageAvailableButNotInstalled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function GetCandidatesAsync
   (
      this : in out TextPredictionGenerator;
      input : WinRt.WString
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_input : WinRt.HString := To_HString (input);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITextPredictionGenerator.all.GetCandidatesAsync (HStr_input, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_input);
      return m_RetVal;
   end;

   function GetCandidatesAsync
   (
      this : in out TextPredictionGenerator;
      input : WinRt.WString;
      maxCandidates : WinRt.UInt32
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_input : WinRt.HString := To_HString (input);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITextPredictionGenerator.all.GetCandidatesAsync (HStr_input, maxCandidates, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_input);
      return m_RetVal;
   end;

   function GetCandidatesAsync
   (
      this : in out TextPredictionGenerator;
      input : WinRt.WString;
      maxCandidates : WinRt.UInt32;
      predictionOptions : Windows.Data.Text.TextPredictionOptions;
      previousStrings : GenericObject
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Data.Text.ITextPredictionGenerator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_input : WinRt.HString := To_HString (input);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.Data.Text.ITextPredictionGenerator_Interface, WinRt.Windows.Data.Text.ITextPredictionGenerator2, WinRt.Windows.Data.Text.IID_ITextPredictionGenerator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextPredictionGenerator.all);
      Hr := m_Interface.GetCandidatesAsync (HStr_input, maxCandidates, predictionOptions, previousStrings, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_input);
      return m_RetVal;
   end;

   function GetNextWordCandidatesAsync
   (
      this : in out TextPredictionGenerator;
      maxCandidates : WinRt.UInt32;
      previousStrings : GenericObject
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Data.Text.ITextPredictionGenerator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.Data.Text.ITextPredictionGenerator_Interface, WinRt.Windows.Data.Text.ITextPredictionGenerator2, WinRt.Windows.Data.Text.IID_ITextPredictionGenerator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextPredictionGenerator.all);
      Hr := m_Interface.GetNextWordCandidatesAsync (maxCandidates, previousStrings, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_InputScope
   (
      this : in out TextPredictionGenerator
   )
   return WinRt.Windows.UI.Text.Core.CoreTextInputScope is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Data.Text.ITextPredictionGenerator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Text.Core.CoreTextInputScope;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Data.Text.ITextPredictionGenerator_Interface, WinRt.Windows.Data.Text.ITextPredictionGenerator2, WinRt.Windows.Data.Text.IID_ITextPredictionGenerator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextPredictionGenerator.all);
      Hr := m_Interface.get_InputScope (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_InputScope
   (
      this : in out TextPredictionGenerator;
      value : Windows.UI.Text.Core.CoreTextInputScope
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Data.Text.ITextPredictionGenerator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Data.Text.ITextPredictionGenerator_Interface, WinRt.Windows.Data.Text.ITextPredictionGenerator2, WinRt.Windows.Data.Text.IID_ITextPredictionGenerator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextPredictionGenerator.all);
      Hr := m_Interface.put_InputScope (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextReverseConversionGenerator

   procedure Initialize (this : in out TextReverseConversionGenerator) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextReverseConversionGenerator) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextReverseConversionGenerator, ITextReverseConversionGenerator_Ptr);
   begin
      if this.m_ITextReverseConversionGenerator /= null then
         if this.m_ITextReverseConversionGenerator.all /= null then
            RefCount := this.m_ITextReverseConversionGenerator.all.Release;
            Free (this.m_ITextReverseConversionGenerator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextReverseConversionGenerator

   function Constructor
   (
      languageTag : WinRt.WString
   )
   return TextReverseConversionGenerator is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Data.Text.TextReverseConversionGenerator");
      m_Factory    : access ITextReverseConversionGeneratorFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Data.Text.ITextReverseConversionGenerator;
      HStr_languageTag : WinRt.HString := To_HString (languageTag);
   begin
      return RetVal : TextReverseConversionGenerator do
         Hr := RoGetActivationFactory (m_hString, IID_ITextReverseConversionGeneratorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (HStr_languageTag, m_ComRetVal'Access);
            Retval.m_ITextReverseConversionGenerator := new Windows.Data.Text.ITextReverseConversionGenerator;
            Retval.m_ITextReverseConversionGenerator.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_languageTag);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextReverseConversionGenerator

   function get_ResolvedLanguage
   (
      this : in out TextReverseConversionGenerator
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextReverseConversionGenerator.all.get_ResolvedLanguage (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_LanguageAvailableButNotInstalled
   (
      this : in out TextReverseConversionGenerator
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ITextReverseConversionGenerator.all.get_LanguageAvailableButNotInstalled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function ConvertBackAsync
   (
      this : in out TextReverseConversionGenerator;
      input : WinRt.WString
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_input : WinRt.HString := To_HString (input);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_HString.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HString.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.HString;
      AdaRetval        : WString;
      m_IID            : aliased WinRt.IID := (1042277891, 63639, 21091, (179, 40, 8, 6, 66, 107, 138, 121 )); -- HString;
      m_HandlerIID     : aliased WinRt.IID := (3080352799, 32693, 20654, (158, 153, 145, 18, 1, 236, 61, 65 ));
      m_Handler        : AsyncOperationCompletedHandler_HString.Kind := new AsyncOperationCompletedHandler_HString.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HString.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HString.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HString.Kind_Delegate, AsyncOperationCompletedHandler_HString.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITextReverseConversionGenerator.all.ConvertBackAsync (HStr_input, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_input);
      AdaRetval := To_Ada (m_RetVal);
      Hr := WindowsDeleteString (m_RetVal);
      return AdaRetVal;
   end;

   function GetPhonemesAsync
   (
      this : in out TextReverseConversionGenerator;
      input : WinRt.WString
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Data.Text.ITextReverseConversionGenerator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_input : WinRt.HString := To_HString (input);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (1807942045, 56592, 21776, (177, 100, 128, 140, 35, 43, 125, 100 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (2212578055, 3041, 21856, (139, 252, 41, 16, 149, 207, 109, 48 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.Data.Text.ITextReverseConversionGenerator_Interface, WinRt.Windows.Data.Text.ITextReverseConversionGenerator2, WinRt.Windows.Data.Text.IID_ITextReverseConversionGenerator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextReverseConversionGenerator.all);
      Hr := m_Interface.GetPhonemesAsync (HStr_input, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_input);
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body UnicodeCharacters is

      function GetCodepointFromSurrogatePair
      (
         highSurrogate : WinRt.UInt32;
         lowSurrogate : WinRt.UInt32
      )
      return WinRt.UInt32 is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.UInt32;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetCodepointFromSurrogatePair (highSurrogate, lowSurrogate, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      procedure GetSurrogatePairFromCodepoint
      (
         codepoint : WinRt.UInt32;
         highSurrogate : WinRt.Wide_Char_Ptr;
         lowSurrogate : WinRt.Wide_Char_Ptr
      ) is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetSurrogatePairFromCodepoint (codepoint, highSurrogate, lowSurrogate);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end;

      function IsHighSurrogate
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsHighSurrogate (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsLowSurrogate
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsLowSurrogate (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsSupplementary
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsSupplementary (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsNoncharacter
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsNoncharacter (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsWhitespace
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsWhitespace (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsAlphabetic
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsAlphabetic (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsCased
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsCased (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsUppercase
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsUppercase (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsLowercase
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsLowercase (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsIdStart
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsIdStart (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsIdContinue
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsIdContinue (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsGraphemeBase
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsGraphemeBase (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function IsGraphemeExtend
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.IsGraphemeExtend (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function GetNumericType
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Windows.Data.Text.UnicodeNumericType is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Data.Text.UnicodeNumericType;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetNumericType (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function GetGeneralCategory
      (
         codepoint : WinRt.UInt32
      )
      return WinRt.Windows.Data.Text.UnicodeGeneralCategory is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Data.Text.UnicodeCharacters");
         m_Factory        : access WinRt.Windows.Data.Text.IUnicodeCharactersStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Data.Text.UnicodeGeneralCategory;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IUnicodeCharactersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetGeneralCategory (codepoint, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

   end UnicodeCharacters;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WordSegment

   procedure Initialize (this : in out WordSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out WordSegment) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWordSegment, IWordSegment_Ptr);
   begin
      if this.m_IWordSegment /= null then
         if this.m_IWordSegment.all /= null then
            RefCount := this.m_IWordSegment.all.Release;
            Free (this.m_IWordSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WordSegment

   function get_Text
   (
      this : in out WordSegment
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IWordSegment.all.get_Text (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SourceTextSegment
   (
      this : in out WordSegment
   )
   return WinRt.Windows.Data.Text.TextSegment is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Data.Text.TextSegment;
   begin
      Hr := this.m_IWordSegment.all.get_SourceTextSegment (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AlternateForms
   (
      this : in out WordSegment
   )
   return IVectorView_IAlternateWordForm.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IAlternateWordForm.Kind;
   begin
      Hr := this.m_IWordSegment.all.get_AlternateForms (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IAlternateWordForm (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate WordSegmentsTokenizingHandler

   function Invoke
   (
      this : access WordSegmentsTokenizingHandler_Delegate;
      precedingWords : GenericObject;
      words : GenericObject
   )
   return WinRt.Hresult is
      Hr : WinRt.HResult := S_OK;
   begin
      this.Callback (precedingWords, words);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WordsSegmenter

   procedure Initialize (this : in out WordsSegmenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out WordsSegmenter) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWordsSegmenter, IWordsSegmenter_Ptr);
   begin
      if this.m_IWordsSegmenter /= null then
         if this.m_IWordsSegmenter.all /= null then
            RefCount := this.m_IWordsSegmenter.all.Release;
            Free (this.m_IWordsSegmenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for WordsSegmenter

   function Constructor
   (
      language : WinRt.WString
   )
   return WordsSegmenter is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Data.Text.WordsSegmenter");
      m_Factory    : access IWordsSegmenterFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Data.Text.IWordsSegmenter;
      HStr_language : WinRt.HString := To_HString (language);
   begin
      return RetVal : WordsSegmenter do
         Hr := RoGetActivationFactory (m_hString, IID_IWordsSegmenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithLanguage (HStr_language, m_ComRetVal'Access);
            Retval.m_IWordsSegmenter := new Windows.Data.Text.IWordsSegmenter;
            Retval.m_IWordsSegmenter.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_language);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WordsSegmenter

   function get_ResolvedLanguage
   (
      this : in out WordsSegmenter
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IWordsSegmenter.all.get_ResolvedLanguage (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetTokenAt
   (
      this : in out WordsSegmenter;
      text : WinRt.WString;
      startIndex : WinRt.UInt32
   )
   return WinRt.Windows.Data.Text.WordSegment'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Data.Text.IWordSegment;
      HStr_text : WinRt.HString := To_HString (text);
   begin
      return RetVal : WinRt.Windows.Data.Text.WordSegment do
         Hr := this.m_IWordsSegmenter.all.GetTokenAt (HStr_text, startIndex, m_ComRetVal'Access);
         Retval.m_IWordSegment := new Windows.Data.Text.IWordSegment;
         Retval.m_IWordSegment.all := m_ComRetVal;
         Hr := WindowsDeleteString (HStr_text);
      end return;
   end;

   function GetTokens
   (
      this : in out WordsSegmenter;
      text : WinRt.WString
   )
   return IVectorView_IWordSegment.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IWordSegment.Kind;
      HStr_text : WinRt.HString := To_HString (text);
   begin
      Hr := this.m_IWordsSegmenter.all.GetTokens (HStr_text, m_ComRetVal'Access);
      Hr := WindowsDeleteString (HStr_text);
      m_GenericRetVal := QInterface_IVectorView_IWordSegment (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure Tokenize
   (
      this : in out WordsSegmenter;
      text : WinRt.WString;
      startIndex : WinRt.UInt32;
      handler : Windows.Data.Text.WordSegmentsTokenizingHandler
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_text : WinRt.HString := To_HString (text);
   begin
      Hr := this.m_IWordsSegmenter.all.Tokenize (HStr_text, startIndex, handler);
      Hr := WindowsDeleteString (HStr_text);
   end;

end WinRt.Windows.Data.Text;
