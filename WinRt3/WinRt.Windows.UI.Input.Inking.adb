--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.Foundation.Numerics;
with WinRt.Windows.Storage.Streams;
with WinRt.Windows.UI.Core;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.Input.Inking is

   package IAsyncOperation_GenericObject is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.GenericObject);
   package AsyncOperationCompletedHandler_GenericObject is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.GenericObject);

   package IAsyncOperation_UInt32 is new WinRt.Windows.Foundation.IAsyncOperationWithProgress (WinRt.UInt32, GenericObject);
   package AsyncOperationCompletedHandler_UInt32 is new WinRt.Windows.Foundation.AsyncOperationWithProgressCompletedHandler (WinRt.UInt32, GenericObject);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkDrawingAttributes

   procedure Initialize (this : in out InkDrawingAttributes) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkDrawingAttributes) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkDrawingAttributes, IInkDrawingAttributes_Ptr);
   begin
      if this.m_IInkDrawingAttributes /= null then
         if this.m_IInkDrawingAttributes.all /= null then
            RefCount := this.m_IInkDrawingAttributes.all.Release;
            Free (this.m_IInkDrawingAttributes);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkDrawingAttributes

   function Constructor return InkDrawingAttributes is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkDrawingAttributes");
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkDrawingAttributes;
   begin
      return RetVal : InkDrawingAttributes do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInkDrawingAttributes := new Windows.UI.Input.Inking.IInkDrawingAttributes;
            Retval.m_IInkDrawingAttributes.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkDrawingAttributes

   function CreateForPencil
   return WinRt.Windows.UI.Input.Inking.InkDrawingAttributes is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkDrawingAttributes");
      m_Factory        : access WinRt.Windows.UI.Input.Inking.IInkDrawingAttributesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkDrawingAttributes;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkDrawingAttributes do
         Hr := RoGetActivationFactory (m_hString, IID_IInkDrawingAttributesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForPencil (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IInkDrawingAttributes := new Windows.UI.Input.Inking.IInkDrawingAttributes;
            Retval.m_IInkDrawingAttributes.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkDrawingAttributes

   function get_Color
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IInkDrawingAttributes.all.get_Color (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out InkDrawingAttributes;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkDrawingAttributes.all.put_Color (value);
   end;

   function get_PenTip
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Windows.UI.Input.Inking.PenTipShape is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.PenTipShape;
   begin
      Hr := this.m_IInkDrawingAttributes.all.get_PenTip (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_PenTip
   (
      this : in out InkDrawingAttributes;
      value : Windows.UI.Input.Inking.PenTipShape
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkDrawingAttributes.all.put_PenTip (value);
   end;

   function get_Size
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Size;
   begin
      Hr := this.m_IInkDrawingAttributes.all.get_Size (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Size
   (
      this : in out InkDrawingAttributes;
      value : Windows.Foundation.Size
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkDrawingAttributes.all.put_Size (value);
   end;

   function get_IgnorePressure
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkDrawingAttributes.all.get_IgnorePressure (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IgnorePressure
   (
      this : in out InkDrawingAttributes;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkDrawingAttributes.all.put_IgnorePressure (value);
   end;

   function get_FitToCurve
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkDrawingAttributes.all.get_FitToCurve (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_FitToCurve
   (
      this : in out InkDrawingAttributes;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkDrawingAttributes.all.put_FitToCurve (value);
   end;

   function get_PenTipTransform
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Matrix3x2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
      Hr := m_Interface.get_PenTipTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_PenTipTransform
   (
      this : in out InkDrawingAttributes;
      value : Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
      Hr := m_Interface.put_PenTipTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_DrawAsHighlighter
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
      Hr := m_Interface.get_DrawAsHighlighter (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_DrawAsHighlighter
   (
      this : in out InkDrawingAttributes;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes2, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
      Hr := m_Interface.put_DrawAsHighlighter (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_Kind
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Windows.UI.Input.Inking.InkDrawingAttributesKind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.InkDrawingAttributesKind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes3, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
      Hr := m_Interface.get_Kind (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_PencilProperties
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Windows.UI.Input.Inking.InkDrawingAttributesPencilProperties'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkDrawingAttributesPencilProperties;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes3, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkDrawingAttributesPencilProperties do
         m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
         Hr := m_Interface.get_PencilProperties (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IInkDrawingAttributesPencilProperties := new Windows.UI.Input.Inking.IInkDrawingAttributesPencilProperties;
         Retval.m_IInkDrawingAttributesPencilProperties.all := m_ComRetVal;
      end return;
   end;

   function get_IgnoreTilt
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes4, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
      Hr := m_Interface.get_IgnoreTilt (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_IgnoreTilt
   (
      this : in out InkDrawingAttributes;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes4, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
      Hr := m_Interface.put_IgnoreTilt (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ModelerAttributes
   (
      this : in out InkDrawingAttributes
   )
   return WinRt.Windows.UI.Input.Inking.InkModelerAttributes'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes5 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkModelerAttributes;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkDrawingAttributes5, WinRt.Windows.UI.Input.Inking.IID_IInkDrawingAttributes5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkModelerAttributes do
         m_Interface := QInterface (this.m_IInkDrawingAttributes.all);
         Hr := m_Interface.get_ModelerAttributes (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IInkModelerAttributes := new Windows.UI.Input.Inking.IInkModelerAttributes;
         Retval.m_IInkModelerAttributes.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkDrawingAttributesPencilProperties

   procedure Initialize (this : in out InkDrawingAttributesPencilProperties) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkDrawingAttributesPencilProperties) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkDrawingAttributesPencilProperties, IInkDrawingAttributesPencilProperties_Ptr);
   begin
      if this.m_IInkDrawingAttributesPencilProperties /= null then
         if this.m_IInkDrawingAttributesPencilProperties.all /= null then
            RefCount := this.m_IInkDrawingAttributesPencilProperties.all.Release;
            Free (this.m_IInkDrawingAttributesPencilProperties);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkDrawingAttributesPencilProperties

   function get_Opacity
   (
      this : in out InkDrawingAttributesPencilProperties
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInkDrawingAttributesPencilProperties.all.get_Opacity (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Opacity
   (
      this : in out InkDrawingAttributesPencilProperties;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkDrawingAttributesPencilProperties.all.put_Opacity (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkInputConfiguration

   procedure Initialize (this : in out InkInputConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkInputConfiguration) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkInputConfiguration, IInkInputConfiguration_Ptr);
   begin
      if this.m_IInkInputConfiguration /= null then
         if this.m_IInkInputConfiguration.all /= null then
            RefCount := this.m_IInkInputConfiguration.all.Release;
            Free (this.m_IInkInputConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkInputConfiguration

   function get_IsPrimaryBarrelButtonInputEnabled
   (
      this : in out InkInputConfiguration
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkInputConfiguration.all.get_IsPrimaryBarrelButtonInputEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IsPrimaryBarrelButtonInputEnabled
   (
      this : in out InkInputConfiguration;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkInputConfiguration.all.put_IsPrimaryBarrelButtonInputEnabled (value);
   end;

   function get_IsEraserInputEnabled
   (
      this : in out InkInputConfiguration
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkInputConfiguration.all.get_IsEraserInputEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IsEraserInputEnabled
   (
      this : in out InkInputConfiguration;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkInputConfiguration.all.put_IsEraserInputEnabled (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkInputProcessingConfiguration

   procedure Initialize (this : in out InkInputProcessingConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkInputProcessingConfiguration) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkInputProcessingConfiguration, IInkInputProcessingConfiguration_Ptr);
   begin
      if this.m_IInkInputProcessingConfiguration /= null then
         if this.m_IInkInputProcessingConfiguration.all /= null then
            RefCount := this.m_IInkInputProcessingConfiguration.all.Release;
            Free (this.m_IInkInputProcessingConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkInputProcessingConfiguration

   function get_Mode
   (
      this : in out InkInputProcessingConfiguration
   )
   return WinRt.Windows.UI.Input.Inking.InkInputProcessingMode is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.InkInputProcessingMode;
   begin
      Hr := this.m_IInkInputProcessingConfiguration.all.get_Mode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Mode
   (
      this : in out InkInputProcessingConfiguration;
      value : Windows.UI.Input.Inking.InkInputProcessingMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkInputProcessingConfiguration.all.put_Mode (value);
   end;

   function get_RightDragAction
   (
      this : in out InkInputProcessingConfiguration
   )
   return WinRt.Windows.UI.Input.Inking.InkInputRightDragAction is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.InkInputRightDragAction;
   begin
      Hr := this.m_IInkInputProcessingConfiguration.all.get_RightDragAction (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RightDragAction
   (
      this : in out InkInputProcessingConfiguration;
      value : Windows.UI.Input.Inking.InkInputRightDragAction
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkInputProcessingConfiguration.all.put_RightDragAction (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkManager

   procedure Initialize (this : in out InkManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkManager) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkManager, IInkManager_Ptr);
   begin
      if this.m_IInkManager /= null then
         if this.m_IInkManager.all /= null then
            RefCount := this.m_IInkManager.all.Release;
            Free (this.m_IInkManager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkManager

   function Constructor return InkManager is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkManager");
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkManager;
   begin
      return RetVal : InkManager do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInkManager := new Windows.UI.Input.Inking.IInkManager;
            Retval.m_IInkManager.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkManager

   function get_Mode
   (
      this : in out InkManager
   )
   return WinRt.Windows.UI.Input.Inking.InkManipulationMode is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.InkManipulationMode;
   begin
      Hr := this.m_IInkManager.all.get_Mode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Mode
   (
      this : in out InkManager;
      value : Windows.UI.Input.Inking.InkManipulationMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkManager.all.put_Mode (value);
   end;

   procedure ProcessPointerDown
   (
      this : in out InkManager;
      pointerPoint : Windows.UI.Input.PointerPoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkManager.all.ProcessPointerDown (pointerPoint.m_IPointerPoint.all);
   end;

   function ProcessPointerUpdate
   (
      this : in out InkManager;
      pointerPoint : Windows.UI.Input.PointerPoint'Class
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := this.m_IInkManager.all.ProcessPointerUpdate (pointerPoint.m_IPointerPoint.all, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function ProcessPointerUp
   (
      this : in out InkManager;
      pointerPoint : Windows.UI.Input.PointerPoint'Class
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkManager.all.ProcessPointerUp (pointerPoint.m_IPointerPoint.all, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure SetDefaultDrawingAttributes
   (
      this : in out InkManager;
      drawingAttributes : Windows.UI.Input.Inking.InkDrawingAttributes'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkManager.all.SetDefaultDrawingAttributes (drawingAttributes.m_IInkDrawingAttributes.all);
   end;

   function RecognizeAsync
   (
      this : in out InkManager;
      recognitionTarget : Windows.UI.Input.Inking.InkRecognitionTarget
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (2979151705, 54900, 21349, (185, 154, 63, 30, 82, 38, 140, 127 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (3974649471, 32896, 23789, (137, 136, 187, 3, 100, 200, 3, 212 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IInkManager.all.RecognizeAsync (recognitionTarget, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   procedure SetDefaultRecognizer
   (
      this : in out InkManager;
      recognizer : Windows.UI.Input.Inking.InkRecognizer'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkRecognizerContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkRecognizerContainer, WinRt.Windows.UI.Input.Inking.IID_IInkRecognizerContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.SetDefaultRecognizer (recognizer.m_IInkRecognizer.all);
      m_RefCount := m_Interface.Release;
   end;

   function RecognizeAsync
   (
      this : in out InkManager;
      strokeCollection : Windows.UI.Input.Inking.InkStrokeContainer'Class;
      recognitionTarget : Windows.UI.Input.Inking.InkRecognitionTarget
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkRecognizerContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (2979151705, 54900, 21349, (185, 154, 63, 30, 82, 38, 140, 127 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (3974649471, 32896, 23789, (137, 136, 187, 3, 100, 200, 3, 212 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkRecognizerContainer, WinRt.Windows.UI.Input.Inking.IID_IInkRecognizerContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.RecognizeAsync (strokeCollection.m_IInkStrokeContainer.all, recognitionTarget, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function GetRecognizers
   (
      this : in out InkManager
   )
   return IVectorView_IInkRecognizer.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkRecognizerContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkRecognizer.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkRecognizerContainer, WinRt.Windows.UI.Input.Inking.IID_IInkRecognizerContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.GetRecognizers (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVectorView_IInkRecognizer (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_BoundingRect
   (
      this : in out InkManager
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.get_BoundingRect (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure AddStroke
   (
      this : in out InkManager;
      stroke : Windows.UI.Input.Inking.InkStroke'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.AddStroke (stroke.m_IInkStroke.all);
      m_RefCount := m_Interface.Release;
   end;

   function DeleteSelected
   (
      this : in out InkManager
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.DeleteSelected (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function MoveSelected
   (
      this : in out InkManager;
      translation : Windows.Foundation.Point
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.MoveSelected (translation, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function SelectWithPolyLine
   (
      this : in out InkManager;
      polyline : GenericObject
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.SelectWithPolyLine (polyline, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function SelectWithLine
   (
      this : in out InkManager;
      from : Windows.Foundation.Point;
      to : Windows.Foundation.Point
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.SelectWithLine (from, to, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure CopySelectedToClipboard
   (
      this : in out InkManager
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.CopySelectedToClipboard;
      m_RefCount := m_Interface.Release;
   end;

   function PasteFromClipboard
   (
      this : in out InkManager;
      position : Windows.Foundation.Point
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.PasteFromClipboard (position, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function CanPasteFromClipboard
   (
      this : in out InkManager
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.CanPasteFromClipboard (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure LoadAsync
   (
      this : in out InkManager;
      inputStream : Windows.Storage.Streams.IInputStream
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.LoadAsync (inputStream, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function SaveAsync
   (
      this : in out InkManager;
      outputStream : Windows.Storage.Streams.IOutputStream
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_UInt32.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_UInt32.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.UInt32;
      m_IID            : aliased WinRt.IID := (3972749130, 50820, 21874, (166, 121, 107, 8, 66, 207, 181, 127 )); -- UInt32;
      m_HandlerIID     : aliased WinRt.IID := (507932101, 33807, 21753, (184, 119, 94, 58, 159, 75, 108, 116 ));
      m_Handler        : AsyncOperationCompletedHandler_UInt32.Kind := new AsyncOperationCompletedHandler_UInt32.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_UInt32.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_UInt32.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_UInt32.Kind_Delegate, AsyncOperationCompletedHandler_UInt32.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.SaveAsync (outputStream, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   procedure UpdateRecognitionResults
   (
      this : in out InkManager;
      recognitionResults : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.UpdateRecognitionResults (recognitionResults);
      m_RefCount := m_Interface.Release;
   end;

   function GetStrokes
   (
      this : in out InkManager
   )
   return IVectorView_IInkStroke.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkStroke.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.GetStrokes (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVectorView_IInkStroke (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRecognitionResults
   (
      this : in out InkManager
   )
   return IVectorView_IInkRecognitionResult.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkRecognitionResult.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkManager_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkManager.all);
      Hr := m_Interface.GetRecognitionResults (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVectorView_IInkRecognitionResult (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkModelerAttributes

   procedure Initialize (this : in out InkModelerAttributes) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkModelerAttributes) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkModelerAttributes, IInkModelerAttributes_Ptr);
   begin
      if this.m_IInkModelerAttributes /= null then
         if this.m_IInkModelerAttributes.all /= null then
            RefCount := this.m_IInkModelerAttributes.all.Release;
            Free (this.m_IInkModelerAttributes);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkModelerAttributes

   function get_PredictionTime
   (
      this : in out InkModelerAttributes
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IInkModelerAttributes.all.get_PredictionTime (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_PredictionTime
   (
      this : in out InkModelerAttributes;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkModelerAttributes.all.put_PredictionTime (value);
   end;

   function get_ScalingFactor
   (
      this : in out InkModelerAttributes
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInkModelerAttributes.all.get_ScalingFactor (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ScalingFactor
   (
      this : in out InkModelerAttributes;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkModelerAttributes.all.put_ScalingFactor (value);
   end;

   function get_UseVelocityBasedPressure
   (
      this : in out InkModelerAttributes
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkModelerAttributes2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkModelerAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkModelerAttributes2, WinRt.Windows.UI.Input.Inking.IID_IInkModelerAttributes2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkModelerAttributes.all);
      Hr := m_Interface.get_UseVelocityBasedPressure (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_UseVelocityBasedPressure
   (
      this : in out InkModelerAttributes;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkModelerAttributes2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkModelerAttributes_Interface, WinRt.Windows.UI.Input.Inking.IInkModelerAttributes2, WinRt.Windows.UI.Input.Inking.IID_IInkModelerAttributes2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkModelerAttributes.all);
      Hr := m_Interface.put_UseVelocityBasedPressure (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkPoint

   procedure Initialize (this : in out InkPoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkPoint) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkPoint, IInkPoint_Ptr);
   begin
      if this.m_IInkPoint /= null then
         if this.m_IInkPoint.all /= null then
            RefCount := this.m_IInkPoint.all.Release;
            Free (this.m_IInkPoint);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkPoint

   function Constructor
   (
      position : Windows.Foundation.Point;
      pressure : WinRt.Single;
      tiltX : WinRt.Single;
      tiltY : WinRt.Single;
      timestamp : WinRt.UInt64
   )
   return InkPoint is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkPoint");
      m_Factory    : access IInkPointFactory2_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkPoint;
   begin
      return RetVal : InkPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IInkPointFactory2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInkPointWithTiltAndTimestamp (position, pressure, tiltX, tiltY, timestamp, m_ComRetVal'Access);
            Retval.m_IInkPoint := new Windows.UI.Input.Inking.IInkPoint;
            Retval.m_IInkPoint.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      position : Windows.Foundation.Point;
      pressure : WinRt.Single
   )
   return InkPoint is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkPoint");
      m_Factory    : access IInkPointFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkPoint;
   begin
      return RetVal : InkPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IInkPointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInkPoint (position, pressure, m_ComRetVal'Access);
            Retval.m_IInkPoint := new Windows.UI.Input.Inking.IInkPoint;
            Retval.m_IInkPoint.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkPoint

   function get_Position
   (
      this : in out InkPoint
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IInkPoint.all.get_Position (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Pressure
   (
      this : in out InkPoint
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInkPoint.all.get_Pressure (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_TiltX
   (
      this : in out InkPoint
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPoint2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPoint_Interface, WinRt.Windows.UI.Input.Inking.IInkPoint2, WinRt.Windows.UI.Input.Inking.IID_IInkPoint2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPoint.all);
      Hr := m_Interface.get_TiltX (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_TiltY
   (
      this : in out InkPoint
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPoint2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPoint_Interface, WinRt.Windows.UI.Input.Inking.IInkPoint2, WinRt.Windows.UI.Input.Inking.IID_IInkPoint2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPoint.all);
      Hr := m_Interface.get_TiltY (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_Timestamp
   (
      this : in out InkPoint
   )
   return WinRt.UInt64 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPoint2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt64;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPoint_Interface, WinRt.Windows.UI.Input.Inking.IInkPoint2, WinRt.Windows.UI.Input.Inking.IID_IInkPoint2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPoint.all);
      Hr := m_Interface.get_Timestamp (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkPresenter

   procedure Initialize (this : in out InkPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkPresenter) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkPresenter, IInkPresenter_Ptr);
   begin
      if this.m_IInkPresenter /= null then
         if this.m_IInkPresenter.all /= null then
            RefCount := this.m_IInkPresenter.all.Release;
            Free (this.m_IInkPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkPresenter

   function get_IsInputEnabled
   (
      this : in out InkPresenter
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkPresenter.all.get_IsInputEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IsInputEnabled
   (
      this : in out InkPresenter;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenter.all.put_IsInputEnabled (value);
   end;

   function get_InputDeviceTypes
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Core.CoreInputDeviceTypes is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Core.CoreInputDeviceTypes;
   begin
      Hr := this.m_IInkPresenter.all.get_InputDeviceTypes (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_InputDeviceTypes
   (
      this : in out InkPresenter;
      value : Windows.UI.Core.CoreInputDeviceTypes
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenter.all.put_InputDeviceTypes (value);
   end;

   function get_UnprocessedInput
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkUnprocessedInput'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkUnprocessedInput;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkUnprocessedInput do
         Hr := this.m_IInkPresenter.all.get_UnprocessedInput (m_ComRetVal'Access);
         Retval.m_IInkUnprocessedInput := new Windows.UI.Input.Inking.IInkUnprocessedInput;
         Retval.m_IInkUnprocessedInput.all := m_ComRetVal;
      end return;
   end;

   function get_StrokeInput
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkStrokeInput'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStrokeInput;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStrokeInput do
         Hr := this.m_IInkPresenter.all.get_StrokeInput (m_ComRetVal'Access);
         Retval.m_IInkStrokeInput := new Windows.UI.Input.Inking.IInkStrokeInput;
         Retval.m_IInkStrokeInput.all := m_ComRetVal;
      end return;
   end;

   function get_InputProcessingConfiguration
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkInputProcessingConfiguration'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkInputProcessingConfiguration;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkInputProcessingConfiguration do
         Hr := this.m_IInkPresenter.all.get_InputProcessingConfiguration (m_ComRetVal'Access);
         Retval.m_IInkInputProcessingConfiguration := new Windows.UI.Input.Inking.IInkInputProcessingConfiguration;
         Retval.m_IInkInputProcessingConfiguration.all := m_ComRetVal;
      end return;
   end;

   function get_StrokeContainer
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkStrokeContainer'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStrokeContainer;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStrokeContainer do
         Hr := this.m_IInkPresenter.all.get_StrokeContainer (m_ComRetVal'Access);
         Retval.m_IInkStrokeContainer := new Windows.UI.Input.Inking.IInkStrokeContainer;
         Retval.m_IInkStrokeContainer.all := m_ComRetVal;
      end return;
   end;

   procedure put_StrokeContainer
   (
      this : in out InkPresenter;
      value : Windows.UI.Input.Inking.InkStrokeContainer'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenter.all.put_StrokeContainer (value.m_IInkStrokeContainer.all);
   end;

   function CopyDefaultDrawingAttributes
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkDrawingAttributes'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkDrawingAttributes;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkDrawingAttributes do
         Hr := this.m_IInkPresenter.all.CopyDefaultDrawingAttributes (m_ComRetVal'Access);
         Retval.m_IInkDrawingAttributes := new Windows.UI.Input.Inking.IInkDrawingAttributes;
         Retval.m_IInkDrawingAttributes.all := m_ComRetVal;
      end return;
   end;

   procedure UpdateDefaultDrawingAttributes
   (
      this : in out InkPresenter;
      value : Windows.UI.Input.Inking.InkDrawingAttributes'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenter.all.UpdateDefaultDrawingAttributes (value.m_IInkDrawingAttributes.all);
   end;

   function ActivateCustomDrying
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkSynchronizer'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkSynchronizer;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkSynchronizer do
         Hr := this.m_IInkPresenter.all.ActivateCustomDrying (m_ComRetVal'Access);
         Retval.m_IInkSynchronizer := new Windows.UI.Input.Inking.IInkSynchronizer;
         Retval.m_IInkSynchronizer.all := m_ComRetVal;
      end return;
   end;

   procedure SetPredefinedConfiguration
   (
      this : in out InkPresenter;
      value : Windows.UI.Input.Inking.InkPresenterPredefinedConfiguration
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenter.all.SetPredefinedConfiguration (value);
   end;

   function add_StrokesCollected
   (
      this : in out InkPresenter;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkPresenter.all.add_StrokesCollected (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_StrokesCollected
   (
      this : in out InkPresenter;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenter.all.remove_StrokesCollected (cookie);
   end;

   function add_StrokesErased
   (
      this : in out InkPresenter;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkPresenter.all.add_StrokesErased (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_StrokesErased
   (
      this : in out InkPresenter;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenter.all.remove_StrokesErased (cookie);
   end;

   function get_HighContrastAdjustment
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkHighContrastAdjustment is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenter2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.InkHighContrastAdjustment;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenter_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenter2, WinRt.Windows.UI.Input.Inking.IID_IInkPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenter.all);
      Hr := m_Interface.get_HighContrastAdjustment (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_HighContrastAdjustment
   (
      this : in out InkPresenter;
      value : Windows.UI.Input.Inking.InkHighContrastAdjustment
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenter2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenter_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenter2, WinRt.Windows.UI.Input.Inking.IID_IInkPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenter.all);
      Hr := m_Interface.put_HighContrastAdjustment (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_InputConfiguration
   (
      this : in out InkPresenter
   )
   return WinRt.Windows.UI.Input.Inking.InkInputConfiguration'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenter3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkInputConfiguration;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenter_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenter3, WinRt.Windows.UI.Input.Inking.IID_IInkPresenter3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkInputConfiguration do
         m_Interface := QInterface (this.m_IInkPresenter.all);
         Hr := m_Interface.get_InputConfiguration (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IInkInputConfiguration := new Windows.UI.Input.Inking.IInkInputConfiguration;
         Retval.m_IInkInputConfiguration.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkPresenterProtractor

   procedure Initialize (this : in out InkPresenterProtractor) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkPresenterProtractor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkPresenterProtractor, IInkPresenterProtractor_Ptr);
   begin
      if this.m_IInkPresenterProtractor /= null then
         if this.m_IInkPresenterProtractor.all /= null then
            RefCount := this.m_IInkPresenterProtractor.all.Release;
            Free (this.m_IInkPresenterProtractor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkPresenterProtractor

   function Constructor
   (
      inkPresenter_p : Windows.UI.Input.Inking.InkPresenter'Class
   )
   return InkPresenterProtractor is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkPresenterProtractor");
      m_Factory    : access IInkPresenterProtractorFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkPresenterProtractor;
   begin
      return RetVal : InkPresenterProtractor do
         Hr := RoGetActivationFactory (m_hString, IID_IInkPresenterProtractorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (inkPresenter_p.m_IInkPresenter.all, m_ComRetVal'Access);
            Retval.m_IInkPresenterProtractor := new Windows.UI.Input.Inking.IInkPresenterProtractor;
            Retval.m_IInkPresenterProtractor.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkPresenterProtractor

   function get_AreTickMarksVisible
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkPresenterProtractor.all.get_AreTickMarksVisible (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AreTickMarksVisible
   (
      this : in out InkPresenterProtractor;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterProtractor.all.put_AreTickMarksVisible (value);
   end;

   function get_AreRaysVisible
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkPresenterProtractor.all.get_AreRaysVisible (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AreRaysVisible
   (
      this : in out InkPresenterProtractor;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterProtractor.all.put_AreRaysVisible (value);
   end;

   function get_IsCenterMarkerVisible
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkPresenterProtractor.all.get_IsCenterMarkerVisible (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IsCenterMarkerVisible
   (
      this : in out InkPresenterProtractor;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterProtractor.all.put_IsCenterMarkerVisible (value);
   end;

   function get_IsAngleReadoutVisible
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkPresenterProtractor.all.get_IsAngleReadoutVisible (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IsAngleReadoutVisible
   (
      this : in out InkPresenterProtractor;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterProtractor.all.put_IsAngleReadoutVisible (value);
   end;

   function get_IsResizable
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkPresenterProtractor.all.get_IsResizable (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IsResizable
   (
      this : in out InkPresenterProtractor;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterProtractor.all.put_IsResizable (value);
   end;

   function get_Radius
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInkPresenterProtractor.all.get_Radius (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Radius
   (
      this : in out InkPresenterProtractor;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterProtractor.all.put_Radius (value);
   end;

   function get_AccentColor
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IInkPresenterProtractor.all.get_AccentColor (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AccentColor
   (
      this : in out InkPresenterProtractor;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterProtractor.all.put_AccentColor (value);
   end;

   function get_Kind
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Windows.UI.Input.Inking.InkPresenterStencilKind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.InkPresenterStencilKind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.get_Kind (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_IsVisible
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.get_IsVisible (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_IsVisible
   (
      this : in out InkPresenterProtractor;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.put_IsVisible (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_BackgroundColor
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.get_BackgroundColor (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_BackgroundColor
   (
      this : in out InkPresenterProtractor;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.put_BackgroundColor (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ForegroundColor
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.get_ForegroundColor (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ForegroundColor
   (
      this : in out InkPresenterProtractor;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.put_ForegroundColor (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_Transform
   (
      this : in out InkPresenterProtractor
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Matrix3x2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.get_Transform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_Transform
   (
      this : in out InkPresenterProtractor;
      value : Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterProtractor_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterProtractor.all);
      Hr := m_Interface.put_Transform (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkPresenterRuler

   procedure Initialize (this : in out InkPresenterRuler) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkPresenterRuler) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkPresenterRuler, IInkPresenterRuler_Ptr);
   begin
      if this.m_IInkPresenterRuler /= null then
         if this.m_IInkPresenterRuler.all /= null then
            RefCount := this.m_IInkPresenterRuler.all.Release;
            Free (this.m_IInkPresenterRuler);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkPresenterRuler

   function Constructor
   (
      inkPresenter_p : Windows.UI.Input.Inking.InkPresenter'Class
   )
   return InkPresenterRuler is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkPresenterRuler");
      m_Factory    : access IInkPresenterRulerFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkPresenterRuler;
   begin
      return RetVal : InkPresenterRuler do
         Hr := RoGetActivationFactory (m_hString, IID_IInkPresenterRulerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (inkPresenter_p.m_IInkPresenter.all, m_ComRetVal'Access);
            Retval.m_IInkPresenterRuler := new Windows.UI.Input.Inking.IInkPresenterRuler;
            Retval.m_IInkPresenterRuler.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkPresenterRuler

   function get_Length
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInkPresenterRuler.all.get_Length (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Length
   (
      this : in out InkPresenterRuler;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterRuler.all.put_Length (value);
   end;

   function get_Width
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInkPresenterRuler.all.get_Width (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Width
   (
      this : in out InkPresenterRuler;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkPresenterRuler.all.put_Width (value);
   end;

   function get_Kind
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Windows.UI.Input.Inking.InkPresenterStencilKind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.InkPresenterStencilKind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.get_Kind (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_IsVisible
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.get_IsVisible (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_IsVisible
   (
      this : in out InkPresenterRuler;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.put_IsVisible (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_BackgroundColor
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.get_BackgroundColor (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_BackgroundColor
   (
      this : in out InkPresenterRuler;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.put_BackgroundColor (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ForegroundColor
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.get_ForegroundColor (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ForegroundColor
   (
      this : in out InkPresenterRuler;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.put_ForegroundColor (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_Transform
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Matrix3x2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.get_Transform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_Transform
   (
      this : in out InkPresenterRuler;
      value : Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterStencil := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterStencil, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterStencil'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.put_Transform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_AreTickMarksVisible
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterRuler2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.get_AreTickMarksVisible (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_AreTickMarksVisible
   (
      this : in out InkPresenterRuler;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterRuler2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.put_AreTickMarksVisible (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_IsCompassVisible
   (
      this : in out InkPresenterRuler
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterRuler2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.get_IsCompassVisible (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_IsCompassVisible
   (
      this : in out InkPresenterRuler;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkPresenterRuler_Interface, WinRt.Windows.UI.Input.Inking.IInkPresenterRuler2, WinRt.Windows.UI.Input.Inking.IID_IInkPresenterRuler2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkPresenterRuler.all);
      Hr := m_Interface.put_IsCompassVisible (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkRecognitionResult

   procedure Initialize (this : in out InkRecognitionResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkRecognitionResult) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkRecognitionResult, IInkRecognitionResult_Ptr);
   begin
      if this.m_IInkRecognitionResult /= null then
         if this.m_IInkRecognitionResult.all /= null then
            RefCount := this.m_IInkRecognitionResult.all.Release;
            Free (this.m_IInkRecognitionResult);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkRecognitionResult

   function get_BoundingRect
   (
      this : in out InkRecognitionResult
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkRecognitionResult.all.get_BoundingRect (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function GetTextCandidates
   (
      this : in out InkRecognitionResult
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_IInkRecognitionResult.all.GetTextCandidates (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetStrokes
   (
      this : in out InkRecognitionResult
   )
   return IVectorView_IInkStroke.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkStroke.Kind;
   begin
      Hr := this.m_IInkRecognitionResult.all.GetStrokes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkStroke (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkRecognizer

   procedure Initialize (this : in out InkRecognizer) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkRecognizer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkRecognizer, IInkRecognizer_Ptr);
   begin
      if this.m_IInkRecognizer /= null then
         if this.m_IInkRecognizer.all /= null then
            RefCount := this.m_IInkRecognizer.all.Release;
            Free (this.m_IInkRecognizer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkRecognizer

   function get_Name
   (
      this : in out InkRecognizer
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IInkRecognizer.all.get_Name (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkRecognizerContainer

   procedure Initialize (this : in out InkRecognizerContainer) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkRecognizerContainer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkRecognizerContainer, IInkRecognizerContainer_Ptr);
   begin
      if this.m_IInkRecognizerContainer /= null then
         if this.m_IInkRecognizerContainer.all /= null then
            RefCount := this.m_IInkRecognizerContainer.all.Release;
            Free (this.m_IInkRecognizerContainer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkRecognizerContainer

   function Constructor return InkRecognizerContainer is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkRecognizerContainer");
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkRecognizerContainer;
   begin
      return RetVal : InkRecognizerContainer do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInkRecognizerContainer := new Windows.UI.Input.Inking.IInkRecognizerContainer;
            Retval.m_IInkRecognizerContainer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkRecognizerContainer

   procedure SetDefaultRecognizer
   (
      this : in out InkRecognizerContainer;
      recognizer : Windows.UI.Input.Inking.InkRecognizer'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkRecognizerContainer.all.SetDefaultRecognizer (recognizer.m_IInkRecognizer.all);
   end;

   function RecognizeAsync
   (
      this : in out InkRecognizerContainer;
      strokeCollection : Windows.UI.Input.Inking.InkStrokeContainer'Class;
      recognitionTarget : Windows.UI.Input.Inking.InkRecognitionTarget
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (2979151705, 54900, 21349, (185, 154, 63, 30, 82, 38, 140, 127 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (3974649471, 32896, 23789, (137, 136, 187, 3, 100, 200, 3, 212 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IInkRecognizerContainer.all.RecognizeAsync (strokeCollection.m_IInkStrokeContainer.all, recognitionTarget, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function GetRecognizers
   (
      this : in out InkRecognizerContainer
   )
   return IVectorView_IInkRecognizer.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkRecognizer.Kind;
   begin
      Hr := this.m_IInkRecognizerContainer.all.GetRecognizers (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkRecognizer (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkStroke

   procedure Initialize (this : in out InkStroke) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkStroke) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkStroke, IInkStroke_Ptr);
   begin
      if this.m_IInkStroke /= null then
         if this.m_IInkStroke.all /= null then
            RefCount := this.m_IInkStroke.all.Release;
            Free (this.m_IInkStroke);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkStroke

   function get_DrawingAttributes
   (
      this : in out InkStroke
   )
   return WinRt.Windows.UI.Input.Inking.InkDrawingAttributes'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkDrawingAttributes;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkDrawingAttributes do
         Hr := this.m_IInkStroke.all.get_DrawingAttributes (m_ComRetVal'Access);
         Retval.m_IInkDrawingAttributes := new Windows.UI.Input.Inking.IInkDrawingAttributes;
         Retval.m_IInkDrawingAttributes.all := m_ComRetVal;
      end return;
   end;

   procedure put_DrawingAttributes
   (
      this : in out InkStroke;
      value : Windows.UI.Input.Inking.InkDrawingAttributes'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStroke.all.put_DrawingAttributes (value.m_IInkDrawingAttributes.all);
   end;

   function get_BoundingRect
   (
      this : in out InkStroke
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkStroke.all.get_BoundingRect (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Selected
   (
      this : in out InkStroke
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkStroke.all.get_Selected (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Selected
   (
      this : in out InkStroke;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStroke.all.put_Selected (value);
   end;

   function get_Recognized
   (
      this : in out InkStroke
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkStroke.all.get_Recognized (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function GetRenderingSegments
   (
      this : in out InkStroke
   )
   return IVectorView_IInkStrokeRenderingSegment.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkStrokeRenderingSegment.Kind;
   begin
      Hr := this.m_IInkStroke.all.GetRenderingSegments (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkStrokeRenderingSegment (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function Clone
   (
      this : in out InkStroke
   )
   return WinRt.Windows.UI.Input.Inking.InkStroke'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStroke;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStroke do
         Hr := this.m_IInkStroke.all.Clone (m_ComRetVal'Access);
         Retval.m_IInkStroke := new Windows.UI.Input.Inking.IInkStroke;
         Retval.m_IInkStroke.all := m_ComRetVal;
      end return;
   end;

   function get_PointTransform
   (
      this : in out InkStroke
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Matrix3x2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke2, WinRt.Windows.UI.Input.Inking.IID_IInkStroke2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.get_PointTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_PointTransform
   (
      this : in out InkStroke;
      value : Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke2, WinRt.Windows.UI.Input.Inking.IID_IInkStroke2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.put_PointTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function GetInkPoints
   (
      this : in out InkStroke
   )
   return IVectorView_IInkPoint.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkPoint.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke2, WinRt.Windows.UI.Input.Inking.IID_IInkStroke2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.GetInkPoints (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVectorView_IInkPoint (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Id
   (
      this : in out InkStroke
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke3, WinRt.Windows.UI.Input.Inking.IID_IInkStroke3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.get_Id (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_StrokeStartedTime
   (
      this : in out InkStroke
   )
   return IReference_DateTime.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke3, WinRt.Windows.UI.Input.Inking.IID_IInkStroke3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.get_StrokeStartedTime (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_StrokeStartedTime
   (
      this : in out InkStroke;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke3, WinRt.Windows.UI.Input.Inking.IID_IInkStroke3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.put_StrokeStartedTime (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_StrokeDuration
   (
      this : in out InkStroke
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke3, WinRt.Windows.UI.Input.Inking.IID_IInkStroke3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.get_StrokeDuration (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_StrokeDuration
   (
      this : in out InkStroke;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStroke3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStroke_Interface, WinRt.Windows.UI.Input.Inking.IInkStroke3, WinRt.Windows.UI.Input.Inking.IID_IInkStroke3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStroke.all);
      Hr := m_Interface.put_StrokeDuration (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkStrokeBuilder

   procedure Initialize (this : in out InkStrokeBuilder) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkStrokeBuilder) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkStrokeBuilder, IInkStrokeBuilder_Ptr);
   begin
      if this.m_IInkStrokeBuilder /= null then
         if this.m_IInkStrokeBuilder.all /= null then
            RefCount := this.m_IInkStrokeBuilder.all.Release;
            Free (this.m_IInkStrokeBuilder);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkStrokeBuilder

   function Constructor return InkStrokeBuilder is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkStrokeBuilder");
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkStrokeBuilder;
   begin
      return RetVal : InkStrokeBuilder do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInkStrokeBuilder := new Windows.UI.Input.Inking.IInkStrokeBuilder;
            Retval.m_IInkStrokeBuilder.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkStrokeBuilder

   procedure BeginStroke
   (
      this : in out InkStrokeBuilder;
      pointerPoint : Windows.UI.Input.PointerPoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeBuilder.all.BeginStroke (pointerPoint.m_IPointerPoint.all);
   end;

   function AppendToStroke
   (
      this : in out InkStrokeBuilder;
      pointerPoint : Windows.UI.Input.PointerPoint'Class
   )
   return WinRt.Windows.UI.Input.PointerPoint'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IPointerPoint;
   begin
      return RetVal : WinRt.Windows.UI.Input.PointerPoint do
         Hr := this.m_IInkStrokeBuilder.all.AppendToStroke (pointerPoint.m_IPointerPoint.all, m_ComRetVal'Access);
         Retval.m_IPointerPoint := new Windows.UI.Input.IPointerPoint;
         Retval.m_IPointerPoint.all := m_ComRetVal;
      end return;
   end;

   function EndStroke
   (
      this : in out InkStrokeBuilder;
      pointerPoint : Windows.UI.Input.PointerPoint'Class
   )
   return WinRt.Windows.UI.Input.Inking.InkStroke'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStroke;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStroke do
         Hr := this.m_IInkStrokeBuilder.all.EndStroke (pointerPoint.m_IPointerPoint.all, m_ComRetVal'Access);
         Retval.m_IInkStroke := new Windows.UI.Input.Inking.IInkStroke;
         Retval.m_IInkStroke.all := m_ComRetVal;
      end return;
   end;

   function CreateStroke
   (
      this : in out InkStrokeBuilder;
      points : GenericObject
   )
   return WinRt.Windows.UI.Input.Inking.InkStroke'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStroke;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStroke do
         Hr := this.m_IInkStrokeBuilder.all.CreateStroke (points, m_ComRetVal'Access);
         Retval.m_IInkStroke := new Windows.UI.Input.Inking.IInkStroke;
         Retval.m_IInkStroke.all := m_ComRetVal;
      end return;
   end;

   procedure SetDefaultDrawingAttributes
   (
      this : in out InkStrokeBuilder;
      drawingAttributes : Windows.UI.Input.Inking.InkDrawingAttributes'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeBuilder.all.SetDefaultDrawingAttributes (drawingAttributes.m_IInkDrawingAttributes.all);
   end;

   function CreateStrokeFromInkPoints
   (
      this : in out InkStrokeBuilder;
      inkPoints : GenericObject;
      transform : Windows.Foundation.Numerics.Matrix3x2
   )
   return WinRt.Windows.UI.Input.Inking.InkStroke'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeBuilder2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStroke;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStrokeBuilder_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeBuilder2, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeBuilder2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStroke do
         m_Interface := QInterface (this.m_IInkStrokeBuilder.all);
         Hr := m_Interface.CreateStrokeFromInkPoints (inkPoints, transform, m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IInkStroke := new Windows.UI.Input.Inking.IInkStroke;
         Retval.m_IInkStroke.all := m_ComRetVal;
      end return;
   end;

   function CreateStrokeFromInkPoints
   (
      this : in out InkStrokeBuilder;
      inkPoints : GenericObject;
      transform : Windows.Foundation.Numerics.Matrix3x2;
      strokeStartedTime : GenericObject;
      strokeDuration : GenericObject
   )
   return WinRt.Windows.UI.Input.Inking.InkStroke'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeBuilder3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStroke;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStrokeBuilder_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeBuilder3, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeBuilder3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStroke do
         m_Interface := QInterface (this.m_IInkStrokeBuilder.all);
         Hr := m_Interface.CreateStrokeFromInkPoints (inkPoints, transform, strokeStartedTime, strokeDuration, m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IInkStroke := new Windows.UI.Input.Inking.IInkStroke;
         Retval.m_IInkStroke.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkStrokeContainer

   procedure Initialize (this : in out InkStrokeContainer) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkStrokeContainer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkStrokeContainer, IInkStrokeContainer_Ptr);
   begin
      if this.m_IInkStrokeContainer /= null then
         if this.m_IInkStrokeContainer.all /= null then
            RefCount := this.m_IInkStrokeContainer.all.Release;
            Free (this.m_IInkStrokeContainer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkStrokeContainer

   function Constructor return InkStrokeContainer is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.UI.Input.Inking.InkStrokeContainer");
      m_ComRetVal  : aliased Windows.UI.Input.Inking.IInkStrokeContainer;
   begin
      return RetVal : InkStrokeContainer do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInkStrokeContainer := new Windows.UI.Input.Inking.IInkStrokeContainer;
            Retval.m_IInkStrokeContainer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkStrokeContainer

   function get_BoundingRect
   (
      this : in out InkStrokeContainer
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkStrokeContainer.all.get_BoundingRect (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure AddStroke
   (
      this : in out InkStrokeContainer;
      stroke : Windows.UI.Input.Inking.InkStroke'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeContainer.all.AddStroke (stroke.m_IInkStroke.all);
   end;

   function DeleteSelected
   (
      this : in out InkStrokeContainer
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkStrokeContainer.all.DeleteSelected (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function MoveSelected
   (
      this : in out InkStrokeContainer;
      translation : Windows.Foundation.Point
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkStrokeContainer.all.MoveSelected (translation, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function SelectWithPolyLine
   (
      this : in out InkStrokeContainer;
      polyline : GenericObject
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkStrokeContainer.all.SelectWithPolyLine (polyline, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function SelectWithLine
   (
      this : in out InkStrokeContainer;
      from : Windows.Foundation.Point;
      to : Windows.Foundation.Point
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkStrokeContainer.all.SelectWithLine (from, to, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure CopySelectedToClipboard
   (
      this : in out InkStrokeContainer
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeContainer.all.CopySelectedToClipboard;
   end;

   function PasteFromClipboard
   (
      this : in out InkStrokeContainer;
      position : Windows.Foundation.Point
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IInkStrokeContainer.all.PasteFromClipboard (position, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function CanPasteFromClipboard
   (
      this : in out InkStrokeContainer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInkStrokeContainer.all.CanPasteFromClipboard (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure LoadAsync
   (
      this : in out InkStrokeContainer;
      inputStream : Windows.Storage.Streams.IInputStream
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IInkStrokeContainer.all.LoadAsync (inputStream, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function SaveAsync
   (
      this : in out InkStrokeContainer;
      outputStream : Windows.Storage.Streams.IOutputStream
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_UInt32.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_UInt32.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.UInt32;
      m_IID            : aliased WinRt.IID := (3972749130, 50820, 21874, (166, 121, 107, 8, 66, 207, 181, 127 )); -- UInt32;
      m_HandlerIID     : aliased WinRt.IID := (507932101, 33807, 21753, (184, 119, 94, 58, 159, 75, 108, 116 ));
      m_Handler        : AsyncOperationCompletedHandler_UInt32.Kind := new AsyncOperationCompletedHandler_UInt32.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_UInt32.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_UInt32.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_UInt32.Kind_Delegate, AsyncOperationCompletedHandler_UInt32.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IInkStrokeContainer.all.SaveAsync (outputStream, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   procedure UpdateRecognitionResults
   (
      this : in out InkStrokeContainer;
      recognitionResults : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeContainer.all.UpdateRecognitionResults (recognitionResults);
   end;

   function GetStrokes
   (
      this : in out InkStrokeContainer
   )
   return IVectorView_IInkStroke.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkStroke.Kind;
   begin
      Hr := this.m_IInkStrokeContainer.all.GetStrokes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkStroke (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRecognitionResults
   (
      this : in out InkStrokeContainer
   )
   return IVectorView_IInkRecognitionResult.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkRecognitionResult.Kind;
   begin
      Hr := this.m_IInkStrokeContainer.all.GetRecognitionResults (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkRecognitionResult (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure AddStrokes
   (
      this : in out InkStrokeContainer;
      strokes : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStrokeContainer_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer2, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStrokeContainer.all);
      Hr := m_Interface.AddStrokes (strokes);
      m_RefCount := m_Interface.Release;
   end;

   procedure Clear
   (
      this : in out InkStrokeContainer
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStrokeContainer_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer2, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStrokeContainer.all);
      Hr := m_Interface.Clear;
      m_RefCount := m_Interface.Release;
   end;

   function SaveAsync
   (
      this : in out InkStrokeContainer;
      outputStream : Windows.Storage.Streams.IOutputStream;
      inkPersistenceFormat : Windows.UI.Input.Inking.InkPersistenceFormat
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_UInt32.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_UInt32.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.UInt32;
      m_IID            : aliased WinRt.IID := (3972749130, 50820, 21874, (166, 121, 107, 8, 66, 207, 181, 127 )); -- UInt32;
      m_HandlerIID     : aliased WinRt.IID := (507932101, 33807, 21753, (184, 119, 94, 58, 159, 75, 108, 116 ));
      m_Handler        : AsyncOperationCompletedHandler_UInt32.Kind := new AsyncOperationCompletedHandler_UInt32.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_UInt32.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_UInt32.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_UInt32.Kind_Delegate, AsyncOperationCompletedHandler_UInt32.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStrokeContainer_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer3, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkStrokeContainer.all);
      Hr := m_Interface.SaveAsync (outputStream, inkPersistenceFormat, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function GetStrokeById
   (
      this : in out InkStrokeContainer;
      id : WinRt.UInt32
   )
   return WinRt.Windows.UI.Input.Inking.InkStroke'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.Inking.IInkStrokeContainer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkStroke;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.Inking.IInkStrokeContainer_Interface, WinRt.Windows.UI.Input.Inking.IInkStrokeContainer3, WinRt.Windows.UI.Input.Inking.IID_IInkStrokeContainer3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkStroke do
         m_Interface := QInterface (this.m_IInkStrokeContainer.all);
         Hr := m_Interface.GetStrokeById (id, m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IInkStroke := new Windows.UI.Input.Inking.IInkStroke;
         Retval.m_IInkStroke.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkStrokeInput

   procedure Initialize (this : in out InkStrokeInput) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkStrokeInput) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkStrokeInput, IInkStrokeInput_Ptr);
   begin
      if this.m_IInkStrokeInput /= null then
         if this.m_IInkStrokeInput.all /= null then
            RefCount := this.m_IInkStrokeInput.all.Release;
            Free (this.m_IInkStrokeInput);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkStrokeInput

   function add_StrokeStarted
   (
      this : in out InkStrokeInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkStrokeInput.all.add_StrokeStarted (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_StrokeStarted
   (
      this : in out InkStrokeInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeInput.all.remove_StrokeStarted (cookie);
   end;

   function add_StrokeContinued
   (
      this : in out InkStrokeInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkStrokeInput.all.add_StrokeContinued (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_StrokeContinued
   (
      this : in out InkStrokeInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeInput.all.remove_StrokeContinued (cookie);
   end;

   function add_StrokeEnded
   (
      this : in out InkStrokeInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkStrokeInput.all.add_StrokeEnded (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_StrokeEnded
   (
      this : in out InkStrokeInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeInput.all.remove_StrokeEnded (cookie);
   end;

   function add_StrokeCanceled
   (
      this : in out InkStrokeInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkStrokeInput.all.add_StrokeCanceled (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_StrokeCanceled
   (
      this : in out InkStrokeInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkStrokeInput.all.remove_StrokeCanceled (cookie);
   end;

   function get_InkPresenter
   (
      this : in out InkStrokeInput
   )
   return WinRt.Windows.UI.Input.Inking.InkPresenter'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkPresenter;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkPresenter do
         Hr := this.m_IInkStrokeInput.all.get_InkPresenter (m_ComRetVal'Access);
         Retval.m_IInkPresenter := new Windows.UI.Input.Inking.IInkPresenter;
         Retval.m_IInkPresenter.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkStrokeRenderingSegment

   procedure Initialize (this : in out InkStrokeRenderingSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkStrokeRenderingSegment) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkStrokeRenderingSegment, IInkStrokeRenderingSegment_Ptr);
   begin
      if this.m_IInkStrokeRenderingSegment /= null then
         if this.m_IInkStrokeRenderingSegment.all /= null then
            RefCount := this.m_IInkStrokeRenderingSegment.all.Release;
            Free (this.m_IInkStrokeRenderingSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkStrokeRenderingSegment

   function get_Position
   (
      this : in out InkStrokeRenderingSegment
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IInkStrokeRenderingSegment.all.get_Position (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_BezierControlPoint1
   (
      this : in out InkStrokeRenderingSegment
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IInkStrokeRenderingSegment.all.get_BezierControlPoint1 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_BezierControlPoint2
   (
      this : in out InkStrokeRenderingSegment
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IInkStrokeRenderingSegment.all.get_BezierControlPoint2 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Pressure
   (
      this : in out InkStrokeRenderingSegment
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInkStrokeRenderingSegment.all.get_Pressure (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_TiltX
   (
      this : in out InkStrokeRenderingSegment
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInkStrokeRenderingSegment.all.get_TiltX (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_TiltY
   (
      this : in out InkStrokeRenderingSegment
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInkStrokeRenderingSegment.all.get_TiltY (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Twist
   (
      this : in out InkStrokeRenderingSegment
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInkStrokeRenderingSegment.all.get_Twist (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkStrokesCollectedEventArgs

   procedure Initialize (this : in out InkStrokesCollectedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkStrokesCollectedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkStrokesCollectedEventArgs, IInkStrokesCollectedEventArgs_Ptr);
   begin
      if this.m_IInkStrokesCollectedEventArgs /= null then
         if this.m_IInkStrokesCollectedEventArgs.all /= null then
            RefCount := this.m_IInkStrokesCollectedEventArgs.all.Release;
            Free (this.m_IInkStrokesCollectedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkStrokesCollectedEventArgs

   function get_Strokes
   (
      this : in out InkStrokesCollectedEventArgs
   )
   return IVectorView_IInkStroke.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkStroke.Kind;
   begin
      Hr := this.m_IInkStrokesCollectedEventArgs.all.get_Strokes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkStroke (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkStrokesErasedEventArgs

   procedure Initialize (this : in out InkStrokesErasedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkStrokesErasedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkStrokesErasedEventArgs, IInkStrokesErasedEventArgs_Ptr);
   begin
      if this.m_IInkStrokesErasedEventArgs /= null then
         if this.m_IInkStrokesErasedEventArgs.all /= null then
            RefCount := this.m_IInkStrokesErasedEventArgs.all.Release;
            Free (this.m_IInkStrokesErasedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkStrokesErasedEventArgs

   function get_Strokes
   (
      this : in out InkStrokesErasedEventArgs
   )
   return IVectorView_IInkStroke.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkStroke.Kind;
   begin
      Hr := this.m_IInkStrokesErasedEventArgs.all.get_Strokes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkStroke (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkSynchronizer

   procedure Initialize (this : in out InkSynchronizer) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkSynchronizer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkSynchronizer, IInkSynchronizer_Ptr);
   begin
      if this.m_IInkSynchronizer /= null then
         if this.m_IInkSynchronizer.all /= null then
            RefCount := this.m_IInkSynchronizer.all.Release;
            Free (this.m_IInkSynchronizer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkSynchronizer

   function BeginDry
   (
      this : in out InkSynchronizer
   )
   return IVectorView_IInkStroke.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IInkStroke.Kind;
   begin
      Hr := this.m_IInkSynchronizer.all.BeginDry (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IInkStroke (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure EndDry
   (
      this : in out InkSynchronizer
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkSynchronizer.all.EndDry;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkUnprocessedInput

   procedure Initialize (this : in out InkUnprocessedInput) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkUnprocessedInput) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkUnprocessedInput, IInkUnprocessedInput_Ptr);
   begin
      if this.m_IInkUnprocessedInput /= null then
         if this.m_IInkUnprocessedInput.all /= null then
            RefCount := this.m_IInkUnprocessedInput.all.Release;
            Free (this.m_IInkUnprocessedInput);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkUnprocessedInput

   function add_PointerEntered
   (
      this : in out InkUnprocessedInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkUnprocessedInput.all.add_PointerEntered (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PointerEntered
   (
      this : in out InkUnprocessedInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkUnprocessedInput.all.remove_PointerEntered (cookie);
   end;

   function add_PointerHovered
   (
      this : in out InkUnprocessedInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkUnprocessedInput.all.add_PointerHovered (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PointerHovered
   (
      this : in out InkUnprocessedInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkUnprocessedInput.all.remove_PointerHovered (cookie);
   end;

   function add_PointerExited
   (
      this : in out InkUnprocessedInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkUnprocessedInput.all.add_PointerExited (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PointerExited
   (
      this : in out InkUnprocessedInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkUnprocessedInput.all.remove_PointerExited (cookie);
   end;

   function add_PointerPressed
   (
      this : in out InkUnprocessedInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkUnprocessedInput.all.add_PointerPressed (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PointerPressed
   (
      this : in out InkUnprocessedInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkUnprocessedInput.all.remove_PointerPressed (cookie);
   end;

   function add_PointerMoved
   (
      this : in out InkUnprocessedInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkUnprocessedInput.all.add_PointerMoved (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PointerMoved
   (
      this : in out InkUnprocessedInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkUnprocessedInput.all.remove_PointerMoved (cookie);
   end;

   function add_PointerReleased
   (
      this : in out InkUnprocessedInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkUnprocessedInput.all.add_PointerReleased (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PointerReleased
   (
      this : in out InkUnprocessedInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkUnprocessedInput.all.remove_PointerReleased (cookie);
   end;

   function add_PointerLost
   (
      this : in out InkUnprocessedInput;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkUnprocessedInput.all.add_PointerLost (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PointerLost
   (
      this : in out InkUnprocessedInput;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInkUnprocessedInput.all.remove_PointerLost (cookie);
   end;

   function get_InkPresenter
   (
      this : in out InkUnprocessedInput
   )
   return WinRt.Windows.UI.Input.Inking.InkPresenter'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IInkPresenter;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.InkPresenter do
         Hr := this.m_IInkUnprocessedInput.all.get_InkPresenter (m_ComRetVal'Access);
         Retval.m_IInkPresenter := new Windows.UI.Input.Inking.IInkPresenter;
         Retval.m_IInkPresenter.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PenAndInkSettings

   procedure Initialize (this : in out PenAndInkSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out PenAndInkSettings) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPenAndInkSettings, IPenAndInkSettings_Ptr);
   begin
      if this.m_IPenAndInkSettings /= null then
         if this.m_IPenAndInkSettings.all /= null then
            RefCount := this.m_IPenAndInkSettings.all.Release;
            Free (this.m_IPenAndInkSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PenAndInkSettings

   function GetDefault
   return WinRt.Windows.UI.Input.Inking.PenAndInkSettings is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.UI.Input.Inking.PenAndInkSettings");
      m_Factory        : access WinRt.Windows.UI.Input.Inking.IPenAndInkSettingsStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.IPenAndInkSettings;
   begin
      return RetVal : WinRt.Windows.UI.Input.Inking.PenAndInkSettings do
         Hr := RoGetActivationFactory (m_hString, IID_IPenAndInkSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPenAndInkSettings := new Windows.UI.Input.Inking.IPenAndInkSettings;
            Retval.m_IPenAndInkSettings.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PenAndInkSettings

   function get_IsHandwritingDirectlyIntoTextFieldEnabled
   (
      this : in out PenAndInkSettings
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPenAndInkSettings.all.get_IsHandwritingDirectlyIntoTextFieldEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PenHandedness
   (
      this : in out PenAndInkSettings
   )
   return WinRt.Windows.UI.Input.Inking.PenHandedness is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.PenHandedness;
   begin
      Hr := this.m_IPenAndInkSettings.all.get_PenHandedness (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_HandwritingLineHeight
   (
      this : in out PenAndInkSettings
   )
   return WinRt.Windows.UI.Input.Inking.HandwritingLineHeight is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.Inking.HandwritingLineHeight;
   begin
      Hr := this.m_IPenAndInkSettings.all.get_HandwritingLineHeight (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_FontFamilyName
   (
      this : in out PenAndInkSettings
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPenAndInkSettings.all.get_FontFamilyName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_UserConsentsToHandwritingTelemetryCollection
   (
      this : in out PenAndInkSettings
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPenAndInkSettings.all.get_UserConsentsToHandwritingTelemetryCollection (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsTouchHandwritingEnabled
   (
      this : in out PenAndInkSettings
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPenAndInkSettings.all.get_IsTouchHandwritingEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

end;
