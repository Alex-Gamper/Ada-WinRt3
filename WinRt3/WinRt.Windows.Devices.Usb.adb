--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.Storage.Streams;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Devices.Usb is

   package IAsyncOperation_UInt32 is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.UInt32);
   package AsyncOperationCompletedHandler_UInt32 is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.UInt32);

   package IAsyncOperation_IBuffer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Storage.Streams.IBuffer);
   package AsyncOperationCompletedHandler_IBuffer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Storage.Streams.IBuffer);

   package IAsyncOperation_UsbDevice is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Usb.IUsbDevice);
   package AsyncOperationCompletedHandler_UsbDevice is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Usb.IUsbDevice);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbBulkInEndpointDescriptor

   procedure Initialize (this : in out UsbBulkInEndpointDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbBulkInEndpointDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbBulkInEndpointDescriptor, IUsbBulkInEndpointDescriptor_Ptr);
   begin
      if this.m_IUsbBulkInEndpointDescriptor /= null then
         if this.m_IUsbBulkInEndpointDescriptor.all /= null then
            RefCount := this.m_IUsbBulkInEndpointDescriptor.all.Release;
            Free (this.m_IUsbBulkInEndpointDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbBulkInEndpointDescriptor

   function get_MaxPacketSize
   (
      this : in out UsbBulkInEndpointDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbBulkInEndpointDescriptor.all.get_MaxPacketSize (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EndpointNumber
   (
      this : in out UsbBulkInEndpointDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbBulkInEndpointDescriptor.all.get_EndpointNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Pipe
   (
      this : in out UsbBulkInEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbBulkInPipe'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbBulkInPipe;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbBulkInPipe do
         Hr := this.m_IUsbBulkInEndpointDescriptor.all.get_Pipe (m_ComRetVal'Access);
         Retval.m_IUsbBulkInPipe := new Windows.Devices.Usb.IUsbBulkInPipe;
         Retval.m_IUsbBulkInPipe.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbBulkInPipe

   procedure Initialize (this : in out UsbBulkInPipe) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbBulkInPipe) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbBulkInPipe, IUsbBulkInPipe_Ptr);
   begin
      if this.m_IUsbBulkInPipe /= null then
         if this.m_IUsbBulkInPipe.all /= null then
            RefCount := this.m_IUsbBulkInPipe.all.Release;
            Free (this.m_IUsbBulkInPipe);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbBulkInPipe

   function get_MaxTransferSizeBytes
   (
      this : in out UsbBulkInPipe
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbBulkInPipe.all.get_MaxTransferSizeBytes (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EndpointDescriptor
   (
      this : in out UsbBulkInPipe
   )
   return WinRt.Windows.Devices.Usb.UsbBulkInEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbBulkInEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbBulkInEndpointDescriptor do
         Hr := this.m_IUsbBulkInPipe.all.get_EndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbBulkInEndpointDescriptor := new Windows.Devices.Usb.IUsbBulkInEndpointDescriptor;
         Retval.m_IUsbBulkInEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   procedure ClearStallAsync
   (
      this : in out UsbBulkInPipe
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUsbBulkInPipe.all.ClearStallAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure put_ReadOptions
   (
      this : in out UsbBulkInPipe;
      value : Windows.Devices.Usb.UsbReadOptions
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbBulkInPipe.all.put_ReadOptions (value);
   end;

   function get_ReadOptions
   (
      this : in out UsbBulkInPipe
   )
   return WinRt.Windows.Devices.Usb.UsbReadOptions is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbReadOptions;
   begin
      Hr := this.m_IUsbBulkInPipe.all.get_ReadOptions (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure FlushBuffer
   (
      this : in out UsbBulkInPipe
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbBulkInPipe.all.FlushBuffer;
   end;

   function get_InputStream
   (
      this : in out UsbBulkInPipe
   )
   return WinRt.Windows.Storage.Streams.IInputStream is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IInputStream;
   begin
      Hr := this.m_IUsbBulkInPipe.all.get_InputStream (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbBulkOutEndpointDescriptor

   procedure Initialize (this : in out UsbBulkOutEndpointDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbBulkOutEndpointDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbBulkOutEndpointDescriptor, IUsbBulkOutEndpointDescriptor_Ptr);
   begin
      if this.m_IUsbBulkOutEndpointDescriptor /= null then
         if this.m_IUsbBulkOutEndpointDescriptor.all /= null then
            RefCount := this.m_IUsbBulkOutEndpointDescriptor.all.Release;
            Free (this.m_IUsbBulkOutEndpointDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbBulkOutEndpointDescriptor

   function get_MaxPacketSize
   (
      this : in out UsbBulkOutEndpointDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbBulkOutEndpointDescriptor.all.get_MaxPacketSize (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EndpointNumber
   (
      this : in out UsbBulkOutEndpointDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbBulkOutEndpointDescriptor.all.get_EndpointNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Pipe
   (
      this : in out UsbBulkOutEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbBulkOutPipe'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbBulkOutPipe;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbBulkOutPipe do
         Hr := this.m_IUsbBulkOutEndpointDescriptor.all.get_Pipe (m_ComRetVal'Access);
         Retval.m_IUsbBulkOutPipe := new Windows.Devices.Usb.IUsbBulkOutPipe;
         Retval.m_IUsbBulkOutPipe.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbBulkOutPipe

   procedure Initialize (this : in out UsbBulkOutPipe) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbBulkOutPipe) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbBulkOutPipe, IUsbBulkOutPipe_Ptr);
   begin
      if this.m_IUsbBulkOutPipe /= null then
         if this.m_IUsbBulkOutPipe.all /= null then
            RefCount := this.m_IUsbBulkOutPipe.all.Release;
            Free (this.m_IUsbBulkOutPipe);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbBulkOutPipe

   function get_EndpointDescriptor
   (
      this : in out UsbBulkOutPipe
   )
   return WinRt.Windows.Devices.Usb.UsbBulkOutEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbBulkOutEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbBulkOutEndpointDescriptor do
         Hr := this.m_IUsbBulkOutPipe.all.get_EndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbBulkOutEndpointDescriptor := new Windows.Devices.Usb.IUsbBulkOutEndpointDescriptor;
         Retval.m_IUsbBulkOutEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   procedure ClearStallAsync
   (
      this : in out UsbBulkOutPipe
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUsbBulkOutPipe.all.ClearStallAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure put_WriteOptions
   (
      this : in out UsbBulkOutPipe;
      value : Windows.Devices.Usb.UsbWriteOptions
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbBulkOutPipe.all.put_WriteOptions (value);
   end;

   function get_WriteOptions
   (
      this : in out UsbBulkOutPipe
   )
   return WinRt.Windows.Devices.Usb.UsbWriteOptions is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbWriteOptions;
   begin
      Hr := this.m_IUsbBulkOutPipe.all.get_WriteOptions (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_OutputStream
   (
      this : in out UsbBulkOutPipe
   )
   return WinRt.Windows.Storage.Streams.IOutputStream is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IOutputStream;
   begin
      Hr := this.m_IUsbBulkOutPipe.all.get_OutputStream (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbConfiguration

   procedure Initialize (this : in out UsbConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbConfiguration) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbConfiguration, IUsbConfiguration_Ptr);
   begin
      if this.m_IUsbConfiguration /= null then
         if this.m_IUsbConfiguration.all /= null then
            RefCount := this.m_IUsbConfiguration.all.Release;
            Free (this.m_IUsbConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbConfiguration

   function get_UsbInterfaces
   (
      this : in out UsbConfiguration
   )
   return IVectorView_IUsbInterface.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbInterface.Kind;
   begin
      Hr := this.m_IUsbConfiguration.all.get_UsbInterfaces (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbInterface (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ConfigurationDescriptor
   (
      this : in out UsbConfiguration
   )
   return WinRt.Windows.Devices.Usb.UsbConfigurationDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbConfigurationDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbConfigurationDescriptor do
         Hr := this.m_IUsbConfiguration.all.get_ConfigurationDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbConfigurationDescriptor := new Windows.Devices.Usb.IUsbConfigurationDescriptor;
         Retval.m_IUsbConfigurationDescriptor.all := m_ComRetVal;
      end return;
   end;

   function get_Descriptors
   (
      this : in out UsbConfiguration
   )
   return IVectorView_IUsbDescriptor.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbDescriptor.Kind;
   begin
      Hr := this.m_IUsbConfiguration.all.get_Descriptors (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbDescriptor (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbConfigurationDescriptor

   procedure Initialize (this : in out UsbConfigurationDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbConfigurationDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbConfigurationDescriptor, IUsbConfigurationDescriptor_Ptr);
   begin
      if this.m_IUsbConfigurationDescriptor /= null then
         if this.m_IUsbConfigurationDescriptor.all /= null then
            RefCount := this.m_IUsbConfigurationDescriptor.all.Release;
            Free (this.m_IUsbConfigurationDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UsbConfigurationDescriptor

   function TryParse
   (
      descriptor : Windows.Devices.Usb.UsbDescriptor'Class;
      parsed : access Windows.Devices.Usb.IUsbConfigurationDescriptor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbConfigurationDescriptor");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbConfigurationDescriptorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUsbConfigurationDescriptorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.TryParse (descriptor.m_IUsbDescriptor.all, parsed, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Parse
   (
      descriptor : Windows.Devices.Usb.UsbDescriptor'Class
   )
   return WinRt.Windows.Devices.Usb.UsbConfigurationDescriptor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbConfigurationDescriptor");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbConfigurationDescriptorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbConfigurationDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbConfigurationDescriptor do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbConfigurationDescriptorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Parse (descriptor.m_IUsbDescriptor.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbConfigurationDescriptor := new Windows.Devices.Usb.IUsbConfigurationDescriptor;
            Retval.m_IUsbConfigurationDescriptor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbConfigurationDescriptor

   function get_ConfigurationValue
   (
      this : in out UsbConfigurationDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbConfigurationDescriptor.all.get_ConfigurationValue (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MaxPowerMilliamps
   (
      this : in out UsbConfigurationDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbConfigurationDescriptor.all.get_MaxPowerMilliamps (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_SelfPowered
   (
      this : in out UsbConfigurationDescriptor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IUsbConfigurationDescriptor.all.get_SelfPowered (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_RemoteWakeup
   (
      this : in out UsbConfigurationDescriptor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IUsbConfigurationDescriptor.all.get_RemoteWakeup (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbControlRequestType

   procedure Initialize (this : in out UsbControlRequestType) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbControlRequestType) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbControlRequestType, IUsbControlRequestType_Ptr);
   begin
      if this.m_IUsbControlRequestType /= null then
         if this.m_IUsbControlRequestType.all /= null then
            RefCount := this.m_IUsbControlRequestType.all.Release;
            Free (this.m_IUsbControlRequestType);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UsbControlRequestType

   function Constructor return UsbControlRequestType is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbControlRequestType");
      m_ComRetVal  : aliased Windows.Devices.Usb.IUsbControlRequestType;
   begin
      return RetVal : UsbControlRequestType do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IUsbControlRequestType := new Windows.Devices.Usb.IUsbControlRequestType;
            Retval.m_IUsbControlRequestType.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbControlRequestType

   function get_Direction
   (
      this : in out UsbControlRequestType
   )
   return WinRt.Windows.Devices.Usb.UsbTransferDirection is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbTransferDirection;
   begin
      Hr := this.m_IUsbControlRequestType.all.get_Direction (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Direction
   (
      this : in out UsbControlRequestType;
      value : Windows.Devices.Usb.UsbTransferDirection
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbControlRequestType.all.put_Direction (value);
   end;

   function get_ControlTransferType
   (
      this : in out UsbControlRequestType
   )
   return WinRt.Windows.Devices.Usb.UsbControlTransferType is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbControlTransferType;
   begin
      Hr := this.m_IUsbControlRequestType.all.get_ControlTransferType (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ControlTransferType
   (
      this : in out UsbControlRequestType;
      value : Windows.Devices.Usb.UsbControlTransferType
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbControlRequestType.all.put_ControlTransferType (value);
   end;

   function get_Recipient
   (
      this : in out UsbControlRequestType
   )
   return WinRt.Windows.Devices.Usb.UsbControlRecipient is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbControlRecipient;
   begin
      Hr := this.m_IUsbControlRequestType.all.get_Recipient (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Recipient
   (
      this : in out UsbControlRequestType;
      value : Windows.Devices.Usb.UsbControlRecipient
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbControlRequestType.all.put_Recipient (value);
   end;

   function get_AsByte
   (
      this : in out UsbControlRequestType
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbControlRequestType.all.get_AsByte (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AsByte
   (
      this : in out UsbControlRequestType;
      value : WinRt.Byte
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbControlRequestType.all.put_AsByte (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbDescriptor

   procedure Initialize (this : in out UsbDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbDescriptor, IUsbDescriptor_Ptr);
   begin
      if this.m_IUsbDescriptor /= null then
         if this.m_IUsbDescriptor.all /= null then
            RefCount := this.m_IUsbDescriptor.all.Release;
            Free (this.m_IUsbDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbDescriptor

   function get_Length
   (
      this : in out UsbDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbDescriptor.all.get_Length (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_DescriptorType
   (
      this : in out UsbDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbDescriptor.all.get_DescriptorType (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure ReadDescriptorBuffer
   (
      this : in out UsbDescriptor;
      buffer : Windows.Storage.Streams.IBuffer
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbDescriptor.all.ReadDescriptorBuffer (buffer);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbDevice

   procedure Initialize (this : in out UsbDevice) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbDevice) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbDevice, IUsbDevice_Ptr);
   begin
      if this.m_IUsbDevice /= null then
         if this.m_IUsbDevice.all /= null then
            RefCount := this.m_IUsbDevice.all.Release;
            Free (this.m_IUsbDevice);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UsbDevice

   function GetDeviceSelector
   (
      vendorId : WinRt.UInt32;
      productId : WinRt.UInt32;
      winUsbInterfaceClass : WinRt.Guid
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDevice");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (vendorId, productId, winUsbInterfaceClass, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetDeviceSelector
   (
      winUsbInterfaceClass : WinRt.Guid
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDevice");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (winUsbInterfaceClass, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetDeviceSelector
   (
      vendorId : WinRt.UInt32;
      productId : WinRt.UInt32
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDevice");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (vendorId, productId, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetDeviceClassSelector
   (
      usbClass : Windows.Devices.Usb.UsbDeviceClass'Class
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDevice");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceClassSelector (usbClass.m_IUsbDeviceClass.all, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Usb.UsbDevice is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDevice");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_UsbDevice.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_UsbDevice.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Usb.IUsbDevice;
      m_IID            : aliased WinRt.IID := (557368813, 46874, 20838, (153, 72, 213, 87, 146, 116, 143, 92 )); -- Windows.Devices.Usb.UsbDevice;
      m_HandlerIID     : aliased WinRt.IID := (1932600655, 27823, 22653, (156, 42, 1, 140, 102, 211, 18, 219 ));
      m_Handler        : AsyncOperationCompletedHandler_UsbDevice.Kind := new AsyncOperationCompletedHandler_UsbDevice.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_UsbDevice.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_UsbDevice.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_UsbDevice.Kind_Delegate, AsyncOperationCompletedHandler_UsbDevice.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDevice do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IUsbDevice := new Windows.Devices.Usb.IUsbDevice;
                     Retval.m_IUsbDevice.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbDevice

   function SendControlOutTransferAsync
   (
      this : in out UsbDevice;
      setupPacket : Windows.Devices.Usb.UsbSetupPacket'Class;
      buffer : Windows.Storage.Streams.IBuffer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_UInt32.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_UInt32.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.UInt32;
      m_IID            : aliased WinRt.IID := (4016060511, 48760, 22603, (170, 239, 120, 41, 173, 162, 176, 222 )); -- UInt32;
      m_HandlerIID     : aliased WinRt.IID := (2470688487, 58322, 24138, (171, 45, 43, 206, 73, 25, 166, 164 ));
      m_Handler        : AsyncOperationCompletedHandler_UInt32.Kind := new AsyncOperationCompletedHandler_UInt32.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_UInt32.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_UInt32.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_UInt32.Kind_Delegate, AsyncOperationCompletedHandler_UInt32.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IUsbDevice.all.SendControlOutTransferAsync (setupPacket.m_IUsbSetupPacket.all, buffer, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function SendControlOutTransferAsync
   (
      this : in out UsbDevice;
      setupPacket : Windows.Devices.Usb.UsbSetupPacket'Class
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_UInt32.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_UInt32.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.UInt32;
      m_IID            : aliased WinRt.IID := (4016060511, 48760, 22603, (170, 239, 120, 41, 173, 162, 176, 222 )); -- UInt32;
      m_HandlerIID     : aliased WinRt.IID := (2470688487, 58322, 24138, (171, 45, 43, 206, 73, 25, 166, 164 ));
      m_Handler        : AsyncOperationCompletedHandler_UInt32.Kind := new AsyncOperationCompletedHandler_UInt32.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_UInt32.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_UInt32.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_UInt32.Kind_Delegate, AsyncOperationCompletedHandler_UInt32.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IUsbDevice.all.SendControlOutTransferAsync (setupPacket.m_IUsbSetupPacket.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function SendControlInTransferAsync
   (
      this : in out UsbDevice;
      setupPacket : Windows.Devices.Usb.UsbSetupPacket'Class;
      buffer : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_IBuffer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Storage.Streams.IBuffer;
      m_IID            : aliased WinRt.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
      m_HandlerIID     : aliased WinRt.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
      m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IUsbDevice.all.SendControlInTransferAsync (setupPacket.m_IUsbSetupPacket.all, buffer, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function SendControlInTransferAsync
   (
      this : in out UsbDevice;
      setupPacket : Windows.Devices.Usb.UsbSetupPacket'Class
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_IBuffer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Storage.Streams.IBuffer;
      m_IID            : aliased WinRt.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
      m_HandlerIID     : aliased WinRt.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
      m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IUsbDevice.all.SendControlInTransferAsync (setupPacket.m_IUsbSetupPacket.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_DefaultInterface
   (
      this : in out UsbDevice
   )
   return WinRt.Windows.Devices.Usb.UsbInterface'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterface;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterface do
         Hr := this.m_IUsbDevice.all.get_DefaultInterface (m_ComRetVal'Access);
         Retval.m_IUsbInterface := new Windows.Devices.Usb.IUsbInterface;
         Retval.m_IUsbInterface.all := m_ComRetVal;
      end return;
   end;

   function get_DeviceDescriptor
   (
      this : in out UsbDevice
   )
   return WinRt.Windows.Devices.Usb.UsbDeviceDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceDescriptor do
         Hr := this.m_IUsbDevice.all.get_DeviceDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbDeviceDescriptor := new Windows.Devices.Usb.IUsbDeviceDescriptor;
         Retval.m_IUsbDeviceDescriptor.all := m_ComRetVal;
      end return;
   end;

   function get_Configuration
   (
      this : in out UsbDevice
   )
   return WinRt.Windows.Devices.Usb.UsbConfiguration'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbConfiguration;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbConfiguration do
         Hr := this.m_IUsbDevice.all.get_Configuration (m_ComRetVal'Access);
         Retval.m_IUsbConfiguration := new Windows.Devices.Usb.IUsbConfiguration;
         Retval.m_IUsbConfiguration.all := m_ComRetVal;
      end return;
   end;

   procedure Close
   (
      this : in out UsbDevice
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Usb.IUsbDevice_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUsbDevice.all);
      Hr := m_Interface.Close;
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbDeviceClass

   procedure Initialize (this : in out UsbDeviceClass) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbDeviceClass) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbDeviceClass, IUsbDeviceClass_Ptr);
   begin
      if this.m_IUsbDeviceClass /= null then
         if this.m_IUsbDeviceClass.all /= null then
            RefCount := this.m_IUsbDeviceClass.all.Release;
            Free (this.m_IUsbDeviceClass);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UsbDeviceClass

   function Constructor return UsbDeviceClass is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClass");
      m_ComRetVal  : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : UsbDeviceClass do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbDeviceClass

   function get_ClassCode
   (
      this : in out UsbDeviceClass
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbDeviceClass.all.get_ClassCode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ClassCode
   (
      this : in out UsbDeviceClass;
      value : WinRt.Byte
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbDeviceClass.all.put_ClassCode (value);
   end;

   function get_SubclassCode
   (
      this : in out UsbDeviceClass
   )
   return IReference_Byte.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Byte.Kind;
   begin
      Hr := this.m_IUsbDeviceClass.all.get_SubclassCode (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Byte (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_SubclassCode
   (
      this : in out UsbDeviceClass;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbDeviceClass.all.put_SubclassCode (value);
   end;

   function get_ProtocolCode
   (
      this : in out UsbDeviceClass
   )
   return IReference_Byte.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Byte.Kind;
   begin
      Hr := this.m_IUsbDeviceClass.all.get_ProtocolCode (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Byte (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ProtocolCode
   (
      this : in out UsbDeviceClass;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbDeviceClass.all.put_ProtocolCode (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbDeviceClasses

   procedure Initialize (this : in out UsbDeviceClasses) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbDeviceClasses) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbDeviceClasses, IUsbDeviceClasses_Ptr);
   begin
      if this.m_IUsbDeviceClasses /= null then
         if this.m_IUsbDeviceClasses.all /= null then
            RefCount := this.m_IUsbDeviceClasses.all.Release;
            Free (this.m_IUsbDeviceClasses);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UsbDeviceClasses

   function get_CdcControl
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CdcControl (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Physical
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Physical (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PersonalHealthcare
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PersonalHealthcare (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActiveSync
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActiveSync (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PalmSync
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PalmSync (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DeviceFirmwareUpdate
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DeviceFirmwareUpdate (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Irda
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Irda (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Measurement
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Measurement (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VendorSpecific
   return WinRt.Windows.Devices.Usb.UsbDeviceClass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbDeviceClasses");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbDeviceClassesStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbDeviceClass;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbDeviceClass do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbDeviceClassesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VendorSpecific (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbDeviceClass := new Windows.Devices.Usb.IUsbDeviceClass;
            Retval.m_IUsbDeviceClass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbDeviceClasses

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbDeviceDescriptor

   procedure Initialize (this : in out UsbDeviceDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbDeviceDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbDeviceDescriptor, IUsbDeviceDescriptor_Ptr);
   begin
      if this.m_IUsbDeviceDescriptor /= null then
         if this.m_IUsbDeviceDescriptor.all /= null then
            RefCount := this.m_IUsbDeviceDescriptor.all.Release;
            Free (this.m_IUsbDeviceDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbDeviceDescriptor

   function get_BcdUsb
   (
      this : in out UsbDeviceDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbDeviceDescriptor.all.get_BcdUsb (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MaxPacketSize0
   (
      this : in out UsbDeviceDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbDeviceDescriptor.all.get_MaxPacketSize0 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_VendorId
   (
      this : in out UsbDeviceDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbDeviceDescriptor.all.get_VendorId (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ProductId
   (
      this : in out UsbDeviceDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbDeviceDescriptor.all.get_ProductId (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_BcdDeviceRevision
   (
      this : in out UsbDeviceDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbDeviceDescriptor.all.get_BcdDeviceRevision (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_NumberOfConfigurations
   (
      this : in out UsbDeviceDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbDeviceDescriptor.all.get_NumberOfConfigurations (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbEndpointDescriptor

   procedure Initialize (this : in out UsbEndpointDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbEndpointDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbEndpointDescriptor, IUsbEndpointDescriptor_Ptr);
   begin
      if this.m_IUsbEndpointDescriptor /= null then
         if this.m_IUsbEndpointDescriptor.all /= null then
            RefCount := this.m_IUsbEndpointDescriptor.all.Release;
            Free (this.m_IUsbEndpointDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UsbEndpointDescriptor

   function TryParse
   (
      descriptor : Windows.Devices.Usb.UsbDescriptor'Class;
      parsed : access Windows.Devices.Usb.IUsbEndpointDescriptor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbEndpointDescriptor");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbEndpointDescriptorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUsbEndpointDescriptorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.TryParse (descriptor.m_IUsbDescriptor.all, parsed, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Parse
   (
      descriptor : Windows.Devices.Usb.UsbDescriptor'Class
   )
   return WinRt.Windows.Devices.Usb.UsbEndpointDescriptor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbEndpointDescriptor");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbEndpointDescriptorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbEndpointDescriptor do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbEndpointDescriptorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Parse (descriptor.m_IUsbDescriptor.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbEndpointDescriptor := new Windows.Devices.Usb.IUsbEndpointDescriptor;
            Retval.m_IUsbEndpointDescriptor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbEndpointDescriptor

   function get_EndpointNumber
   (
      this : in out UsbEndpointDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbEndpointDescriptor.all.get_EndpointNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Direction
   (
      this : in out UsbEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbTransferDirection is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbTransferDirection;
   begin
      Hr := this.m_IUsbEndpointDescriptor.all.get_Direction (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EndpointType
   (
      this : in out UsbEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbEndpointType is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbEndpointType;
   begin
      Hr := this.m_IUsbEndpointDescriptor.all.get_EndpointType (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AsBulkInEndpointDescriptor
   (
      this : in out UsbEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbBulkInEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbBulkInEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbBulkInEndpointDescriptor do
         Hr := this.m_IUsbEndpointDescriptor.all.get_AsBulkInEndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbBulkInEndpointDescriptor := new Windows.Devices.Usb.IUsbBulkInEndpointDescriptor;
         Retval.m_IUsbBulkInEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   function get_AsInterruptInEndpointDescriptor
   (
      this : in out UsbEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbInterruptInEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterruptInEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterruptInEndpointDescriptor do
         Hr := this.m_IUsbEndpointDescriptor.all.get_AsInterruptInEndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbInterruptInEndpointDescriptor := new Windows.Devices.Usb.IUsbInterruptInEndpointDescriptor;
         Retval.m_IUsbInterruptInEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   function get_AsBulkOutEndpointDescriptor
   (
      this : in out UsbEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbBulkOutEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbBulkOutEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbBulkOutEndpointDescriptor do
         Hr := this.m_IUsbEndpointDescriptor.all.get_AsBulkOutEndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbBulkOutEndpointDescriptor := new Windows.Devices.Usb.IUsbBulkOutEndpointDescriptor;
         Retval.m_IUsbBulkOutEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   function get_AsInterruptOutEndpointDescriptor
   (
      this : in out UsbEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterruptOutEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor do
         Hr := this.m_IUsbEndpointDescriptor.all.get_AsInterruptOutEndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbInterruptOutEndpointDescriptor := new Windows.Devices.Usb.IUsbInterruptOutEndpointDescriptor;
         Retval.m_IUsbInterruptOutEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterface

   procedure Initialize (this : in out UsbInterface) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterface) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterface, IUsbInterface_Ptr);
   begin
      if this.m_IUsbInterface /= null then
         if this.m_IUsbInterface.all /= null then
            RefCount := this.m_IUsbInterface.all.Release;
            Free (this.m_IUsbInterface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterface

   function get_BulkInPipes
   (
      this : in out UsbInterface
   )
   return IVectorView_IUsbBulkInPipe.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbBulkInPipe.Kind;
   begin
      Hr := this.m_IUsbInterface.all.get_BulkInPipes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbBulkInPipe (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_InterruptInPipes
   (
      this : in out UsbInterface
   )
   return IVectorView_IUsbInterruptInPipe.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbInterruptInPipe.Kind;
   begin
      Hr := this.m_IUsbInterface.all.get_InterruptInPipes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbInterruptInPipe (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_BulkOutPipes
   (
      this : in out UsbInterface
   )
   return IVectorView_IUsbBulkOutPipe.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbBulkOutPipe.Kind;
   begin
      Hr := this.m_IUsbInterface.all.get_BulkOutPipes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbBulkOutPipe (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_InterruptOutPipes
   (
      this : in out UsbInterface
   )
   return IVectorView_IUsbInterruptOutPipe.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbInterruptOutPipe.Kind;
   begin
      Hr := this.m_IUsbInterface.all.get_InterruptOutPipes (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbInterruptOutPipe (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_InterfaceSettings
   (
      this : in out UsbInterface
   )
   return IVectorView_IUsbInterfaceSetting.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbInterfaceSetting.Kind;
   begin
      Hr := this.m_IUsbInterface.all.get_InterfaceSettings (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbInterfaceSetting (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_InterfaceNumber
   (
      this : in out UsbInterface
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterface.all.get_InterfaceNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Descriptors
   (
      this : in out UsbInterface
   )
   return IVectorView_IUsbDescriptor.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbDescriptor.Kind;
   begin
      Hr := this.m_IUsbInterface.all.get_Descriptors (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbDescriptor (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterfaceDescriptor

   procedure Initialize (this : in out UsbInterfaceDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterfaceDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterfaceDescriptor, IUsbInterfaceDescriptor_Ptr);
   begin
      if this.m_IUsbInterfaceDescriptor /= null then
         if this.m_IUsbInterfaceDescriptor.all /= null then
            RefCount := this.m_IUsbInterfaceDescriptor.all.Release;
            Free (this.m_IUsbInterfaceDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UsbInterfaceDescriptor

   function TryParse
   (
      descriptor : Windows.Devices.Usb.UsbDescriptor'Class;
      parsed : access Windows.Devices.Usb.IUsbInterfaceDescriptor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbInterfaceDescriptor");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbInterfaceDescriptorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUsbInterfaceDescriptorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.TryParse (descriptor.m_IUsbDescriptor.all, parsed, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function Parse
   (
      descriptor : Windows.Devices.Usb.UsbDescriptor'Class
   )
   return WinRt.Windows.Devices.Usb.UsbInterfaceDescriptor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbInterfaceDescriptor");
      m_Factory        : access WinRt.Windows.Devices.Usb.IUsbInterfaceDescriptorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterfaceDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterfaceDescriptor do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbInterfaceDescriptorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Parse (descriptor.m_IUsbDescriptor.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IUsbInterfaceDescriptor := new Windows.Devices.Usb.IUsbInterfaceDescriptor;
            Retval.m_IUsbInterfaceDescriptor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterfaceDescriptor

   function get_ClassCode
   (
      this : in out UsbInterfaceDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterfaceDescriptor.all.get_ClassCode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_SubclassCode
   (
      this : in out UsbInterfaceDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterfaceDescriptor.all.get_SubclassCode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ProtocolCode
   (
      this : in out UsbInterfaceDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterfaceDescriptor.all.get_ProtocolCode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AlternateSettingNumber
   (
      this : in out UsbInterfaceDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterfaceDescriptor.all.get_AlternateSettingNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_InterfaceNumber
   (
      this : in out UsbInterfaceDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterfaceDescriptor.all.get_InterfaceNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterfaceSetting

   procedure Initialize (this : in out UsbInterfaceSetting) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterfaceSetting) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterfaceSetting, IUsbInterfaceSetting_Ptr);
   begin
      if this.m_IUsbInterfaceSetting /= null then
         if this.m_IUsbInterfaceSetting.all /= null then
            RefCount := this.m_IUsbInterfaceSetting.all.Release;
            Free (this.m_IUsbInterfaceSetting);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterfaceSetting

   function get_BulkInEndpoints
   (
      this : in out UsbInterfaceSetting
   )
   return IVectorView_IUsbBulkInEndpointDescriptor.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbBulkInEndpointDescriptor.Kind;
   begin
      Hr := this.m_IUsbInterfaceSetting.all.get_BulkInEndpoints (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbBulkInEndpointDescriptor (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_InterruptInEndpoints
   (
      this : in out UsbInterfaceSetting
   )
   return IVectorView_IUsbInterruptInEndpointDescriptor.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbInterruptInEndpointDescriptor.Kind;
   begin
      Hr := this.m_IUsbInterfaceSetting.all.get_InterruptInEndpoints (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbInterruptInEndpointDescriptor (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_BulkOutEndpoints
   (
      this : in out UsbInterfaceSetting
   )
   return IVectorView_IUsbBulkOutEndpointDescriptor.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbBulkOutEndpointDescriptor.Kind;
   begin
      Hr := this.m_IUsbInterfaceSetting.all.get_BulkOutEndpoints (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbBulkOutEndpointDescriptor (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_InterruptOutEndpoints
   (
      this : in out UsbInterfaceSetting
   )
   return IVectorView_IUsbInterruptOutEndpointDescriptor.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbInterruptOutEndpointDescriptor.Kind;
   begin
      Hr := this.m_IUsbInterfaceSetting.all.get_InterruptOutEndpoints (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbInterruptOutEndpointDescriptor (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Selected
   (
      this : in out UsbInterfaceSetting
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IUsbInterfaceSetting.all.get_Selected (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure SelectSettingAsync
   (
      this : in out UsbInterfaceSetting
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUsbInterfaceSetting.all.SelectSettingAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function get_InterfaceDescriptor
   (
      this : in out UsbInterfaceSetting
   )
   return WinRt.Windows.Devices.Usb.UsbInterfaceDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterfaceDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterfaceDescriptor do
         Hr := this.m_IUsbInterfaceSetting.all.get_InterfaceDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbInterfaceDescriptor := new Windows.Devices.Usb.IUsbInterfaceDescriptor;
         Retval.m_IUsbInterfaceDescriptor.all := m_ComRetVal;
      end return;
   end;

   function get_Descriptors
   (
      this : in out UsbInterfaceSetting
   )
   return IVectorView_IUsbDescriptor.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IUsbDescriptor.Kind;
   begin
      Hr := this.m_IUsbInterfaceSetting.all.get_Descriptors (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IUsbDescriptor (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterruptInEndpointDescriptor

   procedure Initialize (this : in out UsbInterruptInEndpointDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterruptInEndpointDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterruptInEndpointDescriptor, IUsbInterruptInEndpointDescriptor_Ptr);
   begin
      if this.m_IUsbInterruptInEndpointDescriptor /= null then
         if this.m_IUsbInterruptInEndpointDescriptor.all /= null then
            RefCount := this.m_IUsbInterruptInEndpointDescriptor.all.Release;
            Free (this.m_IUsbInterruptInEndpointDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterruptInEndpointDescriptor

   function get_MaxPacketSize
   (
      this : in out UsbInterruptInEndpointDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbInterruptInEndpointDescriptor.all.get_MaxPacketSize (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EndpointNumber
   (
      this : in out UsbInterruptInEndpointDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterruptInEndpointDescriptor.all.get_EndpointNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Interval
   (
      this : in out UsbInterruptInEndpointDescriptor
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IUsbInterruptInEndpointDescriptor.all.get_Interval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Pipe
   (
      this : in out UsbInterruptInEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbInterruptInPipe'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterruptInPipe;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterruptInPipe do
         Hr := this.m_IUsbInterruptInEndpointDescriptor.all.get_Pipe (m_ComRetVal'Access);
         Retval.m_IUsbInterruptInPipe := new Windows.Devices.Usb.IUsbInterruptInPipe;
         Retval.m_IUsbInterruptInPipe.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterruptInEventArgs

   procedure Initialize (this : in out UsbInterruptInEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterruptInEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterruptInEventArgs, IUsbInterruptInEventArgs_Ptr);
   begin
      if this.m_IUsbInterruptInEventArgs /= null then
         if this.m_IUsbInterruptInEventArgs.all /= null then
            RefCount := this.m_IUsbInterruptInEventArgs.all.Release;
            Free (this.m_IUsbInterruptInEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterruptInEventArgs

   function get_InterruptData
   (
      this : in out UsbInterruptInEventArgs
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IUsbInterruptInEventArgs.all.get_InterruptData (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterruptInPipe

   procedure Initialize (this : in out UsbInterruptInPipe) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterruptInPipe) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterruptInPipe, IUsbInterruptInPipe_Ptr);
   begin
      if this.m_IUsbInterruptInPipe /= null then
         if this.m_IUsbInterruptInPipe.all /= null then
            RefCount := this.m_IUsbInterruptInPipe.all.Release;
            Free (this.m_IUsbInterruptInPipe);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterruptInPipe

   function get_EndpointDescriptor
   (
      this : in out UsbInterruptInPipe
   )
   return WinRt.Windows.Devices.Usb.UsbInterruptInEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterruptInEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterruptInEndpointDescriptor do
         Hr := this.m_IUsbInterruptInPipe.all.get_EndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbInterruptInEndpointDescriptor := new Windows.Devices.Usb.IUsbInterruptInEndpointDescriptor;
         Retval.m_IUsbInterruptInEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   procedure ClearStallAsync
   (
      this : in out UsbInterruptInPipe
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUsbInterruptInPipe.all.ClearStallAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function add_DataReceived
   (
      this : in out UsbInterruptInPipe;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IUsbInterruptInPipe.all.add_DataReceived (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_DataReceived
   (
      this : in out UsbInterruptInPipe;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbInterruptInPipe.all.remove_DataReceived (token);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterruptOutEndpointDescriptor

   procedure Initialize (this : in out UsbInterruptOutEndpointDescriptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterruptOutEndpointDescriptor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterruptOutEndpointDescriptor, IUsbInterruptOutEndpointDescriptor_Ptr);
   begin
      if this.m_IUsbInterruptOutEndpointDescriptor /= null then
         if this.m_IUsbInterruptOutEndpointDescriptor.all /= null then
            RefCount := this.m_IUsbInterruptOutEndpointDescriptor.all.Release;
            Free (this.m_IUsbInterruptOutEndpointDescriptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterruptOutEndpointDescriptor

   function get_MaxPacketSize
   (
      this : in out UsbInterruptOutEndpointDescriptor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbInterruptOutEndpointDescriptor.all.get_MaxPacketSize (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EndpointNumber
   (
      this : in out UsbInterruptOutEndpointDescriptor
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbInterruptOutEndpointDescriptor.all.get_EndpointNumber (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Interval
   (
      this : in out UsbInterruptOutEndpointDescriptor
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IUsbInterruptOutEndpointDescriptor.all.get_Interval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Pipe
   (
      this : in out UsbInterruptOutEndpointDescriptor
   )
   return WinRt.Windows.Devices.Usb.UsbInterruptOutPipe'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterruptOutPipe;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterruptOutPipe do
         Hr := this.m_IUsbInterruptOutEndpointDescriptor.all.get_Pipe (m_ComRetVal'Access);
         Retval.m_IUsbInterruptOutPipe := new Windows.Devices.Usb.IUsbInterruptOutPipe;
         Retval.m_IUsbInterruptOutPipe.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbInterruptOutPipe

   procedure Initialize (this : in out UsbInterruptOutPipe) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbInterruptOutPipe) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbInterruptOutPipe, IUsbInterruptOutPipe_Ptr);
   begin
      if this.m_IUsbInterruptOutPipe /= null then
         if this.m_IUsbInterruptOutPipe.all /= null then
            RefCount := this.m_IUsbInterruptOutPipe.all.Release;
            Free (this.m_IUsbInterruptOutPipe);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbInterruptOutPipe

   function get_EndpointDescriptor
   (
      this : in out UsbInterruptOutPipe
   )
   return WinRt.Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbInterruptOutEndpointDescriptor;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor do
         Hr := this.m_IUsbInterruptOutPipe.all.get_EndpointDescriptor (m_ComRetVal'Access);
         Retval.m_IUsbInterruptOutEndpointDescriptor := new Windows.Devices.Usb.IUsbInterruptOutEndpointDescriptor;
         Retval.m_IUsbInterruptOutEndpointDescriptor.all := m_ComRetVal;
      end return;
   end;

   procedure ClearStallAsync
   (
      this : in out UsbInterruptOutPipe
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUsbInterruptOutPipe.all.ClearStallAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure put_WriteOptions
   (
      this : in out UsbInterruptOutPipe;
      value : Windows.Devices.Usb.UsbWriteOptions
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbInterruptOutPipe.all.put_WriteOptions (value);
   end;

   function get_WriteOptions
   (
      this : in out UsbInterruptOutPipe
   )
   return WinRt.Windows.Devices.Usb.UsbWriteOptions is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.UsbWriteOptions;
   begin
      Hr := this.m_IUsbInterruptOutPipe.all.get_WriteOptions (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_OutputStream
   (
      this : in out UsbInterruptOutPipe
   )
   return WinRt.Windows.Storage.Streams.IOutputStream is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IOutputStream;
   begin
      Hr := this.m_IUsbInterruptOutPipe.all.get_OutputStream (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UsbSetupPacket

   procedure Initialize (this : in out UsbSetupPacket) is
   begin
      null;
   end;

   procedure Finalize (this : in out UsbSetupPacket) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUsbSetupPacket, IUsbSetupPacket_Ptr);
   begin
      if this.m_IUsbSetupPacket /= null then
         if this.m_IUsbSetupPacket.all /= null then
            RefCount := this.m_IUsbSetupPacket.all.Release;
            Free (this.m_IUsbSetupPacket);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UsbSetupPacket

   function Constructor return UsbSetupPacket is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbSetupPacket");
      m_ComRetVal  : aliased Windows.Devices.Usb.IUsbSetupPacket;
   begin
      return RetVal : UsbSetupPacket do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IUsbSetupPacket := new Windows.Devices.Usb.IUsbSetupPacket;
            Retval.m_IUsbSetupPacket.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      eightByteBuffer : Windows.Storage.Streams.IBuffer
   )
   return UsbSetupPacket is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Usb.UsbSetupPacket");
      m_Factory    : access IUsbSetupPacketFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Usb.IUsbSetupPacket;
   begin
      return RetVal : UsbSetupPacket do
         Hr := RoGetActivationFactory (m_hString, IID_IUsbSetupPacketFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithEightByteBuffer (eightByteBuffer, m_ComRetVal'Access);
            Retval.m_IUsbSetupPacket := new Windows.Devices.Usb.IUsbSetupPacket;
            Retval.m_IUsbSetupPacket.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UsbSetupPacket

   function get_RequestType
   (
      this : in out UsbSetupPacket
   )
   return WinRt.Windows.Devices.Usb.UsbControlRequestType'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Usb.IUsbControlRequestType;
   begin
      return RetVal : WinRt.Windows.Devices.Usb.UsbControlRequestType do
         Hr := this.m_IUsbSetupPacket.all.get_RequestType (m_ComRetVal'Access);
         Retval.m_IUsbControlRequestType := new Windows.Devices.Usb.IUsbControlRequestType;
         Retval.m_IUsbControlRequestType.all := m_ComRetVal;
      end return;
   end;

   procedure put_RequestType
   (
      this : in out UsbSetupPacket;
      value : Windows.Devices.Usb.UsbControlRequestType'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbSetupPacket.all.put_RequestType (value.m_IUsbControlRequestType.all);
   end;

   function get_Request
   (
      this : in out UsbSetupPacket
   )
   return WinRt.Byte is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte;
   begin
      Hr := this.m_IUsbSetupPacket.all.get_Request (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Request
   (
      this : in out UsbSetupPacket;
      value : WinRt.Byte
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbSetupPacket.all.put_Request (value);
   end;

   function get_Value
   (
      this : in out UsbSetupPacket
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbSetupPacket.all.get_Value (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out UsbSetupPacket;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbSetupPacket.all.put_Value (value);
   end;

   function get_Index
   (
      this : in out UsbSetupPacket
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbSetupPacket.all.get_Index (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Index
   (
      this : in out UsbSetupPacket;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbSetupPacket.all.put_Index (value);
   end;

   function get_Length
   (
      this : in out UsbSetupPacket
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IUsbSetupPacket.all.get_Length (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Length
   (
      this : in out UsbSetupPacket;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IUsbSetupPacket.all.put_Length (value);
   end;

end;
