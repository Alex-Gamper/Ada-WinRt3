--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Devices.Geolocation;
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.UI.Popups;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Services.Maps is

   package IAsyncOperation_MapLocationFinderResult is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Services.Maps.IMapLocationFinderResult);
   package AsyncOperationCompletedHandler_MapLocationFinderResult is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Services.Maps.IMapLocationFinderResult);

   package IAsyncOperation_MapRouteFinderResult is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Services.Maps.IMapRouteFinderResult);
   package AsyncOperationCompletedHandler_MapRouteFinderResult is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Services.Maps.IMapRouteFinderResult);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EnhancedWaypoint

   procedure Initialize (this : in out EnhancedWaypoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out EnhancedWaypoint) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEnhancedWaypoint, IEnhancedWaypoint_Ptr);
   begin
      if this.m_IEnhancedWaypoint /= null then
         if this.m_IEnhancedWaypoint.all /= null then
            RefCount := this.m_IEnhancedWaypoint.all.Release;
            Free (this.m_IEnhancedWaypoint);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for EnhancedWaypoint

   function Constructor
   (
      point : Windows.Devices.Geolocation.Geopoint'Class;
      kind : Windows.Services.Maps.WaypointKind
   )
   return EnhancedWaypoint is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Services.Maps.EnhancedWaypoint");
      m_Factory    : access IEnhancedWaypointFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Services.Maps.IEnhancedWaypoint;
   begin
      return RetVal : EnhancedWaypoint do
         Hr := RoGetActivationFactory (m_hString, IID_IEnhancedWaypointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (point.m_IGeopoint.all, kind, m_ComRetVal'Access);
            Retval.m_IEnhancedWaypoint := new Windows.Services.Maps.IEnhancedWaypoint;
            Retval.m_IEnhancedWaypoint.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EnhancedWaypoint

   function get_Point
   (
      this : in out EnhancedWaypoint
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IEnhancedWaypoint.all.get_Point (m_ComRetVal'Access);
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_Kind
   (
      this : in out EnhancedWaypoint
   )
   return WinRt.Windows.Services.Maps.WaypointKind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.WaypointKind;
   begin
      Hr := this.m_IEnhancedWaypoint.all.get_Kind (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManeuverWarning

   procedure Initialize (this : in out ManeuverWarning) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManeuverWarning) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManeuverWarning, IManeuverWarning_Ptr);
   begin
      if this.m_IManeuverWarning /= null then
         if this.m_IManeuverWarning.all /= null then
            RefCount := this.m_IManeuverWarning.all.Release;
            Free (this.m_IManeuverWarning);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManeuverWarning

   function get_Kind
   (
      this : in out ManeuverWarning
   )
   return WinRt.Windows.Services.Maps.ManeuverWarningKind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.ManeuverWarningKind;
   begin
      Hr := this.m_IManeuverWarning.all.get_Kind (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Severity
   (
      this : in out ManeuverWarning
   )
   return WinRt.Windows.Services.Maps.ManeuverWarningSeverity is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.ManeuverWarningSeverity;
   begin
      Hr := this.m_IManeuverWarning.all.get_Severity (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapAddress

   procedure Initialize (this : in out MapAddress) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapAddress) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapAddress, IMapAddress_Ptr);
   begin
      if this.m_IMapAddress /= null then
         if this.m_IMapAddress.all /= null then
            RefCount := this.m_IMapAddress.all.Release;
            Free (this.m_IMapAddress);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapAddress

   function get_BuildingName
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_BuildingName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_BuildingFloor
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_BuildingFloor (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_BuildingRoom
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_BuildingRoom (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_BuildingWing
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_BuildingWing (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_StreetNumber
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_StreetNumber (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Street
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_Street (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Neighborhood
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_Neighborhood (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_District
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_District (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Town
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_Town (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Region
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_Region (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_RegionCode
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_RegionCode (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Country
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_Country (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_CountryCode
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_CountryCode (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_PostCode
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_PostCode (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Continent
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapAddress.all.get_Continent (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_FormattedAddress
   (
      this : in out MapAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapAddress2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapAddress_Interface, WinRt.Windows.Services.Maps.IMapAddress2, WinRt.Windows.Services.Maps.IID_IMapAddress2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapAddress.all);
      Hr := m_Interface.get_FormattedAddress (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapLocation

   procedure Initialize (this : in out MapLocation) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapLocation) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapLocation, IMapLocation_Ptr);
   begin
      if this.m_IMapLocation /= null then
         if this.m_IMapLocation.all /= null then
            RefCount := this.m_IMapLocation.all.Release;
            Free (this.m_IMapLocation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapLocation

   function get_Point
   (
      this : in out MapLocation
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapLocation.all.get_Point (m_ComRetVal'Access);
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_DisplayName
   (
      this : in out MapLocation
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapLocation.all.get_DisplayName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Description
   (
      this : in out MapLocation
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapLocation.all.get_Description (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Address
   (
      this : in out MapLocation
   )
   return WinRt.Windows.Services.Maps.MapAddress'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IMapAddress;
   begin
      return RetVal : WinRt.Windows.Services.Maps.MapAddress do
         Hr := this.m_IMapLocation.all.get_Address (m_ComRetVal'Access);
         Retval.m_IMapAddress := new Windows.Services.Maps.IMapAddress;
         Retval.m_IMapAddress.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body MapLocationFinder is

      function FindLocationsAtAsync
      (
         queryPoint : Windows.Devices.Geolocation.Geopoint'Class;
         accuracy : Windows.Services.Maps.MapLocationDesiredAccuracy
      )
      return WinRt.Windows.Services.Maps.MapLocationFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapLocationFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapLocationFinderStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapLocationFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapLocationFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapLocationFinderResult;
         m_IID            : aliased WinRt.IID := (3857051187, 43992, 22165, (159, 229, 172, 149, 133, 13, 113, 152 )); -- Windows.Services.Maps.MapLocationFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (651094801, 4641, 23595, (187, 249, 207, 234, 54, 99, 194, 237 ));
         m_Handler        : AsyncOperationCompletedHandler_MapLocationFinderResult.Kind := new AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapLocationFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapLocationFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapLocationFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapLocationFinderStatics2'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.FindLocationsAtAsync (queryPoint.m_IGeopoint.all, accuracy, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapLocationFinderResult := new Windows.Services.Maps.IMapLocationFinderResult;
                        Retval.m_IMapLocationFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function FindLocationsAtAsync
      (
         queryPoint : Windows.Devices.Geolocation.Geopoint'Class
      )
      return WinRt.Windows.Services.Maps.MapLocationFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapLocationFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapLocationFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapLocationFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapLocationFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapLocationFinderResult;
         m_IID            : aliased WinRt.IID := (3857051187, 43992, 22165, (159, 229, 172, 149, 133, 13, 113, 152 )); -- Windows.Services.Maps.MapLocationFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (651094801, 4641, 23595, (187, 249, 207, 234, 54, 99, 194, 237 ));
         m_Handler        : AsyncOperationCompletedHandler_MapLocationFinderResult.Kind := new AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapLocationFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapLocationFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapLocationFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapLocationFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.FindLocationsAtAsync (queryPoint.m_IGeopoint.all, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapLocationFinderResult := new Windows.Services.Maps.IMapLocationFinderResult;
                        Retval.m_IMapLocationFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function FindLocationsAsync
      (
         searchText : WinRt.WString;
         referencePoint : Windows.Devices.Geolocation.Geopoint'Class
      )
      return WinRt.Windows.Services.Maps.MapLocationFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapLocationFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapLocationFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_searchText : WinRt.HString := To_HString (searchText);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapLocationFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapLocationFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapLocationFinderResult;
         m_IID            : aliased WinRt.IID := (3857051187, 43992, 22165, (159, 229, 172, 149, 133, 13, 113, 152 )); -- Windows.Services.Maps.MapLocationFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (651094801, 4641, 23595, (187, 249, 207, 234, 54, 99, 194, 237 ));
         m_Handler        : AsyncOperationCompletedHandler_MapLocationFinderResult.Kind := new AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapLocationFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapLocationFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapLocationFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapLocationFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.FindLocationsAsync (HStr_searchText, referencePoint.m_IGeopoint.all, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapLocationFinderResult := new Windows.Services.Maps.IMapLocationFinderResult;
                        Retval.m_IMapLocationFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
            Hr := WindowsDeleteString (HStr_searchText);
         end return;
      end;

      function FindLocationsAsync
      (
         searchText : WinRt.WString;
         referencePoint : Windows.Devices.Geolocation.Geopoint'Class;
         maxCount : WinRt.UInt32
      )
      return WinRt.Windows.Services.Maps.MapLocationFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapLocationFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapLocationFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_searchText : WinRt.HString := To_HString (searchText);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapLocationFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapLocationFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapLocationFinderResult;
         m_IID            : aliased WinRt.IID := (3857051187, 43992, 22165, (159, 229, 172, 149, 133, 13, 113, 152 )); -- Windows.Services.Maps.MapLocationFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (651094801, 4641, 23595, (187, 249, 207, 234, 54, 99, 194, 237 ));
         m_Handler        : AsyncOperationCompletedHandler_MapLocationFinderResult.Kind := new AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapLocationFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapLocationFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapLocationFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapLocationFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapLocationFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.FindLocationsAsync (HStr_searchText, referencePoint.m_IGeopoint.all, maxCount, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapLocationFinderResult := new Windows.Services.Maps.IMapLocationFinderResult;
                        Retval.m_IMapLocationFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
            Hr := WindowsDeleteString (HStr_searchText);
         end return;
      end;

   end MapLocationFinder;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapLocationFinderResult

   procedure Initialize (this : in out MapLocationFinderResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapLocationFinderResult) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapLocationFinderResult, IMapLocationFinderResult_Ptr);
   begin
      if this.m_IMapLocationFinderResult /= null then
         if this.m_IMapLocationFinderResult.all /= null then
            RefCount := this.m_IMapLocationFinderResult.all.Release;
            Free (this.m_IMapLocationFinderResult);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapLocationFinderResult

   function get_Locations
   (
      this : in out MapLocationFinderResult
   )
   return IVectorView_IMapLocation.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapLocation.Kind;
   begin
      Hr := this.m_IMapLocationFinderResult.all.get_Locations (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IMapLocation (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Status
   (
      this : in out MapLocationFinderResult
   )
   return WinRt.Windows.Services.Maps.MapLocationFinderStatus is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.MapLocationFinderStatus;
   begin
      Hr := this.m_IMapLocationFinderResult.all.get_Status (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body MapManager is

      procedure ShowDownloadedMapsUI is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapManager");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapManagerStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ShowDownloadedMapsUI;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end;

      procedure ShowMapsUpdateUI is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapManager");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapManagerStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ShowMapsUpdateUI;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end;

   end MapManager;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapRoute

   procedure Initialize (this : in out MapRoute) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapRoute) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapRoute, IMapRoute_Ptr);
   begin
      if this.m_IMapRoute /= null then
         if this.m_IMapRoute.all /= null then
            RefCount := this.m_IMapRoute.all.Release;
            Free (this.m_IMapRoute);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapRoute

   function get_BoundingBox
   (
      this : in out MapRoute
   )
   return WinRt.Windows.Devices.Geolocation.GeoboundingBox'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeoboundingBox do
         Hr := this.m_IMapRoute.all.get_BoundingBox (m_ComRetVal'Access);
         Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
         Retval.m_IGeoboundingBox.all := m_ComRetVal;
      end return;
   end;

   function get_LengthInMeters
   (
      this : in out MapRoute
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapRoute.all.get_LengthInMeters (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EstimatedDuration
   (
      this : in out MapRoute
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IMapRoute.all.get_EstimatedDuration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Path
   (
      this : in out MapRoute
   )
   return WinRt.Windows.Devices.Geolocation.Geopath'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopath do
         Hr := this.m_IMapRoute.all.get_Path (m_ComRetVal'Access);
         Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
         Retval.m_IGeopath.all := m_ComRetVal;
      end return;
   end;

   function get_Legs
   (
      this : in out MapRoute
   )
   return IVectorView_IMapRouteLeg.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapRouteLeg.Kind;
   begin
      Hr := this.m_IMapRoute.all.get_Legs (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IMapRouteLeg (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IsTrafficBased
   (
      this : in out MapRoute
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapRoute.all.get_IsTrafficBased (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ViolatedRestrictions
   (
      this : in out MapRoute
   )
   return WinRt.Windows.Services.Maps.MapRouteRestrictions is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRoute2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.MapRouteRestrictions;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRoute_Interface, WinRt.Windows.Services.Maps.IMapRoute2, WinRt.Windows.Services.Maps.IID_IMapRoute2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRoute.all);
      Hr := m_Interface.get_ViolatedRestrictions (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_HasBlockedRoads
   (
      this : in out MapRoute
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRoute2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRoute_Interface, WinRt.Windows.Services.Maps.IMapRoute2, WinRt.Windows.Services.Maps.IID_IMapRoute2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRoute.all);
      Hr := m_Interface.get_HasBlockedRoads (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_DurationWithoutTraffic
   (
      this : in out MapRoute
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRoute3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRoute_Interface, WinRt.Windows.Services.Maps.IMapRoute3, WinRt.Windows.Services.Maps.IID_IMapRoute3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRoute.all);
      Hr := m_Interface.get_DurationWithoutTraffic (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_TrafficCongestion
   (
      this : in out MapRoute
   )
   return WinRt.Windows.Services.Maps.TrafficCongestion is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRoute3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.TrafficCongestion;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRoute_Interface, WinRt.Windows.Services.Maps.IMapRoute3, WinRt.Windows.Services.Maps.IID_IMapRoute3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRoute.all);
      Hr := m_Interface.get_TrafficCongestion (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_IsScenic
   (
      this : in out MapRoute
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRoute4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRoute_Interface, WinRt.Windows.Services.Maps.IMapRoute4, WinRt.Windows.Services.Maps.IID_IMapRoute4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRoute.all);
      Hr := m_Interface.get_IsScenic (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapRouteDrivingOptions

   procedure Initialize (this : in out MapRouteDrivingOptions) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapRouteDrivingOptions) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapRouteDrivingOptions, IMapRouteDrivingOptions_Ptr);
   begin
      if this.m_IMapRouteDrivingOptions /= null then
         if this.m_IMapRouteDrivingOptions.all /= null then
            RefCount := this.m_IMapRouteDrivingOptions.all.Release;
            Free (this.m_IMapRouteDrivingOptions);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapRouteDrivingOptions

   function Constructor return MapRouteDrivingOptions is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteDrivingOptions");
      m_ComRetVal  : aliased Windows.Services.Maps.IMapRouteDrivingOptions;
   begin
      return RetVal : MapRouteDrivingOptions do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapRouteDrivingOptions := new Windows.Services.Maps.IMapRouteDrivingOptions;
            Retval.m_IMapRouteDrivingOptions.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapRouteDrivingOptions

   function get_MaxAlternateRouteCount
   (
      this : in out MapRouteDrivingOptions
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.get_MaxAlternateRouteCount (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_MaxAlternateRouteCount
   (
      this : in out MapRouteDrivingOptions;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.put_MaxAlternateRouteCount (value);
   end;

   function get_InitialHeading
   (
      this : in out MapRouteDrivingOptions
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.get_InitialHeading (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_InitialHeading
   (
      this : in out MapRouteDrivingOptions;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.put_InitialHeading (value);
   end;

   function get_RouteOptimization
   (
      this : in out MapRouteDrivingOptions
   )
   return WinRt.Windows.Services.Maps.MapRouteOptimization is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.MapRouteOptimization;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.get_RouteOptimization (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RouteOptimization
   (
      this : in out MapRouteDrivingOptions;
      value : Windows.Services.Maps.MapRouteOptimization
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.put_RouteOptimization (value);
   end;

   function get_RouteRestrictions
   (
      this : in out MapRouteDrivingOptions
   )
   return WinRt.Windows.Services.Maps.MapRouteRestrictions is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.MapRouteRestrictions;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.get_RouteRestrictions (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RouteRestrictions
   (
      this : in out MapRouteDrivingOptions;
      value : Windows.Services.Maps.MapRouteRestrictions
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapRouteDrivingOptions.all.put_RouteRestrictions (value);
   end;

   function get_DepartureTime
   (
      this : in out MapRouteDrivingOptions
   )
   return IReference_DateTime.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteDrivingOptions2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteDrivingOptions_Interface, WinRt.Windows.Services.Maps.IMapRouteDrivingOptions2, WinRt.Windows.Services.Maps.IID_IMapRouteDrivingOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteDrivingOptions.all);
      Hr := m_Interface.get_DepartureTime (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_DepartureTime
   (
      this : in out MapRouteDrivingOptions;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteDrivingOptions2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteDrivingOptions_Interface, WinRt.Windows.Services.Maps.IMapRouteDrivingOptions2, WinRt.Windows.Services.Maps.IID_IMapRouteDrivingOptions2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteDrivingOptions.all);
      Hr := m_Interface.put_DepartureTime (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body MapRouteFinder is

      function GetDrivingRouteAsync
      (
         startPoint : Windows.Devices.Geolocation.Geopoint'Class;
         endPoint : Windows.Devices.Geolocation.Geopoint'Class
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteAsync (startPoint.m_IGeopoint.all, endPoint.m_IGeopoint.all, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteAsync
      (
         startPoint : Windows.Devices.Geolocation.Geopoint'Class;
         endPoint : Windows.Devices.Geolocation.Geopoint'Class;
         optimization : Windows.Services.Maps.MapRouteOptimization
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteAsync (startPoint.m_IGeopoint.all, endPoint.m_IGeopoint.all, optimization, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteAsync
      (
         startPoint : Windows.Devices.Geolocation.Geopoint'Class;
         endPoint : Windows.Devices.Geolocation.Geopoint'Class;
         optimization : Windows.Services.Maps.MapRouteOptimization;
         restrictions : Windows.Services.Maps.MapRouteRestrictions
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteAsync (startPoint.m_IGeopoint.all, endPoint.m_IGeopoint.all, optimization, restrictions, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteAsync
      (
         startPoint : Windows.Devices.Geolocation.Geopoint'Class;
         endPoint : Windows.Devices.Geolocation.Geopoint'Class;
         optimization : Windows.Services.Maps.MapRouteOptimization;
         restrictions : Windows.Services.Maps.MapRouteRestrictions;
         headingInDegrees : WinRt.Double
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteAsync (startPoint.m_IGeopoint.all, endPoint.m_IGeopoint.all, optimization, restrictions, headingInDegrees, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteFromWaypointsAsync
      (
         wayPoints : GenericObject
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteFromWaypointsAsync (wayPoints, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteFromWaypointsAsync
      (
         wayPoints : GenericObject;
         optimization : Windows.Services.Maps.MapRouteOptimization
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteFromWaypointsAsync (wayPoints, optimization, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteFromWaypointsAsync
      (
         wayPoints : GenericObject;
         optimization : Windows.Services.Maps.MapRouteOptimization;
         restrictions : Windows.Services.Maps.MapRouteRestrictions
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteFromWaypointsAsync (wayPoints, optimization, restrictions, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteFromWaypointsAsync
      (
         wayPoints : GenericObject;
         optimization : Windows.Services.Maps.MapRouteOptimization;
         restrictions : Windows.Services.Maps.MapRouteRestrictions;
         headingInDegrees : WinRt.Double
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteFromWaypointsAsync (wayPoints, optimization, restrictions, headingInDegrees, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetWalkingRouteAsync
      (
         startPoint : Windows.Devices.Geolocation.Geopoint'Class;
         endPoint : Windows.Devices.Geolocation.Geopoint'Class
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetWalkingRouteAsync (startPoint.m_IGeopoint.all, endPoint.m_IGeopoint.all, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetWalkingRouteFromWaypointsAsync
      (
         wayPoints : GenericObject
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetWalkingRouteFromWaypointsAsync (wayPoints, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteFromEnhancedWaypointsAsync
      (
         waypoints : GenericObject
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics3_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics3'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteFromEnhancedWaypointsAsync (waypoints, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteFromEnhancedWaypointsAsync
      (
         waypoints : GenericObject;
         options : Windows.Services.Maps.MapRouteDrivingOptions'Class
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics3_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics3'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteFromEnhancedWaypointsAsync (waypoints, options.m_IMapRouteDrivingOptions.all, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetDrivingRouteAsync
      (
         startPoint : Windows.Devices.Geolocation.Geopoint'Class;
         endPoint : Windows.Devices.Geolocation.Geopoint'Class;
         options : Windows.Services.Maps.MapRouteDrivingOptions'Class
      )
      return WinRt.Windows.Services.Maps.MapRouteFinderResult is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapRouteFinder");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapRouteFinderStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_MapRouteFinderResult.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_MapRouteFinderResult.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Services.Maps.IMapRouteFinderResult;
         m_IID            : aliased WinRt.IID := (3970580095, 50470, 20631, (182, 36, 207, 116, 61, 120, 169, 186 )); -- Windows.Services.Maps.MapRouteFinderResult;
         m_HandlerIID     : aliased WinRt.IID := (1853500239, 33052, 21699, (137, 56, 103, 149, 244, 230, 112, 9 ));
         m_Handler        : AsyncOperationCompletedHandler_MapRouteFinderResult.Kind := new AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapRouteFinderResult.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapRouteFinderResult.Kind_Delegate, AsyncOperationCompletedHandler_MapRouteFinderResult.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Services.Maps.MapRouteFinderResult do
            Hr := RoGetActivationFactory (m_hString, IID_IMapRouteFinderStatics2'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetDrivingRouteAsync (startPoint.m_IGeopoint.all, endPoint.m_IGeopoint.all, options.m_IMapRouteDrivingOptions.all, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_IMapRouteFinderResult := new Windows.Services.Maps.IMapRouteFinderResult;
                        Retval.m_IMapRouteFinderResult.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

   end MapRouteFinder;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapRouteFinderResult

   procedure Initialize (this : in out MapRouteFinderResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapRouteFinderResult) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapRouteFinderResult, IMapRouteFinderResult_Ptr);
   begin
      if this.m_IMapRouteFinderResult /= null then
         if this.m_IMapRouteFinderResult.all /= null then
            RefCount := this.m_IMapRouteFinderResult.all.Release;
            Free (this.m_IMapRouteFinderResult);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapRouteFinderResult

   function get_Route
   (
      this : in out MapRouteFinderResult
   )
   return WinRt.Windows.Services.Maps.MapRoute'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IMapRoute;
   begin
      return RetVal : WinRt.Windows.Services.Maps.MapRoute do
         Hr := this.m_IMapRouteFinderResult.all.get_Route (m_ComRetVal'Access);
         Retval.m_IMapRoute := new Windows.Services.Maps.IMapRoute;
         Retval.m_IMapRoute.all := m_ComRetVal;
      end return;
   end;

   function get_Status
   (
      this : in out MapRouteFinderResult
   )
   return WinRt.Windows.Services.Maps.MapRouteFinderStatus is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.MapRouteFinderStatus;
   begin
      Hr := this.m_IMapRouteFinderResult.all.get_Status (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AlternateRoutes
   (
      this : in out MapRouteFinderResult
   )
   return IVectorView_IMapRoute.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteFinderResult2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapRoute.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteFinderResult_Interface, WinRt.Windows.Services.Maps.IMapRouteFinderResult2, WinRt.Windows.Services.Maps.IID_IMapRouteFinderResult2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteFinderResult.all);
      Hr := m_Interface.get_AlternateRoutes (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVectorView_IMapRoute (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapRouteLeg

   procedure Initialize (this : in out MapRouteLeg) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapRouteLeg) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapRouteLeg, IMapRouteLeg_Ptr);
   begin
      if this.m_IMapRouteLeg /= null then
         if this.m_IMapRouteLeg.all /= null then
            RefCount := this.m_IMapRouteLeg.all.Release;
            Free (this.m_IMapRouteLeg);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapRouteLeg

   function get_BoundingBox
   (
      this : in out MapRouteLeg
   )
   return WinRt.Windows.Devices.Geolocation.GeoboundingBox'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeoboundingBox do
         Hr := this.m_IMapRouteLeg.all.get_BoundingBox (m_ComRetVal'Access);
         Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
         Retval.m_IGeoboundingBox.all := m_ComRetVal;
      end return;
   end;

   function get_Path
   (
      this : in out MapRouteLeg
   )
   return WinRt.Windows.Devices.Geolocation.Geopath'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopath do
         Hr := this.m_IMapRouteLeg.all.get_Path (m_ComRetVal'Access);
         Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
         Retval.m_IGeopath.all := m_ComRetVal;
      end return;
   end;

   function get_LengthInMeters
   (
      this : in out MapRouteLeg
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapRouteLeg.all.get_LengthInMeters (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EstimatedDuration
   (
      this : in out MapRouteLeg
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IMapRouteLeg.all.get_EstimatedDuration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Maneuvers
   (
      this : in out MapRouteLeg
   )
   return IVectorView_IMapRouteManeuver.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapRouteManeuver.Kind;
   begin
      Hr := this.m_IMapRouteLeg.all.get_Maneuvers (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IMapRouteManeuver (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_DurationWithoutTraffic
   (
      this : in out MapRouteLeg
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteLeg2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteLeg_Interface, WinRt.Windows.Services.Maps.IMapRouteLeg2, WinRt.Windows.Services.Maps.IID_IMapRouteLeg2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteLeg.all);
      Hr := m_Interface.get_DurationWithoutTraffic (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_TrafficCongestion
   (
      this : in out MapRouteLeg
   )
   return WinRt.Windows.Services.Maps.TrafficCongestion is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteLeg2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.TrafficCongestion;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteLeg_Interface, WinRt.Windows.Services.Maps.IMapRouteLeg2, WinRt.Windows.Services.Maps.IID_IMapRouteLeg2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteLeg.all);
      Hr := m_Interface.get_TrafficCongestion (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapRouteManeuver

   procedure Initialize (this : in out MapRouteManeuver) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapRouteManeuver) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapRouteManeuver, IMapRouteManeuver_Ptr);
   begin
      if this.m_IMapRouteManeuver /= null then
         if this.m_IMapRouteManeuver.all /= null then
            RefCount := this.m_IMapRouteManeuver.all.Release;
            Free (this.m_IMapRouteManeuver);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapRouteManeuver

   function get_StartingPoint
   (
      this : in out MapRouteManeuver
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapRouteManeuver.all.get_StartingPoint (m_ComRetVal'Access);
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_LengthInMeters
   (
      this : in out MapRouteManeuver
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapRouteManeuver.all.get_LengthInMeters (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_InstructionText
   (
      this : in out MapRouteManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapRouteManeuver.all.get_InstructionText (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Kind
   (
      this : in out MapRouteManeuver
   )
   return WinRt.Windows.Services.Maps.MapRouteManeuverKind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.MapRouteManeuverKind;
   begin
      Hr := this.m_IMapRouteManeuver.all.get_Kind (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ExitNumber
   (
      this : in out MapRouteManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapRouteManeuver.all.get_ExitNumber (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ManeuverNotices
   (
      this : in out MapRouteManeuver
   )
   return WinRt.Windows.Services.Maps.MapManeuverNotices is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.MapManeuverNotices;
   begin
      Hr := this.m_IMapRouteManeuver.all.get_ManeuverNotices (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_StartHeading
   (
      this : in out MapRouteManeuver
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteManeuver2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteManeuver_Interface, WinRt.Windows.Services.Maps.IMapRouteManeuver2, WinRt.Windows.Services.Maps.IID_IMapRouteManeuver2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteManeuver.all);
      Hr := m_Interface.get_StartHeading (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_EndHeading
   (
      this : in out MapRouteManeuver
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteManeuver2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteManeuver_Interface, WinRt.Windows.Services.Maps.IMapRouteManeuver2, WinRt.Windows.Services.Maps.IID_IMapRouteManeuver2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteManeuver.all);
      Hr := m_Interface.get_EndHeading (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_StreetName
   (
      this : in out MapRouteManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteManeuver2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteManeuver_Interface, WinRt.Windows.Services.Maps.IMapRouteManeuver2, WinRt.Windows.Services.Maps.IID_IMapRouteManeuver2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteManeuver.all);
      Hr := m_Interface.get_StreetName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Warnings
   (
      this : in out MapRouteManeuver
   )
   return IVectorView_IManeuverWarning.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.IMapRouteManeuver3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IManeuverWarning.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.IMapRouteManeuver_Interface, WinRt.Windows.Services.Maps.IMapRouteManeuver3, WinRt.Windows.Services.Maps.IID_IMapRouteManeuver3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapRouteManeuver.all);
      Hr := m_Interface.get_Warnings (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVectorView_IManeuverWarning (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body MapService is

      procedure put_ServiceToken
      (
         value : WinRt.WString
      ) is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapService");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapServiceStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_value : WinRt.HString := To_HString (value);
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.put_ServiceToken (HStr_value);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_value);
      end;

      function get_ServiceToken
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapService");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapServiceStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ServiceToken (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_DataAttributions
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapService");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapServiceStatics3_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapServiceStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataAttributions (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      procedure put_DataUsagePreference
      (
         value : Windows.Services.Maps.MapServiceDataUsagePreference
      ) is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapService");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapServiceStatics4_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapServiceStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.put_DataUsagePreference (value);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end;

      function get_DataUsagePreference
      return WinRt.Windows.Services.Maps.MapServiceDataUsagePreference is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapService");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapServiceStatics4_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Services.Maps.MapServiceDataUsagePreference;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapServiceStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataUsagePreference (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_WorldViewRegionCode
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.MapService");
         m_Factory        : access WinRt.Windows.Services.Maps.IMapServiceStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapServiceStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WorldViewRegionCode (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end MapService;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PlaceInfo

   procedure Initialize (this : in out PlaceInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out PlaceInfo) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPlaceInfo, IPlaceInfo_Ptr);
   begin
      if this.m_IPlaceInfo /= null then
         if this.m_IPlaceInfo.all /= null then
            RefCount := this.m_IPlaceInfo.all.Release;
            Free (this.m_IPlaceInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PlaceInfo

   function Create
   (
      referencePoint : Windows.Devices.Geolocation.Geopoint'Class
   )
   return WinRt.Windows.Services.Maps.PlaceInfo is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IPlaceInfo;
   begin
      return RetVal : WinRt.Windows.Services.Maps.PlaceInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (referencePoint.m_IGeopoint.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPlaceInfo := new Windows.Services.Maps.IPlaceInfo;
            Retval.m_IPlaceInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Create
   (
      referencePoint : Windows.Devices.Geolocation.Geopoint'Class;
      options : Windows.Services.Maps.PlaceInfoCreateOptions'Class
   )
   return WinRt.Windows.Services.Maps.PlaceInfo is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IPlaceInfo;
   begin
      return RetVal : WinRt.Windows.Services.Maps.PlaceInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (referencePoint.m_IGeopoint.all, options.m_IPlaceInfoCreateOptions.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPlaceInfo := new Windows.Services.Maps.IPlaceInfo;
            Retval.m_IPlaceInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromIdentifier
   (
      identifier : WinRt.WString
   )
   return WinRt.Windows.Services.Maps.PlaceInfo is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IPlaceInfo;
      HStr_identifier : WinRt.HString := To_HString (identifier);
   begin
      return RetVal : WinRt.Windows.Services.Maps.PlaceInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromIdentifier (HStr_identifier, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPlaceInfo := new Windows.Services.Maps.IPlaceInfo;
            Retval.m_IPlaceInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_identifier);
      end return;
   end;

   function CreateFromIdentifier
   (
      identifier : WinRt.WString;
      defaultPoint : Windows.Devices.Geolocation.Geopoint'Class;
      options : Windows.Services.Maps.PlaceInfoCreateOptions'Class
   )
   return WinRt.Windows.Services.Maps.PlaceInfo is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IPlaceInfo;
      HStr_identifier : WinRt.HString := To_HString (identifier);
   begin
      return RetVal : WinRt.Windows.Services.Maps.PlaceInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromIdentifier (HStr_identifier, defaultPoint.m_IGeopoint.all, options.m_IPlaceInfoCreateOptions.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPlaceInfo := new Windows.Services.Maps.IPlaceInfo;
            Retval.m_IPlaceInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_identifier);
      end return;
   end;

   function CreateFromMapLocation
   (
      location : Windows.Services.Maps.MapLocation'Class
   )
   return WinRt.Windows.Services.Maps.PlaceInfo is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IPlaceInfo;
   begin
      return RetVal : WinRt.Windows.Services.Maps.PlaceInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromMapLocation (location.m_IMapLocation.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPlaceInfo := new Windows.Services.Maps.IPlaceInfo;
            Retval.m_IPlaceInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsShowSupported
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_IsShowSupported (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function CreateFromAddress
   (
      displayAddress : WinRt.WString
   )
   return WinRt.Windows.Services.Maps.PlaceInfo is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IPlaceInfo;
      HStr_displayAddress : WinRt.HString := To_HString (displayAddress);
   begin
      return RetVal : WinRt.Windows.Services.Maps.PlaceInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromAddress (HStr_displayAddress, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPlaceInfo := new Windows.Services.Maps.IPlaceInfo;
            Retval.m_IPlaceInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_displayAddress);
      end return;
   end;

   function CreateFromAddress
   (
      displayAddress : WinRt.WString;
      displayName : WinRt.WString
   )
   return WinRt.Windows.Services.Maps.PlaceInfo is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfo");
      m_Factory        : access WinRt.Windows.Services.Maps.IPlaceInfoStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IPlaceInfo;
      HStr_displayAddress : WinRt.HString := To_HString (displayAddress);
      HStr_displayName : WinRt.HString := To_HString (displayName);
   begin
      return RetVal : WinRt.Windows.Services.Maps.PlaceInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IPlaceInfoStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromAddress (HStr_displayAddress, HStr_displayName, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IPlaceInfo := new Windows.Services.Maps.IPlaceInfo;
            Retval.m_IPlaceInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_displayAddress);
         Hr := WindowsDeleteString (HStr_displayName);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PlaceInfo

   procedure Show
   (
      this : in out PlaceInfo;
      selection : Windows.Foundation.Rect
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPlaceInfo.all.Show (selection);
   end;

   procedure Show
   (
      this : in out PlaceInfo;
      selection : Windows.Foundation.Rect;
      preferredPlacement : Windows.UI.Popups.Placement
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPlaceInfo.all.Show (selection, preferredPlacement);
   end;

   function get_Identifier
   (
      this : in out PlaceInfo
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPlaceInfo.all.get_Identifier (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_DisplayName
   (
      this : in out PlaceInfo
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPlaceInfo.all.get_DisplayName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_DisplayAddress
   (
      this : in out PlaceInfo
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPlaceInfo.all.get_DisplayAddress (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Geoshape
   (
      this : in out PlaceInfo
   )
   return WinRt.Windows.Devices.Geolocation.IGeoshape is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoshape;
   begin
      Hr := this.m_IPlaceInfo.all.get_Geoshape (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PlaceInfoCreateOptions

   procedure Initialize (this : in out PlaceInfoCreateOptions) is
   begin
      null;
   end;

   procedure Finalize (this : in out PlaceInfoCreateOptions) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPlaceInfoCreateOptions, IPlaceInfoCreateOptions_Ptr);
   begin
      if this.m_IPlaceInfoCreateOptions /= null then
         if this.m_IPlaceInfoCreateOptions.all /= null then
            RefCount := this.m_IPlaceInfoCreateOptions.all.Release;
            Free (this.m_IPlaceInfoCreateOptions);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PlaceInfoCreateOptions

   function Constructor return PlaceInfoCreateOptions is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Services.Maps.PlaceInfoCreateOptions");
      m_ComRetVal  : aliased Windows.Services.Maps.IPlaceInfoCreateOptions;
   begin
      return RetVal : PlaceInfoCreateOptions do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPlaceInfoCreateOptions := new Windows.Services.Maps.IPlaceInfoCreateOptions;
            Retval.m_IPlaceInfoCreateOptions.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PlaceInfoCreateOptions

   procedure put_DisplayName
   (
      this : in out PlaceInfoCreateOptions;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IPlaceInfoCreateOptions.all.put_DisplayName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_DisplayName
   (
      this : in out PlaceInfoCreateOptions
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPlaceInfoCreateOptions.all.get_DisplayName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisplayAddress
   (
      this : in out PlaceInfoCreateOptions;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IPlaceInfoCreateOptions.all.put_DisplayAddress (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_DisplayAddress
   (
      this : in out PlaceInfoCreateOptions
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPlaceInfoCreateOptions.all.get_DisplayAddress (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

end;
