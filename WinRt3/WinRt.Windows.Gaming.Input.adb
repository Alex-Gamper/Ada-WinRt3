--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Devices.Power;
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Gaming.Input.ForceFeedback;
with WinRt.Windows.System;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Gaming.Input is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ArcadeStick

   procedure Initialize (this : in out ArcadeStick) is
   begin
      null;
   end;

   procedure Finalize (this : in out ArcadeStick) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IArcadeStick, IArcadeStick_Ptr);
   begin
      if this.m_IArcadeStick /= null then
         if this.m_IArcadeStick.all /= null then
            temp := this.m_IArcadeStick.all.Release;
            if temp < 1 then
               Free (this.m_IArcadeStick);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ArcadeStick

   function FromGameController
   (
      gameController : WinRt.Windows.Gaming.Input.IGameController
   )
   return WinRt.Windows.Gaming.Input.ArcadeStick is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.ArcadeStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IArcadeStickStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IArcadeStick;
   begin
      return RetVal : WinRt.Windows.Gaming.Input.ArcadeStick do
         Hr := RoGetActivationFactory (m_hString, IID_IArcadeStickStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromGameController (gameController, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IArcadeStick := new WinRt.Windows.Gaming.Input.IArcadeStick;
            Retval.m_IArcadeStick.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function add_ArcadeStickAdded
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.ArcadeStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IArcadeStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IArcadeStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_ArcadeStickAdded (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_ArcadeStickAdded
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.ArcadeStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IArcadeStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IArcadeStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_ArcadeStickAdded (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_ArcadeStickRemoved
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.ArcadeStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IArcadeStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IArcadeStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_ArcadeStickRemoved (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_ArcadeStickRemoved
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.ArcadeStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IArcadeStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IArcadeStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_ArcadeStickRemoved (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ArcadeSticks
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.ArcadeStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IArcadeStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IArcadeStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_ArcadeSticks (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ArcadeStick

   function GetButtonLabel
   (
      this : in out ArcadeStick;
      button : WinRt.Windows.Gaming.Input.ArcadeStickButtons
   )
   return WinRt.Windows.Gaming.Input.GameControllerButtonLabel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerButtonLabel;
   begin
      Hr := this.m_IArcadeStick.all.GetButtonLabel (button, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetCurrentReading
   (
      this : in out ArcadeStick
   )
   return WinRt.Windows.Gaming.Input.ArcadeStickReading is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.ArcadeStickReading;
   begin
      Hr := this.m_IArcadeStick.all.GetCurrentReading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HeadsetConnected
   (
      this : in out ArcadeStick;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IArcadeStick.all);
      Hr := m_Interface.add_HeadsetConnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetConnected
   (
      this : in out ArcadeStick;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IArcadeStick.all);
      Hr := m_Interface.remove_HeadsetConnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_HeadsetDisconnected
   (
      this : in out ArcadeStick;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IArcadeStick.all);
      Hr := m_Interface.add_HeadsetDisconnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetDisconnected
   (
      this : in out ArcadeStick;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IArcadeStick.all);
      Hr := m_Interface.remove_HeadsetDisconnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UserChanged
   (
      this : in out ArcadeStick;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IArcadeStick.all);
      Hr := m_Interface.add_UserChanged (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UserChanged
   (
      this : in out ArcadeStick;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IArcadeStick.all);
      Hr := m_Interface.remove_UserChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Headset
   (
      this : in out ArcadeStick
   )
   return WinRt.Windows.Gaming.Input.Headset'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IHeadset;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Gaming.Input.Headset do
         m_Interface := QInterface (this.m_IArcadeStick.all);
         Hr := m_Interface.get_Headset (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHeadset := new WinRt.Windows.Gaming.Input.IHeadset;
         Retval.m_IHeadset.all := m_ComRetVal;
      end return;
   end;

   function get_IsWireless
   (
      this : in out ArcadeStick
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IArcadeStick.all);
      Hr := m_Interface.get_IsWireless (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_User
   (
      this : in out ArcadeStick
   )
   return WinRt.Windows.System.User'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IUser;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.User do
         m_Interface := QInterface (this.m_IArcadeStick.all);
         Hr := m_Interface.get_User (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUser := new WinRt.Windows.System.IUser;
         Retval.m_IUser.all := m_ComRetVal;
      end return;
   end;

   function TryGetBatteryReport
   (
      this : in out ArcadeStick
   )
   return WinRt.Windows.Devices.Power.BatteryReport'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Power.IBatteryReport;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IArcadeStick_Interface, WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo, WinRt.Windows.Gaming.Input.IID_IGameControllerBatteryInfo'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Power.BatteryReport do
         m_Interface := QInterface (this.m_IArcadeStick.all);
         Hr := m_Interface.TryGetBatteryReport (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBatteryReport := new WinRt.Windows.Devices.Power.IBatteryReport;
         Retval.m_IBatteryReport.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlightStick

   procedure Initialize (this : in out FlightStick) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlightStick) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlightStick, IFlightStick_Ptr);
   begin
      if this.m_IFlightStick /= null then
         if this.m_IFlightStick.all /= null then
            temp := this.m_IFlightStick.all.Release;
            if temp < 1 then
               Free (this.m_IFlightStick);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FlightStick

   function add_FlightStickAdded
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.FlightStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IFlightStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFlightStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_FlightStickAdded (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_FlightStickAdded
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.FlightStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IFlightStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFlightStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_FlightStickAdded (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_FlightStickRemoved
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.FlightStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IFlightStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFlightStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_FlightStickRemoved (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_FlightStickRemoved
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.FlightStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IFlightStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFlightStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_FlightStickRemoved (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_FlightSticks
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.FlightStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IFlightStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFlightStickStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_FlightSticks (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromGameController
   (
      gameController : WinRt.Windows.Gaming.Input.IGameController
   )
   return WinRt.Windows.Gaming.Input.FlightStick is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.FlightStick");
      m_Factory        : access WinRt.Windows.Gaming.Input.IFlightStickStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IFlightStick;
   begin
      return RetVal : WinRt.Windows.Gaming.Input.FlightStick do
         Hr := RoGetActivationFactory (m_hString, IID_IFlightStickStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromGameController (gameController, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IFlightStick := new WinRt.Windows.Gaming.Input.IFlightStick;
            Retval.m_IFlightStick.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlightStick

   function get_HatSwitchKind
   (
      this : in out FlightStick
   )
   return WinRt.Windows.Gaming.Input.GameControllerSwitchKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerSwitchKind;
   begin
      Hr := this.m_IFlightStick.all.get_HatSwitchKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetButtonLabel
   (
      this : in out FlightStick;
      button : WinRt.Windows.Gaming.Input.FlightStickButtons
   )
   return WinRt.Windows.Gaming.Input.GameControllerButtonLabel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerButtonLabel;
   begin
      Hr := this.m_IFlightStick.all.GetButtonLabel (button, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetCurrentReading
   (
      this : in out FlightStick
   )
   return WinRt.Windows.Gaming.Input.FlightStickReading is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.FlightStickReading;
   begin
      Hr := this.m_IFlightStick.all.GetCurrentReading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HeadsetConnected
   (
      this : in out FlightStick;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlightStick.all);
      Hr := m_Interface.add_HeadsetConnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetConnected
   (
      this : in out FlightStick;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlightStick.all);
      Hr := m_Interface.remove_HeadsetConnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_HeadsetDisconnected
   (
      this : in out FlightStick;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlightStick.all);
      Hr := m_Interface.add_HeadsetDisconnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetDisconnected
   (
      this : in out FlightStick;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlightStick.all);
      Hr := m_Interface.remove_HeadsetDisconnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UserChanged
   (
      this : in out FlightStick;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlightStick.all);
      Hr := m_Interface.add_UserChanged (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UserChanged
   (
      this : in out FlightStick;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlightStick.all);
      Hr := m_Interface.remove_UserChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Headset
   (
      this : in out FlightStick
   )
   return WinRt.Windows.Gaming.Input.Headset'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IHeadset;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Gaming.Input.Headset do
         m_Interface := QInterface (this.m_IFlightStick.all);
         Hr := m_Interface.get_Headset (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHeadset := new WinRt.Windows.Gaming.Input.IHeadset;
         Retval.m_IHeadset.all := m_ComRetVal;
      end return;
   end;

   function get_IsWireless
   (
      this : in out FlightStick
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlightStick.all);
      Hr := m_Interface.get_IsWireless (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_User
   (
      this : in out FlightStick
   )
   return WinRt.Windows.System.User'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IUser;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.User do
         m_Interface := QInterface (this.m_IFlightStick.all);
         Hr := m_Interface.get_User (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUser := new WinRt.Windows.System.IUser;
         Retval.m_IUser.all := m_ComRetVal;
      end return;
   end;

   function TryGetBatteryReport
   (
      this : in out FlightStick
   )
   return WinRt.Windows.Devices.Power.BatteryReport'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Power.IBatteryReport;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IFlightStick_Interface, WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo, WinRt.Windows.Gaming.Input.IID_IGameControllerBatteryInfo'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Power.BatteryReport do
         m_Interface := QInterface (this.m_IFlightStick.all);
         Hr := m_Interface.TryGetBatteryReport (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBatteryReport := new WinRt.Windows.Devices.Power.IBatteryReport;
         Retval.m_IBatteryReport.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Gamepad

   procedure Initialize (this : in out Gamepad) is
   begin
      null;
   end;

   procedure Finalize (this : in out Gamepad) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGamepad, IGamepad_Ptr);
   begin
      if this.m_IGamepad /= null then
         if this.m_IGamepad.all /= null then
            temp := this.m_IGamepad.all.Release;
            if temp < 1 then
               Free (this.m_IGamepad);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Gamepad

   function FromGameController
   (
      gameController : WinRt.Windows.Gaming.Input.IGameController
   )
   return WinRt.Windows.Gaming.Input.Gamepad is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.Gamepad");
      m_Factory        : access WinRt.Windows.Gaming.Input.IGamepadStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IGamepad;
   begin
      return RetVal : WinRt.Windows.Gaming.Input.Gamepad do
         Hr := RoGetActivationFactory (m_hString, IID_IGamepadStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromGameController (gameController, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IGamepad := new WinRt.Windows.Gaming.Input.IGamepad;
            Retval.m_IGamepad.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function add_GamepadAdded
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.Gamepad");
      m_Factory        : access WinRt.Windows.Gaming.Input.IGamepadStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGamepadStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_GamepadAdded (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_GamepadAdded
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.Gamepad");
      m_Factory        : access WinRt.Windows.Gaming.Input.IGamepadStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGamepadStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_GamepadAdded (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_GamepadRemoved
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.Gamepad");
      m_Factory        : access WinRt.Windows.Gaming.Input.IGamepadStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGamepadStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_GamepadRemoved (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_GamepadRemoved
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.Gamepad");
      m_Factory        : access WinRt.Windows.Gaming.Input.IGamepadStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGamepadStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_GamepadRemoved (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_Gamepads
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.Gamepad");
      m_Factory        : access WinRt.Windows.Gaming.Input.IGamepadStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGamepadStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Gamepads (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Gamepad

   function get_Vibration
   (
      this : in out Gamepad
   )
   return WinRt.Windows.Gaming.Input.GamepadVibration is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GamepadVibration;
   begin
      Hr := this.m_IGamepad.all.get_Vibration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Vibration
   (
      this : in out Gamepad;
      value : WinRt.Windows.Gaming.Input.GamepadVibration
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGamepad.all.put_Vibration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetCurrentReading
   (
      this : in out Gamepad
   )
   return WinRt.Windows.Gaming.Input.GamepadReading is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GamepadReading;
   begin
      Hr := this.m_IGamepad.all.GetCurrentReading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HeadsetConnected
   (
      this : in out Gamepad;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.add_HeadsetConnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetConnected
   (
      this : in out Gamepad;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.remove_HeadsetConnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_HeadsetDisconnected
   (
      this : in out Gamepad;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.add_HeadsetDisconnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetDisconnected
   (
      this : in out Gamepad;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.remove_HeadsetDisconnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UserChanged
   (
      this : in out Gamepad;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.add_UserChanged (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UserChanged
   (
      this : in out Gamepad;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.remove_UserChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Headset
   (
      this : in out Gamepad
   )
   return WinRt.Windows.Gaming.Input.Headset'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IHeadset;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Gaming.Input.Headset do
         m_Interface := QInterface (this.m_IGamepad.all);
         Hr := m_Interface.get_Headset (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHeadset := new WinRt.Windows.Gaming.Input.IHeadset;
         Retval.m_IHeadset.all := m_ComRetVal;
      end return;
   end;

   function get_IsWireless
   (
      this : in out Gamepad
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.get_IsWireless (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_User
   (
      this : in out Gamepad
   )
   return WinRt.Windows.System.User'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IUser;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.User do
         m_Interface := QInterface (this.m_IGamepad.all);
         Hr := m_Interface.get_User (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUser := new WinRt.Windows.System.IUser;
         Retval.m_IUser.all := m_ComRetVal;
      end return;
   end;

   function GetButtonLabel
   (
      this : in out Gamepad;
      button : WinRt.Windows.Gaming.Input.GamepadButtons
   )
   return WinRt.Windows.Gaming.Input.GameControllerButtonLabel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGamepad2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerButtonLabel;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGamepad2, WinRt.Windows.Gaming.Input.IID_IGamepad2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGamepad.all);
      Hr := m_Interface.GetButtonLabel (button, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryGetBatteryReport
   (
      this : in out Gamepad
   )
   return WinRt.Windows.Devices.Power.BatteryReport'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Power.IBatteryReport;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IGamepad_Interface, WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo, WinRt.Windows.Gaming.Input.IID_IGameControllerBatteryInfo'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Power.BatteryReport do
         m_Interface := QInterface (this.m_IGamepad.all);
         Hr := m_Interface.TryGetBatteryReport (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBatteryReport := new WinRt.Windows.Devices.Power.IBatteryReport;
         Retval.m_IBatteryReport.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Headset

   procedure Initialize (this : in out Headset) is
   begin
      null;
   end;

   procedure Finalize (this : in out Headset) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHeadset, IHeadset_Ptr);
   begin
      if this.m_IHeadset /= null then
         if this.m_IHeadset.all /= null then
            temp := this.m_IHeadset.all.Release;
            if temp < 1 then
               Free (this.m_IHeadset);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Headset

   function get_CaptureDeviceId
   (
      this : in out Headset
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IHeadset.all.get_CaptureDeviceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_RenderDeviceId
   (
      this : in out Headset
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IHeadset.all.get_RenderDeviceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function TryGetBatteryReport
   (
      this : in out Headset
   )
   return WinRt.Windows.Devices.Power.BatteryReport'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Power.IBatteryReport;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IHeadset_Interface, WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo, WinRt.Windows.Gaming.Input.IID_IGameControllerBatteryInfo'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Power.BatteryReport do
         m_Interface := QInterface (this.m_IHeadset.all);
         Hr := m_Interface.TryGetBatteryReport (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBatteryReport := new WinRt.Windows.Devices.Power.IBatteryReport;
         Retval.m_IBatteryReport.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RacingWheel

   procedure Initialize (this : in out RacingWheel) is
   begin
      null;
   end;

   procedure Finalize (this : in out RacingWheel) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRacingWheel, IRacingWheel_Ptr);
   begin
      if this.m_IRacingWheel /= null then
         if this.m_IRacingWheel.all /= null then
            temp := this.m_IRacingWheel.all.Release;
            if temp < 1 then
               Free (this.m_IRacingWheel);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RacingWheel

   function FromGameController
   (
      gameController : WinRt.Windows.Gaming.Input.IGameController
   )
   return WinRt.Windows.Gaming.Input.RacingWheel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RacingWheel");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRacingWheelStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IRacingWheel;
   begin
      return RetVal : WinRt.Windows.Gaming.Input.RacingWheel do
         Hr := RoGetActivationFactory (m_hString, IID_IRacingWheelStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromGameController (gameController, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRacingWheel := new WinRt.Windows.Gaming.Input.IRacingWheel;
            Retval.m_IRacingWheel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function add_RacingWheelAdded
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RacingWheel");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRacingWheelStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRacingWheelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_RacingWheelAdded (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_RacingWheelAdded
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RacingWheel");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRacingWheelStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRacingWheelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_RacingWheelAdded (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_RacingWheelRemoved
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RacingWheel");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRacingWheelStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRacingWheelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_RacingWheelRemoved (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_RacingWheelRemoved
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RacingWheel");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRacingWheelStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRacingWheelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_RacingWheelRemoved (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RacingWheels
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RacingWheel");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRacingWheelStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRacingWheelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_RacingWheels (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RacingWheel

   function get_HasClutch
   (
      this : in out RacingWheel
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRacingWheel.all.get_HasClutch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasHandbrake
   (
      this : in out RacingWheel
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRacingWheel.all.get_HasHandbrake (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasPatternShifter
   (
      this : in out RacingWheel
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRacingWheel.all.get_HasPatternShifter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxPatternShifterGear
   (
      this : in out RacingWheel
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IRacingWheel.all.get_MaxPatternShifterGear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxWheelAngle
   (
      this : in out RacingWheel
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IRacingWheel.all.get_MaxWheelAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WheelMotor
   (
      this : in out RacingWheel
   )
   return WinRt.Windows.Gaming.Input.ForceFeedback.ForceFeedbackMotor'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.ForceFeedback.IForceFeedbackMotor;
   begin
      return RetVal : WinRt.Windows.Gaming.Input.ForceFeedback.ForceFeedbackMotor do
         Hr := this.m_IRacingWheel.all.get_WheelMotor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IForceFeedbackMotor := new WinRt.Windows.Gaming.Input.ForceFeedback.IForceFeedbackMotor;
         Retval.m_IForceFeedbackMotor.all := m_ComRetVal;
      end return;
   end;

   function GetButtonLabel
   (
      this : in out RacingWheel;
      button : WinRt.Windows.Gaming.Input.RacingWheelButtons
   )
   return WinRt.Windows.Gaming.Input.GameControllerButtonLabel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerButtonLabel;
   begin
      Hr := this.m_IRacingWheel.all.GetButtonLabel (button, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetCurrentReading
   (
      this : in out RacingWheel
   )
   return WinRt.Windows.Gaming.Input.RacingWheelReading is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.RacingWheelReading;
   begin
      Hr := this.m_IRacingWheel.all.GetCurrentReading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HeadsetConnected
   (
      this : in out RacingWheel;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRacingWheel.all);
      Hr := m_Interface.add_HeadsetConnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetConnected
   (
      this : in out RacingWheel;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRacingWheel.all);
      Hr := m_Interface.remove_HeadsetConnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_HeadsetDisconnected
   (
      this : in out RacingWheel;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRacingWheel.all);
      Hr := m_Interface.add_HeadsetDisconnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetDisconnected
   (
      this : in out RacingWheel;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRacingWheel.all);
      Hr := m_Interface.remove_HeadsetDisconnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UserChanged
   (
      this : in out RacingWheel;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRacingWheel.all);
      Hr := m_Interface.add_UserChanged (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UserChanged
   (
      this : in out RacingWheel;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRacingWheel.all);
      Hr := m_Interface.remove_UserChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Headset
   (
      this : in out RacingWheel
   )
   return WinRt.Windows.Gaming.Input.Headset'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IHeadset;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Gaming.Input.Headset do
         m_Interface := QInterface (this.m_IRacingWheel.all);
         Hr := m_Interface.get_Headset (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHeadset := new WinRt.Windows.Gaming.Input.IHeadset;
         Retval.m_IHeadset.all := m_ComRetVal;
      end return;
   end;

   function get_IsWireless
   (
      this : in out RacingWheel
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRacingWheel.all);
      Hr := m_Interface.get_IsWireless (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_User
   (
      this : in out RacingWheel
   )
   return WinRt.Windows.System.User'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IUser;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.User do
         m_Interface := QInterface (this.m_IRacingWheel.all);
         Hr := m_Interface.get_User (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUser := new WinRt.Windows.System.IUser;
         Retval.m_IUser.all := m_ComRetVal;
      end return;
   end;

   function TryGetBatteryReport
   (
      this : in out RacingWheel
   )
   return WinRt.Windows.Devices.Power.BatteryReport'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Power.IBatteryReport;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRacingWheel_Interface, WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo, WinRt.Windows.Gaming.Input.IID_IGameControllerBatteryInfo'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Power.BatteryReport do
         m_Interface := QInterface (this.m_IRacingWheel.all);
         Hr := m_Interface.TryGetBatteryReport (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBatteryReport := new WinRt.Windows.Devices.Power.IBatteryReport;
         Retval.m_IBatteryReport.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RawGameController

   procedure Initialize (this : in out RawGameController) is
   begin
      null;
   end;

   procedure Finalize (this : in out RawGameController) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRawGameController, IRawGameController_Ptr);
   begin
      if this.m_IRawGameController /= null then
         if this.m_IRawGameController.all /= null then
            temp := this.m_IRawGameController.all.Release;
            if temp < 1 then
               Free (this.m_IRawGameController);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RawGameController

   function add_RawGameControllerAdded
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RawGameController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRawGameControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRawGameControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_RawGameControllerAdded (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_RawGameControllerAdded
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RawGameController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRawGameControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRawGameControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_RawGameControllerAdded (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_RawGameControllerRemoved
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RawGameController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRawGameControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRawGameControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_RawGameControllerRemoved (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_RawGameControllerRemoved
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RawGameController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRawGameControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRawGameControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_RawGameControllerRemoved (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RawGameControllers
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RawGameController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRawGameControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRawGameControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_RawGameControllers (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromGameController
   (
      gameController : WinRt.Windows.Gaming.Input.IGameController
   )
   return WinRt.Windows.Gaming.Input.RawGameController is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.RawGameController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IRawGameControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IRawGameController;
   begin
      return RetVal : WinRt.Windows.Gaming.Input.RawGameController do
         Hr := RoGetActivationFactory (m_hString, IID_IRawGameControllerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromGameController (gameController, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRawGameController := new WinRt.Windows.Gaming.Input.IRawGameController;
            Retval.m_IRawGameController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RawGameController

   function get_AxisCount
   (
      this : in out RawGameController
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IRawGameController.all.get_AxisCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ButtonCount
   (
      this : in out RawGameController
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IRawGameController.all.get_ButtonCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ForceFeedbackMotors
   (
      this : in out RawGameController
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := this.m_IRawGameController.all.get_ForceFeedbackMotors (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HardwareProductId
   (
      this : in out RawGameController
   )
   return WinRt.UInt16 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt16;
   begin
      Hr := this.m_IRawGameController.all.get_HardwareProductId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HardwareVendorId
   (
      this : in out RawGameController
   )
   return WinRt.UInt16 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt16;
   begin
      Hr := this.m_IRawGameController.all.get_HardwareVendorId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SwitchCount
   (
      this : in out RawGameController
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IRawGameController.all.get_SwitchCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetButtonLabel
   (
      this : in out RawGameController;
      buttonIndex : WinRt.Int32
   )
   return WinRt.Windows.Gaming.Input.GameControllerButtonLabel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerButtonLabel;
   begin
      Hr := this.m_IRawGameController.all.GetButtonLabel (buttonIndex, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetCurrentReading
   (
      this : in out RawGameController;
      buttonArray : WinRt.Boolean_Array;
      switchArray : WinRt.Windows.Gaming.Input.GameControllerSwitchPosition_Array;
      axisArray : WinRt.Double_Array
   )
   return WinRt.UInt64 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt64;
      function Convert_buttonArray is new Ada.Unchecked_Conversion (Address, WinRt.Boolean_Ptr);
      function Convert_switchArray is new Ada.Unchecked_Conversion (Address, WinRt.Windows.Gaming.Input.GameControllerSwitchPosition_Ptr);
      function Convert_axisArray is new Ada.Unchecked_Conversion (Address, WinRt.Double_Ptr);
   begin
      Hr := this.m_IRawGameController.all.GetCurrentReading (WinRt.UInt32(buttonArray'Length), Convert_buttonArray (buttonArray (buttonArray'First)'Address), WinRt.UInt32(switchArray'Length), Convert_switchArray (switchArray (switchArray'First)'Address), WinRt.UInt32(axisArray'Length), Convert_axisArray (axisArray (axisArray'First)'Address), m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetSwitchKind
   (
      this : in out RawGameController;
      switchIndex : WinRt.Int32
   )
   return WinRt.Windows.Gaming.Input.GameControllerSwitchKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerSwitchKind;
   begin
      Hr := this.m_IRawGameController.all.GetSwitchKind (switchIndex, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HeadsetConnected
   (
      this : in out RawGameController;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.add_HeadsetConnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetConnected
   (
      this : in out RawGameController;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.remove_HeadsetConnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_HeadsetDisconnected
   (
      this : in out RawGameController;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.add_HeadsetDisconnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetDisconnected
   (
      this : in out RawGameController;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.remove_HeadsetDisconnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UserChanged
   (
      this : in out RawGameController;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.add_UserChanged (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UserChanged
   (
      this : in out RawGameController;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.remove_UserChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Headset
   (
      this : in out RawGameController
   )
   return WinRt.Windows.Gaming.Input.Headset'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IHeadset;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Gaming.Input.Headset do
         m_Interface := QInterface (this.m_IRawGameController.all);
         Hr := m_Interface.get_Headset (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHeadset := new WinRt.Windows.Gaming.Input.IHeadset;
         Retval.m_IHeadset.all := m_ComRetVal;
      end return;
   end;

   function get_IsWireless
   (
      this : in out RawGameController
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.get_IsWireless (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_User
   (
      this : in out RawGameController
   )
   return WinRt.Windows.System.User'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IUser;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.User do
         m_Interface := QInterface (this.m_IRawGameController.all);
         Hr := m_Interface.get_User (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUser := new WinRt.Windows.System.IUser;
         Retval.m_IUser.all := m_ComRetVal;
      end return;
   end;

   function TryGetBatteryReport
   (
      this : in out RawGameController
   )
   return WinRt.Windows.Devices.Power.BatteryReport'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Power.IBatteryReport;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo, WinRt.Windows.Gaming.Input.IID_IGameControllerBatteryInfo'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Power.BatteryReport do
         m_Interface := QInterface (this.m_IRawGameController.all);
         Hr := m_Interface.TryGetBatteryReport (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBatteryReport := new WinRt.Windows.Devices.Power.IBatteryReport;
         Retval.m_IBatteryReport.all := m_ComRetVal;
      end return;
   end;

   function get_SimpleHapticsControllers
   (
      this : in out RawGameController
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IRawGameController2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IRawGameController2, WinRt.Windows.Gaming.Input.IID_IRawGameController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.get_SimpleHapticsControllers (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NonRoamableId
   (
      this : in out RawGameController
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IRawGameController2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IRawGameController2, WinRt.Windows.Gaming.Input.IID_IRawGameController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.get_NonRoamableId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_DisplayName
   (
      this : in out RawGameController
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IRawGameController2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IRawGameController_Interface, WinRt.Windows.Gaming.Input.IRawGameController2, WinRt.Windows.Gaming.Input.IID_IRawGameController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRawGameController.all);
      Hr := m_Interface.get_DisplayName (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UINavigationController

   procedure Initialize (this : in out UINavigationController) is
   begin
      null;
   end;

   procedure Finalize (this : in out UINavigationController) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUINavigationController, IUINavigationController_Ptr);
   begin
      if this.m_IUINavigationController /= null then
         if this.m_IUINavigationController.all /= null then
            temp := this.m_IUINavigationController.all.Release;
            if temp < 1 then
               Free (this.m_IUINavigationController);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UINavigationController

   function add_UINavigationControllerAdded
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.UINavigationController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IUINavigationControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUINavigationControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_UINavigationControllerAdded (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_UINavigationControllerAdded
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.UINavigationController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IUINavigationControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUINavigationControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_UINavigationControllerAdded (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_UINavigationControllerRemoved
   (
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.UINavigationController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IUINavigationControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUINavigationControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_UINavigationControllerRemoved (value, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_UINavigationControllerRemoved
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.UINavigationController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IUINavigationControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUINavigationControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_UINavigationControllerRemoved (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_UINavigationControllers
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.UINavigationController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IUINavigationControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IUINavigationControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_UINavigationControllers (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromGameController
   (
      gameController : WinRt.Windows.Gaming.Input.IGameController
   )
   return WinRt.Windows.Gaming.Input.UINavigationController is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Gaming.Input.UINavigationController");
      m_Factory        : access WinRt.Windows.Gaming.Input.IUINavigationControllerStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IUINavigationController;
   begin
      return RetVal : WinRt.Windows.Gaming.Input.UINavigationController do
         Hr := RoGetActivationFactory (m_hString, IID_IUINavigationControllerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromGameController (gameController, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IUINavigationController := new WinRt.Windows.Gaming.Input.IUINavigationController;
            Retval.m_IUINavigationController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UINavigationController

   function GetCurrentReading
   (
      this : in out UINavigationController
   )
   return WinRt.Windows.Gaming.Input.UINavigationReading is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.UINavigationReading;
   begin
      Hr := this.m_IUINavigationController.all.GetCurrentReading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetOptionalButtonLabel
   (
      this : in out UINavigationController;
      button : WinRt.Windows.Gaming.Input.OptionalUINavigationButtons
   )
   return WinRt.Windows.Gaming.Input.GameControllerButtonLabel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerButtonLabel;
   begin
      Hr := this.m_IUINavigationController.all.GetOptionalButtonLabel (button, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetRequiredButtonLabel
   (
      this : in out UINavigationController;
      button : WinRt.Windows.Gaming.Input.RequiredUINavigationButtons
   )
   return WinRt.Windows.Gaming.Input.GameControllerButtonLabel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.GameControllerButtonLabel;
   begin
      Hr := this.m_IUINavigationController.all.GetRequiredButtonLabel (button, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HeadsetConnected
   (
      this : in out UINavigationController;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUINavigationController.all);
      Hr := m_Interface.add_HeadsetConnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetConnected
   (
      this : in out UINavigationController;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUINavigationController.all);
      Hr := m_Interface.remove_HeadsetConnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_HeadsetDisconnected
   (
      this : in out UINavigationController;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUINavigationController.all);
      Hr := m_Interface.add_HeadsetDisconnected (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadsetDisconnected
   (
      this : in out UINavigationController;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUINavigationController.all);
      Hr := m_Interface.remove_HeadsetDisconnected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UserChanged
   (
      this : in out UINavigationController;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUINavigationController.all);
      Hr := m_Interface.add_UserChanged (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UserChanged
   (
      this : in out UINavigationController;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUINavigationController.all);
      Hr := m_Interface.remove_UserChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Headset
   (
      this : in out UINavigationController
   )
   return WinRt.Windows.Gaming.Input.Headset'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Gaming.Input.IHeadset;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Gaming.Input.Headset do
         m_Interface := QInterface (this.m_IUINavigationController.all);
         Hr := m_Interface.get_Headset (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHeadset := new WinRt.Windows.Gaming.Input.IHeadset;
         Retval.m_IHeadset.all := m_ComRetVal;
      end return;
   end;

   function get_IsWireless
   (
      this : in out UINavigationController
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUINavigationController.all);
      Hr := m_Interface.get_IsWireless (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_User
   (
      this : in out UINavigationController
   )
   return WinRt.Windows.System.User'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameController := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IUser;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameController, WinRt.Windows.Gaming.Input.IID_IGameController'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.User do
         m_Interface := QInterface (this.m_IUINavigationController.all);
         Hr := m_Interface.get_User (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUser := new WinRt.Windows.System.IUser;
         Retval.m_IUser.all := m_ComRetVal;
      end return;
   end;

   function TryGetBatteryReport
   (
      this : in out UINavigationController
   )
   return WinRt.Windows.Devices.Power.BatteryReport'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Power.IBatteryReport;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Gaming.Input.IUINavigationController_Interface, WinRt.Windows.Gaming.Input.IGameControllerBatteryInfo, WinRt.Windows.Gaming.Input.IID_IGameControllerBatteryInfo'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Power.BatteryReport do
         m_Interface := QInterface (this.m_IUINavigationController.all);
         Hr := m_Interface.TryGetBatteryReport (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBatteryReport := new WinRt.Windows.Devices.Power.IBatteryReport;
         Retval.m_IBatteryReport.all := m_ComRetVal;
      end return;
   end;

end WinRt.Windows.Gaming.Input;
