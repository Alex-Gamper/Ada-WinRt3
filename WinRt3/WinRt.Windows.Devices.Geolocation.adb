--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Devices.Geolocation is

   package IAsyncOperation_Geoposition is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Geolocation.IGeoposition);
   package AsyncOperationCompletedHandler_Geoposition is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Geolocation.IGeoposition);

   package IAsyncOperation_GeolocationAccessStatus is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Geolocation.GeolocationAccessStatus);
   package AsyncOperationCompletedHandler_GeolocationAccessStatus is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Geolocation.GeolocationAccessStatus);

   package IAsyncOperation_GenericObject is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.GenericObject);
   package AsyncOperationCompletedHandler_GenericObject is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.GenericObject);

   package IAsyncOperation_Geovisit is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Geolocation.IGeovisit);
   package AsyncOperationCompletedHandler_Geovisit is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Geolocation.IGeovisit);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CivicAddress

   procedure Initialize (this : in out CivicAddress) is
   begin
      null;
   end;

   procedure Finalize (this : in out CivicAddress) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICivicAddress, ICivicAddress_Ptr);
   begin
      if this.m_ICivicAddress /= null then
         if this.m_ICivicAddress.all /= null then
            RefCount := this.m_ICivicAddress.all.Release;
            Free (this.m_ICivicAddress);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CivicAddress

   function get_Country
   (
      this : in out CivicAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICivicAddress.all.get_Country (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_State
   (
      this : in out CivicAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICivicAddress.all.get_State (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_City
   (
      this : in out CivicAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICivicAddress.all.get_City (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_PostalCode
   (
      this : in out CivicAddress
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICivicAddress.all.get_PostalCode (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Timestamp
   (
      this : in out CivicAddress
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICivicAddress.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeoboundingBox

   procedure Initialize (this : in out GeoboundingBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeoboundingBox) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeoboundingBox, IGeoboundingBox_Ptr);
   begin
      if this.m_IGeoboundingBox /= null then
         if this.m_IGeoboundingBox.all /= null then
            RefCount := this.m_IGeoboundingBox.all.Release;
            Free (this.m_IGeoboundingBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GeoboundingBox

   function Constructor
   (
      northwestCorner : Windows.Devices.Geolocation.BasicGeoposition;
      southeastCorner : Windows.Devices.Geolocation.BasicGeoposition
   )
   return GeoboundingBox is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeoboundingBox");
      m_Factory    : access IGeoboundingBoxFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : GeoboundingBox do
         Hr := RoGetActivationFactory (m_hString, IID_IGeoboundingBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (northwestCorner, southeastCorner, m_ComRetVal'Access);
            Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
            Retval.m_IGeoboundingBox.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      northwestCorner : Windows.Devices.Geolocation.BasicGeoposition;
      southeastCorner : Windows.Devices.Geolocation.BasicGeoposition;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem
   )
   return GeoboundingBox is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeoboundingBox");
      m_Factory    : access IGeoboundingBoxFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : GeoboundingBox do
         Hr := RoGetActivationFactory (m_hString, IID_IGeoboundingBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReference (northwestCorner, southeastCorner, altitudeReferenceSystem, m_ComRetVal'Access);
            Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
            Retval.m_IGeoboundingBox.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      northwestCorner : Windows.Devices.Geolocation.BasicGeoposition;
      southeastCorner : Windows.Devices.Geolocation.BasicGeoposition;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem;
      spatialReferenceId : WinRt.UInt32
   )
   return GeoboundingBox is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeoboundingBox");
      m_Factory    : access IGeoboundingBoxFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : GeoboundingBox do
         Hr := RoGetActivationFactory (m_hString, IID_IGeoboundingBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReferenceAndSpatialReference (northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId, m_ComRetVal'Access);
            Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
            Retval.m_IGeoboundingBox.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GeoboundingBox

   function TryCompute
   (
      positions : GenericObject
   )
   return WinRt.Windows.Devices.Geolocation.GeoboundingBox is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeoboundingBox");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeoboundingBoxStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeoboundingBox do
         Hr := RoGetActivationFactory (m_hString, IID_IGeoboundingBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryCompute (positions, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
            Retval.m_IGeoboundingBox.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function TryCompute
   (
      positions : GenericObject;
      altitudeRefSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem
   )
   return WinRt.Windows.Devices.Geolocation.GeoboundingBox is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeoboundingBox");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeoboundingBoxStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeoboundingBox do
         Hr := RoGetActivationFactory (m_hString, IID_IGeoboundingBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryCompute (positions, altitudeRefSystem, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
            Retval.m_IGeoboundingBox.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function TryCompute
   (
      positions : GenericObject;
      altitudeRefSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem;
      spatialReferenceId : WinRt.UInt32
   )
   return WinRt.Windows.Devices.Geolocation.GeoboundingBox is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeoboundingBox");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeoboundingBoxStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeoboundingBox do
         Hr := RoGetActivationFactory (m_hString, IID_IGeoboundingBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryCompute (positions, altitudeRefSystem, spatialReferenceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
            Retval.m_IGeoboundingBox.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeoboundingBox

   function get_NorthwestCorner
   (
      this : in out GeoboundingBox
   )
   return WinRt.Windows.Devices.Geolocation.BasicGeoposition is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.BasicGeoposition;
   begin
      Hr := this.m_IGeoboundingBox.all.get_NorthwestCorner (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_SoutheastCorner
   (
      this : in out GeoboundingBox
   )
   return WinRt.Windows.Devices.Geolocation.BasicGeoposition is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.BasicGeoposition;
   begin
      Hr := this.m_IGeoboundingBox.all.get_SoutheastCorner (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Center
   (
      this : in out GeoboundingBox
   )
   return WinRt.Windows.Devices.Geolocation.BasicGeoposition is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.BasicGeoposition;
   begin
      Hr := this.m_IGeoboundingBox.all.get_Center (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MinAltitude
   (
      this : in out GeoboundingBox
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGeoboundingBox.all.get_MinAltitude (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MaxAltitude
   (
      this : in out GeoboundingBox
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGeoboundingBox.all.get_MaxAltitude (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_GeoshapeType
   (
      this : in out GeoboundingBox
   )
   return WinRt.Windows.Devices.Geolocation.GeoshapeType is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.GeoshapeType;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeoboundingBox_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeoboundingBox.all);
      Hr := m_Interface.get_GeoshapeType (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_SpatialReferenceId
   (
      this : in out GeoboundingBox
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeoboundingBox_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeoboundingBox.all);
      Hr := m_Interface.get_SpatialReferenceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_AltitudeReferenceSystem
   (
      this : in out GeoboundingBox
   )
   return WinRt.Windows.Devices.Geolocation.AltitudeReferenceSystem is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.AltitudeReferenceSystem;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeoboundingBox_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeoboundingBox.all);
      Hr := m_Interface.get_AltitudeReferenceSystem (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geocircle

   procedure Initialize (this : in out Geocircle) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geocircle) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeocircle, IGeocircle_Ptr);
   begin
      if this.m_IGeocircle /= null then
         if this.m_IGeocircle.all /= null then
            RefCount := this.m_IGeocircle.all.Release;
            Free (this.m_IGeocircle);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Geocircle

   function Constructor
   (
      position : Windows.Devices.Geolocation.BasicGeoposition;
      radius : WinRt.Double
   )
   return Geocircle is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geocircle");
      m_Factory    : access IGeocircleFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeocircle;
   begin
      return RetVal : Geocircle do
         Hr := RoGetActivationFactory (m_hString, IID_IGeocircleFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (position, radius, m_ComRetVal'Access);
            Retval.m_IGeocircle := new Windows.Devices.Geolocation.IGeocircle;
            Retval.m_IGeocircle.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      position : Windows.Devices.Geolocation.BasicGeoposition;
      radius : WinRt.Double;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem
   )
   return Geocircle is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geocircle");
      m_Factory    : access IGeocircleFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeocircle;
   begin
      return RetVal : Geocircle do
         Hr := RoGetActivationFactory (m_hString, IID_IGeocircleFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReferenceSystem (position, radius, altitudeReferenceSystem, m_ComRetVal'Access);
            Retval.m_IGeocircle := new Windows.Devices.Geolocation.IGeocircle;
            Retval.m_IGeocircle.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      position : Windows.Devices.Geolocation.BasicGeoposition;
      radius : WinRt.Double;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem;
      spatialReferenceId : WinRt.UInt32
   )
   return Geocircle is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geocircle");
      m_Factory    : access IGeocircleFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeocircle;
   begin
      return RetVal : Geocircle do
         Hr := RoGetActivationFactory (m_hString, IID_IGeocircleFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReferenceSystemAndSpatialReferenceId (position, radius, altitudeReferenceSystem, spatialReferenceId, m_ComRetVal'Access);
            Retval.m_IGeocircle := new Windows.Devices.Geolocation.IGeocircle;
            Retval.m_IGeocircle.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geocircle

   function get_Center
   (
      this : in out Geocircle
   )
   return WinRt.Windows.Devices.Geolocation.BasicGeoposition is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.BasicGeoposition;
   begin
      Hr := this.m_IGeocircle.all.get_Center (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Radius
   (
      this : in out Geocircle
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGeocircle.all.get_Radius (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_GeoshapeType
   (
      this : in out Geocircle
   )
   return WinRt.Windows.Devices.Geolocation.GeoshapeType is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.GeoshapeType;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeocircle_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeocircle.all);
      Hr := m_Interface.get_GeoshapeType (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_SpatialReferenceId
   (
      this : in out Geocircle
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeocircle_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeocircle.all);
      Hr := m_Interface.get_SpatialReferenceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_AltitudeReferenceSystem
   (
      this : in out Geocircle
   )
   return WinRt.Windows.Devices.Geolocation.AltitudeReferenceSystem is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.AltitudeReferenceSystem;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeocircle_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeocircle.all);
      Hr := m_Interface.get_AltitudeReferenceSystem (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geocoordinate

   procedure Initialize (this : in out Geocoordinate) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geocoordinate) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeocoordinate, IGeocoordinate_Ptr);
   begin
      if this.m_IGeocoordinate /= null then
         if this.m_IGeocoordinate.all /= null then
            RefCount := this.m_IGeocoordinate.all.Release;
            Free (this.m_IGeocoordinate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geocoordinate

   function get_Latitude
   (
      this : in out Geocoordinate
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGeocoordinate.all.get_Latitude (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Longitude
   (
      this : in out Geocoordinate
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGeocoordinate.all.get_Longitude (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Altitude
   (
      this : in out Geocoordinate
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IGeocoordinate.all.get_Altitude (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Accuracy
   (
      this : in out Geocoordinate
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGeocoordinate.all.get_Accuracy (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AltitudeAccuracy
   (
      this : in out Geocoordinate
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IGeocoordinate.all.get_AltitudeAccuracy (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Heading
   (
      this : in out Geocoordinate
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IGeocoordinate.all.get_Heading (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Speed
   (
      this : in out Geocoordinate
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IGeocoordinate.all.get_Speed (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Timestamp
   (
      this : in out Geocoordinate
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IGeocoordinate.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PositionSource
   (
      this : in out Geocoordinate
   )
   return WinRt.Windows.Devices.Geolocation.PositionSource is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPositionData := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.PositionSource;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeocoordinate_Interface, WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPositionData, WinRt.Windows.Devices.Geolocation.IID_IGeocoordinateWithPositionData'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeocoordinate.all);
      Hr := m_Interface.get_PositionSource (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_SatelliteData
   (
      this : in out Geocoordinate
   )
   return WinRt.Windows.Devices.Geolocation.GeocoordinateSatelliteData'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPositionData := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeocoordinateSatelliteData;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeocoordinate_Interface, WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPositionData, WinRt.Windows.Devices.Geolocation.IID_IGeocoordinateWithPositionData'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeocoordinateSatelliteData do
         m_Interface := QInterface (this.m_IGeocoordinate.all);
         Hr := m_Interface.get_SatelliteData (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IGeocoordinateSatelliteData := new Windows.Devices.Geolocation.IGeocoordinateSatelliteData;
         Retval.m_IGeocoordinateSatelliteData.all := m_ComRetVal;
      end return;
   end;

   function get_Point
   (
      this : in out Geocoordinate
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPoint := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeocoordinate_Interface, WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPoint, WinRt.Windows.Devices.Geolocation.IID_IGeocoordinateWithPoint'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         m_Interface := QInterface (this.m_IGeocoordinate.all);
         Hr := m_Interface.get_Point (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_PositionSourceTimestamp
   (
      this : in out Geocoordinate
   )
   return IReference_DateTime.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPositionSourceTimestamp := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeocoordinate_Interface, WinRt.Windows.Devices.Geolocation.IGeocoordinateWithPositionSourceTimestamp, WinRt.Windows.Devices.Geolocation.IID_IGeocoordinateWithPositionSourceTimestamp'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeocoordinate.all);
      Hr := m_Interface.get_PositionSourceTimestamp (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeocoordinateSatelliteData

   procedure Initialize (this : in out GeocoordinateSatelliteData) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeocoordinateSatelliteData) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeocoordinateSatelliteData, IGeocoordinateSatelliteData_Ptr);
   begin
      if this.m_IGeocoordinateSatelliteData /= null then
         if this.m_IGeocoordinateSatelliteData.all /= null then
            RefCount := this.m_IGeocoordinateSatelliteData.all.Release;
            Free (this.m_IGeocoordinateSatelliteData);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeocoordinateSatelliteData

   function get_PositionDilutionOfPrecision
   (
      this : in out GeocoordinateSatelliteData
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IGeocoordinateSatelliteData.all.get_PositionDilutionOfPrecision (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_HorizontalDilutionOfPrecision
   (
      this : in out GeocoordinateSatelliteData
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IGeocoordinateSatelliteData.all.get_HorizontalDilutionOfPrecision (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_VerticalDilutionOfPrecision
   (
      this : in out GeocoordinateSatelliteData
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_IGeocoordinateSatelliteData.all.get_VerticalDilutionOfPrecision (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geolocator

   procedure Initialize (this : in out Geolocator) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geolocator) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeolocator, IGeolocator_Ptr);
   begin
      if this.m_IGeolocator /= null then
         if this.m_IGeolocator.all /= null then
            RefCount := this.m_IGeolocator.all.Release;
            Free (this.m_IGeolocator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Geolocator

   function Constructor return Geolocator is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geolocator");
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeolocator;
   begin
      return RetVal : Geolocator do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IGeolocator := new Windows.Devices.Geolocation.IGeolocator;
            Retval.m_IGeolocator.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Geolocator

   function RequestAccessAsync
   return WinRt.Windows.Devices.Geolocation.GeolocationAccessStatus is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geolocator");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeolocatorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GeolocationAccessStatus.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GeolocationAccessStatus.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Geolocation.GeolocationAccessStatus;
      m_IID            : aliased WinRt.IID := (3727369424, 46886, 22449, (167, 197, 229, 161, 57, 50, 183, 222 )); -- Windows.Devices.Geolocation.GeolocationAccessStatus;
      m_HandlerIID     : aliased WinRt.IID := (4082257043, 58823, 23432, (190, 219, 211, 230, 55, 207, 242, 113 ));
      m_Handler        : AsyncOperationCompletedHandler_GeolocationAccessStatus.Kind := new AsyncOperationCompletedHandler_GeolocationAccessStatus.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GeolocationAccessStatus.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GeolocationAccessStatus.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GeolocationAccessStatus.Kind_Delegate, AsyncOperationCompletedHandler_GeolocationAccessStatus.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeolocatorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.RequestAccessAsync (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   function GetGeopositionHistoryAsync
   (
      startTime : Windows.Foundation.DateTime
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geolocator");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeolocatorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (2488579379, 61364, 21381, (141, 58, 67, 127, 171, 195, 45, 145 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (1818730961, 37953, 23278, (182, 37, 227, 193, 181, 103, 106, 109 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeolocatorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetGeopositionHistoryAsync (startTime, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   function GetGeopositionHistoryAsync
   (
      startTime : Windows.Foundation.DateTime;
      duration : Windows.Foundation.TimeSpan
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geolocator");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeolocatorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (2488579379, 61364, 21381, (141, 58, 67, 127, 171, 195, 45, 145 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (1818730961, 37953, 23278, (182, 37, 227, 193, 181, 103, 106, 109 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeolocatorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetGeopositionHistoryAsync (startTime, duration, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   function get_IsDefaultGeopositionRecommended
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geolocator");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeolocatorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeolocatorStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_IsDefaultGeopositionRecommended (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure put_DefaultGeoposition
   (
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geolocator");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeolocatorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeolocatorStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_DefaultGeoposition (value);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
   end;

   function get_DefaultGeoposition
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geolocator");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeolocatorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGeolocatorStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_DefaultGeoposition (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geolocator

   function get_DesiredAccuracy
   (
      this : in out Geolocator
   )
   return WinRt.Windows.Devices.Geolocation.PositionAccuracy is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.PositionAccuracy;
   begin
      Hr := this.m_IGeolocator.all.get_DesiredAccuracy (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_DesiredAccuracy
   (
      this : in out Geolocator;
      value : Windows.Devices.Geolocation.PositionAccuracy
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeolocator.all.put_DesiredAccuracy (value);
   end;

   function get_MovementThreshold
   (
      this : in out Geolocator
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGeolocator.all.get_MovementThreshold (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_MovementThreshold
   (
      this : in out Geolocator;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeolocator.all.put_MovementThreshold (value);
   end;

   function get_ReportInterval
   (
      this : in out Geolocator
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IGeolocator.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Geolocator;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeolocator.all.put_ReportInterval (value);
   end;

   function get_LocationStatus
   (
      this : in out Geolocator
   )
   return WinRt.Windows.Devices.Geolocation.PositionStatus is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.PositionStatus;
   begin
      Hr := this.m_IGeolocator.all.get_LocationStatus (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function GetGeopositionAsync
   (
      this : in out Geolocator
   )
   return WinRt.Windows.Devices.Geolocation.Geoposition'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Geoposition.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Geoposition.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Geolocation.IGeoposition;
      m_IID            : aliased WinRt.IID := (4000574704, 2461, 22501, (132, 7, 91, 50, 229, 175, 28, 196 )); -- Windows.Devices.Geolocation.Geoposition;
      m_HandlerIID     : aliased WinRt.IID := (1986569988, 9294, 24082, (141, 203, 146, 163, 41, 158, 186, 38 ));
      m_Handler        : AsyncOperationCompletedHandler_Geoposition.Kind := new AsyncOperationCompletedHandler_Geoposition.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Geoposition.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Geoposition.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Geoposition.Kind_Delegate, AsyncOperationCompletedHandler_Geoposition.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geoposition do
         Hr := this.m_IGeolocator.all.GetGeopositionAsync (m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IGeoposition := new Windows.Devices.Geolocation.IGeoposition;
                  Retval.m_IGeoposition.all := m_RetVal;
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function GetGeopositionAsync
   (
      this : in out Geolocator;
      maximumAge : Windows.Foundation.TimeSpan;
      timeout : Windows.Foundation.TimeSpan
   )
   return WinRt.Windows.Devices.Geolocation.Geoposition'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Geoposition.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Geoposition.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Geolocation.IGeoposition;
      m_IID            : aliased WinRt.IID := (4000574704, 2461, 22501, (132, 7, 91, 50, 229, 175, 28, 196 )); -- Windows.Devices.Geolocation.Geoposition;
      m_HandlerIID     : aliased WinRt.IID := (1986569988, 9294, 24082, (141, 203, 146, 163, 41, 158, 186, 38 ));
      m_Handler        : AsyncOperationCompletedHandler_Geoposition.Kind := new AsyncOperationCompletedHandler_Geoposition.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Geoposition.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Geoposition.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Geoposition.Kind_Delegate, AsyncOperationCompletedHandler_Geoposition.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geoposition do
         Hr := this.m_IGeolocator.all.GetGeopositionAsync (maximumAge, timeout, m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IGeoposition := new Windows.Devices.Geolocation.IGeoposition;
                  Retval.m_IGeoposition.all := m_RetVal;
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function add_PositionChanged
   (
      this : in out Geolocator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGeolocator.all.add_PositionChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_PositionChanged
   (
      this : in out Geolocator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeolocator.all.remove_PositionChanged (token);
   end;

   function add_StatusChanged
   (
      this : in out Geolocator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGeolocator.all.add_StatusChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_StatusChanged
   (
      this : in out Geolocator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeolocator.all.remove_StatusChanged (token);
   end;

   function get_DesiredAccuracyInMeters
   (
      this : in out Geolocator
   )
   return IReference_UInt32.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeolocatorWithScalarAccuracy := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_UInt32.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeolocator_Interface, WinRt.Windows.Devices.Geolocation.IGeolocatorWithScalarAccuracy, WinRt.Windows.Devices.Geolocation.IID_IGeolocatorWithScalarAccuracy'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeolocator.all);
      Hr := m_Interface.get_DesiredAccuracyInMeters (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_UInt32 (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_DesiredAccuracyInMeters
   (
      this : in out Geolocator;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeolocatorWithScalarAccuracy := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeolocator_Interface, WinRt.Windows.Devices.Geolocation.IGeolocatorWithScalarAccuracy, WinRt.Windows.Devices.Geolocation.IID_IGeolocatorWithScalarAccuracy'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeolocator.all);
      Hr := m_Interface.put_DesiredAccuracyInMeters (value);
      m_RefCount := m_Interface.Release;
   end;

   procedure AllowFallbackToConsentlessPositions
   (
      this : in out Geolocator
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeolocator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeolocator_Interface, WinRt.Windows.Devices.Geolocation.IGeolocator2, WinRt.Windows.Devices.Geolocation.IID_IGeolocator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeolocator.all);
      Hr := m_Interface.AllowFallbackToConsentlessPositions;
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geopath

   procedure Initialize (this : in out Geopath) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geopath) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeopath, IGeopath_Ptr);
   begin
      if this.m_IGeopath /= null then
         if this.m_IGeopath.all /= null then
            RefCount := this.m_IGeopath.all.Release;
            Free (this.m_IGeopath);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Geopath

   function Constructor
   (
      positions : GenericObject
   )
   return Geopath is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geopath");
      m_Factory    : access IGeopathFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : Geopath do
         Hr := RoGetActivationFactory (m_hString, IID_IGeopathFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (positions, m_ComRetVal'Access);
            Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
            Retval.m_IGeopath.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      positions : GenericObject;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem
   )
   return Geopath is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geopath");
      m_Factory    : access IGeopathFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : Geopath do
         Hr := RoGetActivationFactory (m_hString, IID_IGeopathFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReference (positions, altitudeReferenceSystem, m_ComRetVal'Access);
            Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
            Retval.m_IGeopath.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      positions : GenericObject;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem;
      spatialReferenceId : WinRt.UInt32
   )
   return Geopath is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geopath");
      m_Factory    : access IGeopathFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : Geopath do
         Hr := RoGetActivationFactory (m_hString, IID_IGeopathFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReferenceAndSpatialReference (positions, altitudeReferenceSystem, spatialReferenceId, m_ComRetVal'Access);
            Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
            Retval.m_IGeopath.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geopath

   function get_Positions
   (
      this : in out Geopath
   )
   return IVectorView_BasicGeoposition.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_BasicGeoposition.Kind;
   begin
      Hr := this.m_IGeopath.all.get_Positions (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_BasicGeoposition (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_GeoshapeType
   (
      this : in out Geopath
   )
   return WinRt.Windows.Devices.Geolocation.GeoshapeType is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.GeoshapeType;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeopath_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeopath.all);
      Hr := m_Interface.get_GeoshapeType (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_SpatialReferenceId
   (
      this : in out Geopath
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeopath_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeopath.all);
      Hr := m_Interface.get_SpatialReferenceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_AltitudeReferenceSystem
   (
      this : in out Geopath
   )
   return WinRt.Windows.Devices.Geolocation.AltitudeReferenceSystem is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.AltitudeReferenceSystem;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeopath_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeopath.all);
      Hr := m_Interface.get_AltitudeReferenceSystem (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geopoint

   procedure Initialize (this : in out Geopoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geopoint) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeopoint, IGeopoint_Ptr);
   begin
      if this.m_IGeopoint /= null then
         if this.m_IGeopoint.all /= null then
            RefCount := this.m_IGeopoint.all.Release;
            Free (this.m_IGeopoint);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Geopoint

   function Constructor
   (
      position : Windows.Devices.Geolocation.BasicGeoposition
   )
   return Geopoint is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geopoint");
      m_Factory    : access IGeopointFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : Geopoint do
         Hr := RoGetActivationFactory (m_hString, IID_IGeopointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (position, m_ComRetVal'Access);
            Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
            Retval.m_IGeopoint.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      position : Windows.Devices.Geolocation.BasicGeoposition;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem
   )
   return Geopoint is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geopoint");
      m_Factory    : access IGeopointFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : Geopoint do
         Hr := RoGetActivationFactory (m_hString, IID_IGeopointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReferenceSystem (position, altitudeReferenceSystem, m_ComRetVal'Access);
            Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
            Retval.m_IGeopoint.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      position : Windows.Devices.Geolocation.BasicGeoposition;
      altitudeReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem;
      spatialReferenceId : WinRt.UInt32
   )
   return Geopoint is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.Geopoint");
      m_Factory    : access IGeopointFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : Geopoint do
         Hr := RoGetActivationFactory (m_hString, IID_IGeopointFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithAltitudeReferenceSystemAndSpatialReferenceId (position, altitudeReferenceSystem, spatialReferenceId, m_ComRetVal'Access);
            Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
            Retval.m_IGeopoint.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geopoint

   function get_Position
   (
      this : in out Geopoint
   )
   return WinRt.Windows.Devices.Geolocation.BasicGeoposition is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.BasicGeoposition;
   begin
      Hr := this.m_IGeopoint.all.get_Position (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_GeoshapeType
   (
      this : in out Geopoint
   )
   return WinRt.Windows.Devices.Geolocation.GeoshapeType is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.GeoshapeType;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeopoint_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeopoint.all);
      Hr := m_Interface.get_GeoshapeType (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_SpatialReferenceId
   (
      this : in out Geopoint
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeopoint_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeopoint.all);
      Hr := m_Interface.get_SpatialReferenceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_AltitudeReferenceSystem
   (
      this : in out Geopoint
   )
   return WinRt.Windows.Devices.Geolocation.AltitudeReferenceSystem is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoshape := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.AltitudeReferenceSystem;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeopoint_Interface, WinRt.Windows.Devices.Geolocation.IGeoshape, WinRt.Windows.Devices.Geolocation.IID_IGeoshape'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGeopoint.all);
      Hr := m_Interface.get_AltitudeReferenceSystem (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geoposition

   procedure Initialize (this : in out Geoposition) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geoposition) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeoposition, IGeoposition_Ptr);
   begin
      if this.m_IGeoposition /= null then
         if this.m_IGeoposition.all /= null then
            RefCount := this.m_IGeoposition.all.Release;
            Free (this.m_IGeoposition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geoposition

   function get_Coordinate
   (
      this : in out Geoposition
   )
   return WinRt.Windows.Devices.Geolocation.Geocoordinate'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeocoordinate;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geocoordinate do
         Hr := this.m_IGeoposition.all.get_Coordinate (m_ComRetVal'Access);
         Retval.m_IGeocoordinate := new Windows.Devices.Geolocation.IGeocoordinate;
         Retval.m_IGeocoordinate.all := m_ComRetVal;
      end return;
   end;

   function get_CivicAddress
   (
      this : in out Geoposition
   )
   return WinRt.Windows.Devices.Geolocation.CivicAddress'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.ICivicAddress;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.CivicAddress do
         Hr := this.m_IGeoposition.all.get_CivicAddress (m_ComRetVal'Access);
         Retval.m_ICivicAddress := new Windows.Devices.Geolocation.ICivicAddress;
         Retval.m_ICivicAddress.all := m_ComRetVal;
      end return;
   end;

   function get_VenueData
   (
      this : in out Geoposition
   )
   return WinRt.Windows.Devices.Geolocation.VenueData'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Geolocation.IGeoposition2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IVenueData;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Geolocation.IGeoposition_Interface, WinRt.Windows.Devices.Geolocation.IGeoposition2, WinRt.Windows.Devices.Geolocation.IID_IGeoposition2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.VenueData do
         m_Interface := QInterface (this.m_IGeoposition.all);
         Hr := m_Interface.get_VenueData (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IVenueData := new Windows.Devices.Geolocation.IVenueData;
         Retval.m_IVenueData.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Geovisit

   procedure Initialize (this : in out Geovisit) is
   begin
      null;
   end;

   procedure Finalize (this : in out Geovisit) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeovisit, IGeovisit_Ptr);
   begin
      if this.m_IGeovisit /= null then
         if this.m_IGeovisit.all /= null then
            RefCount := this.m_IGeovisit.all.Release;
            Free (this.m_IGeovisit);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Geovisit

   function get_Position
   (
      this : in out Geovisit
   )
   return WinRt.Windows.Devices.Geolocation.Geoposition'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoposition;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geoposition do
         Hr := this.m_IGeovisit.all.get_Position (m_ComRetVal'Access);
         Retval.m_IGeoposition := new Windows.Devices.Geolocation.IGeoposition;
         Retval.m_IGeoposition.all := m_ComRetVal;
      end return;
   end;

   function get_StateChange
   (
      this : in out Geovisit
   )
   return WinRt.Windows.Devices.Geolocation.VisitStateChange is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.VisitStateChange;
   begin
      Hr := this.m_IGeovisit.all.get_StateChange (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Timestamp
   (
      this : in out Geovisit
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IGeovisit.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeovisitMonitor

   procedure Initialize (this : in out GeovisitMonitor) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeovisitMonitor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeovisitMonitor, IGeovisitMonitor_Ptr);
   begin
      if this.m_IGeovisitMonitor /= null then
         if this.m_IGeovisitMonitor.all /= null then
            RefCount := this.m_IGeovisitMonitor.all.Release;
            Free (this.m_IGeovisitMonitor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GeovisitMonitor

   function Constructor return GeovisitMonitor is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeovisitMonitor");
      m_ComRetVal  : aliased Windows.Devices.Geolocation.IGeovisitMonitor;
   begin
      return RetVal : GeovisitMonitor do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IGeovisitMonitor := new Windows.Devices.Geolocation.IGeovisitMonitor;
            Retval.m_IGeovisitMonitor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GeovisitMonitor

   function GetLastReportAsync
   return WinRt.Windows.Devices.Geolocation.Geovisit is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Geolocation.GeovisitMonitor");
      m_Factory        : access WinRt.Windows.Devices.Geolocation.IGeovisitMonitorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Geovisit.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Geovisit.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Geolocation.IGeovisit;
      m_IID            : aliased WinRt.IID := (2367460618, 61369, 21568, (166, 167, 130, 10, 131, 155, 224, 123 )); -- Windows.Devices.Geolocation.Geovisit;
      m_HandlerIID     : aliased WinRt.IID := (3116165323, 11780, 21097, (155, 3, 22, 20, 208, 192, 11, 1 ));
      m_Handler        : AsyncOperationCompletedHandler_Geovisit.Kind := new AsyncOperationCompletedHandler_Geovisit.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Geovisit.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Geovisit.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Geovisit.Kind_Delegate, AsyncOperationCompletedHandler_Geovisit.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geovisit do
         Hr := RoGetActivationFactory (m_hString, IID_IGeovisitMonitorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetLastReportAsync (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IGeovisit := new Windows.Devices.Geolocation.IGeovisit;
                     Retval.m_IGeovisit.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeovisitMonitor

   function get_MonitoringScope
   (
      this : in out GeovisitMonitor
   )
   return WinRt.Windows.Devices.Geolocation.VisitMonitoringScope is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.VisitMonitoringScope;
   begin
      Hr := this.m_IGeovisitMonitor.all.get_MonitoringScope (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure Start
   (
      this : in out GeovisitMonitor;
      value : Windows.Devices.Geolocation.VisitMonitoringScope
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeovisitMonitor.all.Start (value);
   end;

   procedure Stop
   (
      this : in out GeovisitMonitor
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeovisitMonitor.all.Stop;
   end;

   function add_VisitStateChanged
   (
      this : in out GeovisitMonitor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGeovisitMonitor.all.add_VisitStateChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_VisitStateChanged
   (
      this : in out GeovisitMonitor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGeovisitMonitor.all.remove_VisitStateChanged (token);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeovisitStateChangedEventArgs

   procedure Initialize (this : in out GeovisitStateChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeovisitStateChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeovisitStateChangedEventArgs, IGeovisitStateChangedEventArgs_Ptr);
   begin
      if this.m_IGeovisitStateChangedEventArgs /= null then
         if this.m_IGeovisitStateChangedEventArgs.all /= null then
            RefCount := this.m_IGeovisitStateChangedEventArgs.all.Release;
            Free (this.m_IGeovisitStateChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeovisitStateChangedEventArgs

   function get_Visit
   (
      this : in out GeovisitStateChangedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geovisit'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeovisit;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geovisit do
         Hr := this.m_IGeovisitStateChangedEventArgs.all.get_Visit (m_ComRetVal'Access);
         Retval.m_IGeovisit := new Windows.Devices.Geolocation.IGeovisit;
         Retval.m_IGeovisit.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GeovisitTriggerDetails

   procedure Initialize (this : in out GeovisitTriggerDetails) is
   begin
      null;
   end;

   procedure Finalize (this : in out GeovisitTriggerDetails) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGeovisitTriggerDetails, IGeovisitTriggerDetails_Ptr);
   begin
      if this.m_IGeovisitTriggerDetails /= null then
         if this.m_IGeovisitTriggerDetails.all /= null then
            RefCount := this.m_IGeovisitTriggerDetails.all.Release;
            Free (this.m_IGeovisitTriggerDetails);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GeovisitTriggerDetails

   function ReadReports
   (
      this : in out GeovisitTriggerDetails
   )
   return IVectorView_IGeovisit.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IGeovisit.Kind;
   begin
      Hr := this.m_IGeovisitTriggerDetails.all.ReadReports (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IGeovisit (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PositionChangedEventArgs

   procedure Initialize (this : in out PositionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PositionChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPositionChangedEventArgs, IPositionChangedEventArgs_Ptr);
   begin
      if this.m_IPositionChangedEventArgs /= null then
         if this.m_IPositionChangedEventArgs.all /= null then
            RefCount := this.m_IPositionChangedEventArgs.all.Release;
            Free (this.m_IPositionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PositionChangedEventArgs

   function get_Position
   (
      this : in out PositionChangedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geoposition'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoposition;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geoposition do
         Hr := this.m_IPositionChangedEventArgs.all.get_Position (m_ComRetVal'Access);
         Retval.m_IGeoposition := new Windows.Devices.Geolocation.IGeoposition;
         Retval.m_IGeoposition.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StatusChangedEventArgs

   procedure Initialize (this : in out StatusChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out StatusChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStatusChangedEventArgs, IStatusChangedEventArgs_Ptr);
   begin
      if this.m_IStatusChangedEventArgs /= null then
         if this.m_IStatusChangedEventArgs.all /= null then
            RefCount := this.m_IStatusChangedEventArgs.all.Release;
            Free (this.m_IStatusChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StatusChangedEventArgs

   function get_Status
   (
      this : in out StatusChangedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.PositionStatus is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.PositionStatus;
   begin
      Hr := this.m_IStatusChangedEventArgs.all.get_Status (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VenueData

   procedure Initialize (this : in out VenueData) is
   begin
      null;
   end;

   procedure Finalize (this : in out VenueData) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVenueData, IVenueData_Ptr);
   begin
      if this.m_IVenueData /= null then
         if this.m_IVenueData.all /= null then
            RefCount := this.m_IVenueData.all.Release;
            Free (this.m_IVenueData);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VenueData

   function get_Id
   (
      this : in out VenueData
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IVenueData.all.get_Id (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Level
   (
      this : in out VenueData
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IVenueData.all.get_Level (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

end WinRt.Windows.Devices.Geolocation;
