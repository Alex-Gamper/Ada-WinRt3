--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Devices.Geolocation;
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.UI;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Services.Maps.Guidance is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceAudioNotificationRequestedEventArgs

   procedure Initialize (this : in out GuidanceAudioNotificationRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceAudioNotificationRequestedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceAudioNotificationRequestedEventArgs, IGuidanceAudioNotificationRequestedEventArgs_Ptr);
   begin
      if this.m_IGuidanceAudioNotificationRequestedEventArgs /= null then
         if this.m_IGuidanceAudioNotificationRequestedEventArgs.all /= null then
            RefCount := this.m_IGuidanceAudioNotificationRequestedEventArgs.all.Release;
            Free (this.m_IGuidanceAudioNotificationRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceAudioNotificationRequestedEventArgs

   function get_AudioNotification
   (
      this : in out GuidanceAudioNotificationRequestedEventArgs
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceAudioNotificationKind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.GuidanceAudioNotificationKind;
   begin
      Hr := this.m_IGuidanceAudioNotificationRequestedEventArgs.all.get_AudioNotification (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AudioFilePaths
   (
      this : in out GuidanceAudioNotificationRequestedEventArgs
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_IGuidanceAudioNotificationRequestedEventArgs.all.get_AudioFilePaths (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_AudioText
   (
      this : in out GuidanceAudioNotificationRequestedEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceAudioNotificationRequestedEventArgs.all.get_AudioText (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceLaneInfo

   procedure Initialize (this : in out GuidanceLaneInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceLaneInfo) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceLaneInfo, IGuidanceLaneInfo_Ptr);
   begin
      if this.m_IGuidanceLaneInfo /= null then
         if this.m_IGuidanceLaneInfo.all /= null then
            RefCount := this.m_IGuidanceLaneInfo.all.Release;
            Free (this.m_IGuidanceLaneInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceLaneInfo

   function get_LaneMarkers
   (
      this : in out GuidanceLaneInfo
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceLaneMarkers is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.GuidanceLaneMarkers;
   begin
      Hr := this.m_IGuidanceLaneInfo.all.get_LaneMarkers (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsOnRoute
   (
      this : in out GuidanceLaneInfo
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGuidanceLaneInfo.all.get_IsOnRoute (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceManeuver

   procedure Initialize (this : in out GuidanceManeuver) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceManeuver) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceManeuver, IGuidanceManeuver_Ptr);
   begin
      if this.m_IGuidanceManeuver /= null then
         if this.m_IGuidanceManeuver.all /= null then
            RefCount := this.m_IGuidanceManeuver.all.Release;
            Free (this.m_IGuidanceManeuver);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceManeuver

   function get_StartLocation
   (
      this : in out GuidanceManeuver
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IGuidanceManeuver.all.get_StartLocation (m_ComRetVal'Access);
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_DistanceFromRouteStart
   (
      this : in out GuidanceManeuver
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_DistanceFromRouteStart (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_DistanceFromPreviousManeuver
   (
      this : in out GuidanceManeuver
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_DistanceFromPreviousManeuver (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_DepartureRoadName
   (
      this : in out GuidanceManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_DepartureRoadName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_NextRoadName
   (
      this : in out GuidanceManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_NextRoadName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_DepartureShortRoadName
   (
      this : in out GuidanceManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_DepartureShortRoadName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_NextShortRoadName
   (
      this : in out GuidanceManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_NextShortRoadName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Kind
   (
      this : in out GuidanceManeuver
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceManeuverKind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.GuidanceManeuverKind;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_Kind (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_StartAngle
   (
      this : in out GuidanceManeuver
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_StartAngle (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EndAngle
   (
      this : in out GuidanceManeuver
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_EndAngle (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_RoadSignpost
   (
      this : in out GuidanceManeuver
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceRoadSignpost'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceRoadSignpost;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceRoadSignpost do
         Hr := this.m_IGuidanceManeuver.all.get_RoadSignpost (m_ComRetVal'Access);
         Retval.m_IGuidanceRoadSignpost := new Windows.Services.Maps.Guidance.IGuidanceRoadSignpost;
         Retval.m_IGuidanceRoadSignpost.all := m_ComRetVal;
      end return;
   end;

   function get_InstructionText
   (
      this : in out GuidanceManeuver
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceManeuver.all.get_InstructionText (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceMapMatchedCoordinate

   procedure Initialize (this : in out GuidanceMapMatchedCoordinate) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceMapMatchedCoordinate) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceMapMatchedCoordinate, IGuidanceMapMatchedCoordinate_Ptr);
   begin
      if this.m_IGuidanceMapMatchedCoordinate /= null then
         if this.m_IGuidanceMapMatchedCoordinate.all /= null then
            RefCount := this.m_IGuidanceMapMatchedCoordinate.all.Release;
            Free (this.m_IGuidanceMapMatchedCoordinate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceMapMatchedCoordinate

   function get_Location
   (
      this : in out GuidanceMapMatchedCoordinate
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IGuidanceMapMatchedCoordinate.all.get_Location (m_ComRetVal'Access);
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_CurrentHeading
   (
      this : in out GuidanceMapMatchedCoordinate
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGuidanceMapMatchedCoordinate.all.get_CurrentHeading (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_CurrentSpeed
   (
      this : in out GuidanceMapMatchedCoordinate
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGuidanceMapMatchedCoordinate.all.get_CurrentSpeed (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsOnStreet
   (
      this : in out GuidanceMapMatchedCoordinate
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGuidanceMapMatchedCoordinate.all.get_IsOnStreet (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Road
   (
      this : in out GuidanceMapMatchedCoordinate
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceRoadSegment'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceRoadSegment;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceRoadSegment do
         Hr := this.m_IGuidanceMapMatchedCoordinate.all.get_Road (m_ComRetVal'Access);
         Retval.m_IGuidanceRoadSegment := new Windows.Services.Maps.Guidance.IGuidanceRoadSegment;
         Retval.m_IGuidanceRoadSegment.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceNavigator

   procedure Initialize (this : in out GuidanceNavigator) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceNavigator) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceNavigator, IGuidanceNavigator_Ptr);
   begin
      if this.m_IGuidanceNavigator /= null then
         if this.m_IGuidanceNavigator.all /= null then
            RefCount := this.m_IGuidanceNavigator.all.Release;
            Free (this.m_IGuidanceNavigator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GuidanceNavigator

   function GetCurrent
   return WinRt.Windows.Services.Maps.Guidance.GuidanceNavigator is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.Guidance.GuidanceNavigator");
      m_Factory        : access WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigatorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceNavigator;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceNavigator do
         Hr := RoGetActivationFactory (m_hString, IID_IGuidanceNavigatorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetCurrent (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IGuidanceNavigator := new Windows.Services.Maps.Guidance.IGuidanceNavigator;
            Retval.m_IGuidanceNavigator.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UseAppProvidedVoice
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.Guidance.GuidanceNavigator");
      m_Factory        : access WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigatorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGuidanceNavigatorStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_UseAppProvidedVoice (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceNavigator

   procedure StartNavigating
   (
      this : in out GuidanceNavigator;
      route : Windows.Services.Maps.Guidance.GuidanceRoute'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.StartNavigating (route.m_IGuidanceRoute.all);
   end;

   procedure StartSimulating
   (
      this : in out GuidanceNavigator;
      route : Windows.Services.Maps.Guidance.GuidanceRoute'Class;
      speedInMetersPerSecond : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.StartSimulating (route.m_IGuidanceRoute.all, speedInMetersPerSecond);
   end;

   procedure StartTracking
   (
      this : in out GuidanceNavigator
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.StartTracking;
   end;

   procedure Pause
   (
      this : in out GuidanceNavigator
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.Pause;
   end;

   procedure Resume
   (
      this : in out GuidanceNavigator
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.Resume;
   end;

   procedure Stop
   (
      this : in out GuidanceNavigator
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.Stop;
   end;

   procedure RepeatLastAudioNotification
   (
      this : in out GuidanceNavigator
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.RepeatLastAudioNotification;
   end;

   function get_AudioMeasurementSystem
   (
      this : in out GuidanceNavigator
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceAudioMeasurementSystem is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.GuidanceAudioMeasurementSystem;
   begin
      Hr := this.m_IGuidanceNavigator.all.get_AudioMeasurementSystem (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AudioMeasurementSystem
   (
      this : in out GuidanceNavigator;
      value : Windows.Services.Maps.Guidance.GuidanceAudioMeasurementSystem
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.put_AudioMeasurementSystem (value);
   end;

   function get_AudioNotifications
   (
      this : in out GuidanceNavigator
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceAudioNotifications is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.GuidanceAudioNotifications;
   begin
      Hr := this.m_IGuidanceNavigator.all.get_AudioNotifications (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AudioNotifications
   (
      this : in out GuidanceNavigator;
      value : Windows.Services.Maps.Guidance.GuidanceAudioNotifications
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.put_AudioNotifications (value);
   end;

   function add_GuidanceUpdated
   (
      this : in out GuidanceNavigator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGuidanceNavigator.all.add_GuidanceUpdated (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_GuidanceUpdated
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.remove_GuidanceUpdated (token);
   end;

   function add_DestinationReached
   (
      this : in out GuidanceNavigator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGuidanceNavigator.all.add_DestinationReached (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_DestinationReached
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.remove_DestinationReached (token);
   end;

   function add_Rerouting
   (
      this : in out GuidanceNavigator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGuidanceNavigator.all.add_Rerouting (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_Rerouting
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.remove_Rerouting (token);
   end;

   function add_Rerouted
   (
      this : in out GuidanceNavigator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGuidanceNavigator.all.add_Rerouted (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_Rerouted
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.remove_Rerouted (token);
   end;

   function add_RerouteFailed
   (
      this : in out GuidanceNavigator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGuidanceNavigator.all.add_RerouteFailed (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_RerouteFailed
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.remove_RerouteFailed (token);
   end;

   function add_UserLocationLost
   (
      this : in out GuidanceNavigator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGuidanceNavigator.all.add_UserLocationLost (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_UserLocationLost
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.remove_UserLocationLost (token);
   end;

   function add_UserLocationRestored
   (
      this : in out GuidanceNavigator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGuidanceNavigator.all.add_UserLocationRestored (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_UserLocationRestored
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.remove_UserLocationRestored (token);
   end;

   procedure SetGuidanceVoice
   (
      this : in out GuidanceNavigator;
      voiceId : WinRt.Int32;
      voiceFolder : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_voiceFolder : WinRt.HString := To_HString (voiceFolder);
   begin
      Hr := this.m_IGuidanceNavigator.all.SetGuidanceVoice (voiceId, HStr_voiceFolder);
      Hr := WindowsDeleteString (HStr_voiceFolder);
   end;

   procedure UpdateUserLocation
   (
      this : in out GuidanceNavigator;
      userLocation : Windows.Devices.Geolocation.Geocoordinate'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.UpdateUserLocation (userLocation.m_IGeocoordinate.all);
   end;

   procedure UpdateUserLocation
   (
      this : in out GuidanceNavigator;
      userLocation : Windows.Devices.Geolocation.Geocoordinate'Class;
      positionOverride : Windows.Devices.Geolocation.BasicGeoposition
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceNavigator.all.UpdateUserLocation (userLocation.m_IGeocoordinate.all, positionOverride);
   end;

   function add_AudioNotificationRequested
   (
      this : in out GuidanceNavigator;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator_Interface, WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2, WinRt.Windows.Services.Maps.Guidance.IID_IGuidanceNavigator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGuidanceNavigator.all);
      Hr := m_Interface.add_AudioNotificationRequested (value, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure remove_AudioNotificationRequested
   (
      this : in out GuidanceNavigator;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator_Interface, WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2, WinRt.Windows.Services.Maps.Guidance.IID_IGuidanceNavigator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGuidanceNavigator.all);
      Hr := m_Interface.remove_AudioNotificationRequested (token);
      m_RefCount := m_Interface.Release;
   end;

   function get_IsGuidanceAudioMuted
   (
      this : in out GuidanceNavigator
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator_Interface, WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2, WinRt.Windows.Services.Maps.Guidance.IID_IGuidanceNavigator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGuidanceNavigator.all);
      Hr := m_Interface.get_IsGuidanceAudioMuted (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_IsGuidanceAudioMuted
   (
      this : in out GuidanceNavigator;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator_Interface, WinRt.Windows.Services.Maps.Guidance.IGuidanceNavigator2, WinRt.Windows.Services.Maps.Guidance.IID_IGuidanceNavigator2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGuidanceNavigator.all);
      Hr := m_Interface.put_IsGuidanceAudioMuted (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceReroutedEventArgs

   procedure Initialize (this : in out GuidanceReroutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceReroutedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceReroutedEventArgs, IGuidanceReroutedEventArgs_Ptr);
   begin
      if this.m_IGuidanceReroutedEventArgs /= null then
         if this.m_IGuidanceReroutedEventArgs.all /= null then
            RefCount := this.m_IGuidanceReroutedEventArgs.all.Release;
            Free (this.m_IGuidanceReroutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceReroutedEventArgs

   function get_Route
   (
      this : in out GuidanceReroutedEventArgs
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceRoute'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceRoute;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceRoute do
         Hr := this.m_IGuidanceReroutedEventArgs.all.get_Route (m_ComRetVal'Access);
         Retval.m_IGuidanceRoute := new Windows.Services.Maps.Guidance.IGuidanceRoute;
         Retval.m_IGuidanceRoute.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceRoadSegment

   procedure Initialize (this : in out GuidanceRoadSegment) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceRoadSegment) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceRoadSegment, IGuidanceRoadSegment_Ptr);
   begin
      if this.m_IGuidanceRoadSegment /= null then
         if this.m_IGuidanceRoadSegment.all /= null then
            RefCount := this.m_IGuidanceRoadSegment.all.Release;
            Free (this.m_IGuidanceRoadSegment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceRoadSegment

   function get_RoadName
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_RoadName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ShortRoadName
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_ShortRoadName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SpeedLimit
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_SpeedLimit (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_TravelTime
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_TravelTime (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Path
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.Windows.Devices.Geolocation.Geopath'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopath do
         Hr := this.m_IGuidanceRoadSegment.all.get_Path (m_ComRetVal'Access);
         Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
         Retval.m_IGeopath.all := m_ComRetVal;
      end return;
   end;

   function get_Id
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_Id (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_IsHighway
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_IsHighway (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsTunnel
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_IsTunnel (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsTollRoad
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGuidanceRoadSegment.all.get_IsTollRoad (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsScenic
   (
      this : in out GuidanceRoadSegment
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Services.Maps.Guidance.IGuidanceRoadSegment2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Services.Maps.Guidance.IGuidanceRoadSegment_Interface, WinRt.Windows.Services.Maps.Guidance.IGuidanceRoadSegment2, WinRt.Windows.Services.Maps.Guidance.IID_IGuidanceRoadSegment2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGuidanceRoadSegment.all);
      Hr := m_Interface.get_IsScenic (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceRoadSignpost

   procedure Initialize (this : in out GuidanceRoadSignpost) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceRoadSignpost) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceRoadSignpost, IGuidanceRoadSignpost_Ptr);
   begin
      if this.m_IGuidanceRoadSignpost /= null then
         if this.m_IGuidanceRoadSignpost.all /= null then
            RefCount := this.m_IGuidanceRoadSignpost.all.Release;
            Free (this.m_IGuidanceRoadSignpost);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceRoadSignpost

   function get_ExitNumber
   (
      this : in out GuidanceRoadSignpost
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceRoadSignpost.all.get_ExitNumber (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Exit
   (
      this : in out GuidanceRoadSignpost
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceRoadSignpost.all.get_Exit (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_BackgroundColor
   (
      this : in out GuidanceRoadSignpost
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IGuidanceRoadSignpost.all.get_BackgroundColor (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ForegroundColor
   (
      this : in out GuidanceRoadSignpost
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IGuidanceRoadSignpost.all.get_ForegroundColor (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ExitDirections
   (
      this : in out GuidanceRoadSignpost
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_IGuidanceRoadSignpost.all.get_ExitDirections (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceRoute

   procedure Initialize (this : in out GuidanceRoute) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceRoute) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceRoute, IGuidanceRoute_Ptr);
   begin
      if this.m_IGuidanceRoute /= null then
         if this.m_IGuidanceRoute.all /= null then
            RefCount := this.m_IGuidanceRoute.all.Release;
            Free (this.m_IGuidanceRoute);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GuidanceRoute

   function CanCreateFromMapRoute
   (
      mapRoute : Windows.Services.Maps.MapRoute'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.Guidance.GuidanceRoute");
      m_Factory        : access WinRt.Windows.Services.Maps.Guidance.IGuidanceRouteStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGuidanceRouteStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.CanCreateFromMapRoute (mapRoute.m_IMapRoute.all, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function TryCreateFromMapRoute
   (
      mapRoute : Windows.Services.Maps.MapRoute'Class
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceRoute is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.Guidance.GuidanceRoute");
      m_Factory        : access WinRt.Windows.Services.Maps.Guidance.IGuidanceRouteStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceRoute;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceRoute do
         Hr := RoGetActivationFactory (m_hString, IID_IGuidanceRouteStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryCreateFromMapRoute (mapRoute.m_IMapRoute.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IGuidanceRoute := new Windows.Services.Maps.Guidance.IGuidanceRoute;
            Retval.m_IGuidanceRoute.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceRoute

   function get_Duration
   (
      this : in out GuidanceRoute
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IGuidanceRoute.all.get_Duration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Distance
   (
      this : in out GuidanceRoute
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceRoute.all.get_Distance (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Maneuvers
   (
      this : in out GuidanceRoute
   )
   return IVectorView_IGuidanceManeuver.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IGuidanceManeuver.Kind;
   begin
      Hr := this.m_IGuidanceRoute.all.get_Maneuvers (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IGuidanceManeuver (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_BoundingBox
   (
      this : in out GuidanceRoute
   )
   return WinRt.Windows.Devices.Geolocation.GeoboundingBox'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeoboundingBox do
         Hr := this.m_IGuidanceRoute.all.get_BoundingBox (m_ComRetVal'Access);
         Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
         Retval.m_IGeoboundingBox.all := m_ComRetVal;
      end return;
   end;

   function get_Path
   (
      this : in out GuidanceRoute
   )
   return WinRt.Windows.Devices.Geolocation.Geopath'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopath do
         Hr := this.m_IGuidanceRoute.all.get_Path (m_ComRetVal'Access);
         Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
         Retval.m_IGeopath.all := m_ComRetVal;
      end return;
   end;

   function get_RoadSegments
   (
      this : in out GuidanceRoute
   )
   return IVectorView_IGuidanceRoadSegment.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IGuidanceRoadSegment.Kind;
   begin
      Hr := this.m_IGuidanceRoute.all.get_RoadSegments (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IGuidanceRoadSegment (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function ConvertToMapRoute
   (
      this : in out GuidanceRoute
   )
   return WinRt.Windows.Services.Maps.MapRoute'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IMapRoute;
   begin
      return RetVal : WinRt.Windows.Services.Maps.MapRoute do
         Hr := this.m_IGuidanceRoute.all.ConvertToMapRoute (m_ComRetVal'Access);
         Retval.m_IMapRoute := new Windows.Services.Maps.IMapRoute;
         Retval.m_IMapRoute.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceTelemetryCollector

   procedure Initialize (this : in out GuidanceTelemetryCollector) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceTelemetryCollector) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceTelemetryCollector, IGuidanceTelemetryCollector_Ptr);
   begin
      if this.m_IGuidanceTelemetryCollector /= null then
         if this.m_IGuidanceTelemetryCollector.all /= null then
            RefCount := this.m_IGuidanceTelemetryCollector.all.Release;
            Free (this.m_IGuidanceTelemetryCollector);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for GuidanceTelemetryCollector

   function GetCurrent
   return WinRt.Windows.Services.Maps.Guidance.GuidanceTelemetryCollector is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Services.Maps.Guidance.GuidanceTelemetryCollector");
      m_Factory        : access WinRt.Windows.Services.Maps.Guidance.IGuidanceTelemetryCollectorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceTelemetryCollector;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceTelemetryCollector do
         Hr := RoGetActivationFactory (m_hString, IID_IGuidanceTelemetryCollectorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetCurrent (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IGuidanceTelemetryCollector := new Windows.Services.Maps.Guidance.IGuidanceTelemetryCollector;
            Retval.m_IGuidanceTelemetryCollector.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceTelemetryCollector

   function get_Enabled
   (
      this : in out GuidanceTelemetryCollector
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGuidanceTelemetryCollector.all.get_Enabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Enabled
   (
      this : in out GuidanceTelemetryCollector;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceTelemetryCollector.all.put_Enabled (value);
   end;

   procedure ClearLocalData
   (
      this : in out GuidanceTelemetryCollector
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceTelemetryCollector.all.ClearLocalData;
   end;

   function get_SpeedTrigger
   (
      this : in out GuidanceTelemetryCollector
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGuidanceTelemetryCollector.all.get_SpeedTrigger (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_SpeedTrigger
   (
      this : in out GuidanceTelemetryCollector;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceTelemetryCollector.all.put_SpeedTrigger (value);
   end;

   function get_UploadFrequency
   (
      this : in out GuidanceTelemetryCollector
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceTelemetryCollector.all.get_UploadFrequency (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_UploadFrequency
   (
      this : in out GuidanceTelemetryCollector;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGuidanceTelemetryCollector.all.put_UploadFrequency (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GuidanceUpdatedEventArgs

   procedure Initialize (this : in out GuidanceUpdatedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out GuidanceUpdatedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGuidanceUpdatedEventArgs, IGuidanceUpdatedEventArgs_Ptr);
   begin
      if this.m_IGuidanceUpdatedEventArgs /= null then
         if this.m_IGuidanceUpdatedEventArgs.all /= null then
            RefCount := this.m_IGuidanceUpdatedEventArgs.all.Release;
            Free (this.m_IGuidanceUpdatedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GuidanceUpdatedEventArgs

   function get_Mode
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceMode is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.GuidanceMode;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_Mode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_NextManeuver
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceManeuver'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceManeuver;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceManeuver do
         Hr := this.m_IGuidanceUpdatedEventArgs.all.get_NextManeuver (m_ComRetVal'Access);
         Retval.m_IGuidanceManeuver := new Windows.Services.Maps.Guidance.IGuidanceManeuver;
         Retval.m_IGuidanceManeuver.all := m_ComRetVal;
      end return;
   end;

   function get_NextManeuverDistance
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_NextManeuverDistance (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AfterNextManeuver
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceManeuver'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceManeuver;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceManeuver do
         Hr := this.m_IGuidanceUpdatedEventArgs.all.get_AfterNextManeuver (m_ComRetVal'Access);
         Retval.m_IGuidanceManeuver := new Windows.Services.Maps.Guidance.IGuidanceManeuver;
         Retval.m_IGuidanceManeuver.all := m_ComRetVal;
      end return;
   end;

   function get_AfterNextManeuverDistance
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_AfterNextManeuverDistance (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_DistanceToDestination
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_DistanceToDestination (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ElapsedDistance
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_ElapsedDistance (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ElapsedTime
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_ElapsedTime (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_TimeToDestination
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_TimeToDestination (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_RoadName
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_RoadName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Route
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceRoute'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceRoute;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceRoute do
         Hr := this.m_IGuidanceUpdatedEventArgs.all.get_Route (m_ComRetVal'Access);
         Retval.m_IGuidanceRoute := new Windows.Services.Maps.Guidance.IGuidanceRoute;
         Retval.m_IGuidanceRoute.all := m_ComRetVal;
      end return;
   end;

   function get_CurrentLocation
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Windows.Services.Maps.Guidance.GuidanceMapMatchedCoordinate'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.Guidance.IGuidanceMapMatchedCoordinate;
   begin
      return RetVal : WinRt.Windows.Services.Maps.Guidance.GuidanceMapMatchedCoordinate do
         Hr := this.m_IGuidanceUpdatedEventArgs.all.get_CurrentLocation (m_ComRetVal'Access);
         Retval.m_IGuidanceMapMatchedCoordinate := new Windows.Services.Maps.Guidance.IGuidanceMapMatchedCoordinate;
         Retval.m_IGuidanceMapMatchedCoordinate.all := m_ComRetVal;
      end return;
   end;

   function get_IsNewManeuver
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_IsNewManeuver (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_LaneInfo
   (
      this : in out GuidanceUpdatedEventArgs
   )
   return IVectorView_IGuidanceLaneInfo.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IGuidanceLaneInfo.Kind;
   begin
      Hr := this.m_IGuidanceUpdatedEventArgs.all.get_LaneInfo (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IGuidanceLaneInfo (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

end;
