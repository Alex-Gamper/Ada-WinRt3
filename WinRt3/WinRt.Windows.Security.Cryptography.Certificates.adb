--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.Networking;
with WinRt.Windows.Storage.Streams;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Security.Cryptography.Certificates is

   package IAsyncOperation_CertificateChain is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Security.Cryptography.Certificates.ICertificateChain);
   package AsyncOperationCompletedHandler_CertificateChain is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Security.Cryptography.Certificates.ICertificateChain);

   package IAsyncOperation_HString is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.HString);
   package AsyncOperationCompletedHandler_HString is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.HString);

   package IAsyncOperation_GenericObject is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.GenericObject);
   package AsyncOperationCompletedHandler_GenericObject is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.GenericObject);

   package IAsyncOperation_IBuffer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Storage.Streams.IBuffer);
   package AsyncOperationCompletedHandler_IBuffer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Storage.Streams.IBuffer);

   package IAsyncOperation_SignatureValidationResult is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Security.Cryptography.Certificates.SignatureValidationResult);
   package AsyncOperationCompletedHandler_SignatureValidationResult is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Security.Cryptography.Certificates.SignatureValidationResult);

   package IAsyncOperation_Boolean is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Boolean);
   package AsyncOperationCompletedHandler_Boolean is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Boolean);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Certificate

   procedure Initialize (this : in out Certificate) is
   begin
      null;
   end;

   procedure Finalize (this : in out Certificate) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICertificate, ICertificate_Ptr);
   begin
      if this.m_ICertificate /= null then
         if this.m_ICertificate.all /= null then
            RefCount := this.m_ICertificate.all.Release;
            Free (this.m_ICertificate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Certificate

   function Constructor
   (
      certBlob : Windows.Storage.Streams.IBuffer
   )
   return Certificate is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.Certificate");
      m_Factory    : access ICertificateFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICertificate;
   begin
      return RetVal : Certificate do
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateCertificate (certBlob, m_ComRetVal'Access);
            Retval.m_ICertificate := new Windows.Security.Cryptography.Certificates.ICertificate;
            Retval.m_ICertificate.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Certificate

   function BuildChainAsync
   (
      this : in out Certificate;
      certificates : GenericObject
   )
   return WinRt.Windows.Security.Cryptography.Certificates.CertificateChain'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_CertificateChain.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_CertificateChain.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Security.Cryptography.Certificates.ICertificateChain;
      m_IID            : aliased WinRt.IID := (4128819156, 44769, 22702, (175, 232, 252, 51, 109, 175, 3, 149 )); -- Windows.Security.Cryptography.Certificates.CertificateChain;
      m_HandlerIID     : aliased WinRt.IID := (1279217897, 37091, 23088, (144, 21, 74, 160, 55, 105, 4, 243 ));
      m_Handler        : AsyncOperationCompletedHandler_CertificateChain.Kind := new AsyncOperationCompletedHandler_CertificateChain.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_CertificateChain.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_CertificateChain.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_CertificateChain.Kind_Delegate, AsyncOperationCompletedHandler_CertificateChain.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CertificateChain do
         Hr := this.m_ICertificate.all.BuildChainAsync (certificates, m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_ICertificateChain := new Windows.Security.Cryptography.Certificates.ICertificateChain;
                  Retval.m_ICertificateChain.all := m_RetVal;
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function BuildChainAsync
   (
      this : in out Certificate;
      certificates : GenericObject;
      parameters : Windows.Security.Cryptography.Certificates.ChainBuildingParameters'Class
   )
   return WinRt.Windows.Security.Cryptography.Certificates.CertificateChain'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_CertificateChain.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_CertificateChain.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Security.Cryptography.Certificates.ICertificateChain;
      m_IID            : aliased WinRt.IID := (4128819156, 44769, 22702, (175, 232, 252, 51, 109, 175, 3, 149 )); -- Windows.Security.Cryptography.Certificates.CertificateChain;
      m_HandlerIID     : aliased WinRt.IID := (1279217897, 37091, 23088, (144, 21, 74, 160, 55, 105, 4, 243 ));
      m_Handler        : AsyncOperationCompletedHandler_CertificateChain.Kind := new AsyncOperationCompletedHandler_CertificateChain.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_CertificateChain.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_CertificateChain.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_CertificateChain.Kind_Delegate, AsyncOperationCompletedHandler_CertificateChain.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CertificateChain do
         Hr := this.m_ICertificate.all.BuildChainAsync (certificates, parameters.m_IChainBuildingParameters.all, m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_ICertificateChain := new Windows.Security.Cryptography.Certificates.ICertificateChain;
                  Retval.m_ICertificateChain.all := m_RetVal;
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function get_SerialNumber
   (
      this : in out Certificate
   )
   return WinRt.Byte_Array is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificate.all.get_SerialNumber (m_ComRetValSize'Access, m_ComRetVal'Access);
      declare
         ArrayRetVal : WinRt.Byte_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Byte is new To_Ada_Type (WinRt.Byte, WinRt.Byte_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Byte (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function GetHashValue
   (
      this : in out Certificate
   )
   return WinRt.Byte_Array is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificate.all.GetHashValue (m_ComRetValSize'Access, m_ComRetVal'Access);
      declare
         ArrayRetVal : WinRt.Byte_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Byte is new To_Ada_Type (WinRt.Byte, WinRt.Byte_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Byte (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function GetHashValue
   (
      this : in out Certificate;
      hashAlgorithmName : WinRt.WString
   )
   return WinRt.Byte_Array is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
      HStr_hashAlgorithmName : WinRt.HString := To_HString (hashAlgorithmName);
   begin
      Hr := this.m_ICertificate.all.GetHashValue (HStr_hashAlgorithmName, m_ComRetValSize'Access, m_ComRetVal'Access);
      Hr := WindowsDeleteString (HStr_hashAlgorithmName);
      declare
         ArrayRetVal : WinRt.Byte_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Byte is new To_Ada_Type (WinRt.Byte, WinRt.Byte_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Byte (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function GetCertificateBlob
   (
      this : in out Certificate
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_ICertificate.all.GetCertificateBlob (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Subject
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificate.all.get_Subject (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Issuer
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificate.all.get_Issuer (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_HasPrivateKey
   (
      this : in out Certificate
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificate.all.get_HasPrivateKey (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsStronglyProtected
   (
      this : in out Certificate
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificate.all.get_IsStronglyProtected (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ValidFrom
   (
      this : in out Certificate
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICertificate.all.get_ValidFrom (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ValidTo
   (
      this : in out Certificate
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICertificate.all.get_ValidTo (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_EnhancedKeyUsages
   (
      this : in out Certificate
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_ICertificate.all.get_EnhancedKeyUsages (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_FriendlyName
   (
      this : in out Certificate;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificate.all.put_FriendlyName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_FriendlyName
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificate.all.get_FriendlyName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_IsSecurityDeviceBound
   (
      this : in out Certificate
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificate.all);
      Hr := m_Interface.get_IsSecurityDeviceBound (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_KeyUsages
   (
      this : in out Certificate
   )
   return WinRt.Windows.Security.Cryptography.Certificates.CertificateKeyUsages'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificateKeyUsages;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CertificateKeyUsages do
         m_Interface := QInterface (this.m_ICertificate.all);
         Hr := m_Interface.get_KeyUsages (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ICertificateKeyUsages := new Windows.Security.Cryptography.Certificates.ICertificateKeyUsages;
         Retval.m_ICertificateKeyUsages.all := m_ComRetVal;
      end return;
   end;

   function get_KeyAlgorithmName
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificate.all);
      Hr := m_Interface.get_KeyAlgorithmName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SignatureAlgorithmName
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificate.all);
      Hr := m_Interface.get_SignatureAlgorithmName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SignatureHashAlgorithmName
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificate.all);
      Hr := m_Interface.get_SignatureHashAlgorithmName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SubjectAlternativeName
   (
      this : in out Certificate
   )
   return WinRt.Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo do
         m_Interface := QInterface (this.m_ICertificate.all);
         Hr := m_Interface.get_SubjectAlternativeName (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ISubjectAlternativeNameInfo := new Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo;
         Retval.m_ISubjectAlternativeNameInfo.all := m_ComRetVal;
      end return;
   end;

   function get_IsPerUser
   (
      this : in out Certificate
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificate.all);
      Hr := m_Interface.get_IsPerUser (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_StoreName
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificate.all);
      Hr := m_Interface.get_StoreName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_KeyStorageProviderName
   (
      this : in out Certificate
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificate3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificate_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificate3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificate3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificate.all);
      Hr := m_Interface.get_KeyStorageProviderName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CertificateChain

   procedure Initialize (this : in out CertificateChain) is
   begin
      null;
   end;

   procedure Finalize (this : in out CertificateChain) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICertificateChain, ICertificateChain_Ptr);
   begin
      if this.m_ICertificateChain /= null then
         if this.m_ICertificateChain.all /= null then
            RefCount := this.m_ICertificateChain.all.Release;
            Free (this.m_ICertificateChain);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CertificateChain

   function Validate
   (
      this : in out CertificateChain
   )
   return WinRt.Windows.Security.Cryptography.Certificates.ChainValidationResult is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ChainValidationResult;
   begin
      Hr := this.m_ICertificateChain.all.Validate (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function Validate
   (
      this : in out CertificateChain;
      parameter : Windows.Security.Cryptography.Certificates.ChainValidationParameters'Class
   )
   return WinRt.Windows.Security.Cryptography.Certificates.ChainValidationResult is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ChainValidationResult;
   begin
      Hr := this.m_ICertificateChain.all.Validate (parameter.m_IChainValidationParameters.all, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function GetCertificates
   (
      this : in out CertificateChain;
      includeRoot : WinRt.Boolean
   )
   return IVectorView_ICertificate.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ICertificate.Kind;
   begin
      Hr := this.m_ICertificateChain.all.GetCertificates (includeRoot, m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_ICertificate (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body CertificateEnrollmentManager is

      function CreateRequestAsync
      (
         request : Windows.Security.Cryptography.Certificates.CertificateRequestProperties'Class
      )
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateEnrollmentManagerStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_HString.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_HString.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.HString;
         AdaRetval        : WString;
         m_IID            : aliased WinRt.IID := (1042277891, 63639, 21091, (179, 40, 8, 6, 66, 107, 138, 121 )); -- HString;
         m_HandlerIID     : aliased WinRt.IID := (3080352799, 32693, 20654, (158, 153, 145, 18, 1, 236, 61, 65 ));
         m_Handler        : AsyncOperationCompletedHandler_HString.Kind := new AsyncOperationCompletedHandler_HString.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HString.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HString.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HString.Kind_Delegate, AsyncOperationCompletedHandler_HString.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateEnrollmentManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateRequestAsync (request.m_ICertificateRequestProperties.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_RetVal);
         Hr := WindowsDeleteString (m_RetVal);
         return AdaRetVal;
      end;

      procedure InstallCertificateAsync
      (
         certificate_p : WinRt.WString;
         installOption : Windows.Security.Cryptography.Certificates.InstallOptions
      ) is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateEnrollmentManagerStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_certificate_p : WinRt.HString := To_HString (certificate_p);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

         procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               Hr := asyncInfo.GetResults;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

         m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
         procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateEnrollmentManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.InstallCertificateAsync (HStr_certificate_p, installOption, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_Captured := m_Completed;
               Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               m_RefCount := m_ComRetVal.Release;
               m_RefCount := m_CompletedHandler.Release;
               if m_RefCount = 0 then
                  Free (m_CompletedHandler);
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_certificate_p);
      end;

      procedure ImportPfxDataAsync
      (
         pfxData : WinRt.WString;
         password : WinRt.WString;
         exportable : Windows.Security.Cryptography.Certificates.ExportOption;
         keyProtectionLevel : Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
         installOption : Windows.Security.Cryptography.Certificates.InstallOptions;
         friendlyName : WinRt.WString
      ) is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateEnrollmentManagerStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_pfxData : WinRt.HString := To_HString (pfxData);
         HStr_password : WinRt.HString := To_HString (password);
         HStr_friendlyName : WinRt.HString := To_HString (friendlyName);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

         procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               Hr := asyncInfo.GetResults;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

         m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
         procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateEnrollmentManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ImportPfxDataAsync (HStr_pfxData, HStr_password, exportable, keyProtectionLevel, installOption, HStr_friendlyName, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_Captured := m_Completed;
               Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               m_RefCount := m_ComRetVal.Release;
               m_RefCount := m_CompletedHandler.Release;
               if m_RefCount = 0 then
                  Free (m_CompletedHandler);
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_pfxData);
         Hr := WindowsDeleteString (HStr_password);
         Hr := WindowsDeleteString (HStr_friendlyName);
      end;

      procedure ImportPfxDataAsync
      (
         pfxData : WinRt.WString;
         password : WinRt.WString;
         pfxImportParameters_p : Windows.Security.Cryptography.Certificates.PfxImportParameters'Class
      ) is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateEnrollmentManagerStatics3_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_pfxData : WinRt.HString := To_HString (pfxData);
         HStr_password : WinRt.HString := To_HString (password);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

         procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               Hr := asyncInfo.GetResults;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

         m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
         procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateEnrollmentManagerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ImportPfxDataAsync (HStr_pfxData, HStr_password, pfxImportParameters_p.m_IPfxImportParameters.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_Captured := m_Completed;
               Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               m_RefCount := m_ComRetVal.Release;
               m_RefCount := m_CompletedHandler.Release;
               if m_RefCount = 0 then
                  Free (m_CompletedHandler);
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_pfxData);
         Hr := WindowsDeleteString (HStr_password);
      end;

      function get_UserCertificateEnrollmentManager
      return WinRt.Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateEnrollmentManagerStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.IUserCertificateEnrollmentManager;
      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager do
            Hr := RoGetActivationFactory (m_hString, IID_ICertificateEnrollmentManagerStatics2'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.get_UserCertificateEnrollmentManager (m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               Retval.m_IUserCertificateEnrollmentManager := new Windows.Security.Cryptography.Certificates.IUserCertificateEnrollmentManager;
               Retval.m_IUserCertificateEnrollmentManager.all := m_ComRetVal;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      procedure ImportPfxDataAsync
      (
         pfxData : WinRt.WString;
         password : WinRt.WString;
         exportable : Windows.Security.Cryptography.Certificates.ExportOption;
         keyProtectionLevel : Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
         installOption : Windows.Security.Cryptography.Certificates.InstallOptions;
         friendlyName : WinRt.WString;
         keyStorageProvider : WinRt.WString
      ) is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateEnrollmentManager");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateEnrollmentManagerStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_pfxData : WinRt.HString := To_HString (pfxData);
         HStr_password : WinRt.HString := To_HString (password);
         HStr_friendlyName : WinRt.HString := To_HString (friendlyName);
         HStr_keyStorageProvider : WinRt.HString := To_HString (keyStorageProvider);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

         procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               Hr := asyncInfo.GetResults;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

         m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
         procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateEnrollmentManagerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ImportPfxDataAsync (HStr_pfxData, HStr_password, exportable, keyProtectionLevel, installOption, HStr_friendlyName, HStr_keyStorageProvider, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_Captured := m_Completed;
               Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               m_RefCount := m_ComRetVal.Release;
               m_RefCount := m_CompletedHandler.Release;
               if m_RefCount = 0 then
                  Free (m_CompletedHandler);
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_pfxData);
         Hr := WindowsDeleteString (HStr_password);
         Hr := WindowsDeleteString (HStr_friendlyName);
         Hr := WindowsDeleteString (HStr_keyStorageProvider);
      end;

   end CertificateEnrollmentManager;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CertificateExtension

   procedure Initialize (this : in out CertificateExtension) is
   begin
      null;
   end;

   procedure Finalize (this : in out CertificateExtension) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICertificateExtension, ICertificateExtension_Ptr);
   begin
      if this.m_ICertificateExtension /= null then
         if this.m_ICertificateExtension.all /= null then
            RefCount := this.m_ICertificateExtension.all.Release;
            Free (this.m_ICertificateExtension);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CertificateExtension

   function Constructor return CertificateExtension is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateExtension");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICertificateExtension;
   begin
      return RetVal : CertificateExtension do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICertificateExtension := new Windows.Security.Cryptography.Certificates.ICertificateExtension;
            Retval.m_ICertificateExtension.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CertificateExtension

   function get_ObjectId
   (
      this : in out CertificateExtension
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateExtension.all.get_ObjectId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ObjectId
   (
      this : in out CertificateExtension;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateExtension.all.put_ObjectId (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_IsCritical
   (
      this : in out CertificateExtension
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateExtension.all.get_IsCritical (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_IsCritical
   (
      this : in out CertificateExtension;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateExtension.all.put_IsCritical (value);
   end;

   procedure EncodeValue
   (
      this : in out CertificateExtension;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateExtension.all.EncodeValue (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_Value
   (
      this : in out CertificateExtension
   )
   return WinRt.Byte_Array is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateExtension.all.get_Value (m_ComRetValSize'Access, m_ComRetVal'Access);
      declare
         ArrayRetVal : WinRt.Byte_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Byte is new To_Ada_Type (WinRt.Byte, WinRt.Byte_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Byte (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   procedure put_Value
   (
      this : in out CertificateExtension;
      value : WinRt.Byte_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      function Convert_value is new Ada.Unchecked_Conversion (Address, WinRt.Byte_Ptr);
   begin
      Hr := this.m_ICertificateExtension.all.put_Value (WinRt.UInt32(value'Length), Convert_value (value (value'First)'Address));
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CertificateKeyUsages

   procedure Initialize (this : in out CertificateKeyUsages) is
   begin
      null;
   end;

   procedure Finalize (this : in out CertificateKeyUsages) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICertificateKeyUsages, ICertificateKeyUsages_Ptr);
   begin
      if this.m_ICertificateKeyUsages /= null then
         if this.m_ICertificateKeyUsages.all /= null then
            RefCount := this.m_ICertificateKeyUsages.all.Release;
            Free (this.m_ICertificateKeyUsages);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CertificateKeyUsages

   function Constructor return CertificateKeyUsages is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateKeyUsages");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICertificateKeyUsages;
   begin
      return RetVal : CertificateKeyUsages do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICertificateKeyUsages := new Windows.Security.Cryptography.Certificates.ICertificateKeyUsages;
            Retval.m_ICertificateKeyUsages.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CertificateKeyUsages

   function get_EncipherOnly
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_EncipherOnly (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_EncipherOnly
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_EncipherOnly (value);
   end;

   function get_CrlSign
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_CrlSign (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_CrlSign
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_CrlSign (value);
   end;

   function get_KeyCertificateSign
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_KeyCertificateSign (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KeyCertificateSign
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_KeyCertificateSign (value);
   end;

   function get_KeyAgreement
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_KeyAgreement (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KeyAgreement
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_KeyAgreement (value);
   end;

   function get_DataEncipherment
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_DataEncipherment (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_DataEncipherment
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_DataEncipherment (value);
   end;

   function get_KeyEncipherment
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_KeyEncipherment (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KeyEncipherment
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_KeyEncipherment (value);
   end;

   function get_NonRepudiation
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_NonRepudiation (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_NonRepudiation
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_NonRepudiation (value);
   end;

   function get_DigitalSignature
   (
      this : in out CertificateKeyUsages
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateKeyUsages.all.get_DigitalSignature (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_DigitalSignature
   (
      this : in out CertificateKeyUsages;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateKeyUsages.all.put_DigitalSignature (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CertificateQuery

   procedure Initialize (this : in out CertificateQuery) is
   begin
      null;
   end;

   procedure Finalize (this : in out CertificateQuery) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICertificateQuery, ICertificateQuery_Ptr);
   begin
      if this.m_ICertificateQuery /= null then
         if this.m_ICertificateQuery.all /= null then
            RefCount := this.m_ICertificateQuery.all.Release;
            Free (this.m_ICertificateQuery);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CertificateQuery

   function Constructor return CertificateQuery is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateQuery");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICertificateQuery;
   begin
      return RetVal : CertificateQuery do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICertificateQuery := new Windows.Security.Cryptography.Certificates.ICertificateQuery;
            Retval.m_ICertificateQuery.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CertificateQuery

   function get_EnhancedKeyUsages
   (
      this : in out CertificateQuery
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
   begin
      Hr := this.m_ICertificateQuery.all.get_EnhancedKeyUsages (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IssuerName
   (
      this : in out CertificateQuery
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateQuery.all.get_IssuerName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_IssuerName
   (
      this : in out CertificateQuery;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateQuery.all.put_IssuerName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_FriendlyName
   (
      this : in out CertificateQuery
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateQuery.all.get_FriendlyName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_FriendlyName
   (
      this : in out CertificateQuery;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateQuery.all.put_FriendlyName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_Thumbprint
   (
      this : in out CertificateQuery
   )
   return WinRt.Byte_Array is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateQuery.all.get_Thumbprint (m_ComRetValSize'Access, m_ComRetVal'Access);
      declare
         ArrayRetVal : WinRt.Byte_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Byte is new To_Ada_Type (WinRt.Byte, WinRt.Byte_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Byte (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   procedure put_Thumbprint
   (
      this : in out CertificateQuery;
      value : WinRt.Byte_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      function Convert_value is new Ada.Unchecked_Conversion (Address, WinRt.Byte_Ptr);
   begin
      Hr := this.m_ICertificateQuery.all.put_Thumbprint (WinRt.UInt32(value'Length), Convert_value (value (value'First)'Address));
   end;

   function get_HardwareOnly
   (
      this : in out CertificateQuery
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICertificateQuery.all.get_HardwareOnly (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_HardwareOnly
   (
      this : in out CertificateQuery;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateQuery.all.put_HardwareOnly (value);
   end;

   function get_IncludeDuplicates
   (
      this : in out CertificateQuery
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateQuery2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateQuery.all);
      Hr := m_Interface.get_IncludeDuplicates (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_IncludeDuplicates
   (
      this : in out CertificateQuery;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateQuery2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateQuery.all);
      Hr := m_Interface.put_IncludeDuplicates (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_IncludeExpiredCertificates
   (
      this : in out CertificateQuery
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateQuery2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateQuery.all);
      Hr := m_Interface.get_IncludeExpiredCertificates (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_IncludeExpiredCertificates
   (
      this : in out CertificateQuery;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateQuery2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateQuery.all);
      Hr := m_Interface.put_IncludeExpiredCertificates (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_StoreName
   (
      this : in out CertificateQuery
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateQuery2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateQuery.all);
      Hr := m_Interface.get_StoreName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_StoreName
   (
      this : in out CertificateQuery;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateQuery2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateQuery2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateQuery.all);
      Hr := m_Interface.put_StoreName (HStr_value);
      m_RefCount := m_Interface.Release;
      Hr := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CertificateRequestProperties

   procedure Initialize (this : in out CertificateRequestProperties) is
   begin
      null;
   end;

   procedure Finalize (this : in out CertificateRequestProperties) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICertificateRequestProperties, ICertificateRequestProperties_Ptr);
   begin
      if this.m_ICertificateRequestProperties /= null then
         if this.m_ICertificateRequestProperties.all /= null then
            RefCount := this.m_ICertificateRequestProperties.all.Release;
            Free (this.m_ICertificateRequestProperties);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CertificateRequestProperties

   function Constructor return CertificateRequestProperties is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateRequestProperties");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICertificateRequestProperties;
   begin
      return RetVal : CertificateRequestProperties do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICertificateRequestProperties := new Windows.Security.Cryptography.Certificates.ICertificateRequestProperties;
            Retval.m_ICertificateRequestProperties.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CertificateRequestProperties

   function get_Subject
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_Subject (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Subject
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_Subject (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_KeyAlgorithmName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_KeyAlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyAlgorithmName
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_KeyAlgorithmName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_KeySize
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_KeySize (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KeySize
   (
      this : in out CertificateRequestProperties;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_KeySize (value);
   end;

   function get_FriendlyName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_FriendlyName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_FriendlyName
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_FriendlyName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_HashAlgorithmName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_HashAlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_HashAlgorithmName
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_HashAlgorithmName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_Exportable
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Windows.Security.Cryptography.Certificates.ExportOption is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ExportOption;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_Exportable (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Exportable
   (
      this : in out CertificateRequestProperties;
      value : Windows.Security.Cryptography.Certificates.ExportOption
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_Exportable (value);
   end;

   function get_KeyUsages
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Windows.Security.Cryptography.Certificates.EnrollKeyUsages is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.EnrollKeyUsages;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_KeyUsages (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KeyUsages
   (
      this : in out CertificateRequestProperties;
      value : Windows.Security.Cryptography.Certificates.EnrollKeyUsages
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_KeyUsages (value);
   end;

   function get_KeyProtectionLevel
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Windows.Security.Cryptography.Certificates.KeyProtectionLevel is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_KeyProtectionLevel (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KeyProtectionLevel
   (
      this : in out CertificateRequestProperties;
      value : Windows.Security.Cryptography.Certificates.KeyProtectionLevel
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_KeyProtectionLevel (value);
   end;

   function get_KeyStorageProviderName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICertificateRequestProperties.all.get_KeyStorageProviderName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyStorageProviderName
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICertificateRequestProperties.all.put_KeyStorageProviderName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_SmartcardReaderName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_SmartcardReaderName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SmartcardReaderName
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_SmartcardReaderName (HStr_value);
      m_RefCount := m_Interface.Release;
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_SigningCertificate
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Windows.Security.Cryptography.Certificates.Certificate'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificate;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.Certificate do
         m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
         Hr := m_Interface.get_SigningCertificate (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ICertificate := new Windows.Security.Cryptography.Certificates.ICertificate;
         Retval.m_ICertificate.all := m_ComRetVal;
      end return;
   end;

   procedure put_SigningCertificate
   (
      this : in out CertificateRequestProperties;
      value : Windows.Security.Cryptography.Certificates.Certificate'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_SigningCertificate (value.m_ICertificate.all);
      m_RefCount := m_Interface.Release;
   end;

   function get_AttestationCredentialCertificate
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Windows.Security.Cryptography.Certificates.Certificate'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificate;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.Certificate do
         m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
         Hr := m_Interface.get_AttestationCredentialCertificate (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ICertificate := new Windows.Security.Cryptography.Certificates.ICertificate;
         Retval.m_ICertificate.all := m_ComRetVal;
      end return;
   end;

   procedure put_AttestationCredentialCertificate
   (
      this : in out CertificateRequestProperties;
      value : Windows.Security.Cryptography.Certificates.Certificate'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_AttestationCredentialCertificate (value.m_ICertificate.all);
      m_RefCount := m_Interface.Release;
   end;

   function get_CurveName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_CurveName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CurveName
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_CurveName (HStr_value);
      m_RefCount := m_Interface.Release;
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_CurveParameters
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Byte_Array is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_CurveParameters (m_ComRetValSize'Access, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      declare
         ArrayRetVal : WinRt.Byte_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Byte is new To_Ada_Type (WinRt.Byte, WinRt.Byte_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Byte (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   procedure put_CurveParameters
   (
      this : in out CertificateRequestProperties;
      value : WinRt.Byte_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
      function Convert_value is new Ada.Unchecked_Conversion (Address, WinRt.Byte_Ptr);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_CurveParameters (WinRt.UInt32(value'Length), Convert_value (value (value'First)'Address));
      m_RefCount := m_Interface.Release;
   end;

   function get_ContainerNamePrefix
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_ContainerNamePrefix (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ContainerNamePrefix
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_ContainerNamePrefix (HStr_value);
      m_RefCount := m_Interface.Release;
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_ContainerName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_ContainerName (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ContainerName
   (
      this : in out CertificateRequestProperties;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_ContainerName (HStr_value);
      m_RefCount := m_Interface.Release;
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_UseExistingKey
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_UseExistingKey (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_UseExistingKey
   (
      this : in out CertificateRequestProperties;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties3, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.put_UseExistingKey (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_SuppressedDefaults
   (
      this : in out CertificateRequestProperties
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties4, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_SuppressedDefaults (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SubjectAlternativeName
   (
      this : in out CertificateRequestProperties
   )
   return WinRt.Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties4, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo do
         m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
         Hr := m_Interface.get_SubjectAlternativeName (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ISubjectAlternativeNameInfo := new Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo;
         Retval.m_ISubjectAlternativeNameInfo.all := m_ComRetVal;
      end return;
   end;

   function get_Extensions
   (
      this : in out CertificateRequestProperties
   )
   return IVector_ICertificateExtension.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_ICertificateExtension.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateRequestProperties4, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateRequestProperties4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateRequestProperties.all);
      Hr := m_Interface.get_Extensions (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_ICertificateExtension (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CertificateStore

   procedure Initialize (this : in out CertificateStore) is
   begin
      null;
   end;

   procedure Finalize (this : in out CertificateStore) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICertificateStore, ICertificateStore_Ptr);
   begin
      if this.m_ICertificateStore /= null then
         if this.m_ICertificateStore.all /= null then
            RefCount := this.m_ICertificateStore.all.Release;
            Free (this.m_ICertificateStore);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CertificateStore

   procedure Add
   (
      this : in out CertificateStore;
      certificate_p : Windows.Security.Cryptography.Certificates.Certificate'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateStore.all.Add (certificate_p.m_ICertificate.all);
   end;

   procedure Delete
   (
      this : in out CertificateStore;
      certificate_p : Windows.Security.Cryptography.Certificates.Certificate'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICertificateStore.all.Delete (certificate_p.m_ICertificate.all);
   end;

   function get_Name
   (
      this : in out CertificateStore
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ICertificateStore2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ICertificateStore_Interface, WinRt.Windows.Security.Cryptography.Certificates.ICertificateStore2, WinRt.Windows.Security.Cryptography.Certificates.IID_ICertificateStore2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICertificateStore.all);
      Hr := m_Interface.get_Name (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body CertificateStores is

      function GetUserStoreByName
      (
         storeName : WinRt.WString
      )
      return WinRt.Windows.Security.Cryptography.Certificates.UserCertificateStore is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateStores");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateStoresStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.IUserCertificateStore;
         HStr_storeName : WinRt.HString := To_HString (storeName);
      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Certificates.UserCertificateStore do
            Hr := RoGetActivationFactory (m_hString, IID_ICertificateStoresStatics2'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetUserStoreByName (HStr_storeName, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               Retval.m_IUserCertificateStore := new Windows.Security.Cryptography.Certificates.IUserCertificateStore;
               Retval.m_IUserCertificateStore.all := m_ComRetVal;
            end if;
            Hr := WindowsDeleteString (m_hString);
            Hr := WindowsDeleteString (HStr_storeName);
         end return;
      end;

      function FindAllAsync
      return WinRt.GenericObject is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateStores");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateStoresStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_GenericObject.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.GenericObject;
         m_IID            : aliased WinRt.IID := (2602984590, 45871, 22793, (166, 53, 120, 230, 211, 187, 64, 103 )); -- GenericObject;
         m_HandlerIID     : aliased WinRt.IID := (412547822, 9186, 22986, (152, 2, 15, 72, 238, 217, 142, 244 ));
         m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateStoresStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindAllAsync (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_RetVal;
      end;

      function FindAllAsync
      (
         query : Windows.Security.Cryptography.Certificates.CertificateQuery'Class
      )
      return WinRt.GenericObject is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateStores");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateStoresStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_GenericObject.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.GenericObject;
         m_IID            : aliased WinRt.IID := (2602984590, 45871, 22793, (166, 53, 120, 230, 211, 187, 64, 103 )); -- GenericObject;
         m_HandlerIID     : aliased WinRt.IID := (412547822, 9186, 22986, (152, 2, 15, 72, 238, 217, 142, 244 ));
         m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICertificateStoresStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindAllAsync (query.m_ICertificateQuery.all, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_RetVal;
      end;

      function get_TrustedRootCertificationAuthorities
      return WinRt.Windows.Security.Cryptography.Certificates.CertificateStore is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateStores");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateStoresStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificateStore;
      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CertificateStore do
            Hr := RoGetActivationFactory (m_hString, IID_ICertificateStoresStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.get_TrustedRootCertificationAuthorities (m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               Retval.m_ICertificateStore := new Windows.Security.Cryptography.Certificates.ICertificateStore;
               Retval.m_ICertificateStore.all := m_ComRetVal;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function get_IntermediateCertificationAuthorities
      return WinRt.Windows.Security.Cryptography.Certificates.CertificateStore is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateStores");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateStoresStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificateStore;
      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CertificateStore do
            Hr := RoGetActivationFactory (m_hString, IID_ICertificateStoresStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.get_IntermediateCertificationAuthorities (m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               Retval.m_ICertificateStore := new Windows.Security.Cryptography.Certificates.ICertificateStore;
               Retval.m_ICertificateStore.all := m_ComRetVal;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function GetStoreByName
      (
         storeName : WinRt.WString
      )
      return WinRt.Windows.Security.Cryptography.Certificates.CertificateStore is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CertificateStores");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICertificateStoresStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificateStore;
         HStr_storeName : WinRt.HString := To_HString (storeName);
      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CertificateStore do
            Hr := RoGetActivationFactory (m_hString, IID_ICertificateStoresStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.GetStoreByName (HStr_storeName, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               Retval.m_ICertificateStore := new Windows.Security.Cryptography.Certificates.ICertificateStore;
               Retval.m_ICertificateStore.all := m_ComRetVal;
            end if;
            Hr := WindowsDeleteString (m_hString);
            Hr := WindowsDeleteString (HStr_storeName);
         end return;
      end;

   end CertificateStores;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ChainBuildingParameters

   procedure Initialize (this : in out ChainBuildingParameters) is
   begin
      null;
   end;

   procedure Finalize (this : in out ChainBuildingParameters) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IChainBuildingParameters, IChainBuildingParameters_Ptr);
   begin
      if this.m_IChainBuildingParameters /= null then
         if this.m_IChainBuildingParameters.all /= null then
            RefCount := this.m_IChainBuildingParameters.all.Release;
            Free (this.m_IChainBuildingParameters);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ChainBuildingParameters

   function Constructor return ChainBuildingParameters is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.ChainBuildingParameters");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.IChainBuildingParameters;
   begin
      return RetVal : ChainBuildingParameters do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IChainBuildingParameters := new Windows.Security.Cryptography.Certificates.IChainBuildingParameters;
            Retval.m_IChainBuildingParameters.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ChainBuildingParameters

   function get_EnhancedKeyUsages
   (
      this : in out ChainBuildingParameters
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
   begin
      Hr := this.m_IChainBuildingParameters.all.get_EnhancedKeyUsages (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ValidationTimestamp
   (
      this : in out ChainBuildingParameters
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IChainBuildingParameters.all.get_ValidationTimestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ValidationTimestamp
   (
      this : in out ChainBuildingParameters;
      value : Windows.Foundation.DateTime
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IChainBuildingParameters.all.put_ValidationTimestamp (value);
   end;

   function get_RevocationCheckEnabled
   (
      this : in out ChainBuildingParameters
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IChainBuildingParameters.all.get_RevocationCheckEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RevocationCheckEnabled
   (
      this : in out ChainBuildingParameters;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IChainBuildingParameters.all.put_RevocationCheckEnabled (value);
   end;

   function get_NetworkRetrievalEnabled
   (
      this : in out ChainBuildingParameters
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IChainBuildingParameters.all.get_NetworkRetrievalEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_NetworkRetrievalEnabled
   (
      this : in out ChainBuildingParameters;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IChainBuildingParameters.all.put_NetworkRetrievalEnabled (value);
   end;

   function get_AuthorityInformationAccessEnabled
   (
      this : in out ChainBuildingParameters
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IChainBuildingParameters.all.get_AuthorityInformationAccessEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AuthorityInformationAccessEnabled
   (
      this : in out ChainBuildingParameters;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IChainBuildingParameters.all.put_AuthorityInformationAccessEnabled (value);
   end;

   function get_CurrentTimeValidationEnabled
   (
      this : in out ChainBuildingParameters
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IChainBuildingParameters.all.get_CurrentTimeValidationEnabled (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_CurrentTimeValidationEnabled
   (
      this : in out ChainBuildingParameters;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IChainBuildingParameters.all.put_CurrentTimeValidationEnabled (value);
   end;

   function get_ExclusiveTrustRoots
   (
      this : in out ChainBuildingParameters
   )
   return IVector_ICertificate.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_ICertificate.Kind;
   begin
      Hr := this.m_IChainBuildingParameters.all.get_ExclusiveTrustRoots (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVector_ICertificate (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ChainValidationParameters

   procedure Initialize (this : in out ChainValidationParameters) is
   begin
      null;
   end;

   procedure Finalize (this : in out ChainValidationParameters) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IChainValidationParameters, IChainValidationParameters_Ptr);
   begin
      if this.m_IChainValidationParameters /= null then
         if this.m_IChainValidationParameters.all /= null then
            RefCount := this.m_IChainValidationParameters.all.Release;
            Free (this.m_IChainValidationParameters);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ChainValidationParameters

   function Constructor return ChainValidationParameters is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.ChainValidationParameters");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.IChainValidationParameters;
   begin
      return RetVal : ChainValidationParameters do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IChainValidationParameters := new Windows.Security.Cryptography.Certificates.IChainValidationParameters;
            Retval.m_IChainValidationParameters.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ChainValidationParameters

   function get_CertificateChainPolicy
   (
      this : in out ChainValidationParameters
   )
   return WinRt.Windows.Security.Cryptography.Certificates.CertificateChainPolicy is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.CertificateChainPolicy;
   begin
      Hr := this.m_IChainValidationParameters.all.get_CertificateChainPolicy (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_CertificateChainPolicy
   (
      this : in out ChainValidationParameters;
      value : Windows.Security.Cryptography.Certificates.CertificateChainPolicy
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IChainValidationParameters.all.put_CertificateChainPolicy (value);
   end;

   function get_ServerDnsName
   (
      this : in out ChainValidationParameters
   )
   return WinRt.Windows.Networking.HostName'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Networking.IHostName;
   begin
      return RetVal : WinRt.Windows.Networking.HostName do
         Hr := this.m_IChainValidationParameters.all.get_ServerDnsName (m_ComRetVal'Access);
         Retval.m_IHostName := new Windows.Networking.IHostName;
         Retval.m_IHostName.all := m_ComRetVal;
      end return;
   end;

   procedure put_ServerDnsName
   (
      this : in out ChainValidationParameters;
      value : Windows.Networking.HostName'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IChainValidationParameters.all.put_ServerDnsName (value.m_IHostName.all);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CmsAttachedSignature

   procedure Initialize (this : in out CmsAttachedSignature) is
   begin
      null;
   end;

   procedure Finalize (this : in out CmsAttachedSignature) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICmsAttachedSignature, ICmsAttachedSignature_Ptr);
   begin
      if this.m_ICmsAttachedSignature /= null then
         if this.m_ICmsAttachedSignature.all /= null then
            RefCount := this.m_ICmsAttachedSignature.all.Release;
            Free (this.m_ICmsAttachedSignature);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CmsAttachedSignature

   function Constructor
   (
      inputBlob : Windows.Storage.Streams.IBuffer
   )
   return CmsAttachedSignature is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CmsAttachedSignature");
      m_Factory    : access ICmsAttachedSignatureFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICmsAttachedSignature;
   begin
      return RetVal : CmsAttachedSignature do
         Hr := RoGetActivationFactory (m_hString, IID_ICmsAttachedSignatureFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateCmsAttachedSignature (inputBlob, m_ComRetVal'Access);
            Retval.m_ICmsAttachedSignature := new Windows.Security.Cryptography.Certificates.ICmsAttachedSignature;
            Retval.m_ICmsAttachedSignature.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CmsAttachedSignature

   function GenerateSignatureAsync
   (
      data : Windows.Storage.Streams.IBuffer;
      signers : GenericObject;
      certificates : GenericObject
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CmsAttachedSignature");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICmsAttachedSignatureStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_IBuffer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Storage.Streams.IBuffer;
      m_IID            : aliased WinRt.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
      m_HandlerIID     : aliased WinRt.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
      m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICmsAttachedSignatureStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GenerateSignatureAsync (data, signers, certificates, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CmsAttachedSignature

   function get_Certificates
   (
      this : in out CmsAttachedSignature
   )
   return IVectorView_ICertificate.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ICertificate.Kind;
   begin
      Hr := this.m_ICmsAttachedSignature.all.get_Certificates (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_ICertificate (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Content
   (
      this : in out CmsAttachedSignature
   )
   return WinRt.Byte_Array is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Byte_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICmsAttachedSignature.all.get_Content (m_ComRetValSize'Access, m_ComRetVal'Access);
      declare
         ArrayRetVal : WinRt.Byte_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Byte is new To_Ada_Type (WinRt.Byte, WinRt.Byte_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Byte (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function get_Signers
   (
      this : in out CmsAttachedSignature
   )
   return IVectorView_ICmsSignerInfo.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ICmsSignerInfo.Kind;
   begin
      Hr := this.m_ICmsAttachedSignature.all.get_Signers (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_ICmsSignerInfo (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function VerifySignature
   (
      this : in out CmsAttachedSignature
   )
   return WinRt.Windows.Security.Cryptography.Certificates.SignatureValidationResult is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.SignatureValidationResult;
   begin
      Hr := this.m_ICmsAttachedSignature.all.VerifySignature (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CmsDetachedSignature

   procedure Initialize (this : in out CmsDetachedSignature) is
   begin
      null;
   end;

   procedure Finalize (this : in out CmsDetachedSignature) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICmsDetachedSignature, ICmsDetachedSignature_Ptr);
   begin
      if this.m_ICmsDetachedSignature /= null then
         if this.m_ICmsDetachedSignature.all /= null then
            RefCount := this.m_ICmsDetachedSignature.all.Release;
            Free (this.m_ICmsDetachedSignature);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CmsDetachedSignature

   function Constructor
   (
      inputBlob : Windows.Storage.Streams.IBuffer
   )
   return CmsDetachedSignature is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CmsDetachedSignature");
      m_Factory    : access ICmsDetachedSignatureFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICmsDetachedSignature;
   begin
      return RetVal : CmsDetachedSignature do
         Hr := RoGetActivationFactory (m_hString, IID_ICmsDetachedSignatureFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateCmsDetachedSignature (inputBlob, m_ComRetVal'Access);
            Retval.m_ICmsDetachedSignature := new Windows.Security.Cryptography.Certificates.ICmsDetachedSignature;
            Retval.m_ICmsDetachedSignature.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CmsDetachedSignature

   function GenerateSignatureAsync
   (
      data : Windows.Storage.Streams.IInputStream;
      signers : GenericObject;
      certificates : GenericObject
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CmsDetachedSignature");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.ICmsDetachedSignatureStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_IBuffer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Storage.Streams.IBuffer;
      m_IID            : aliased WinRt.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
      m_HandlerIID     : aliased WinRt.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
      m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICmsDetachedSignatureStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GenerateSignatureAsync (data, signers, certificates, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CmsDetachedSignature

   function get_Certificates
   (
      this : in out CmsDetachedSignature
   )
   return IVectorView_ICertificate.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ICertificate.Kind;
   begin
      Hr := this.m_ICmsDetachedSignature.all.get_Certificates (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_ICertificate (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Signers
   (
      this : in out CmsDetachedSignature
   )
   return IVectorView_ICmsSignerInfo.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ICmsSignerInfo.Kind;
   begin
      Hr := this.m_ICmsDetachedSignature.all.get_Signers (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_ICmsSignerInfo (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function VerifySignatureAsync
   (
      this : in out CmsDetachedSignature;
      data : Windows.Storage.Streams.IInputStream
   )
   return WinRt.Windows.Security.Cryptography.Certificates.SignatureValidationResult is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_SignatureValidationResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_SignatureValidationResult.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Security.Cryptography.Certificates.SignatureValidationResult;
      m_IID            : aliased WinRt.IID := (4036758479, 52795, 24063, (151, 31, 44, 63, 254, 111, 208, 77 )); -- Windows.Security.Cryptography.Certificates.SignatureValidationResult;
      m_HandlerIID     : aliased WinRt.IID := (3757375493, 30893, 24399, (160, 133, 203, 97, 74, 103, 74, 37 ));
      m_Handler        : AsyncOperationCompletedHandler_SignatureValidationResult.Kind := new AsyncOperationCompletedHandler_SignatureValidationResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_SignatureValidationResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_SignatureValidationResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_SignatureValidationResult.Kind_Delegate, AsyncOperationCompletedHandler_SignatureValidationResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ICmsDetachedSignature.all.VerifySignatureAsync (data, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CmsSignerInfo

   procedure Initialize (this : in out CmsSignerInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out CmsSignerInfo) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICmsSignerInfo, ICmsSignerInfo_Ptr);
   begin
      if this.m_ICmsSignerInfo /= null then
         if this.m_ICmsSignerInfo.all /= null then
            RefCount := this.m_ICmsSignerInfo.all.Release;
            Free (this.m_ICmsSignerInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CmsSignerInfo

   function Constructor return CmsSignerInfo is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.CmsSignerInfo");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ICmsSignerInfo;
   begin
      return RetVal : CmsSignerInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICmsSignerInfo := new Windows.Security.Cryptography.Certificates.ICmsSignerInfo;
            Retval.m_ICmsSignerInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CmsSignerInfo

   function get_Certificate
   (
      this : in out CmsSignerInfo
   )
   return WinRt.Windows.Security.Cryptography.Certificates.Certificate'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificate;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.Certificate do
         Hr := this.m_ICmsSignerInfo.all.get_Certificate (m_ComRetVal'Access);
         Retval.m_ICertificate := new Windows.Security.Cryptography.Certificates.ICertificate;
         Retval.m_ICertificate.all := m_ComRetVal;
      end return;
   end;

   procedure put_Certificate
   (
      this : in out CmsSignerInfo;
      value : Windows.Security.Cryptography.Certificates.Certificate'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICmsSignerInfo.all.put_Certificate (value.m_ICertificate.all);
   end;

   function get_HashAlgorithmName
   (
      this : in out CmsSignerInfo
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICmsSignerInfo.all.get_HashAlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_HashAlgorithmName
   (
      this : in out CmsSignerInfo;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICmsSignerInfo.all.put_HashAlgorithmName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_TimestampInfo
   (
      this : in out CmsSignerInfo
   )
   return WinRt.Windows.Security.Cryptography.Certificates.CmsTimestampInfo'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICmsTimestampInfo;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CmsTimestampInfo do
         Hr := this.m_ICmsSignerInfo.all.get_TimestampInfo (m_ComRetVal'Access);
         Retval.m_ICmsTimestampInfo := new Windows.Security.Cryptography.Certificates.ICmsTimestampInfo;
         Retval.m_ICmsTimestampInfo.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CmsTimestampInfo

   procedure Initialize (this : in out CmsTimestampInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out CmsTimestampInfo) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICmsTimestampInfo, ICmsTimestampInfo_Ptr);
   begin
      if this.m_ICmsTimestampInfo /= null then
         if this.m_ICmsTimestampInfo.all /= null then
            RefCount := this.m_ICmsTimestampInfo.all.Release;
            Free (this.m_ICmsTimestampInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CmsTimestampInfo

   function get_SigningCertificate
   (
      this : in out CmsTimestampInfo
   )
   return WinRt.Windows.Security.Cryptography.Certificates.Certificate'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificate;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.Certificate do
         Hr := this.m_ICmsTimestampInfo.all.get_SigningCertificate (m_ComRetVal'Access);
         Retval.m_ICertificate := new Windows.Security.Cryptography.Certificates.ICertificate;
         Retval.m_ICertificate.all := m_ComRetVal;
      end return;
   end;

   function get_Certificates
   (
      this : in out CmsTimestampInfo
   )
   return IVectorView_ICertificate.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ICertificate.Kind;
   begin
      Hr := this.m_ICmsTimestampInfo.all.get_Certificates (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_ICertificate (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Timestamp
   (
      this : in out CmsTimestampInfo
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICmsTimestampInfo.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body KeyAlgorithmNames is

      function get_Ecdsa
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdsa (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ecdh
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdh (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Rsa
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Rsa (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Dsa
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Dsa (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ecdh256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdh256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ecdh384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdh384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ecdh521
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdh521 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ecdsa256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdsa256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ecdsa384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdsa384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ecdsa521
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ecdsa521 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end KeyAlgorithmNames;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body KeyAttestationHelper is

      function DecryptTpmAttestationCredentialAsync
      (
         credential : WinRt.WString
      )
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAttestationHelper");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAttestationHelperStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_credential : WinRt.HString := To_HString (credential);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_HString.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_HString.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.HString;
         AdaRetval        : WString;
         m_IID            : aliased WinRt.IID := (1042277891, 63639, 21091, (179, 40, 8, 6, 66, 107, 138, 121 )); -- HString;
         m_HandlerIID     : aliased WinRt.IID := (3080352799, 32693, 20654, (158, 153, 145, 18, 1, 236, 61, 65 ));
         m_Handler        : AsyncOperationCompletedHandler_HString.Kind := new AsyncOperationCompletedHandler_HString.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HString.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HString.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HString.Kind_Delegate, AsyncOperationCompletedHandler_HString.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAttestationHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.DecryptTpmAttestationCredentialAsync (HStr_credential, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_credential);
         AdaRetval := To_Ada (m_RetVal);
         Hr := WindowsDeleteString (m_RetVal);
         return AdaRetVal;
      end;

      function GetTpmAttestationCredentialId
      (
         credential : WinRt.WString
      )
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAttestationHelper");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAttestationHelperStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
         HStr_credential : WinRt.HString := To_HString (credential);
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAttestationHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetTpmAttestationCredentialId (HStr_credential, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_credential);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function DecryptTpmAttestationCredentialAsync
      (
         credential : WinRt.WString;
         containerName : WinRt.WString
      )
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyAttestationHelper");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyAttestationHelperStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_credential : WinRt.HString := To_HString (credential);
         HStr_containerName : WinRt.HString := To_HString (containerName);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_HString.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_HString.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.HString;
         AdaRetval        : WString;
         m_IID            : aliased WinRt.IID := (1042277891, 63639, 21091, (179, 40, 8, 6, 66, 107, 138, 121 )); -- HString;
         m_HandlerIID     : aliased WinRt.IID := (3080352799, 32693, 20654, (158, 153, 145, 18, 1, 236, 61, 65 ));
         m_Handler        : AsyncOperationCompletedHandler_HString.Kind := new AsyncOperationCompletedHandler_HString.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HString.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HString.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HString.Kind_Delegate, AsyncOperationCompletedHandler_HString.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyAttestationHelperStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.DecryptTpmAttestationCredentialAsync (HStr_credential, HStr_containerName, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_credential);
         Hr := WindowsDeleteString (HStr_containerName);
         AdaRetval := To_Ada (m_RetVal);
         Hr := WindowsDeleteString (m_RetVal);
         return AdaRetVal;
      end;

   end KeyAttestationHelper;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body KeyStorageProviderNames is

      function get_PassportKeyStorageProvider
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyStorageProviderNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyStorageProviderNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyStorageProviderNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PassportKeyStorageProvider (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SoftwareKeyStorageProvider
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyStorageProviderNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyStorageProviderNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyStorageProviderNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SoftwareKeyStorageProvider (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SmartcardKeyStorageProvider
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyStorageProviderNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyStorageProviderNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyStorageProviderNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SmartcardKeyStorageProvider (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_PlatformKeyStorageProvider
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.KeyStorageProviderNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IKeyStorageProviderNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyStorageProviderNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlatformKeyStorageProvider (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end KeyStorageProviderNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PfxImportParameters

   procedure Initialize (this : in out PfxImportParameters) is
   begin
      null;
   end;

   procedure Finalize (this : in out PfxImportParameters) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPfxImportParameters, IPfxImportParameters_Ptr);
   begin
      if this.m_IPfxImportParameters /= null then
         if this.m_IPfxImportParameters.all /= null then
            RefCount := this.m_IPfxImportParameters.all.Release;
            Free (this.m_IPfxImportParameters);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PfxImportParameters

   function Constructor return PfxImportParameters is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.PfxImportParameters");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.IPfxImportParameters;
   begin
      return RetVal : PfxImportParameters do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPfxImportParameters := new Windows.Security.Cryptography.Certificates.IPfxImportParameters;
            Retval.m_IPfxImportParameters.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PfxImportParameters

   function get_Exportable
   (
      this : in out PfxImportParameters
   )
   return WinRt.Windows.Security.Cryptography.Certificates.ExportOption is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ExportOption;
   begin
      Hr := this.m_IPfxImportParameters.all.get_Exportable (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Exportable
   (
      this : in out PfxImportParameters;
      value : Windows.Security.Cryptography.Certificates.ExportOption
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPfxImportParameters.all.put_Exportable (value);
   end;

   function get_KeyProtectionLevel
   (
      this : in out PfxImportParameters
   )
   return WinRt.Windows.Security.Cryptography.Certificates.KeyProtectionLevel is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
   begin
      Hr := this.m_IPfxImportParameters.all.get_KeyProtectionLevel (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KeyProtectionLevel
   (
      this : in out PfxImportParameters;
      value : Windows.Security.Cryptography.Certificates.KeyProtectionLevel
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPfxImportParameters.all.put_KeyProtectionLevel (value);
   end;

   function get_InstallOptions
   (
      this : in out PfxImportParameters
   )
   return WinRt.Windows.Security.Cryptography.Certificates.InstallOptions is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.InstallOptions;
   begin
      Hr := this.m_IPfxImportParameters.all.get_InstallOptions (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_InstallOptions
   (
      this : in out PfxImportParameters;
      value : Windows.Security.Cryptography.Certificates.InstallOptions
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPfxImportParameters.all.put_InstallOptions (value);
   end;

   function get_FriendlyName
   (
      this : in out PfxImportParameters
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPfxImportParameters.all.get_FriendlyName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_FriendlyName
   (
      this : in out PfxImportParameters;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IPfxImportParameters.all.put_FriendlyName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_KeyStorageProviderName
   (
      this : in out PfxImportParameters
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPfxImportParameters.all.get_KeyStorageProviderName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyStorageProviderName
   (
      this : in out PfxImportParameters;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IPfxImportParameters.all.put_KeyStorageProviderName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_ContainerNamePrefix
   (
      this : in out PfxImportParameters
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPfxImportParameters.all.get_ContainerNamePrefix (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ContainerNamePrefix
   (
      this : in out PfxImportParameters;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IPfxImportParameters.all.put_ContainerNamePrefix (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   function get_ReaderName
   (
      this : in out PfxImportParameters
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPfxImportParameters.all.get_ReaderName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReaderName
   (
      this : in out PfxImportParameters;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_value : WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IPfxImportParameters.all.put_ReaderName (HStr_value);
      Hr := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body StandardCertificateStoreNames is

      function get_Personal
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IStandardCertificateStoreNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IStandardCertificateStoreNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Personal (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_TrustedRootCertificationAuthorities
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IStandardCertificateStoreNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IStandardCertificateStoreNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TrustedRootCertificationAuthorities (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_IntermediateCertificationAuthorities
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.StandardCertificateStoreNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Certificates.IStandardCertificateStoreNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IStandardCertificateStoreNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IntermediateCertificationAuthorities (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end StandardCertificateStoreNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SubjectAlternativeNameInfo

   procedure Initialize (this : in out SubjectAlternativeNameInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out SubjectAlternativeNameInfo) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISubjectAlternativeNameInfo, ISubjectAlternativeNameInfo_Ptr);
   begin
      if this.m_ISubjectAlternativeNameInfo /= null then
         if this.m_ISubjectAlternativeNameInfo.all /= null then
            RefCount := this.m_ISubjectAlternativeNameInfo.all.Release;
            Free (this.m_ISubjectAlternativeNameInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SubjectAlternativeNameInfo

   function Constructor return SubjectAlternativeNameInfo is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo");
      m_ComRetVal  : aliased Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo;
   begin
      return RetVal : SubjectAlternativeNameInfo do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISubjectAlternativeNameInfo := new Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo;
            Retval.m_ISubjectAlternativeNameInfo.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SubjectAlternativeNameInfo

   function get_EmailName
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_ISubjectAlternativeNameInfo.all.get_EmailName (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IPAddress
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_ISubjectAlternativeNameInfo.all.get_IPAddress (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Url
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_ISubjectAlternativeNameInfo.all.get_Url (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_DnsName
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_ISubjectAlternativeNameInfo.all.get_DnsName (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_DistinguishedName
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_ISubjectAlternativeNameInfo.all.get_DistinguishedName (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_PrincipalName
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_ISubjectAlternativeNameInfo.all.get_PrincipalName (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_EmailNames
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo_Interface, WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2, WinRt.Windows.Security.Cryptography.Certificates.IID_ISubjectAlternativeNameInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISubjectAlternativeNameInfo.all);
      Hr := m_Interface.get_EmailNames (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IPAddresses
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo_Interface, WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2, WinRt.Windows.Security.Cryptography.Certificates.IID_ISubjectAlternativeNameInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISubjectAlternativeNameInfo.all);
      Hr := m_Interface.get_IPAddresses (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Urls
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo_Interface, WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2, WinRt.Windows.Security.Cryptography.Certificates.IID_ISubjectAlternativeNameInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISubjectAlternativeNameInfo.all);
      Hr := m_Interface.get_Urls (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_DnsNames
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo_Interface, WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2, WinRt.Windows.Security.Cryptography.Certificates.IID_ISubjectAlternativeNameInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISubjectAlternativeNameInfo.all);
      Hr := m_Interface.get_DnsNames (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_DistinguishedNames
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo_Interface, WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2, WinRt.Windows.Security.Cryptography.Certificates.IID_ISubjectAlternativeNameInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISubjectAlternativeNameInfo.all);
      Hr := m_Interface.get_DistinguishedNames (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_PrincipalNames
   (
      this : in out SubjectAlternativeNameInfo
   )
   return IVector_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo_Interface, WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2, WinRt.Windows.Security.Cryptography.Certificates.IID_ISubjectAlternativeNameInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISubjectAlternativeNameInfo.all);
      Hr := m_Interface.get_PrincipalNames (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IVector_HString (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Extension
   (
      this : in out SubjectAlternativeNameInfo
   )
   return WinRt.Windows.Security.Cryptography.Certificates.CertificateExtension'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Certificates.ICertificateExtension;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo_Interface, WinRt.Windows.Security.Cryptography.Certificates.ISubjectAlternativeNameInfo2, WinRt.Windows.Security.Cryptography.Certificates.IID_ISubjectAlternativeNameInfo2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Certificates.CertificateExtension do
         m_Interface := QInterface (this.m_ISubjectAlternativeNameInfo.all);
         Hr := m_Interface.get_Extension (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ICertificateExtension := new Windows.Security.Cryptography.Certificates.ICertificateExtension;
         Retval.m_ICertificateExtension.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UserCertificateEnrollmentManager

   procedure Initialize (this : in out UserCertificateEnrollmentManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out UserCertificateEnrollmentManager) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUserCertificateEnrollmentManager, IUserCertificateEnrollmentManager_Ptr);
   begin
      if this.m_IUserCertificateEnrollmentManager /= null then
         if this.m_IUserCertificateEnrollmentManager.all /= null then
            RefCount := this.m_IUserCertificateEnrollmentManager.all.Release;
            Free (this.m_IUserCertificateEnrollmentManager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UserCertificateEnrollmentManager

   function CreateRequestAsync
   (
      this : in out UserCertificateEnrollmentManager;
      request : Windows.Security.Cryptography.Certificates.CertificateRequestProperties'Class
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_HString.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HString.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.HString;
      AdaRetval        : WString;
      m_IID            : aliased WinRt.IID := (1042277891, 63639, 21091, (179, 40, 8, 6, 66, 107, 138, 121 )); -- HString;
      m_HandlerIID     : aliased WinRt.IID := (3080352799, 32693, 20654, (158, 153, 145, 18, 1, 236, 61, 65 ));
      m_Handler        : AsyncOperationCompletedHandler_HString.Kind := new AsyncOperationCompletedHandler_HString.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HString.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HString.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HString.Kind_Delegate, AsyncOperationCompletedHandler_HString.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IUserCertificateEnrollmentManager.all.CreateRequestAsync (request.m_ICertificateRequestProperties.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      AdaRetval := To_Ada (m_RetVal);
      Hr := WindowsDeleteString (m_RetVal);
      return AdaRetVal;
   end;

   procedure InstallCertificateAsync
   (
      this : in out UserCertificateEnrollmentManager;
      certificate_p : WinRt.WString;
      installOption : Windows.Security.Cryptography.Certificates.InstallOptions
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_certificate_p : WinRt.HString := To_HString (certificate_p);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUserCertificateEnrollmentManager.all.InstallCertificateAsync (HStr_certificate_p, installOption, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_certificate_p);
   end;

   procedure ImportPfxDataAsync
   (
      this : in out UserCertificateEnrollmentManager;
      pfxData : WinRt.WString;
      password : WinRt.WString;
      exportable : Windows.Security.Cryptography.Certificates.ExportOption;
      keyProtectionLevel : Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
      installOption : Windows.Security.Cryptography.Certificates.InstallOptions;
      friendlyName : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_pfxData : WinRt.HString := To_HString (pfxData);
      HStr_password : WinRt.HString := To_HString (password);
      HStr_friendlyName : WinRt.HString := To_HString (friendlyName);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUserCertificateEnrollmentManager.all.ImportPfxDataAsync (HStr_pfxData, HStr_password, exportable, keyProtectionLevel, installOption, HStr_friendlyName, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_pfxData);
      Hr := WindowsDeleteString (HStr_password);
      Hr := WindowsDeleteString (HStr_friendlyName);
   end;

   procedure ImportPfxDataAsync
   (
      this : in out UserCertificateEnrollmentManager;
      pfxData : WinRt.WString;
      password : WinRt.WString;
      exportable : Windows.Security.Cryptography.Certificates.ExportOption;
      keyProtectionLevel : Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
      installOption : Windows.Security.Cryptography.Certificates.InstallOptions;
      friendlyName : WinRt.WString;
      keyStorageProvider : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_pfxData : WinRt.HString := To_HString (pfxData);
      HStr_password : WinRt.HString := To_HString (password);
      HStr_friendlyName : WinRt.HString := To_HString (friendlyName);
      HStr_keyStorageProvider : WinRt.HString := To_HString (keyStorageProvider);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IUserCertificateEnrollmentManager.all.ImportPfxDataAsync (HStr_pfxData, HStr_password, exportable, keyProtectionLevel, installOption, HStr_friendlyName, HStr_keyStorageProvider, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_pfxData);
      Hr := WindowsDeleteString (HStr_password);
      Hr := WindowsDeleteString (HStr_friendlyName);
      Hr := WindowsDeleteString (HStr_keyStorageProvider);
   end;

   procedure ImportPfxDataAsync
   (
      this : in out UserCertificateEnrollmentManager;
      pfxData : WinRt.WString;
      password : WinRt.WString;
      pfxImportParameters_p : Windows.Security.Cryptography.Certificates.PfxImportParameters'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Certificates.IUserCertificateEnrollmentManager2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_pfxData : WinRt.HString := To_HString (pfxData);
      HStr_password : WinRt.HString := To_HString (password);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Certificates.IUserCertificateEnrollmentManager_Interface, WinRt.Windows.Security.Cryptography.Certificates.IUserCertificateEnrollmentManager2, WinRt.Windows.Security.Cryptography.Certificates.IID_IUserCertificateEnrollmentManager2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IUserCertificateEnrollmentManager.all);
      Hr := m_Interface.ImportPfxDataAsync (HStr_pfxData, HStr_password, pfxImportParameters_p.m_IPfxImportParameters.all, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         m_RefCount := m_ComRetVal.Release;
         m_RefCount := m_CompletedHandler.Release;
         if m_RefCount = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
      Hr := WindowsDeleteString (HStr_pfxData);
      Hr := WindowsDeleteString (HStr_password);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UserCertificateStore

   procedure Initialize (this : in out UserCertificateStore) is
   begin
      null;
   end;

   procedure Finalize (this : in out UserCertificateStore) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUserCertificateStore, IUserCertificateStore_Ptr);
   begin
      if this.m_IUserCertificateStore /= null then
         if this.m_IUserCertificateStore.all /= null then
            RefCount := this.m_IUserCertificateStore.all.Release;
            Free (this.m_IUserCertificateStore);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UserCertificateStore

   function RequestAddAsync
   (
      this : in out UserCertificateStore;
      certificate_p : Windows.Security.Cryptography.Certificates.Certificate'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IUserCertificateStore.all.RequestAddAsync (certificate_p.m_ICertificate.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function RequestDeleteAsync
   (
      this : in out UserCertificateStore;
      certificate_p : Windows.Security.Cryptography.Certificates.Certificate'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IUserCertificateStore.all.RequestDeleteAsync (certificate_p.m_ICertificate.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         m_RefCount := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            m_RefCount := m_AsyncOperation.Release;
            m_RefCount := m_Handler.Release;
            if m_RefCount = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_Name
   (
      this : in out UserCertificateStore
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IUserCertificateStore.all.get_Name (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

end;
