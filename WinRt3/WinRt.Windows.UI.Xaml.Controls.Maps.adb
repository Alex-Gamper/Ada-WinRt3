--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Devices.Geolocation;
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Services.Maps;
with WinRt.Windows.Storage.Streams;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.Xaml.Controls.Maps is

   package IAsyncOperation_Boolean is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Boolean);
   package AsyncOperationCompletedHandler_Boolean is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Boolean);

   package IAsyncOperation_MapModel3D is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.UI.Xaml.Controls.Maps.IMapModel3D);
   package AsyncOperationCompletedHandler_MapModel3D is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.UI.Xaml.Controls.Maps.IMapModel3D);

   package IAsyncOperation_StreetsidePanorama is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.UI.Xaml.Controls.Maps.IStreetsidePanorama);
   package AsyncOperationCompletedHandler_StreetsidePanorama is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.UI.Xaml.Controls.Maps.IStreetsidePanorama);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileDataSource

   procedure Initialize (this : in out MapTileDataSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileDataSource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileDataSource, IMapTileDataSource_Ptr);
   begin
      if this.m_IMapTileDataSource /= null then
         if this.m_IMapTileDataSource.all /= null then
            temp := this.m_IMapTileDataSource.all.Release;
            Free (this.m_IMapTileDataSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileDataSource

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapTileDataSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileDataSource");
      m_Factory    : access IMapTileDataSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileDataSource;
   begin
      return RetVal : MapTileDataSource do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileDataSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapTileDataSource := new Windows.UI.Xaml.Controls.Maps.IMapTileDataSource;
            Retval.m_IMapTileDataSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileDataSource

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CustomMapTileDataSource

   procedure Initialize (this : in out CustomMapTileDataSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out CustomMapTileDataSource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICustomMapTileDataSource, ICustomMapTileDataSource_Ptr);
   begin
      if this.m_ICustomMapTileDataSource /= null then
         if this.m_ICustomMapTileDataSource.all /= null then
            temp := this.m_ICustomMapTileDataSource.all.Release;
            Free (this.m_ICustomMapTileDataSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CustomMapTileDataSource

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return CustomMapTileDataSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.CustomMapTileDataSource");
      m_Factory    : access ICustomMapTileDataSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.ICustomMapTileDataSource;
   begin
      return RetVal : CustomMapTileDataSource do
         Hr := RoGetActivationFactory (m_hString, IID_ICustomMapTileDataSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICustomMapTileDataSource := new Windows.UI.Xaml.Controls.Maps.ICustomMapTileDataSource;
            Retval.m_ICustomMapTileDataSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CustomMapTileDataSource

   function add_BitmapRequested
   (
      this : in out CustomMapTileDataSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICustomMapTileDataSource.all.add_BitmapRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BitmapRequested
   (
      this : in out CustomMapTileDataSource;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICustomMapTileDataSource.all.remove_BitmapRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HttpMapTileDataSource

   procedure Initialize (this : in out HttpMapTileDataSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out HttpMapTileDataSource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHttpMapTileDataSource, IHttpMapTileDataSource_Ptr);
   begin
      if this.m_IHttpMapTileDataSource /= null then
         if this.m_IHttpMapTileDataSource.all /= null then
            temp := this.m_IHttpMapTileDataSource.all.Release;
            Free (this.m_IHttpMapTileDataSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HttpMapTileDataSource

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return HttpMapTileDataSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource");
      m_Factory    : access IHttpMapTileDataSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IHttpMapTileDataSource;
   begin
      return RetVal : HttpMapTileDataSource do
         Hr := RoGetActivationFactory (m_hString, IID_IHttpMapTileDataSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHttpMapTileDataSource := new Windows.UI.Xaml.Controls.Maps.IHttpMapTileDataSource;
            Retval.m_IHttpMapTileDataSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      uriFormatString : WinRt.WString;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return HttpMapTileDataSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource");
      m_Factory    : access IHttpMapTileDataSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IHttpMapTileDataSource;
      HStr_uriFormatString : constant WinRt.HString := To_HString (uriFormatString);
   begin
      return RetVal : HttpMapTileDataSource do
         Hr := RoGetActivationFactory (m_hString, IID_IHttpMapTileDataSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithUriFormatString (HStr_uriFormatString, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHttpMapTileDataSource := new Windows.UI.Xaml.Controls.Maps.IHttpMapTileDataSource;
            Retval.m_IHttpMapTileDataSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_uriFormatString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HttpMapTileDataSource

   function get_UriFormatString
   (
      this : in out HttpMapTileDataSource
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IHttpMapTileDataSource.all.get_UriFormatString (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_UriFormatString
   (
      this : in out HttpMapTileDataSource;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IHttpMapTileDataSource.all.put_UriFormatString (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_AdditionalRequestHeaders
   (
      this : in out HttpMapTileDataSource
   )
   return IMap_HString_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMap_HString_HString.Kind;
   begin
      Hr := this.m_IHttpMapTileDataSource.all.get_AdditionalRequestHeaders (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_HString_HString (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_AllowCaching
   (
      this : in out HttpMapTileDataSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IHttpMapTileDataSource.all.get_AllowCaching (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowCaching
   (
      this : in out HttpMapTileDataSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IHttpMapTileDataSource.all.put_AllowCaching (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UriRequested
   (
      this : in out HttpMapTileDataSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHttpMapTileDataSource.all.add_UriRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UriRequested
   (
      this : in out HttpMapTileDataSource;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IHttpMapTileDataSource.all.remove_UriRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LocalMapTileDataSource

   procedure Initialize (this : in out LocalMapTileDataSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out LocalMapTileDataSource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILocalMapTileDataSource, ILocalMapTileDataSource_Ptr);
   begin
      if this.m_ILocalMapTileDataSource /= null then
         if this.m_ILocalMapTileDataSource.all /= null then
            temp := this.m_ILocalMapTileDataSource.all.Release;
            Free (this.m_ILocalMapTileDataSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LocalMapTileDataSource

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return LocalMapTileDataSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource");
      m_Factory    : access ILocalMapTileDataSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.ILocalMapTileDataSource;
   begin
      return RetVal : LocalMapTileDataSource do
         Hr := RoGetActivationFactory (m_hString, IID_ILocalMapTileDataSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ILocalMapTileDataSource := new Windows.UI.Xaml.Controls.Maps.ILocalMapTileDataSource;
            Retval.m_ILocalMapTileDataSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      uriFormatString : WinRt.WString;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return LocalMapTileDataSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource");
      m_Factory    : access ILocalMapTileDataSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.ILocalMapTileDataSource;
      HStr_uriFormatString : constant WinRt.HString := To_HString (uriFormatString);
   begin
      return RetVal : LocalMapTileDataSource do
         Hr := RoGetActivationFactory (m_hString, IID_ILocalMapTileDataSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithUriFormatString (HStr_uriFormatString, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ILocalMapTileDataSource := new Windows.UI.Xaml.Controls.Maps.ILocalMapTileDataSource;
            Retval.m_ILocalMapTileDataSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_uriFormatString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LocalMapTileDataSource

   function get_UriFormatString
   (
      this : in out LocalMapTileDataSource
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ILocalMapTileDataSource.all.get_UriFormatString (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_UriFormatString
   (
      this : in out LocalMapTileDataSource;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ILocalMapTileDataSource.all.put_UriFormatString (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function add_UriRequested
   (
      this : in out LocalMapTileDataSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILocalMapTileDataSource.all.add_UriRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UriRequested
   (
      this : in out LocalMapTileDataSource;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILocalMapTileDataSource.all.remove_UriRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapActualCameraChangedEventArgs

   procedure Initialize (this : in out MapActualCameraChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapActualCameraChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapActualCameraChangedEventArgs, IMapActualCameraChangedEventArgs_Ptr);
   begin
      if this.m_IMapActualCameraChangedEventArgs /= null then
         if this.m_IMapActualCameraChangedEventArgs.all /= null then
            temp := this.m_IMapActualCameraChangedEventArgs.all.Release;
            Free (this.m_IMapActualCameraChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapActualCameraChangedEventArgs

   function Constructor return MapActualCameraChangedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapActualCameraChangedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangedEventArgs;
   begin
      return RetVal : MapActualCameraChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapActualCameraChangedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangedEventArgs;
            Retval.m_IMapActualCameraChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapActualCameraChangedEventArgs

   function get_Camera
   (
      this : in out MapActualCameraChangedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera do
         Hr := this.m_IMapActualCameraChangedEventArgs.all.get_Camera (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
         Retval.m_IMapCamera.all := m_ComRetVal;
      end return;
   end;

   function get_ChangeReason
   (
      this : in out MapActualCameraChangedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCameraChangeReason is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapCameraChangeReason;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangedEventArgs_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangedEventArgs2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapActualCameraChangedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapActualCameraChangedEventArgs.all);
      Hr := m_Interface.get_ChangeReason (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapActualCameraChangingEventArgs

   procedure Initialize (this : in out MapActualCameraChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapActualCameraChangingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapActualCameraChangingEventArgs, IMapActualCameraChangingEventArgs_Ptr);
   begin
      if this.m_IMapActualCameraChangingEventArgs /= null then
         if this.m_IMapActualCameraChangingEventArgs.all /= null then
            temp := this.m_IMapActualCameraChangingEventArgs.all.Release;
            Free (this.m_IMapActualCameraChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapActualCameraChangingEventArgs

   function Constructor return MapActualCameraChangingEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapActualCameraChangingEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangingEventArgs;
   begin
      return RetVal : MapActualCameraChangingEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapActualCameraChangingEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangingEventArgs;
            Retval.m_IMapActualCameraChangingEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapActualCameraChangingEventArgs

   function get_Camera
   (
      this : in out MapActualCameraChangingEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera do
         Hr := this.m_IMapActualCameraChangingEventArgs.all.get_Camera (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
         Retval.m_IMapCamera.all := m_ComRetVal;
      end return;
   end;

   function get_ChangeReason
   (
      this : in out MapActualCameraChangingEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCameraChangeReason is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangingEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapCameraChangeReason;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangingEventArgs_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapActualCameraChangingEventArgs2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapActualCameraChangingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapActualCameraChangingEventArgs.all);
      Hr := m_Interface.get_ChangeReason (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElement

   procedure Initialize (this : in out MapElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElement) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElement, IMapElement_Ptr);
   begin
      if this.m_IMapElement /= null then
         if this.m_IMapElement.all /= null then
            temp := this.m_IMapElement.all.Release;
            Free (this.m_IMapElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElement

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapElement is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory    : access IMapElementFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElement;
   begin
      return RetVal : MapElement do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapElement := new Windows.UI.Xaml.Controls.Maps.IMapElement;
            Retval.m_IMapElement.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapElement

   function get_MapStyleSheetEntryProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementStatics3_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapStyleSheetEntryProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MapStyleSheetEntryStateProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementStatics3_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapStyleSheetEntryStateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TagProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementStatics3_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TagProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsEnabledProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MapTabIndexProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapTabIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZIndexProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VisibleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElement

   function get_ZIndex
   (
      this : in out MapElement
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapElement.all.get_ZIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out MapElement;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement.all.put_ZIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Visible
   (
      this : in out MapElement
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapElement.all.get_Visible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Visible
   (
      this : in out MapElement;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement.all.put_Visible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MapTabIndex
   (
      this : in out MapElement
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.get_MapTabIndex (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MapTabIndex
   (
      this : in out MapElement;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.put_MapTabIndex (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MapStyleSheetEntry
   (
      this : in out MapElement
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.get_MapStyleSheetEntry (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MapStyleSheetEntry
   (
      this : in out MapElement;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.put_MapStyleSheetEntry (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MapStyleSheetEntryState
   (
      this : in out MapElement
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.get_MapStyleSheetEntryState (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MapStyleSheetEntryState
   (
      this : in out MapElement;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.put_MapStyleSheetEntryState (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Tag
   (
      this : in out MapElement
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.get_Tag (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Tag
   (
      this : in out MapElement;
      value : WinRt.IInspectable
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.put_Tag (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsEnabled
   (
      this : in out MapElement
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement4, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.get_IsEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsEnabled
   (
      this : in out MapElement;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement4 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement4, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapElement4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapElement.all);
      Hr := m_Interface.put_IsEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapBillboard

   procedure Initialize (this : in out MapBillboard) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapBillboard) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapBillboard, IMapBillboard_Ptr);
   begin
      if this.m_IMapBillboard /= null then
         if this.m_IMapBillboard.all /= null then
            temp := this.m_IMapBillboard.all.Release;
            Free (this.m_IMapBillboard);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapBillboard

   function Constructor
   (
      camera : Windows.UI.Xaml.Controls.Maps.MapCamera'Class
   )
   return MapBillboard is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapBillboard");
      m_Factory    : access IMapBillboardFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapBillboard;
   begin
      return RetVal : MapBillboard do
         Hr := RoGetActivationFactory (m_hString, IID_IMapBillboardFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceFromCamera (camera.m_IMapCamera.all, m_ComRetVal'Access);
            Retval.m_IMapBillboard := new Windows.UI.Xaml.Controls.Maps.IMapBillboard;
            Retval.m_IMapBillboard.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapBillboard

   function get_LocationProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapBillboard");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapBillboardStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapBillboardStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NormalizedAnchorPointProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapBillboard");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapBillboardStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapBillboardStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NormalizedAnchorPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CollisionBehaviorDesiredProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapBillboard");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapBillboardStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapBillboardStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CollisionBehaviorDesiredProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapBillboard

   function get_Location
   (
      this : in out MapBillboard
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapBillboard.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   procedure put_Location
   (
      this : in out MapBillboard;
      value : Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapBillboard.all.put_Location (value.m_IGeopoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NormalizedAnchorPoint
   (
      this : in out MapBillboard
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapBillboard.all.get_NormalizedAnchorPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NormalizedAnchorPoint
   (
      this : in out MapBillboard;
      value : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapBillboard.all.put_NormalizedAnchorPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Image
   (
      this : in out MapBillboard
   )
   return WinRt.Windows.Storage.Streams.IRandomAccessStreamReference is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IRandomAccessStreamReference;
   begin
      Hr := this.m_IMapBillboard.all.get_Image (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Image
   (
      this : in out MapBillboard;
      value : Windows.Storage.Streams.IRandomAccessStreamReference
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapBillboard.all.put_Image (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CollisionBehaviorDesired
   (
      this : in out MapBillboard
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapElementCollisionBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapElementCollisionBehavior;
   begin
      Hr := this.m_IMapBillboard.all.get_CollisionBehaviorDesired (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CollisionBehaviorDesired
   (
      this : in out MapBillboard;
      value : Windows.UI.Xaml.Controls.Maps.MapElementCollisionBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapBillboard.all.put_CollisionBehaviorDesired (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReferenceCamera
   (
      this : in out MapBillboard
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera do
         Hr := this.m_IMapBillboard.all.get_ReferenceCamera (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
         Retval.m_IMapCamera.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapCamera

   procedure Initialize (this : in out MapCamera) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapCamera) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapCamera, IMapCamera_Ptr);
   begin
      if this.m_IMapCamera /= null then
         if this.m_IMapCamera.all /= null then
            temp := this.m_IMapCamera.all.Release;
            Free (this.m_IMapCamera);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapCamera

   function Constructor
   (
      location : Windows.Devices.Geolocation.Geopoint'Class
   )
   return MapCamera is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapCamera");
      m_Factory    : access IMapCameraFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : MapCamera do
         Hr := RoGetActivationFactory (m_hString, IID_IMapCameraFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithLocation (location.m_IGeopoint.all, m_ComRetVal'Access);
            Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
            Retval.m_IMapCamera.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      location : Windows.Devices.Geolocation.Geopoint'Class;
      headingInDegrees : WinRt.Double
   )
   return MapCamera is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapCamera");
      m_Factory    : access IMapCameraFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : MapCamera do
         Hr := RoGetActivationFactory (m_hString, IID_IMapCameraFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithLocationAndHeading (location.m_IGeopoint.all, headingInDegrees, m_ComRetVal'Access);
            Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
            Retval.m_IMapCamera.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      location : Windows.Devices.Geolocation.Geopoint'Class;
      headingInDegrees : WinRt.Double;
      pitchInDegrees : WinRt.Double
   )
   return MapCamera is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapCamera");
      m_Factory    : access IMapCameraFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : MapCamera do
         Hr := RoGetActivationFactory (m_hString, IID_IMapCameraFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithLocationHeadingAndPitch (location.m_IGeopoint.all, headingInDegrees, pitchInDegrees, m_ComRetVal'Access);
            Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
            Retval.m_IMapCamera.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      location : Windows.Devices.Geolocation.Geopoint'Class;
      headingInDegrees : WinRt.Double;
      pitchInDegrees : WinRt.Double;
      rollInDegrees : WinRt.Double;
      fieldOfViewInDegrees : WinRt.Double
   )
   return MapCamera is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapCamera");
      m_Factory    : access IMapCameraFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : MapCamera do
         Hr := RoGetActivationFactory (m_hString, IID_IMapCameraFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithLocationHeadingPitchRollAndFieldOfView (location.m_IGeopoint.all, headingInDegrees, pitchInDegrees, rollInDegrees, fieldOfViewInDegrees, m_ComRetVal'Access);
            Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
            Retval.m_IMapCamera.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapCamera

   function get_Location
   (
      this : in out MapCamera
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapCamera.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   procedure put_Location
   (
      this : in out MapCamera;
      value : Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapCamera.all.put_Location (value.m_IGeopoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Heading
   (
      this : in out MapCamera
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapCamera.all.get_Heading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Heading
   (
      this : in out MapCamera;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapCamera.all.put_Heading (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pitch
   (
      this : in out MapCamera
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapCamera.all.get_Pitch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Pitch
   (
      this : in out MapCamera;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapCamera.all.put_Pitch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Roll
   (
      this : in out MapCamera
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapCamera.all.get_Roll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Roll
   (
      this : in out MapCamera;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapCamera.all.put_Roll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FieldOfView
   (
      this : in out MapCamera
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapCamera.all.get_FieldOfView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FieldOfView
   (
      this : in out MapCamera;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapCamera.all.put_FieldOfView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapContextRequestedEventArgs

   procedure Initialize (this : in out MapContextRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapContextRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapContextRequestedEventArgs, IMapContextRequestedEventArgs_Ptr);
   begin
      if this.m_IMapContextRequestedEventArgs /= null then
         if this.m_IMapContextRequestedEventArgs.all /= null then
            temp := this.m_IMapContextRequestedEventArgs.all.Release;
            Free (this.m_IMapContextRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapContextRequestedEventArgs

   function Constructor return MapContextRequestedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapContextRequestedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapContextRequestedEventArgs;
   begin
      return RetVal : MapContextRequestedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapContextRequestedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapContextRequestedEventArgs;
            Retval.m_IMapContextRequestedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapContextRequestedEventArgs

   function get_Position
   (
      this : in out MapContextRequestedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapContextRequestedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapContextRequestedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapContextRequestedEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElements
   (
      this : in out MapContextRequestedEventArgs
   )
   return IVectorView_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapElement.Kind;
   begin
      Hr := this.m_IMapContextRequestedEventArgs.all.get_MapElements (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControl

   procedure Initialize (this : in out MapControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControl) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControl, IMapControl_Ptr);
   begin
      if this.m_IMapControl /= null then
         if this.m_IMapControl.all /= null then
            temp := this.m_IMapControl.all.Release;
            Free (this.m_IMapControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControl

   function Constructor return MapControl is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControl;
   begin
      return RetVal : MapControl do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControl := new Windows.UI.Xaml.Controls.Maps.IMapControl;
            Retval.m_IMapControl.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapControl

   function get_CanTiltDownProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics8_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanTiltDownProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanTiltUpProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics8_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanTiltUpProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanZoomInProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics8_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanZoomInProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanZoomOutProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics8_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanZoomOutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BusinessLandmarksVisibleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BusinessLandmarksVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TransitFeaturesVisibleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TransitFeaturesVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PanInteractionModeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PanInteractionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RotateInteractionModeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RotateInteractionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TiltInteractionModeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TiltInteractionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomInteractionModeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomInteractionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Is3DSupportedProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Is3DSupportedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStreetsideSupportedProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStreetsideSupportedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SceneProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SceneProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BusinessLandmarksEnabledProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BusinessLandmarksEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TransitFeaturesEnabledProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TransitFeaturesEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CenterProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CenterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildrenProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColorSchemeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorSchemeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DesiredPitchProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesiredPitchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeadingProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeadingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LandmarksVisibleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LandmarksVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LoadingStatusProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LoadingStatusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MapServiceTokenProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapServiceTokenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PedestrianFeaturesVisibleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PedestrianFeaturesVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PitchProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PitchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StyleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TrafficFlowVisibleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TrafficFlowVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TransformOriginProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TransformOriginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_WatermarkModeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WatermarkModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomLevelProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomLevelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MapElementsProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapElementsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RoutesProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RoutesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TileSourcesProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TileSourcesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LocationProperty_MapControl
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetLocation
   (
      element : Windows.UI.Xaml.DependencyObject'Class
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetLocation (element.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
            Retval.m_IGeopoint.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetLocation
   (
      element : Windows.UI.Xaml.DependencyObject'Class;
      value : Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetLocation (element.m_IDependencyObject.all, value.m_IGeopoint.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_NormalizedAnchorPointProperty_MapControl
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NormalizedAnchorPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetNormalizedAnchorPoint
   (
      element : Windows.UI.Xaml.DependencyObject'Class
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetNormalizedAnchorPoint (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetNormalizedAnchorPoint
   (
      element : Windows.UI.Xaml.DependencyObject'Class;
      value : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetNormalizedAnchorPoint (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RegionProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics7_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RegionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MapProjectionProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics5_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapProjectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StyleSheetProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics5_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StyleSheetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ViewPaddingProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics5_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ViewPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LayersProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LayersProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControl

   function get_Center
   (
      this : in out MapControl
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapControl.all.get_Center (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   procedure put_Center
   (
      this : in out MapControl;
      value : Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_Center (value.m_IGeopoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Children
   (
      this : in out MapControl
   )
   return IVector_IDependencyObject.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IDependencyObject.Kind;
   begin
      Hr := this.m_IMapControl.all.get_Children (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IDependencyObject (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ColorScheme
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapColorScheme is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapColorScheme;
   begin
      Hr := this.m_IMapControl.all.get_ColorScheme (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorScheme
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapColorScheme
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_ColorScheme (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredPitch
   (
      this : in out MapControl
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapControl.all.get_DesiredPitch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredPitch
   (
      this : in out MapControl;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_DesiredPitch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Heading
   (
      this : in out MapControl
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapControl.all.get_Heading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Heading
   (
      this : in out MapControl;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_Heading (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LandmarksVisible
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapControl.all.get_LandmarksVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LandmarksVisible
   (
      this : in out MapControl;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_LandmarksVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LoadingStatus
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapLoadingStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapLoadingStatus;
   begin
      Hr := this.m_IMapControl.all.get_LoadingStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MapServiceToken
   (
      this : in out MapControl
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapControl.all.get_MapServiceToken (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MapServiceToken
   (
      this : in out MapControl;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IMapControl.all.put_MapServiceToken (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MaxZoomLevel
   (
      this : in out MapControl
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapControl.all.get_MaxZoomLevel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinZoomLevel
   (
      this : in out MapControl
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapControl.all.get_MinZoomLevel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PedestrianFeaturesVisible
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapControl.all.get_PedestrianFeaturesVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PedestrianFeaturesVisible
   (
      this : in out MapControl;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_PedestrianFeaturesVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pitch
   (
      this : in out MapControl
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapControl.all.get_Pitch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Style
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyle is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapStyle;
   begin
      Hr := this.m_IMapControl.all.get_Style (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Style
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapStyle
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_Style (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TrafficFlowVisible
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapControl.all.get_TrafficFlowVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TrafficFlowVisible
   (
      this : in out MapControl;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_TrafficFlowVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransformOrigin
   (
      this : in out MapControl
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapControl.all.get_TransformOrigin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransformOrigin
   (
      this : in out MapControl;
      value : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_TransformOrigin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_WatermarkMode
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapWatermarkMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapWatermarkMode;
   begin
      Hr := this.m_IMapControl.all.get_WatermarkMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_WatermarkMode
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapWatermarkMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_WatermarkMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomLevel
   (
      this : in out MapControl
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapControl.all.get_ZoomLevel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomLevel
   (
      this : in out MapControl;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.put_ZoomLevel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MapElements
   (
      this : in out MapControl
   )
   return IVector_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IMapElement.Kind;
   begin
      Hr := this.m_IMapControl.all.get_MapElements (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Routes
   (
      this : in out MapControl
   )
   return IVector_IMapRouteView.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IMapRouteView.Kind;
   begin
      Hr := this.m_IMapControl.all.get_Routes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapRouteView (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_TileSources
   (
      this : in out MapControl
   )
   return IVector_IMapTileSource.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IMapTileSource.Kind;
   begin
      Hr := this.m_IMapControl.all.get_TileSources (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapTileSource (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_CenterChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_CenterChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CenterChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_CenterChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_HeadingChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_HeadingChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HeadingChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_HeadingChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LoadingStatusChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_LoadingStatusChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LoadingStatusChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_LoadingStatusChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapDoubleTapped
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_MapDoubleTapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapDoubleTapped
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_MapDoubleTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapHolding
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_MapHolding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapHolding
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_MapHolding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapTapped
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_MapTapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapTapped
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_MapTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PitchChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_PitchChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PitchChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_PitchChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TransformOriginChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_TransformOriginChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TransformOriginChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_TransformOriginChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ZoomLevelChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControl.all.add_ZoomLevelChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ZoomLevelChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.remove_ZoomLevelChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function FindMapElementsAtOffset
   (
      this : in out MapControl;
      offset : Windows.Foundation.Point
   )
   return IVectorView_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapElement.Kind;
   begin
      Hr := this.m_IMapControl.all.FindMapElementsAtOffset (offset, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure GetLocationFromOffset
   (
      this : in out MapControl;
      offset : Windows.Foundation.Point;
      location : access Windows.Devices.Geolocation.IGeopoint
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.GetLocationFromOffset (offset, location);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GetOffsetFromLocation
   (
      this : in out MapControl;
      location : Windows.Devices.Geolocation.Geopoint'Class;
      offset : Windows.Foundation.Point_Ptr
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.GetOffsetFromLocation (location.m_IGeopoint.all, offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure IsLocationInView
   (
      this : in out MapControl;
      location : Windows.Devices.Geolocation.Geopoint'Class;
      isInView : WinRt.Boolean_Ptr
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControl.all.IsLocationInView (location.m_IGeopoint.all, isInView);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TrySetViewBoundsAsync
   (
      this : in out MapControl;
      bounds : Windows.Devices.Geolocation.GeoboundingBox'Class;
      margin : GenericObject;
      animation : Windows.UI.Xaml.Controls.Maps.MapAnimationKind
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IMapControl.all.TrySetViewBoundsAsync (bounds.m_IGeoboundingBox.all, margin, animation, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TrySetViewAsync
   (
      this : in out MapControl;
      center : Windows.Devices.Geolocation.Geopoint'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IMapControl.all.TrySetViewAsync (center.m_IGeopoint.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TrySetViewAsync
   (
      this : in out MapControl;
      center : Windows.Devices.Geolocation.Geopoint'Class;
      zoomLevel : GenericObject
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IMapControl.all.TrySetViewAsync (center.m_IGeopoint.all, zoomLevel, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TrySetViewAsync
   (
      this : in out MapControl;
      center : Windows.Devices.Geolocation.Geopoint'Class;
      zoomLevel : GenericObject;
      heading : GenericObject;
      desiredPitch : GenericObject
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IMapControl.all.TrySetViewAsync (center.m_IGeopoint.all, zoomLevel, heading, desiredPitch, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TrySetViewAsync
   (
      this : in out MapControl;
      center : Windows.Devices.Geolocation.Geopoint'Class;
      zoomLevel : GenericObject;
      heading : GenericObject;
      desiredPitch : GenericObject;
      animation : Windows.UI.Xaml.Controls.Maps.MapAnimationKind
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IMapControl.all.TrySetViewAsync (center.m_IGeopoint.all, zoomLevel, heading, desiredPitch, animation, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_BusinessLandmarksVisible
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_BusinessLandmarksVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BusinessLandmarksVisible
   (
      this : in out MapControl;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_BusinessLandmarksVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransitFeaturesVisible
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_TransitFeaturesVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransitFeaturesVisible
   (
      this : in out MapControl;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_TransitFeaturesVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PanInteractionMode
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapPanInteractionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapPanInteractionMode;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_PanInteractionMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PanInteractionMode
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapPanInteractionMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_PanInteractionMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotateInteractionMode
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapInteractionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapInteractionMode;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_RotateInteractionMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotateInteractionMode
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapInteractionMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_RotateInteractionMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TiltInteractionMode
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapInteractionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapInteractionMode;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_TiltInteractionMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TiltInteractionMode
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapInteractionMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_TiltInteractionMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomInteractionMode
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapInteractionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapInteractionMode;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_ZoomInteractionMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomInteractionMode
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapInteractionMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_ZoomInteractionMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Is3DSupported
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_Is3DSupported (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsStreetsideSupported
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_IsStreetsideSupported (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Scene
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         m_Interface := QInterface (this.m_IMapControl.all);
         Hr := m_Interface.get_Scene (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
         Retval.m_IMapScene.all := m_ComRetVal;
      end return;
   end;

   procedure put_Scene
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapScene'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_Scene (value.m_IMapScene.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualCamera
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera do
         m_Interface := QInterface (this.m_IMapControl.all);
         Hr := m_Interface.get_ActualCamera (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
         Retval.m_IMapCamera.all := m_ComRetVal;
      end return;
   end;

   function get_TargetCamera
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera do
         m_Interface := QInterface (this.m_IMapControl.all);
         Hr := m_Interface.get_TargetCamera (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
         Retval.m_IMapCamera.all := m_ComRetVal;
      end return;
   end;

   function get_CustomExperience
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCustomExperience'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCustomExperience;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCustomExperience do
         m_Interface := QInterface (this.m_IMapControl.all);
         Hr := m_Interface.get_CustomExperience (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCustomExperience := new Windows.UI.Xaml.Controls.Maps.IMapCustomExperience;
         Retval.m_IMapCustomExperience.all := m_ComRetVal;
      end return;
   end;

   procedure put_CustomExperience
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapCustomExperience'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_CustomExperience (value.m_IMapCustomExperience.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementClick
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_MapElementClick (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementClick
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_MapElementClick (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementPointerEntered
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_MapElementPointerEntered (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementPointerEntered
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_MapElementPointerEntered (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementPointerExited
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_MapElementPointerExited (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementPointerExited
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_MapElementPointerExited (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ActualCameraChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_ActualCameraChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ActualCameraChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_ActualCameraChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ActualCameraChanging
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_ActualCameraChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ActualCameraChanging
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_ActualCameraChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TargetCameraChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_TargetCameraChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TargetCameraChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_TargetCameraChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CustomExperienceChanged
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_CustomExperienceChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CustomExperienceChanged
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_CustomExperienceChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartContinuousRotate
   (
      this : in out MapControl;
      rateInDegreesPerSecond : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StartContinuousRotate (rateInDegreesPerSecond);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StopContinuousRotate
   (
      this : in out MapControl
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StopContinuousRotate;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartContinuousTilt
   (
      this : in out MapControl;
      rateInDegreesPerSecond : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StartContinuousTilt (rateInDegreesPerSecond);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StopContinuousTilt
   (
      this : in out MapControl
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StopContinuousTilt;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartContinuousZoom
   (
      this : in out MapControl;
      rateOfChangePerSecond : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StartContinuousZoom (rateOfChangePerSecond);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StopContinuousZoom
   (
      this : in out MapControl
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StopContinuousZoom;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryRotateAsync
   (
      this : in out MapControl;
      degrees : WinRt.Double
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryRotateAsync (degrees, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryRotateToAsync
   (
      this : in out MapControl;
      angleInDegrees : WinRt.Double
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryRotateToAsync (angleInDegrees, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryTiltAsync
   (
      this : in out MapControl;
      degrees : WinRt.Double
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryTiltAsync (degrees, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryTiltToAsync
   (
      this : in out MapControl;
      angleInDegrees : WinRt.Double
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryTiltToAsync (angleInDegrees, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryZoomInAsync
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryZoomInAsync (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryZoomOutAsync
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryZoomOutAsync (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryZoomToAsync
   (
      this : in out MapControl;
      zoomLevel : WinRt.Double
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryZoomToAsync (zoomLevel, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TrySetSceneAsync
   (
      this : in out MapControl;
      scene : Windows.UI.Xaml.Controls.Maps.MapScene'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TrySetSceneAsync (scene.m_IMapScene.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TrySetSceneAsync
   (
      this : in out MapControl;
      scene : Windows.UI.Xaml.Controls.Maps.MapScene'Class;
      animationKind : Windows.UI.Xaml.Controls.Maps.MapAnimationKind
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TrySetSceneAsync (scene.m_IMapScene.all, animationKind, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function add_MapRightTapped
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_MapRightTapped (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapRightTapped
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl3, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_MapRightTapped (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BusinessLandmarksEnabled
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_BusinessLandmarksEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BusinessLandmarksEnabled
   (
      this : in out MapControl;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_BusinessLandmarksEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransitFeaturesEnabled
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_TransitFeaturesEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransitFeaturesEnabled
   (
      this : in out MapControl;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_TransitFeaturesEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetVisibleRegion
   (
      this : in out MapControl;
      region : Windows.UI.Xaml.Controls.Maps.MapVisibleRegionKind
   )
   return WinRt.Windows.Devices.Geolocation.Geopath'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopath;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl4, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopath do
         m_Interface := QInterface (this.m_IMapControl.all);
         Hr := m_Interface.GetVisibleRegion (region, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
         Retval.m_IGeopath.all := m_ComRetVal;
      end return;
   end;

   function get_MapProjection
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapProjection is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapProjection;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_MapProjection (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MapProjection
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapProjection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_MapProjection (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StyleSheet
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         m_Interface := QInterface (this.m_IMapControl.all);
         Hr := m_Interface.get_StyleSheet (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
         Retval.m_IMapStyleSheet.all := m_ComRetVal;
      end return;
   end;

   procedure put_StyleSheet
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Controls.Maps.MapStyleSheet'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_StyleSheet (value.m_IMapStyleSheet.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ViewPadding
   (
      this : in out MapControl
   )
   return WinRt.Windows.UI.Xaml.Thickness is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_ViewPadding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ViewPadding
   (
      this : in out MapControl;
      value : Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_ViewPadding (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapContextRequested
   (
      this : in out MapControl;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.add_MapContextRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapContextRequested
   (
      this : in out MapControl;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.remove_MapContextRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function FindMapElementsAtOffset
   (
      this : in out MapControl;
      offset : Windows.Foundation.Point;
      radius : WinRt.Double
   )
   return IVectorView_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapElement.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.FindMapElementsAtOffset (offset, radius, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure GetLocationFromOffset
   (
      this : in out MapControl;
      offset : Windows.Foundation.Point;
      desiredReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem;
      location : access Windows.Devices.Geolocation.IGeopoint
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.GetLocationFromOffset (offset, desiredReferenceSystem, location);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartContinuousPan
   (
      this : in out MapControl;
      horizontalPixelsPerSecond : WinRt.Double;
      verticalPixelsPerSecond : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StartContinuousPan (horizontalPixelsPerSecond, verticalPixelsPerSecond);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StopContinuousPan
   (
      this : in out MapControl
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.StopContinuousPan;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryPanAsync
   (
      this : in out MapControl;
      horizontalPixels : WinRt.Double;
      verticalPixels : WinRt.Double
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryPanAsync (horizontalPixels, verticalPixels, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryPanToAsync
   (
      this : in out MapControl;
      location : Windows.Devices.Geolocation.Geopoint'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl5, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryPanToAsync (location.m_IGeopoint.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_Layers
   (
      this : in out MapControl
   )
   return IVector_IMapLayer.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IMapLayer.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_Layers (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapLayer (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Layers
   (
      this : in out MapControl;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_Layers (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryGetLocationFromOffset
   (
      this : in out MapControl;
      offset : Windows.Foundation.Point;
      location : access Windows.Devices.Geolocation.IGeopoint
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryGetLocationFromOffset (offset, location, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryGetLocationFromOffset
   (
      this : in out MapControl;
      offset : Windows.Foundation.Point;
      desiredReferenceSystem : Windows.Devices.Geolocation.AltitudeReferenceSystem;
      location : access Windows.Devices.Geolocation.IGeopoint
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl6, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.TryGetLocationFromOffset (offset, desiredReferenceSystem, location, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Region
   (
      this : in out MapControl
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl7 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl7, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_Region (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Region
   (
      this : in out MapControl;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl7 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl7, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.put_Region (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_CanTiltDown
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_CanTiltDown (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanTiltUp
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_CanTiltUp (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanZoomIn
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_CanZoomIn (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanZoomOut
   (
      this : in out MapControl
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControl8, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControl8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControl.all);
      Hr := m_Interface.get_CanZoomOut (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlBusinessLandmarkClickEventArgs

   procedure Initialize (this : in out MapControlBusinessLandmarkClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlBusinessLandmarkClickEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlBusinessLandmarkClickEventArgs, IMapControlBusinessLandmarkClickEventArgs_Ptr);
   begin
      if this.m_IMapControlBusinessLandmarkClickEventArgs /= null then
         if this.m_IMapControlBusinessLandmarkClickEventArgs.all /= null then
            temp := this.m_IMapControlBusinessLandmarkClickEventArgs.all.Release;
            Free (this.m_IMapControlBusinessLandmarkClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlBusinessLandmarkClickEventArgs

   function Constructor return MapControlBusinessLandmarkClickEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkClickEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkClickEventArgs;
   begin
      return RetVal : MapControlBusinessLandmarkClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlBusinessLandmarkClickEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkClickEventArgs;
            Retval.m_IMapControlBusinessLandmarkClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlBusinessLandmarkClickEventArgs

   function get_LocalLocations
   (
      this : in out MapControlBusinessLandmarkClickEventArgs
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IMapControlBusinessLandmarkClickEventArgs.all.get_LocalLocations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlBusinessLandmarkPointerEnteredEventArgs

   procedure Initialize (this : in out MapControlBusinessLandmarkPointerEnteredEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlBusinessLandmarkPointerEnteredEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlBusinessLandmarkPointerEnteredEventArgs, IMapControlBusinessLandmarkPointerEnteredEventArgs_Ptr);
   begin
      if this.m_IMapControlBusinessLandmarkPointerEnteredEventArgs /= null then
         if this.m_IMapControlBusinessLandmarkPointerEnteredEventArgs.all /= null then
            temp := this.m_IMapControlBusinessLandmarkPointerEnteredEventArgs.all.Release;
            Free (this.m_IMapControlBusinessLandmarkPointerEnteredEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlBusinessLandmarkPointerEnteredEventArgs

   function Constructor return MapControlBusinessLandmarkPointerEnteredEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkPointerEnteredEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkPointerEnteredEventArgs;
   begin
      return RetVal : MapControlBusinessLandmarkPointerEnteredEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlBusinessLandmarkPointerEnteredEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkPointerEnteredEventArgs;
            Retval.m_IMapControlBusinessLandmarkPointerEnteredEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlBusinessLandmarkPointerEnteredEventArgs

   function get_LocalLocations
   (
      this : in out MapControlBusinessLandmarkPointerEnteredEventArgs
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IMapControlBusinessLandmarkPointerEnteredEventArgs.all.get_LocalLocations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlBusinessLandmarkPointerExitedEventArgs

   procedure Initialize (this : in out MapControlBusinessLandmarkPointerExitedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlBusinessLandmarkPointerExitedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlBusinessLandmarkPointerExitedEventArgs, IMapControlBusinessLandmarkPointerExitedEventArgs_Ptr);
   begin
      if this.m_IMapControlBusinessLandmarkPointerExitedEventArgs /= null then
         if this.m_IMapControlBusinessLandmarkPointerExitedEventArgs.all /= null then
            temp := this.m_IMapControlBusinessLandmarkPointerExitedEventArgs.all.Release;
            Free (this.m_IMapControlBusinessLandmarkPointerExitedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlBusinessLandmarkPointerExitedEventArgs

   function Constructor return MapControlBusinessLandmarkPointerExitedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkPointerExitedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkPointerExitedEventArgs;
   begin
      return RetVal : MapControlBusinessLandmarkPointerExitedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlBusinessLandmarkPointerExitedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkPointerExitedEventArgs;
            Retval.m_IMapControlBusinessLandmarkPointerExitedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlBusinessLandmarkPointerExitedEventArgs

   function get_LocalLocations
   (
      this : in out MapControlBusinessLandmarkPointerExitedEventArgs
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IMapControlBusinessLandmarkPointerExitedEventArgs.all.get_LocalLocations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlBusinessLandmarkRightTappedEventArgs

   procedure Initialize (this : in out MapControlBusinessLandmarkRightTappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlBusinessLandmarkRightTappedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlBusinessLandmarkRightTappedEventArgs, IMapControlBusinessLandmarkRightTappedEventArgs_Ptr);
   begin
      if this.m_IMapControlBusinessLandmarkRightTappedEventArgs /= null then
         if this.m_IMapControlBusinessLandmarkRightTappedEventArgs.all /= null then
            temp := this.m_IMapControlBusinessLandmarkRightTappedEventArgs.all.Release;
            Free (this.m_IMapControlBusinessLandmarkRightTappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlBusinessLandmarkRightTappedEventArgs

   function Constructor return MapControlBusinessLandmarkRightTappedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkRightTappedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkRightTappedEventArgs;
   begin
      return RetVal : MapControlBusinessLandmarkRightTappedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlBusinessLandmarkRightTappedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlBusinessLandmarkRightTappedEventArgs;
            Retval.m_IMapControlBusinessLandmarkRightTappedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlBusinessLandmarkRightTappedEventArgs

   function get_LocalLocations
   (
      this : in out MapControlBusinessLandmarkRightTappedEventArgs
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IMapControlBusinessLandmarkRightTappedEventArgs.all.get_LocalLocations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlDataHelper

   procedure Initialize (this : in out MapControlDataHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlDataHelper) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlDataHelper, IMapControlDataHelper_Ptr);
   begin
      if this.m_IMapControlDataHelper /= null then
         if this.m_IMapControlDataHelper.all /= null then
            temp := this.m_IMapControlDataHelper.all.Release;
            Free (this.m_IMapControlDataHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlDataHelper

   function Constructor
   (
      map : Windows.UI.Xaml.Controls.Maps.MapControl'Class
   )
   return MapControlDataHelper is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlDataHelper");
      m_Factory    : access IMapControlDataHelperFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper;
   begin
      return RetVal : MapControlDataHelper do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlDataHelperFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (map.m_IMapControl.all, m_ComRetVal'Access);
            Retval.m_IMapControlDataHelper := new Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper;
            Retval.m_IMapControlDataHelper.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapControlDataHelper

   function CreateMapControl
   (
      rasterRenderMode : WinRt.Boolean
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapControl is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlDataHelper");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelperStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapControl;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapControl do
         Hr := RoGetActivationFactory (m_hString, IID_IMapControlDataHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateMapControl (rasterRenderMode, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapControl := new Windows.UI.Xaml.Controls.Maps.IMapControl;
            Retval.m_IMapControl.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlDataHelper

   function add_BusinessLandmarkClick
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControlDataHelper.all.add_BusinessLandmarkClick (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BusinessLandmarkClick
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControlDataHelper.all.remove_BusinessLandmarkClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TransitFeatureClick
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControlDataHelper.all.add_TransitFeatureClick (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TransitFeatureClick
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControlDataHelper.all.remove_TransitFeatureClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BusinessLandmarkRightTapped
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControlDataHelper.all.add_BusinessLandmarkRightTapped (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BusinessLandmarkRightTapped
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControlDataHelper.all.remove_BusinessLandmarkRightTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TransitFeatureRightTapped
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapControlDataHelper.all.add_TransitFeatureRightTapped (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TransitFeatureRightTapped
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapControlDataHelper.all.remove_TransitFeatureRightTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BusinessLandmarkPointerEntered
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.add_BusinessLandmarkPointerEntered (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BusinessLandmarkPointerEntered
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.remove_BusinessLandmarkPointerEntered (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TransitFeaturePointerEntered
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.add_TransitFeaturePointerEntered (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TransitFeaturePointerEntered
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.remove_TransitFeaturePointerEntered (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BusinessLandmarkPointerExited
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.add_BusinessLandmarkPointerExited (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BusinessLandmarkPointerExited
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.remove_BusinessLandmarkPointerExited (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TransitFeaturePointerExited
   (
      this : in out MapControlDataHelper;
      value : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.add_TransitFeaturePointerExited (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TransitFeaturePointerExited
   (
      this : in out MapControlDataHelper;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapControlDataHelper2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapControlDataHelper2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapControlDataHelper.all);
      Hr := m_Interface.remove_TransitFeaturePointerExited (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlTransitFeatureClickEventArgs

   procedure Initialize (this : in out MapControlTransitFeatureClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlTransitFeatureClickEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlTransitFeatureClickEventArgs, IMapControlTransitFeatureClickEventArgs_Ptr);
   begin
      if this.m_IMapControlTransitFeatureClickEventArgs /= null then
         if this.m_IMapControlTransitFeatureClickEventArgs.all /= null then
            temp := this.m_IMapControlTransitFeatureClickEventArgs.all.Release;
            Free (this.m_IMapControlTransitFeatureClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlTransitFeatureClickEventArgs

   function Constructor return MapControlTransitFeatureClickEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureClickEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeatureClickEventArgs;
   begin
      return RetVal : MapControlTransitFeatureClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlTransitFeatureClickEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeatureClickEventArgs;
            Retval.m_IMapControlTransitFeatureClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlTransitFeatureClickEventArgs

   function get_DisplayName
   (
      this : in out MapControlTransitFeatureClickEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapControlTransitFeatureClickEventArgs.all.get_DisplayName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Location
   (
      this : in out MapControlTransitFeatureClickEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapControlTransitFeatureClickEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_TransitProperties
   (
      this : in out MapControlTransitFeatureClickEventArgs
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
   begin
      Hr := this.m_IMapControlTransitFeatureClickEventArgs.all.get_TransitProperties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlTransitFeaturePointerEnteredEventArgs

   procedure Initialize (this : in out MapControlTransitFeaturePointerEnteredEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlTransitFeaturePointerEnteredEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlTransitFeaturePointerEnteredEventArgs, IMapControlTransitFeaturePointerEnteredEventArgs_Ptr);
   begin
      if this.m_IMapControlTransitFeaturePointerEnteredEventArgs /= null then
         if this.m_IMapControlTransitFeaturePointerEnteredEventArgs.all /= null then
            temp := this.m_IMapControlTransitFeaturePointerEnteredEventArgs.all.Release;
            Free (this.m_IMapControlTransitFeaturePointerEnteredEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlTransitFeaturePointerEnteredEventArgs

   function Constructor return MapControlTransitFeaturePointerEnteredEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerEnteredEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeaturePointerEnteredEventArgs;
   begin
      return RetVal : MapControlTransitFeaturePointerEnteredEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlTransitFeaturePointerEnteredEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeaturePointerEnteredEventArgs;
            Retval.m_IMapControlTransitFeaturePointerEnteredEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlTransitFeaturePointerEnteredEventArgs

   function get_DisplayName
   (
      this : in out MapControlTransitFeaturePointerEnteredEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapControlTransitFeaturePointerEnteredEventArgs.all.get_DisplayName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Location
   (
      this : in out MapControlTransitFeaturePointerEnteredEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapControlTransitFeaturePointerEnteredEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_TransitProperties
   (
      this : in out MapControlTransitFeaturePointerEnteredEventArgs
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
   begin
      Hr := this.m_IMapControlTransitFeaturePointerEnteredEventArgs.all.get_TransitProperties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlTransitFeaturePointerExitedEventArgs

   procedure Initialize (this : in out MapControlTransitFeaturePointerExitedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlTransitFeaturePointerExitedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlTransitFeaturePointerExitedEventArgs, IMapControlTransitFeaturePointerExitedEventArgs_Ptr);
   begin
      if this.m_IMapControlTransitFeaturePointerExitedEventArgs /= null then
         if this.m_IMapControlTransitFeaturePointerExitedEventArgs.all /= null then
            temp := this.m_IMapControlTransitFeaturePointerExitedEventArgs.all.Release;
            Free (this.m_IMapControlTransitFeaturePointerExitedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlTransitFeaturePointerExitedEventArgs

   function Constructor return MapControlTransitFeaturePointerExitedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerExitedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeaturePointerExitedEventArgs;
   begin
      return RetVal : MapControlTransitFeaturePointerExitedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlTransitFeaturePointerExitedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeaturePointerExitedEventArgs;
            Retval.m_IMapControlTransitFeaturePointerExitedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlTransitFeaturePointerExitedEventArgs

   function get_DisplayName
   (
      this : in out MapControlTransitFeaturePointerExitedEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapControlTransitFeaturePointerExitedEventArgs.all.get_DisplayName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Location
   (
      this : in out MapControlTransitFeaturePointerExitedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapControlTransitFeaturePointerExitedEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_TransitProperties
   (
      this : in out MapControlTransitFeaturePointerExitedEventArgs
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
   begin
      Hr := this.m_IMapControlTransitFeaturePointerExitedEventArgs.all.get_TransitProperties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapControlTransitFeatureRightTappedEventArgs

   procedure Initialize (this : in out MapControlTransitFeatureRightTappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapControlTransitFeatureRightTappedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapControlTransitFeatureRightTappedEventArgs, IMapControlTransitFeatureRightTappedEventArgs_Ptr);
   begin
      if this.m_IMapControlTransitFeatureRightTappedEventArgs /= null then
         if this.m_IMapControlTransitFeatureRightTappedEventArgs.all /= null then
            temp := this.m_IMapControlTransitFeatureRightTappedEventArgs.all.Release;
            Free (this.m_IMapControlTransitFeatureRightTappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapControlTransitFeatureRightTappedEventArgs

   function Constructor return MapControlTransitFeatureRightTappedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureRightTappedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeatureRightTappedEventArgs;
   begin
      return RetVal : MapControlTransitFeatureRightTappedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapControlTransitFeatureRightTappedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapControlTransitFeatureRightTappedEventArgs;
            Retval.m_IMapControlTransitFeatureRightTappedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapControlTransitFeatureRightTappedEventArgs

   function get_DisplayName
   (
      this : in out MapControlTransitFeatureRightTappedEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapControlTransitFeatureRightTappedEventArgs.all.get_DisplayName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Location
   (
      this : in out MapControlTransitFeatureRightTappedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapControlTransitFeatureRightTappedEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_TransitProperties
   (
      this : in out MapControlTransitFeatureRightTappedEventArgs
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
   begin
      Hr := this.m_IMapControlTransitFeatureRightTappedEventArgs.all.get_TransitProperties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapCustomExperience

   procedure Initialize (this : in out MapCustomExperience) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapCustomExperience) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapCustomExperience, IMapCustomExperience_Ptr);
   begin
      if this.m_IMapCustomExperience /= null then
         if this.m_IMapCustomExperience.all /= null then
            temp := this.m_IMapCustomExperience.all.Release;
            Free (this.m_IMapCustomExperience);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapCustomExperience

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapCustomExperience is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapCustomExperience");
      m_Factory    : access IMapCustomExperienceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapCustomExperience;
   begin
      return RetVal : MapCustomExperience do
         Hr := RoGetActivationFactory (m_hString, IID_IMapCustomExperienceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapCustomExperience := new Windows.UI.Xaml.Controls.Maps.IMapCustomExperience;
            Retval.m_IMapCustomExperience.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapCustomExperience

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapCustomExperienceChangedEventArgs

   procedure Initialize (this : in out MapCustomExperienceChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapCustomExperienceChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapCustomExperienceChangedEventArgs, IMapCustomExperienceChangedEventArgs_Ptr);
   begin
      if this.m_IMapCustomExperienceChangedEventArgs /= null then
         if this.m_IMapCustomExperienceChangedEventArgs.all /= null then
            temp := this.m_IMapCustomExperienceChangedEventArgs.all.Release;
            Free (this.m_IMapCustomExperienceChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapCustomExperienceChangedEventArgs

   function Constructor return MapCustomExperienceChangedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapCustomExperienceChangedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapCustomExperienceChangedEventArgs;
   begin
      return RetVal : MapCustomExperienceChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapCustomExperienceChangedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapCustomExperienceChangedEventArgs;
            Retval.m_IMapCustomExperienceChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapCustomExperienceChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElement3D

   procedure Initialize (this : in out MapElement3D) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElement3D) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElement3D, IMapElement3D_Ptr);
   begin
      if this.m_IMapElement3D /= null then
         if this.m_IMapElement3D.all /= null then
            temp := this.m_IMapElement3D.all.Release;
            Free (this.m_IMapElement3D);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElement3D

   function Constructor return MapElement3D is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement3D");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElement3D;
   begin
      return RetVal : MapElement3D do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElement3D := new Windows.UI.Xaml.Controls.Maps.IMapElement3D;
            Retval.m_IMapElement3D.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapElement3D

   function get_LocationProperty_MapElement3D
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement3D");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3DStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElement3DStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeadingProperty_MapElement3D
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement3D");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3DStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElement3DStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeadingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PitchProperty_MapElement3D
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement3D");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3DStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElement3DStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PitchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RollProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement3D");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3DStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElement3DStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RollProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScaleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElement3D");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElement3DStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElement3DStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScaleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElement3D

   function get_Location
   (
      this : in out MapElement3D
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElement3D.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   procedure put_Location
   (
      this : in out MapElement3D;
      value : Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement3D.all.put_Location (value.m_IGeopoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Model
   (
      this : in out MapElement3D
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapModel3D'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapModel3D;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapModel3D do
         Hr := this.m_IMapElement3D.all.get_Model (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapModel3D := new Windows.UI.Xaml.Controls.Maps.IMapModel3D;
         Retval.m_IMapModel3D.all := m_ComRetVal;
      end return;
   end;

   procedure put_Model
   (
      this : in out MapElement3D;
      value : Windows.UI.Xaml.Controls.Maps.MapModel3D'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement3D.all.put_Model (value.m_IMapModel3D.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Heading
   (
      this : in out MapElement3D
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapElement3D.all.get_Heading (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Heading
   (
      this : in out MapElement3D;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement3D.all.put_Heading (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pitch
   (
      this : in out MapElement3D
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapElement3D.all.get_Pitch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Pitch
   (
      this : in out MapElement3D;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement3D.all.put_Pitch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Roll
   (
      this : in out MapElement3D
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapElement3D.all.get_Roll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Roll
   (
      this : in out MapElement3D;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement3D.all.put_Roll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out MapElement3D
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IMapElement3D.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out MapElement3D;
      value : Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElement3D.all.put_Scale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementClickEventArgs

   procedure Initialize (this : in out MapElementClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementClickEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementClickEventArgs, IMapElementClickEventArgs_Ptr);
   begin
      if this.m_IMapElementClickEventArgs /= null then
         if this.m_IMapElementClickEventArgs.all /= null then
            temp := this.m_IMapElementClickEventArgs.all.Release;
            Free (this.m_IMapElementClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementClickEventArgs

   function Constructor return MapElementClickEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementClickEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementClickEventArgs;
   begin
      return RetVal : MapElementClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementClickEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapElementClickEventArgs;
            Retval.m_IMapElementClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementClickEventArgs

   function get_Position
   (
      this : in out MapElementClickEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapElementClickEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapElementClickEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementClickEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElements
   (
      this : in out MapElementClickEventArgs
   )
   return IVector_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IMapElement.Kind;
   begin
      Hr := this.m_IMapElementClickEventArgs.all.get_MapElements (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementPointerEnteredEventArgs

   procedure Initialize (this : in out MapElementPointerEnteredEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementPointerEnteredEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementPointerEnteredEventArgs, IMapElementPointerEnteredEventArgs_Ptr);
   begin
      if this.m_IMapElementPointerEnteredEventArgs /= null then
         if this.m_IMapElementPointerEnteredEventArgs.all /= null then
            temp := this.m_IMapElementPointerEnteredEventArgs.all.Release;
            Free (this.m_IMapElementPointerEnteredEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementPointerEnteredEventArgs

   function Constructor return MapElementPointerEnteredEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementPointerEnteredEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementPointerEnteredEventArgs;
   begin
      return RetVal : MapElementPointerEnteredEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementPointerEnteredEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapElementPointerEnteredEventArgs;
            Retval.m_IMapElementPointerEnteredEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementPointerEnteredEventArgs

   function get_Position
   (
      this : in out MapElementPointerEnteredEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapElementPointerEnteredEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapElementPointerEnteredEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementPointerEnteredEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElement
   (
      this : in out MapElementPointerEnteredEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapElement do
         Hr := this.m_IMapElementPointerEnteredEventArgs.all.get_MapElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapElement := new Windows.UI.Xaml.Controls.Maps.IMapElement;
         Retval.m_IMapElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementPointerExitedEventArgs

   procedure Initialize (this : in out MapElementPointerExitedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementPointerExitedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementPointerExitedEventArgs, IMapElementPointerExitedEventArgs_Ptr);
   begin
      if this.m_IMapElementPointerExitedEventArgs /= null then
         if this.m_IMapElementPointerExitedEventArgs.all /= null then
            temp := this.m_IMapElementPointerExitedEventArgs.all.Release;
            Free (this.m_IMapElementPointerExitedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementPointerExitedEventArgs

   function Constructor return MapElementPointerExitedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementPointerExitedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementPointerExitedEventArgs;
   begin
      return RetVal : MapElementPointerExitedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementPointerExitedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapElementPointerExitedEventArgs;
            Retval.m_IMapElementPointerExitedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementPointerExitedEventArgs

   function get_Position
   (
      this : in out MapElementPointerExitedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapElementPointerExitedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapElementPointerExitedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementPointerExitedEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElement
   (
      this : in out MapElementPointerExitedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapElement do
         Hr := this.m_IMapElementPointerExitedEventArgs.all.get_MapElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapElement := new Windows.UI.Xaml.Controls.Maps.IMapElement;
         Retval.m_IMapElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapLayer

   procedure Initialize (this : in out MapLayer) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapLayer) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapLayer, IMapLayer_Ptr);
   begin
      if this.m_IMapLayer /= null then
         if this.m_IMapLayer.all /= null then
            temp := this.m_IMapLayer.all.Release;
            Free (this.m_IMapLayer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapLayer

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapLayer is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapLayer");
      m_Factory    : access IMapLayerFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapLayer;
   begin
      return RetVal : MapLayer do
         Hr := RoGetActivationFactory (m_hString, IID_IMapLayerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapLayer := new Windows.UI.Xaml.Controls.Maps.IMapLayer;
            Retval.m_IMapLayer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapLayer

   function get_MapTabIndexProperty_MapLayer
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapLayer");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapLayerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapLayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapTabIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VisibleProperty_MapLayer
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapLayer");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapLayerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapLayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZIndexProperty_MapLayer
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapLayer");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapLayerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapLayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapLayer

   function get_MapTabIndex
   (
      this : in out MapLayer
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapLayer.all.get_MapTabIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MapTabIndex
   (
      this : in out MapLayer;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapLayer.all.put_MapTabIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Visible
   (
      this : in out MapLayer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapLayer.all.get_Visible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Visible
   (
      this : in out MapLayer;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapLayer.all.put_Visible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZIndex
   (
      this : in out MapLayer
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapLayer.all.get_ZIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out MapLayer;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapLayer.all.put_ZIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementsLayer

   procedure Initialize (this : in out MapElementsLayer) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementsLayer) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementsLayer, IMapElementsLayer_Ptr);
   begin
      if this.m_IMapElementsLayer /= null then
         if this.m_IMapElementsLayer.all /= null then
            temp := this.m_IMapElementsLayer.all.Release;
            Free (this.m_IMapElementsLayer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementsLayer

   function Constructor return MapElementsLayer is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementsLayer");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementsLayer;
   begin
      return RetVal : MapElementsLayer do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementsLayer := new Windows.UI.Xaml.Controls.Maps.IMapElementsLayer;
            Retval.m_IMapElementsLayer.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapElementsLayer

   function get_MapElementsProperty_MapElementsLayer
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementsLayer");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapElementsLayerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapElementsLayerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MapElementsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementsLayer

   function get_MapElements
   (
      this : in out MapElementsLayer
   )
   return IVector_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IMapElement.Kind;
   begin
      Hr := this.m_IMapElementsLayer.all.get_MapElements (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_MapElements
   (
      this : in out MapElementsLayer;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElementsLayer.all.put_MapElements (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementClick
   (
      this : in out MapElementsLayer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapElementsLayer.all.add_MapElementClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementClick
   (
      this : in out MapElementsLayer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElementsLayer.all.remove_MapElementClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementPointerEntered
   (
      this : in out MapElementsLayer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapElementsLayer.all.add_MapElementPointerEntered (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementPointerEntered
   (
      this : in out MapElementsLayer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElementsLayer.all.remove_MapElementPointerEntered (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapElementPointerExited
   (
      this : in out MapElementsLayer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapElementsLayer.all.add_MapElementPointerExited (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapElementPointerExited
   (
      this : in out MapElementsLayer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElementsLayer.all.remove_MapElementPointerExited (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MapContextRequested
   (
      this : in out MapElementsLayer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapElementsLayer.all.add_MapContextRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MapContextRequested
   (
      this : in out MapElementsLayer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapElementsLayer.all.remove_MapContextRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementsLayerClickEventArgs

   procedure Initialize (this : in out MapElementsLayerClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementsLayerClickEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementsLayerClickEventArgs, IMapElementsLayerClickEventArgs_Ptr);
   begin
      if this.m_IMapElementsLayerClickEventArgs /= null then
         if this.m_IMapElementsLayerClickEventArgs.all /= null then
            temp := this.m_IMapElementsLayerClickEventArgs.all.Release;
            Free (this.m_IMapElementsLayerClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementsLayerClickEventArgs

   function Constructor return MapElementsLayerClickEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementsLayerClickEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementsLayerClickEventArgs;
   begin
      return RetVal : MapElementsLayerClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementsLayerClickEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapElementsLayerClickEventArgs;
            Retval.m_IMapElementsLayerClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementsLayerClickEventArgs

   function get_Position
   (
      this : in out MapElementsLayerClickEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapElementsLayerClickEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapElementsLayerClickEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementsLayerClickEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElements
   (
      this : in out MapElementsLayerClickEventArgs
   )
   return IVector_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IMapElement.Kind;
   begin
      Hr := this.m_IMapElementsLayerClickEventArgs.all.get_MapElements (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementsLayerContextRequestedEventArgs

   procedure Initialize (this : in out MapElementsLayerContextRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementsLayerContextRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementsLayerContextRequestedEventArgs, IMapElementsLayerContextRequestedEventArgs_Ptr);
   begin
      if this.m_IMapElementsLayerContextRequestedEventArgs /= null then
         if this.m_IMapElementsLayerContextRequestedEventArgs.all /= null then
            temp := this.m_IMapElementsLayerContextRequestedEventArgs.all.Release;
            Free (this.m_IMapElementsLayerContextRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementsLayerContextRequestedEventArgs

   function Constructor return MapElementsLayerContextRequestedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementsLayerContextRequestedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementsLayerContextRequestedEventArgs;
   begin
      return RetVal : MapElementsLayerContextRequestedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementsLayerContextRequestedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapElementsLayerContextRequestedEventArgs;
            Retval.m_IMapElementsLayerContextRequestedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementsLayerContextRequestedEventArgs

   function get_Position
   (
      this : in out MapElementsLayerContextRequestedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapElementsLayerContextRequestedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapElementsLayerContextRequestedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementsLayerContextRequestedEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElements
   (
      this : in out MapElementsLayerContextRequestedEventArgs
   )
   return IVectorView_IMapElement.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IMapElement.Kind;
   begin
      Hr := this.m_IMapElementsLayerContextRequestedEventArgs.all.get_MapElements (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IMapElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementsLayerPointerEnteredEventArgs

   procedure Initialize (this : in out MapElementsLayerPointerEnteredEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementsLayerPointerEnteredEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementsLayerPointerEnteredEventArgs, IMapElementsLayerPointerEnteredEventArgs_Ptr);
   begin
      if this.m_IMapElementsLayerPointerEnteredEventArgs /= null then
         if this.m_IMapElementsLayerPointerEnteredEventArgs.all /= null then
            temp := this.m_IMapElementsLayerPointerEnteredEventArgs.all.Release;
            Free (this.m_IMapElementsLayerPointerEnteredEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementsLayerPointerEnteredEventArgs

   function Constructor return MapElementsLayerPointerEnteredEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerEnteredEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementsLayerPointerEnteredEventArgs;
   begin
      return RetVal : MapElementsLayerPointerEnteredEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementsLayerPointerEnteredEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapElementsLayerPointerEnteredEventArgs;
            Retval.m_IMapElementsLayerPointerEnteredEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementsLayerPointerEnteredEventArgs

   function get_Position
   (
      this : in out MapElementsLayerPointerEnteredEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapElementsLayerPointerEnteredEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapElementsLayerPointerEnteredEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementsLayerPointerEnteredEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElement
   (
      this : in out MapElementsLayerPointerEnteredEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapElement do
         Hr := this.m_IMapElementsLayerPointerEnteredEventArgs.all.get_MapElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapElement := new Windows.UI.Xaml.Controls.Maps.IMapElement;
         Retval.m_IMapElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapElementsLayerPointerExitedEventArgs

   procedure Initialize (this : in out MapElementsLayerPointerExitedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapElementsLayerPointerExitedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapElementsLayerPointerExitedEventArgs, IMapElementsLayerPointerExitedEventArgs_Ptr);
   begin
      if this.m_IMapElementsLayerPointerExitedEventArgs /= null then
         if this.m_IMapElementsLayerPointerExitedEventArgs.all /= null then
            temp := this.m_IMapElementsLayerPointerExitedEventArgs.all.Release;
            Free (this.m_IMapElementsLayerPointerExitedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapElementsLayerPointerExitedEventArgs

   function Constructor return MapElementsLayerPointerExitedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerExitedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapElementsLayerPointerExitedEventArgs;
   begin
      return RetVal : MapElementsLayerPointerExitedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapElementsLayerPointerExitedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapElementsLayerPointerExitedEventArgs;
            Retval.m_IMapElementsLayerPointerExitedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapElementsLayerPointerExitedEventArgs

   function get_Position
   (
      this : in out MapElementsLayerPointerExitedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapElementsLayerPointerExitedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapElementsLayerPointerExitedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapElementsLayerPointerExitedEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   function get_MapElement
   (
      this : in out MapElementsLayerPointerExitedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapElement do
         Hr := this.m_IMapElementsLayerPointerExitedEventArgs.all.get_MapElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapElement := new Windows.UI.Xaml.Controls.Maps.IMapElement;
         Retval.m_IMapElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapIcon

   procedure Initialize (this : in out MapIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapIcon) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapIcon, IMapIcon_Ptr);
   begin
      if this.m_IMapIcon /= null then
         if this.m_IMapIcon.all /= null then
            temp := this.m_IMapIcon.all.Release;
            Free (this.m_IMapIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapIcon

   function Constructor return MapIcon is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapIcon");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapIcon;
   begin
      return RetVal : MapIcon do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapIcon := new Windows.UI.Xaml.Controls.Maps.IMapIcon;
            Retval.m_IMapIcon.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapIcon

   function get_LocationProperty_MapIcon
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapIcon");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapIconStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LocationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TitleProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapIcon");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapIconStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NormalizedAnchorPointProperty_MapIcon
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapIcon");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapIconStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NormalizedAnchorPointProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CollisionBehaviorDesiredProperty_MapIcon
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapIcon");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapIconStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapIconStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CollisionBehaviorDesiredProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapIcon

   function get_Location
   (
      this : in out MapIcon
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapIcon.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   procedure put_Location
   (
      this : in out MapIcon;
      value : Windows.Devices.Geolocation.Geopoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapIcon.all.put_Location (value.m_IGeopoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Title
   (
      this : in out MapIcon
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMapIcon.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out MapIcon;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IMapIcon.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_NormalizedAnchorPoint
   (
      this : in out MapIcon
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapIcon.all.get_NormalizedAnchorPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NormalizedAnchorPoint
   (
      this : in out MapIcon;
      value : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapIcon.all.put_NormalizedAnchorPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Image
   (
      this : in out MapIcon
   )
   return WinRt.Windows.Storage.Streams.IRandomAccessStreamReference is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IRandomAccessStreamReference;
   begin
      Hr := this.m_IMapIcon.all.get_Image (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Image
   (
      this : in out MapIcon;
      value : Windows.Storage.Streams.IRandomAccessStreamReference
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapIcon.all.put_Image (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CollisionBehaviorDesired
   (
      this : in out MapIcon
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapElementCollisionBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapIcon2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapElementCollisionBehavior;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapIcon_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapIcon2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapIcon2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapIcon.all);
      Hr := m_Interface.get_CollisionBehaviorDesired (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CollisionBehaviorDesired
   (
      this : in out MapIcon;
      value : Windows.UI.Xaml.Controls.Maps.MapElementCollisionBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapIcon2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapIcon_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapIcon2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapIcon2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapIcon.all);
      Hr := m_Interface.put_CollisionBehaviorDesired (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapInputEventArgs

   procedure Initialize (this : in out MapInputEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapInputEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapInputEventArgs, IMapInputEventArgs_Ptr);
   begin
      if this.m_IMapInputEventArgs /= null then
         if this.m_IMapInputEventArgs.all /= null then
            temp := this.m_IMapInputEventArgs.all.Release;
            Free (this.m_IMapInputEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapInputEventArgs

   function Constructor return MapInputEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapInputEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapInputEventArgs;
   begin
      return RetVal : MapInputEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapInputEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapInputEventArgs;
            Retval.m_IMapInputEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapInputEventArgs

   function get_Position
   (
      this : in out MapInputEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapInputEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapInputEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapInputEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapItemsControl

   procedure Initialize (this : in out MapItemsControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapItemsControl) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapItemsControl, IMapItemsControl_Ptr);
   begin
      if this.m_IMapItemsControl /= null then
         if this.m_IMapItemsControl.all /= null then
            temp := this.m_IMapItemsControl.all.Release;
            Free (this.m_IMapItemsControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapItemsControl

   function Constructor return MapItemsControl is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapItemsControl");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapItemsControl;
   begin
      return RetVal : MapItemsControl do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapItemsControl := new Windows.UI.Xaml.Controls.Maps.IMapItemsControl;
            Retval.m_IMapItemsControl.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapItemsControl

   function get_ItemsSourceProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapItemsControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapItemsControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapItemsControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapItemsControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapItemsControl");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapItemsControlStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapItemsControl

   function get_ItemsSource
   (
      this : in out MapItemsControl
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := this.m_IMapItemsControl.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out MapItemsControl;
      value : WinRt.IInspectable
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapItemsControl.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Items
   (
      this : in out MapItemsControl
   )
   return IVector_IDependencyObject.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IDependencyObject.Kind;
   begin
      Hr := this.m_IMapItemsControl.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IDependencyObject (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ItemTemplate
   (
      this : in out MapItemsControl
   )
   return WinRt.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IMapItemsControl.all.get_ItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out MapItemsControl;
      value : Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapItemsControl.all.put_ItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapModel3D

   procedure Initialize (this : in out MapModel3D) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapModel3D) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapModel3D, IMapModel3D_Ptr);
   begin
      if this.m_IMapModel3D /= null then
         if this.m_IMapModel3D.all /= null then
            temp := this.m_IMapModel3D.all.Release;
            Free (this.m_IMapModel3D);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapModel3D

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapModel3D is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapModel3D");
      m_Factory    : access IMapModel3DFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapModel3D;
   begin
      return RetVal : MapModel3D do
         Hr := RoGetActivationFactory (m_hString, IID_IMapModel3DFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapModel3D := new Windows.UI.Xaml.Controls.Maps.IMapModel3D;
            Retval.m_IMapModel3D.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapModel3D

   function CreateFrom3MFAsync
   (
      source : Windows.Storage.Streams.IRandomAccessStreamReference
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapModel3D is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapModel3D");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapModel3DStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_MapModel3D.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_MapModel3D.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Xaml.Controls.Maps.IMapModel3D;
      m_IID            : aliased WinRt.IID := (217064463, 32632, 21339, (133, 12, 254, 98, 49, 117, 144, 100 )); -- Windows.UI.Xaml.Controls.Maps.MapModel3D;
      m_HandlerIID     : aliased WinRt.IID := (1626282315, 56288, 22801, (183, 37, 236, 197, 222, 41, 135, 130 ));
      m_Handler        : AsyncOperationCompletedHandler_MapModel3D.Kind := new AsyncOperationCompletedHandler_MapModel3D.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapModel3D.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapModel3D.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapModel3D.Kind_Delegate, AsyncOperationCompletedHandler_MapModel3D.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapModel3D do
         Hr := RoGetActivationFactory (m_hString, IID_IMapModel3DStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFrom3MFAsync (source, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IMapModel3D := new Windows.UI.Xaml.Controls.Maps.IMapModel3D;
                     Retval.m_IMapModel3D.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFrom3MFAsync
   (
      source : Windows.Storage.Streams.IRandomAccessStreamReference;
      shadingOption : Windows.UI.Xaml.Controls.Maps.MapModel3DShadingOption
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapModel3D is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapModel3D");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapModel3DStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_MapModel3D.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_MapModel3D.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Xaml.Controls.Maps.IMapModel3D;
      m_IID            : aliased WinRt.IID := (217064463, 32632, 21339, (133, 12, 254, 98, 49, 117, 144, 100 )); -- Windows.UI.Xaml.Controls.Maps.MapModel3D;
      m_HandlerIID     : aliased WinRt.IID := (1626282315, 56288, 22801, (183, 37, 236, 197, 222, 41, 135, 130 ));
      m_Handler        : AsyncOperationCompletedHandler_MapModel3D.Kind := new AsyncOperationCompletedHandler_MapModel3D.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_MapModel3D.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_MapModel3D.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_MapModel3D.Kind_Delegate, AsyncOperationCompletedHandler_MapModel3D.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapModel3D do
         Hr := RoGetActivationFactory (m_hString, IID_IMapModel3DStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFrom3MFAsync (source, shadingOption, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IMapModel3D := new Windows.UI.Xaml.Controls.Maps.IMapModel3D;
                     Retval.m_IMapModel3D.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapModel3D

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapPolygon

   procedure Initialize (this : in out MapPolygon) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapPolygon) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapPolygon, IMapPolygon_Ptr);
   begin
      if this.m_IMapPolygon /= null then
         if this.m_IMapPolygon.all /= null then
            temp := this.m_IMapPolygon.all.Release;
            Free (this.m_IMapPolygon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapPolygon

   function Constructor return MapPolygon is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapPolygon");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapPolygon;
   begin
      return RetVal : MapPolygon do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapPolygon := new Windows.UI.Xaml.Controls.Maps.IMapPolygon;
            Retval.m_IMapPolygon.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapPolygon

   function get_PathProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapPolygon");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolygonStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapPolygonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StrokeThicknessProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapPolygon");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolygonStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapPolygonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StrokeThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StrokeDashedProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapPolygon");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolygonStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapPolygonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StrokeDashedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapPolygon

   function get_Path
   (
      this : in out MapPolygon
   )
   return WinRt.Windows.Devices.Geolocation.Geopath'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopath do
         Hr := this.m_IMapPolygon.all.get_Path (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
         Retval.m_IGeopath.all := m_ComRetVal;
      end return;
   end;

   procedure put_Path
   (
      this : in out MapPolygon;
      value : Windows.Devices.Geolocation.Geopath'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolygon.all.put_Path (value.m_IGeopath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeColor
   (
      this : in out MapPolygon
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IMapPolygon.all.get_StrokeColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeColor
   (
      this : in out MapPolygon;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolygon.all.put_StrokeColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeThickness
   (
      this : in out MapPolygon
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapPolygon.all.get_StrokeThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeThickness
   (
      this : in out MapPolygon;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolygon.all.put_StrokeThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeDashed
   (
      this : in out MapPolygon
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapPolygon.all.get_StrokeDashed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeDashed
   (
      this : in out MapPolygon;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolygon.all.put_StrokeDashed (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FillColor
   (
      this : in out MapPolygon
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IMapPolygon.all.get_FillColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FillColor
   (
      this : in out MapPolygon;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolygon.all.put_FillColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Paths
   (
      this : in out MapPolygon
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolygon2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolygon_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolygon2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapPolygon2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapPolygon.all);
      Hr := m_Interface.get_Paths (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapPolyline

   procedure Initialize (this : in out MapPolyline) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapPolyline) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapPolyline, IMapPolyline_Ptr);
   begin
      if this.m_IMapPolyline /= null then
         if this.m_IMapPolyline.all /= null then
            temp := this.m_IMapPolyline.all.Release;
            Free (this.m_IMapPolyline);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapPolyline

   function Constructor return MapPolyline is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapPolyline");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapPolyline;
   begin
      return RetVal : MapPolyline do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapPolyline := new Windows.UI.Xaml.Controls.Maps.IMapPolyline;
            Retval.m_IMapPolyline.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapPolyline

   function get_PathProperty_MapPolyline
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapPolyline");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolylineStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapPolylineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StrokeDashedProperty_MapPolyline
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapPolyline");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapPolylineStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapPolylineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StrokeDashedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapPolyline

   function get_Path
   (
      this : in out MapPolyline
   )
   return WinRt.Windows.Devices.Geolocation.Geopath'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopath;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopath do
         Hr := this.m_IMapPolyline.all.get_Path (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopath := new Windows.Devices.Geolocation.IGeopath;
         Retval.m_IGeopath.all := m_ComRetVal;
      end return;
   end;

   procedure put_Path
   (
      this : in out MapPolyline;
      value : Windows.Devices.Geolocation.Geopath'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolyline.all.put_Path (value.m_IGeopath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeColor
   (
      this : in out MapPolyline
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IMapPolyline.all.get_StrokeColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeColor
   (
      this : in out MapPolyline;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolyline.all.put_StrokeColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeThickness
   (
      this : in out MapPolyline
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IMapPolyline.all.get_StrokeThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeThickness
   (
      this : in out MapPolyline;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolyline.all.put_StrokeThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeDashed
   (
      this : in out MapPolyline
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapPolyline.all.get_StrokeDashed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeDashed
   (
      this : in out MapPolyline;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapPolyline.all.put_StrokeDashed (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapRightTappedEventArgs

   procedure Initialize (this : in out MapRightTappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapRightTappedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapRightTappedEventArgs, IMapRightTappedEventArgs_Ptr);
   begin
      if this.m_IMapRightTappedEventArgs /= null then
         if this.m_IMapRightTappedEventArgs.all /= null then
            temp := this.m_IMapRightTappedEventArgs.all.Release;
            Free (this.m_IMapRightTappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapRightTappedEventArgs

   function Constructor return MapRightTappedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapRightTappedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapRightTappedEventArgs;
   begin
      return RetVal : MapRightTappedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapRightTappedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapRightTappedEventArgs;
            Retval.m_IMapRightTappedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapRightTappedEventArgs

   function get_Position
   (
      this : in out MapRightTappedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMapRightTappedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Location
   (
      this : in out MapRightTappedEventArgs
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IMapRightTappedEventArgs.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapRouteView

   procedure Initialize (this : in out MapRouteView) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapRouteView) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapRouteView, IMapRouteView_Ptr);
   begin
      if this.m_IMapRouteView /= null then
         if this.m_IMapRouteView.all /= null then
            temp := this.m_IMapRouteView.all.Release;
            Free (this.m_IMapRouteView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapRouteView

   function Constructor
   (
      route : Windows.Services.Maps.MapRoute'Class;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapRouteView is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapRouteView");
      m_Factory    : access IMapRouteViewFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapRouteView;
   begin
      return RetVal : MapRouteView do
         Hr := RoGetActivationFactory (m_hString, IID_IMapRouteViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithMapRoute (route.m_IMapRoute.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapRouteView := new Windows.UI.Xaml.Controls.Maps.IMapRouteView;
            Retval.m_IMapRouteView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapRouteView

   function get_RouteColor
   (
      this : in out MapRouteView
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IMapRouteView.all.get_RouteColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RouteColor
   (
      this : in out MapRouteView;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapRouteView.all.put_RouteColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutlineColor
   (
      this : in out MapRouteView
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_IMapRouteView.all.get_OutlineColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OutlineColor
   (
      this : in out MapRouteView;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapRouteView.all.put_OutlineColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Route
   (
      this : in out MapRouteView
   )
   return WinRt.Windows.Services.Maps.MapRoute'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Services.Maps.IMapRoute;
   begin
      return RetVal : WinRt.Windows.Services.Maps.MapRoute do
         Hr := this.m_IMapRouteView.all.get_Route (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapRoute := new Windows.Services.Maps.IMapRoute;
         Retval.m_IMapRoute.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapScene

   procedure Initialize (this : in out MapScene) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapScene) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapScene, IMapScene_Ptr);
   begin
      if this.m_IMapScene /= null then
         if this.m_IMapScene.all /= null then
            temp := this.m_IMapScene.all.Release;
            Free (this.m_IMapScene);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapScene

   function CreateFromBoundingBox
   (
      bounds : Windows.Devices.Geolocation.GeoboundingBox'Class
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromBoundingBox (bounds.m_IGeoboundingBox.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromBoundingBox
   (
      bounds : Windows.Devices.Geolocation.GeoboundingBox'Class;
      headingInDegrees : WinRt.Double;
      pitchInDegrees : WinRt.Double
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromBoundingBox (bounds.m_IGeoboundingBox.all, headingInDegrees, pitchInDegrees, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromCamera
   (
      camera : Windows.UI.Xaml.Controls.Maps.MapCamera'Class
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromCamera (camera.m_IMapCamera.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromLocation
   (
      location : Windows.Devices.Geolocation.Geopoint'Class
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromLocation (location.m_IGeopoint.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromLocation
   (
      location : Windows.Devices.Geolocation.Geopoint'Class;
      headingInDegrees : WinRt.Double;
      pitchInDegrees : WinRt.Double
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromLocation (location.m_IGeopoint.all, headingInDegrees, pitchInDegrees, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromLocationAndRadius
   (
      location : Windows.Devices.Geolocation.Geopoint'Class;
      radiusInMeters : WinRt.Double
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromLocationAndRadius (location.m_IGeopoint.all, radiusInMeters, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromLocationAndRadius
   (
      location : Windows.Devices.Geolocation.Geopoint'Class;
      radiusInMeters : WinRt.Double;
      headingInDegrees : WinRt.Double;
      pitchInDegrees : WinRt.Double
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromLocationAndRadius (location.m_IGeopoint.all, radiusInMeters, headingInDegrees, pitchInDegrees, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromLocations
   (
      locations : GenericObject
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromLocations (locations, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateFromLocations
   (
      locations : GenericObject;
      headingInDegrees : WinRt.Double;
      pitchInDegrees : WinRt.Double
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapScene is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapScene");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapSceneStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapScene;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapScene do
         Hr := RoGetActivationFactory (m_hString, IID_IMapSceneStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromLocations (locations, headingInDegrees, pitchInDegrees, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapScene := new Windows.UI.Xaml.Controls.Maps.IMapScene;
            Retval.m_IMapScene.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapScene

   function get_TargetCamera
   (
      this : in out MapScene
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera do
         Hr := this.m_IMapScene.all.get_TargetCamera (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
         Retval.m_IMapCamera.all := m_ComRetVal;
      end return;
   end;

   function add_TargetCameraChanged
   (
      this : in out MapScene;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMapScene.all.add_TargetCameraChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TargetCameraChanged
   (
      this : in out MapScene;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapScene.all.remove_TargetCameraChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapStyleSheet

   procedure Initialize (this : in out MapStyleSheet) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapStyleSheet) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapStyleSheet, IMapStyleSheet_Ptr);
   begin
      if this.m_IMapStyleSheet /= null then
         if this.m_IMapStyleSheet.all /= null then
            temp := this.m_IMapStyleSheet.all.Release;
            Free (this.m_IMapStyleSheet);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapStyleSheet

   function Aerial
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Aerial (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function AerialWithOverlay
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.AerialWithOverlay (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function RoadLight
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.RoadLight (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function RoadDark
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.RoadDark (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function RoadHighContrastLight
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.RoadHighContrastLight (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function RoadHighContrastDark
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.RoadHighContrastDark (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Combine
   (
      styleSheets : GenericObject
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Combine (styleSheets, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function ParseFromJson
   (
      styleAsJson : WinRt.WString
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
      HStr_styleAsJson : constant WinRt.HString := To_HString (styleAsJson);
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapStyleSheet do
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ParseFromJson (HStr_styleAsJson, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IMapStyleSheet := new Windows.UI.Xaml.Controls.Maps.IMapStyleSheet;
            Retval.m_IMapStyleSheet.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_styleAsJson);
      end return;
   end;

   function TryParseFromJson
   (
      styleAsJson : WinRt.WString;
      styleSheet : access Windows.UI.Xaml.Controls.Maps.IMapStyleSheet
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheet");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      HStr_styleAsJson : constant WinRt.HString := To_HString (styleAsJson);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.TryParseFromJson (HStr_styleAsJson, styleSheet, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_styleAsJson);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapStyleSheet

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body MapStyleSheetEntries is

      function get_Area
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Area (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Airport
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Airport (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Cemetery
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Cemetery (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Continent
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Continent (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Education
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Education (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_IndigenousPeoplesReserve
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IndigenousPeoplesReserve (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Island
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Island (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Medical
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Medical (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Military
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Military (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Nautical
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Nautical (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Neighborhood
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Neighborhood (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Runway
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Runway (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sand
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sand (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_ShoppingCenter
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShoppingCenter (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Stadium
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Stadium (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Vegetation
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Vegetation (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Forest
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Forest (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_GolfCourse
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GolfCourse (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Park
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Park (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_PlayingField
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlayingField (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Reserve
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Reserve (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Point
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Point (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NaturalPoint
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NaturalPoint (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Peak
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Peak (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_VolcanicPeak
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VolcanicPeak (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_WaterPoint
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WaterPoint (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_PointOfInterest
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointOfInterest (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Business
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Business (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_FoodPoint
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FoodPoint (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_PopulatedPlace
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PopulatedPlace (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Capital
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Capital (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AdminDistrictCapital
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AdminDistrictCapital (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_CountryRegionCapital
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CountryRegionCapital (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RoadShield
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RoadShield (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RoadExit
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RoadExit (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Transit
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Transit (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Political
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Political (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_CountryRegion
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CountryRegion (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AdminDistrict
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AdminDistrict (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_District
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_District (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Structure
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Structure (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Building
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Building (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_EducationBuilding
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EducationBuilding (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_MedicalBuilding
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MedicalBuilding (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_TransitBuilding
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TransitBuilding (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Transportation
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Transportation (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Road
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Road (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_ControlledAccessHighway
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ControlledAccessHighway (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_HighSpeedRamp
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HighSpeedRamp (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Highway
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Highway (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_MajorRoad
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MajorRoad (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_ArterialRoad
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ArterialRoad (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Street
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Street (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ramp
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ramp (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_UnpavedStreet
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UnpavedStreet (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_TollRoad
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TollRoad (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Railway
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Railway (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Trail
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Trail (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_WaterRoute
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WaterRoute (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Water
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Water (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_River
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_River (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RouteLine
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RouteLine (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_WalkingRoute
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WalkingRoute (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_DrivingRoute
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntriesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntriesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DrivingRoute (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end MapStyleSheetEntries;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body MapStyleSheetEntryStates is

      function get_Disabled
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntryStatesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntryStatesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Disabled (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Hover
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntryStatesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntryStatesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Hover (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Selected
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates");
         m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapStyleSheetEntryStatesStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMapStyleSheetEntryStatesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Selected (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         tmp := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end MapStyleSheetEntryStates;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTargetCameraChangedEventArgs

   procedure Initialize (this : in out MapTargetCameraChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTargetCameraChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTargetCameraChangedEventArgs, IMapTargetCameraChangedEventArgs_Ptr);
   begin
      if this.m_IMapTargetCameraChangedEventArgs /= null then
         if this.m_IMapTargetCameraChangedEventArgs.all /= null then
            temp := this.m_IMapTargetCameraChangedEventArgs.all.Release;
            Free (this.m_IMapTargetCameraChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTargetCameraChangedEventArgs

   function Constructor return MapTargetCameraChangedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTargetCameraChangedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTargetCameraChangedEventArgs;
   begin
      return RetVal : MapTargetCameraChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapTargetCameraChangedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapTargetCameraChangedEventArgs;
            Retval.m_IMapTargetCameraChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTargetCameraChangedEventArgs

   function get_Camera
   (
      this : in out MapTargetCameraChangedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapCamera;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapCamera do
         Hr := this.m_IMapTargetCameraChangedEventArgs.all.get_Camera (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapCamera := new Windows.UI.Xaml.Controls.Maps.IMapCamera;
         Retval.m_IMapCamera.all := m_ComRetVal;
      end return;
   end;

   function get_ChangeReason
   (
      this : in out MapTargetCameraChangedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapCameraChangeReason is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTargetCameraChangedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapCameraChangeReason;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTargetCameraChangedEventArgs_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTargetCameraChangedEventArgs2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTargetCameraChangedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTargetCameraChangedEventArgs.all);
      Hr := m_Interface.get_ChangeReason (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileBitmapRequest

   procedure Initialize (this : in out MapTileBitmapRequest) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileBitmapRequest) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileBitmapRequest, IMapTileBitmapRequest_Ptr);
   begin
      if this.m_IMapTileBitmapRequest /= null then
         if this.m_IMapTileBitmapRequest.all /= null then
            temp := this.m_IMapTileBitmapRequest.all.Release;
            Free (this.m_IMapTileBitmapRequest);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileBitmapRequest

   function Constructor return MapTileBitmapRequest is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequest;
   begin
      return RetVal : MapTileBitmapRequest do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapTileBitmapRequest := new Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequest;
            Retval.m_IMapTileBitmapRequest.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileBitmapRequest

   function get_PixelData
   (
      this : in out MapTileBitmapRequest
   )
   return WinRt.Windows.Storage.Streams.IRandomAccessStreamReference is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IRandomAccessStreamReference;
   begin
      Hr := this.m_IMapTileBitmapRequest.all.get_PixelData (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PixelData
   (
      this : in out MapTileBitmapRequest;
      value : Windows.Storage.Streams.IRandomAccessStreamReference
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileBitmapRequest.all.put_PixelData (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out MapTileBitmapRequest
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestDeferral'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestDeferral;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestDeferral do
         Hr := this.m_IMapTileBitmapRequest.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapTileBitmapRequestDeferral := new Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestDeferral;
         Retval.m_IMapTileBitmapRequestDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileBitmapRequestDeferral

   procedure Initialize (this : in out MapTileBitmapRequestDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileBitmapRequestDeferral) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileBitmapRequestDeferral, IMapTileBitmapRequestDeferral_Ptr);
   begin
      if this.m_IMapTileBitmapRequestDeferral /= null then
         if this.m_IMapTileBitmapRequestDeferral.all /= null then
            temp := this.m_IMapTileBitmapRequestDeferral.all.Release;
            Free (this.m_IMapTileBitmapRequestDeferral);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileBitmapRequestDeferral

   function Constructor return MapTileBitmapRequestDeferral is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestDeferral");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestDeferral;
   begin
      return RetVal : MapTileBitmapRequestDeferral do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapTileBitmapRequestDeferral := new Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestDeferral;
            Retval.m_IMapTileBitmapRequestDeferral.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileBitmapRequestDeferral

   procedure Complete
   (
      this : in out MapTileBitmapRequestDeferral
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileBitmapRequestDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileBitmapRequestedEventArgs

   procedure Initialize (this : in out MapTileBitmapRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileBitmapRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileBitmapRequestedEventArgs, IMapTileBitmapRequestedEventArgs_Ptr);
   begin
      if this.m_IMapTileBitmapRequestedEventArgs /= null then
         if this.m_IMapTileBitmapRequestedEventArgs.all /= null then
            temp := this.m_IMapTileBitmapRequestedEventArgs.all.Release;
            Free (this.m_IMapTileBitmapRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileBitmapRequestedEventArgs

   function Constructor return MapTileBitmapRequestedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestedEventArgs;
   begin
      return RetVal : MapTileBitmapRequestedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapTileBitmapRequestedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestedEventArgs;
            Retval.m_IMapTileBitmapRequestedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileBitmapRequestedEventArgs

   function get_X
   (
      this : in out MapTileBitmapRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileBitmapRequestedEventArgs.all.get_X (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Y
   (
      this : in out MapTileBitmapRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileBitmapRequestedEventArgs.all.get_Y (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomLevel
   (
      this : in out MapTileBitmapRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileBitmapRequestedEventArgs.all.get_ZoomLevel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Request
   (
      this : in out MapTileBitmapRequestedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequest;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest do
         Hr := this.m_IMapTileBitmapRequestedEventArgs.all.get_Request (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapTileBitmapRequest := new Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequest;
         Retval.m_IMapTileBitmapRequest.all := m_ComRetVal;
      end return;
   end;

   function get_FrameIndex
   (
      this : in out MapTileBitmapRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestedEventArgs_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileBitmapRequestedEventArgs2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileBitmapRequestedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileBitmapRequestedEventArgs.all);
      Hr := m_Interface.get_FrameIndex (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileSource

   procedure Initialize (this : in out MapTileSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileSource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileSource, IMapTileSource_Ptr);
   begin
      if this.m_IMapTileSource /= null then
         if this.m_IMapTileSource.all /= null then
            temp := this.m_IMapTileSource.all.Release;
            Free (this.m_IMapTileSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileSource

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapTileSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory    : access IMapTileSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileSource;
   begin
      return RetVal : MapTileSource do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapTileSource := new Windows.UI.Xaml.Controls.Maps.IMapTileSource;
            Retval.m_IMapTileSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      dataSource : Windows.UI.Xaml.Controls.Maps.MapTileDataSource'Class;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapTileSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory    : access IMapTileSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileSource;
   begin
      return RetVal : MapTileSource do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDataSource (dataSource.m_IMapTileDataSource.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapTileSource := new Windows.UI.Xaml.Controls.Maps.IMapTileSource;
            Retval.m_IMapTileSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      dataSource : Windows.UI.Xaml.Controls.Maps.MapTileDataSource'Class;
      zoomLevelRange : Windows.UI.Xaml.Controls.Maps.MapZoomLevelRange;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapTileSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory    : access IMapTileSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileSource;
   begin
      return RetVal : MapTileSource do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDataSourceAndZoomRange (dataSource.m_IMapTileDataSource.all, zoomLevelRange, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapTileSource := new Windows.UI.Xaml.Controls.Maps.IMapTileSource;
            Retval.m_IMapTileSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      dataSource : Windows.UI.Xaml.Controls.Maps.MapTileDataSource'Class;
      zoomLevelRange : Windows.UI.Xaml.Controls.Maps.MapZoomLevelRange;
      bounds : Windows.Devices.Geolocation.GeoboundingBox'Class;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapTileSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory    : access IMapTileSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileSource;
   begin
      return RetVal : MapTileSource do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDataSourceZoomRangeAndBounds (dataSource.m_IMapTileDataSource.all, zoomLevelRange, bounds.m_IGeoboundingBox.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapTileSource := new Windows.UI.Xaml.Controls.Maps.IMapTileSource;
            Retval.m_IMapTileSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      dataSource : Windows.UI.Xaml.Controls.Maps.MapTileDataSource'Class;
      zoomLevelRange : Windows.UI.Xaml.Controls.Maps.MapZoomLevelRange;
      bounds : Windows.Devices.Geolocation.GeoboundingBox'Class;
      tileSizeInPixels : WinRt.Int32;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return MapTileSource is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory    : access IMapTileSourceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileSource;
   begin
      return RetVal : MapTileSource do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithDataSourceZoomRangeBoundsAndTileSize (dataSource.m_IMapTileDataSource.all, zoomLevelRange, bounds.m_IGeoboundingBox.all, tileSizeInPixels, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMapTileSource := new Windows.UI.Xaml.Controls.Maps.IMapTileSource;
            Retval.m_IMapTileSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MapTileSource

   function get_DataSourceProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LayerProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LayerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomLevelRangeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomLevelRangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BoundsProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AllowOverstretchProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowOverstretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFadingEnabledProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFadingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTransparencyEnabledProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTransparencyEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRetryEnabledProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRetryEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZIndexProperty_MapTileSource
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TilePixelSizeProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TilePixelSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VisibleProperty_MapTileSource
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AnimationStateProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AnimationStateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoPlayProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoPlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FrameCountProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FrameCountProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FrameDurationProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileSource");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSourceStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMapTileSourceStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FrameDurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileSource

   function get_DataSource
   (
      this : in out MapTileSource
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapTileDataSource'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapTileDataSource;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapTileDataSource do
         Hr := this.m_IMapTileSource.all.get_DataSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapTileDataSource := new Windows.UI.Xaml.Controls.Maps.IMapTileDataSource;
         Retval.m_IMapTileDataSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_DataSource
   (
      this : in out MapTileSource;
      value : Windows.UI.Xaml.Controls.Maps.MapTileDataSource'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_DataSource (value.m_IMapTileDataSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Layer
   (
      this : in out MapTileSource
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapTileLayer is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapTileLayer;
   begin
      Hr := this.m_IMapTileSource.all.get_Layer (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Layer
   (
      this : in out MapTileSource;
      value : Windows.UI.Xaml.Controls.Maps.MapTileLayer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_Layer (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomLevelRange
   (
      this : in out MapTileSource
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapZoomLevelRange is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapZoomLevelRange;
   begin
      Hr := this.m_IMapTileSource.all.get_ZoomLevelRange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomLevelRange
   (
      this : in out MapTileSource;
      value : Windows.UI.Xaml.Controls.Maps.MapZoomLevelRange
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_ZoomLevelRange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Bounds
   (
      this : in out MapTileSource
   )
   return WinRt.Windows.Devices.Geolocation.GeoboundingBox'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeoboundingBox;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.GeoboundingBox do
         Hr := this.m_IMapTileSource.all.get_Bounds (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeoboundingBox := new Windows.Devices.Geolocation.IGeoboundingBox;
         Retval.m_IGeoboundingBox.all := m_ComRetVal;
      end return;
   end;

   procedure put_Bounds
   (
      this : in out MapTileSource;
      value : Windows.Devices.Geolocation.GeoboundingBox'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_Bounds (value.m_IGeoboundingBox.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AllowOverstretch
   (
      this : in out MapTileSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapTileSource.all.get_AllowOverstretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AllowOverstretch
   (
      this : in out MapTileSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_AllowOverstretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFadingEnabled
   (
      this : in out MapTileSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapTileSource.all.get_IsFadingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFadingEnabled
   (
      this : in out MapTileSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_IsFadingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTransparencyEnabled
   (
      this : in out MapTileSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapTileSource.all.get_IsTransparencyEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTransparencyEnabled
   (
      this : in out MapTileSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_IsTransparencyEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsRetryEnabled
   (
      this : in out MapTileSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapTileSource.all.get_IsRetryEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRetryEnabled
   (
      this : in out MapTileSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_IsRetryEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZIndex
   (
      this : in out MapTileSource
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileSource.all.get_ZIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out MapTileSource;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_ZIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TilePixelSize
   (
      this : in out MapTileSource
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileSource.all.get_TilePixelSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TilePixelSize
   (
      this : in out MapTileSource;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_TilePixelSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Visible
   (
      this : in out MapTileSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IMapTileSource.all.get_Visible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Visible
   (
      this : in out MapTileSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileSource.all.put_Visible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AnimationState
   (
      this : in out MapTileSource
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapTileAnimationState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.MapTileAnimationState;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.get_AnimationState (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AutoPlay
   (
      this : in out MapTileSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.get_AutoPlay (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoPlay
   (
      this : in out MapTileSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.put_AutoPlay (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FrameCount
   (
      this : in out MapTileSource
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.get_FrameCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FrameCount
   (
      this : in out MapTileSource;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.put_FrameCount (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FrameDuration
   (
      this : in out MapTileSource
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.get_FrameDuration (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FrameDuration
   (
      this : in out MapTileSource;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.put_FrameDuration (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Pause
   (
      this : in out MapTileSource
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.Pause;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Play
   (
      this : in out MapTileSource
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.Play;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out MapTileSource
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileSource2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileSource.all);
      Hr := m_Interface.Stop;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileUriRequest

   procedure Initialize (this : in out MapTileUriRequest) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileUriRequest) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileUriRequest, IMapTileUriRequest_Ptr);
   begin
      if this.m_IMapTileUriRequest /= null then
         if this.m_IMapTileUriRequest.all /= null then
            temp := this.m_IMapTileUriRequest.all.Release;
            Free (this.m_IMapTileUriRequest);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileUriRequest

   function Constructor return MapTileUriRequest is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileUriRequest");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileUriRequest;
   begin
      return RetVal : MapTileUriRequest do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapTileUriRequest := new Windows.UI.Xaml.Controls.Maps.IMapTileUriRequest;
            Retval.m_IMapTileUriRequest.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileUriRequest

   function get_Uri
   (
      this : in out MapTileUriRequest
   )
   return WinRt.Windows.Foundation.Uri'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinRt.Windows.Foundation.Uri do
         Hr := this.m_IMapTileUriRequest.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_Uri
   (
      this : in out MapTileUriRequest;
      value : Windows.Foundation.Uri'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileUriRequest.all.put_Uri (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out MapTileUriRequest
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapTileUriRequestDeferral'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestDeferral;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapTileUriRequestDeferral do
         Hr := this.m_IMapTileUriRequest.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapTileUriRequestDeferral := new Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestDeferral;
         Retval.m_IMapTileUriRequestDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileUriRequestDeferral

   procedure Initialize (this : in out MapTileUriRequestDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileUriRequestDeferral) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileUriRequestDeferral, IMapTileUriRequestDeferral_Ptr);
   begin
      if this.m_IMapTileUriRequestDeferral /= null then
         if this.m_IMapTileUriRequestDeferral.all /= null then
            temp := this.m_IMapTileUriRequestDeferral.all.Release;
            Free (this.m_IMapTileUriRequestDeferral);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileUriRequestDeferral

   function Constructor return MapTileUriRequestDeferral is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileUriRequestDeferral");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestDeferral;
   begin
      return RetVal : MapTileUriRequestDeferral do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapTileUriRequestDeferral := new Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestDeferral;
            Retval.m_IMapTileUriRequestDeferral.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileUriRequestDeferral

   procedure Complete
   (
      this : in out MapTileUriRequestDeferral
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMapTileUriRequestDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MapTileUriRequestedEventArgs

   procedure Initialize (this : in out MapTileUriRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MapTileUriRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMapTileUriRequestedEventArgs, IMapTileUriRequestedEventArgs_Ptr);
   begin
      if this.m_IMapTileUriRequestedEventArgs /= null then
         if this.m_IMapTileUriRequestedEventArgs.all /= null then
            temp := this.m_IMapTileUriRequestedEventArgs.all.Release;
            Free (this.m_IMapTileUriRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MapTileUriRequestedEventArgs

   function Constructor return MapTileUriRequestedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs");
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestedEventArgs;
   begin
      return RetVal : MapTileUriRequestedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMapTileUriRequestedEventArgs := new Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestedEventArgs;
            Retval.m_IMapTileUriRequestedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MapTileUriRequestedEventArgs

   function get_X
   (
      this : in out MapTileUriRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileUriRequestedEventArgs.all.get_X (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Y
   (
      this : in out MapTileUriRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileUriRequestedEventArgs.all.get_Y (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomLevel
   (
      this : in out MapTileUriRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IMapTileUriRequestedEventArgs.all.get_ZoomLevel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Request
   (
      this : in out MapTileUriRequestedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.MapTileUriRequest'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Xaml.Controls.Maps.IMapTileUriRequest;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.MapTileUriRequest do
         Hr := this.m_IMapTileUriRequestedEventArgs.all.get_Request (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMapTileUriRequest := new Windows.UI.Xaml.Controls.Maps.IMapTileUriRequest;
         Retval.m_IMapTileUriRequest.all := m_ComRetVal;
      end return;
   end;

   function get_FrameIndex
   (
      this : in out MapTileUriRequestedEventArgs
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestedEventArgs_Interface, WinRt.Windows.UI.Xaml.Controls.Maps.IMapTileUriRequestedEventArgs2, WinRt.Windows.UI.Xaml.Controls.Maps.IID_IMapTileUriRequestedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMapTileUriRequestedEventArgs.all);
      Hr := m_Interface.get_FrameIndex (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StreetsideExperience

   procedure Initialize (this : in out StreetsideExperience) is
   begin
      null;
   end;

   procedure Finalize (this : in out StreetsideExperience) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStreetsideExperience, IStreetsideExperience_Ptr);
   begin
      if this.m_IStreetsideExperience /= null then
         if this.m_IStreetsideExperience.all /= null then
            temp := this.m_IStreetsideExperience.all.Release;
            Free (this.m_IStreetsideExperience);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StreetsideExperience

   function Constructor
   (
      panorama : Windows.UI.Xaml.Controls.Maps.StreetsidePanorama'Class
   )
   return StreetsideExperience is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.StreetsideExperience");
      m_Factory    : access IStreetsideExperienceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IStreetsideExperience;
   begin
      return RetVal : StreetsideExperience do
         Hr := RoGetActivationFactory (m_hString, IID_IStreetsideExperienceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithPanorama (panorama.m_IStreetsidePanorama.all, m_ComRetVal'Access);
            Retval.m_IStreetsideExperience := new Windows.UI.Xaml.Controls.Maps.IStreetsideExperience;
            Retval.m_IStreetsideExperience.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      panorama : Windows.UI.Xaml.Controls.Maps.StreetsidePanorama'Class;
      headingInDegrees : WinRt.Double;
      pitchInDegrees : WinRt.Double;
      fieldOfViewInDegrees : WinRt.Double
   )
   return StreetsideExperience is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.StreetsideExperience");
      m_Factory    : access IStreetsideExperienceFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.UI.Xaml.Controls.Maps.IStreetsideExperience;
   begin
      return RetVal : StreetsideExperience do
         Hr := RoGetActivationFactory (m_hString, IID_IStreetsideExperienceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithPanoramaHeadingPitchAndFieldOfView (panorama.m_IStreetsidePanorama.all, headingInDegrees, pitchInDegrees, fieldOfViewInDegrees, m_ComRetVal'Access);
            Retval.m_IStreetsideExperience := new Windows.UI.Xaml.Controls.Maps.IStreetsideExperience;
            Retval.m_IStreetsideExperience.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StreetsideExperience

   function get_AddressTextVisible
   (
      this : in out StreetsideExperience
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStreetsideExperience.all.get_AddressTextVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AddressTextVisible
   (
      this : in out StreetsideExperience;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStreetsideExperience.all.put_AddressTextVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CursorVisible
   (
      this : in out StreetsideExperience
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStreetsideExperience.all.get_CursorVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CursorVisible
   (
      this : in out StreetsideExperience;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStreetsideExperience.all.put_CursorVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverviewMapVisible
   (
      this : in out StreetsideExperience
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStreetsideExperience.all.get_OverviewMapVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OverviewMapVisible
   (
      this : in out StreetsideExperience;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStreetsideExperience.all.put_OverviewMapVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StreetLabelsVisible
   (
      this : in out StreetsideExperience
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStreetsideExperience.all.get_StreetLabelsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StreetLabelsVisible
   (
      this : in out StreetsideExperience;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStreetsideExperience.all.put_StreetLabelsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExitButtonVisible
   (
      this : in out StreetsideExperience
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStreetsideExperience.all.get_ExitButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExitButtonVisible
   (
      this : in out StreetsideExperience;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStreetsideExperience.all.put_ExitButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomButtonsVisible
   (
      this : in out StreetsideExperience
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStreetsideExperience.all.get_ZoomButtonsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomButtonsVisible
   (
      this : in out StreetsideExperience;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStreetsideExperience.all.put_ZoomButtonsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StreetsidePanorama

   procedure Initialize (this : in out StreetsidePanorama) is
   begin
      null;
   end;

   procedure Finalize (this : in out StreetsidePanorama) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStreetsidePanorama, IStreetsidePanorama_Ptr);
   begin
      if this.m_IStreetsidePanorama /= null then
         if this.m_IStreetsidePanorama.all /= null then
            temp := this.m_IStreetsidePanorama.all.Release;
            Free (this.m_IStreetsidePanorama);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for StreetsidePanorama

   function FindNearbyAsync
   (
      location : Windows.Devices.Geolocation.Geopoint'Class
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.StreetsidePanorama is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.StreetsidePanorama");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IStreetsidePanoramaStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_StreetsidePanorama.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_StreetsidePanorama.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Xaml.Controls.Maps.IStreetsidePanorama;
      m_IID            : aliased WinRt.IID := (1792600647, 26224, 20952, (161, 219, 51, 254, 117, 73, 31, 12 )); -- Windows.UI.Xaml.Controls.Maps.StreetsidePanorama;
      m_HandlerIID     : aliased WinRt.IID := (4143165820, 17703, 21800, (134, 170, 28, 241, 251, 120, 165, 235 ));
      m_Handler        : AsyncOperationCompletedHandler_StreetsidePanorama.Kind := new AsyncOperationCompletedHandler_StreetsidePanorama.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_StreetsidePanorama.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_StreetsidePanorama.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_StreetsidePanorama.Kind_Delegate, AsyncOperationCompletedHandler_StreetsidePanorama.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.StreetsidePanorama do
         Hr := RoGetActivationFactory (m_hString, IID_IStreetsidePanoramaStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindNearbyAsync (location.m_IGeopoint.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IStreetsidePanorama := new Windows.UI.Xaml.Controls.Maps.IStreetsidePanorama;
                     Retval.m_IStreetsidePanorama.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function FindNearbyAsync
   (
      location : Windows.Devices.Geolocation.Geopoint'Class;
      radiusInMeters : WinRt.Double
   )
   return WinRt.Windows.UI.Xaml.Controls.Maps.StreetsidePanorama is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Controls.Maps.StreetsidePanorama");
      m_Factory        : access WinRt.Windows.UI.Xaml.Controls.Maps.IStreetsidePanoramaStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_StreetsidePanorama.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_StreetsidePanorama.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Xaml.Controls.Maps.IStreetsidePanorama;
      m_IID            : aliased WinRt.IID := (1792600647, 26224, 20952, (161, 219, 51, 254, 117, 73, 31, 12 )); -- Windows.UI.Xaml.Controls.Maps.StreetsidePanorama;
      m_HandlerIID     : aliased WinRt.IID := (4143165820, 17703, 21800, (134, 170, 28, 241, 251, 120, 165, 235 ));
      m_Handler        : AsyncOperationCompletedHandler_StreetsidePanorama.Kind := new AsyncOperationCompletedHandler_StreetsidePanorama.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_StreetsidePanorama.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_StreetsidePanorama.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_StreetsidePanorama.Kind_Delegate, AsyncOperationCompletedHandler_StreetsidePanorama.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.Maps.StreetsidePanorama do
         Hr := RoGetActivationFactory (m_hString, IID_IStreetsidePanoramaStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindNearbyAsync (location.m_IGeopoint.all, radiusInMeters, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IStreetsidePanorama := new Windows.UI.Xaml.Controls.Maps.IStreetsidePanorama;
                     Retval.m_IStreetsidePanorama.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StreetsidePanorama

   function get_Location
   (
      this : in out StreetsidePanorama
   )
   return WinRt.Windows.Devices.Geolocation.Geopoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Geolocation.IGeopoint;
   begin
      return RetVal : WinRt.Windows.Devices.Geolocation.Geopoint do
         Hr := this.m_IStreetsidePanorama.all.get_Location (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeopoint := new Windows.Devices.Geolocation.IGeopoint;
         Retval.m_IGeopoint.all := m_ComRetVal;
      end return;
   end;

end WinRt.Windows.UI.Xaml.Controls.Maps;
