--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.Graphics.Display;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Devices.Sensors is

   package IAsyncOperation_Accelerometer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IAccelerometer);
   package AsyncOperationCompletedHandler_Accelerometer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IAccelerometer);

   package IAsyncOperation_ActivitySensorReading is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IActivitySensorReading);
   package AsyncOperationCompletedHandler_ActivitySensorReading is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IActivitySensorReading);

   package IAsyncOperation_ActivitySensor is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IActivitySensor);
   package AsyncOperationCompletedHandler_ActivitySensor is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IActivitySensor);

   package IAsyncOperation_GenericObject is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.GenericObject);
   package AsyncOperationCompletedHandler_GenericObject is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.GenericObject);

   package IAsyncOperation_Barometer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IBarometer);
   package AsyncOperationCompletedHandler_Barometer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IBarometer);

   package IAsyncOperation_Compass is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.ICompass);
   package AsyncOperationCompletedHandler_Compass is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.ICompass);

   package IAsyncOperation_Gyrometer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IGyrometer);
   package AsyncOperationCompletedHandler_Gyrometer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IGyrometer);

   package IAsyncOperation_HingeAngleReading is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IHingeAngleReading);
   package AsyncOperationCompletedHandler_HingeAngleReading is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IHingeAngleReading);

   package IAsyncOperation_HingeAngleSensor is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IHingeAngleSensor);
   package AsyncOperationCompletedHandler_HingeAngleSensor is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IHingeAngleSensor);

   package IAsyncOperation_Inclinometer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IInclinometer);
   package AsyncOperationCompletedHandler_Inclinometer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IInclinometer);

   package IAsyncOperation_LightSensor is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.ILightSensor);
   package AsyncOperationCompletedHandler_LightSensor is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.ILightSensor);

   package IAsyncOperation_Magnetometer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IMagnetometer);
   package AsyncOperationCompletedHandler_Magnetometer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IMagnetometer);

   package IAsyncOperation_OrientationSensor is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IOrientationSensor);
   package AsyncOperationCompletedHandler_OrientationSensor is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IOrientationSensor);

   package IAsyncOperation_Pedometer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.IPedometer);
   package AsyncOperationCompletedHandler_Pedometer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.IPedometer);

   package IAsyncOperation_SimpleOrientationSensor is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor);
   package AsyncOperationCompletedHandler_SimpleOrientationSensor is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Accelerometer

   procedure Initialize (this : in out Accelerometer) is
   begin
      null;
   end;

   procedure Finalize (this : in out Accelerometer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccelerometer, IAccelerometer_Ptr);
   begin
      if this.m_IAccelerometer /= null then
         if this.m_IAccelerometer.all /= null then
            RefCount := this.m_IAccelerometer.all.Release;
            Free (this.m_IAccelerometer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Accelerometer

   function GetDefault
   (
      readingType : Windows.Devices.Sensors.AccelerometerReadingType
   )
   return WinRt.Windows.Devices.Sensors.Accelerometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Accelerometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IAccelerometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAccelerometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Accelerometer do
         Hr := RoGetActivationFactory (m_hString, IID_IAccelerometerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (readingType, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IAccelerometer := new Windows.Devices.Sensors.IAccelerometer;
            Retval.m_IAccelerometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function FromIdAsync
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.Accelerometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Accelerometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IAccelerometerStatics3_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Accelerometer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Accelerometer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IAccelerometer;
      m_IID            : aliased WinRt.IID := (4235599163, 24141, 20808, (166, 24, 123, 103, 112, 89, 208, 184 )); -- Windows.Devices.Sensors.Accelerometer;
      m_HandlerIID     : aliased WinRt.IID := (3351460278, 29991, 20522, (138, 76, 203, 155, 239, 225, 88, 64 ));
      m_Handler        : AsyncOperationCompletedHandler_Accelerometer.Kind := new AsyncOperationCompletedHandler_Accelerometer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Accelerometer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Accelerometer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Accelerometer.Kind_Delegate, AsyncOperationCompletedHandler_Accelerometer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Accelerometer do
         Hr := RoGetActivationFactory (m_hString, IID_IAccelerometerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IAccelerometer := new Windows.Devices.Sensors.IAccelerometer;
                     Retval.m_IAccelerometer.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDeviceSelector
   (
      readingType : Windows.Devices.Sensors.AccelerometerReadingType
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Accelerometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IAccelerometerStatics3_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAccelerometerStatics3'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (readingType, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetDefault
   return WinRt.Windows.Devices.Sensors.Accelerometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Accelerometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IAccelerometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAccelerometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Accelerometer do
         Hr := RoGetActivationFactory (m_hString, IID_IAccelerometerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IAccelerometer := new Windows.Devices.Sensors.IAccelerometer;
            Retval.m_IAccelerometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Accelerometer

   function GetCurrentReading
   (
      this : in out Accelerometer
   )
   return WinRt.Windows.Devices.Sensors.AccelerometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAccelerometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.AccelerometerReading do
         Hr := this.m_IAccelerometer.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IAccelerometerReading := new Windows.Devices.Sensors.IAccelerometerReading;
         Retval.m_IAccelerometerReading.all := m_ComRetVal;
      end return;
   end;

   function get_MinimumReportInterval
   (
      this : in out Accelerometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IAccelerometer.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Accelerometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAccelerometer.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Accelerometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IAccelerometer.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Accelerometer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAccelerometer.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Accelerometer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAccelerometer.all.remove_ReadingChanged (token);
   end;

   function add_Shaken
   (
      this : in out Accelerometer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAccelerometer.all.add_Shaken (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_Shaken
   (
      this : in out Accelerometer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAccelerometer.all.remove_Shaken (token);
   end;

   function get_DeviceId
   (
      this : in out Accelerometer
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometerDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometerDeviceId, WinRt.Windows.Devices.Sensors.IID_IAccelerometerDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometer.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReadingTransform
   (
      this : in out Accelerometer;
      value : Windows.Graphics.Display.DisplayOrientations
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometer2, WinRt.Windows.Devices.Sensors.IID_IAccelerometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometer.all);
      Hr := m_Interface.put_ReadingTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReadingTransform
   (
      this : in out Accelerometer
   )
   return WinRt.Windows.Graphics.Display.DisplayOrientations is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.Display.DisplayOrientations;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometer2, WinRt.Windows.Devices.Sensors.IID_IAccelerometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometer.all);
      Hr := m_Interface.get_ReadingTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ReportLatency
   (
      this : in out Accelerometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometer3, WinRt.Windows.Devices.Sensors.IID_IAccelerometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometer.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out Accelerometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometer3, WinRt.Windows.Devices.Sensors.IID_IAccelerometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometer.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out Accelerometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometer3, WinRt.Windows.Devices.Sensors.IID_IAccelerometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometer.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReadingType
   (
      this : in out Accelerometer
   )
   return WinRt.Windows.Devices.Sensors.AccelerometerReadingType is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometer4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.AccelerometerReadingType;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometer4, WinRt.Windows.Devices.Sensors.IID_IAccelerometer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometer.all);
      Hr := m_Interface.get_ReadingType (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReportThreshold
   (
      this : in out Accelerometer
   )
   return WinRt.Windows.Devices.Sensors.AccelerometerDataThreshold'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometer5 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAccelerometerDataThreshold;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometer_Interface, WinRt.Windows.Devices.Sensors.IAccelerometer5, WinRt.Windows.Devices.Sensors.IID_IAccelerometer5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.AccelerometerDataThreshold do
         m_Interface := QInterface (this.m_IAccelerometer.all);
         Hr := m_Interface.get_ReportThreshold (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IAccelerometerDataThreshold := new Windows.Devices.Sensors.IAccelerometerDataThreshold;
         Retval.m_IAccelerometerDataThreshold.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccelerometerDataThreshold

   procedure Initialize (this : in out AccelerometerDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccelerometerDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccelerometerDataThreshold, IAccelerometerDataThreshold_Ptr);
   begin
      if this.m_IAccelerometerDataThreshold /= null then
         if this.m_IAccelerometerDataThreshold.all /= null then
            RefCount := this.m_IAccelerometerDataThreshold.all.Release;
            Free (this.m_IAccelerometerDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccelerometerDataThreshold

   function get_XAxisInGForce
   (
      this : in out AccelerometerDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IAccelerometerDataThreshold.all.get_XAxisInGForce (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_XAxisInGForce
   (
      this : in out AccelerometerDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAccelerometerDataThreshold.all.put_XAxisInGForce (value);
   end;

   function get_YAxisInGForce
   (
      this : in out AccelerometerDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IAccelerometerDataThreshold.all.get_YAxisInGForce (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_YAxisInGForce
   (
      this : in out AccelerometerDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAccelerometerDataThreshold.all.put_YAxisInGForce (value);
   end;

   function get_ZAxisInGForce
   (
      this : in out AccelerometerDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IAccelerometerDataThreshold.all.get_ZAxisInGForce (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ZAxisInGForce
   (
      this : in out AccelerometerDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAccelerometerDataThreshold.all.put_ZAxisInGForce (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccelerometerReading

   procedure Initialize (this : in out AccelerometerReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccelerometerReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccelerometerReading, IAccelerometerReading_Ptr);
   begin
      if this.m_IAccelerometerReading /= null then
         if this.m_IAccelerometerReading.all /= null then
            RefCount := this.m_IAccelerometerReading.all.Release;
            Free (this.m_IAccelerometerReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccelerometerReading

   function get_Timestamp
   (
      this : in out AccelerometerReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IAccelerometerReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AccelerationX
   (
      this : in out AccelerometerReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IAccelerometerReading.all.get_AccelerationX (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AccelerationY
   (
      this : in out AccelerometerReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IAccelerometerReading.all.get_AccelerationY (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AccelerationZ
   (
      this : in out AccelerometerReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IAccelerometerReading.all.get_AccelerationZ (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out AccelerometerReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometerReading_Interface, WinRt.Windows.Devices.Sensors.IAccelerometerReading2, WinRt.Windows.Devices.Sensors.IID_IAccelerometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometerReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out AccelerometerReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAccelerometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAccelerometerReading_Interface, WinRt.Windows.Devices.Sensors.IAccelerometerReading2, WinRt.Windows.Devices.Sensors.IID_IAccelerometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAccelerometerReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccelerometerReadingChangedEventArgs

   procedure Initialize (this : in out AccelerometerReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccelerometerReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccelerometerReadingChangedEventArgs, IAccelerometerReadingChangedEventArgs_Ptr);
   begin
      if this.m_IAccelerometerReadingChangedEventArgs /= null then
         if this.m_IAccelerometerReadingChangedEventArgs.all /= null then
            RefCount := this.m_IAccelerometerReadingChangedEventArgs.all.Release;
            Free (this.m_IAccelerometerReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccelerometerReadingChangedEventArgs

   function get_Reading
   (
      this : in out AccelerometerReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.AccelerometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAccelerometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.AccelerometerReading do
         Hr := this.m_IAccelerometerReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IAccelerometerReading := new Windows.Devices.Sensors.IAccelerometerReading;
         Retval.m_IAccelerometerReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccelerometerShakenEventArgs

   procedure Initialize (this : in out AccelerometerShakenEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccelerometerShakenEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccelerometerShakenEventArgs, IAccelerometerShakenEventArgs_Ptr);
   begin
      if this.m_IAccelerometerShakenEventArgs /= null then
         if this.m_IAccelerometerShakenEventArgs.all /= null then
            RefCount := this.m_IAccelerometerShakenEventArgs.all.Release;
            Free (this.m_IAccelerometerShakenEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccelerometerShakenEventArgs

   function get_Timestamp
   (
      this : in out AccelerometerShakenEventArgs
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IAccelerometerShakenEventArgs.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ActivitySensor

   procedure Initialize (this : in out ActivitySensor) is
   begin
      null;
   end;

   procedure Finalize (this : in out ActivitySensor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IActivitySensor, IActivitySensor_Ptr);
   begin
      if this.m_IActivitySensor /= null then
         if this.m_IActivitySensor.all /= null then
            RefCount := this.m_IActivitySensor.all.Release;
            Free (this.m_IActivitySensor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ActivitySensor

   function GetDefaultAsync
   return WinRt.Windows.Devices.Sensors.ActivitySensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ActivitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IActivitySensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_ActivitySensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ActivitySensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IActivitySensor;
      m_IID            : aliased WinRt.IID := (3274703790, 59310, 22315, (141, 85, 125, 177, 151, 53, 108, 48 )); -- Windows.Devices.Sensors.ActivitySensor;
      m_HandlerIID     : aliased WinRt.IID := (4211447028, 37849, 23599, (184, 235, 144, 241, 233, 37, 143, 220 ));
      m_Handler        : AsyncOperationCompletedHandler_ActivitySensor.Kind := new AsyncOperationCompletedHandler_ActivitySensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ActivitySensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ActivitySensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ActivitySensor.Kind_Delegate, AsyncOperationCompletedHandler_ActivitySensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ActivitySensor do
         Hr := RoGetActivationFactory (m_hString, IID_IActivitySensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefaultAsync (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IActivitySensor := new Windows.Devices.Sensors.IActivitySensor;
                     Retval.m_IActivitySensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDeviceSelector
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ActivitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IActivitySensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IActivitySensorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_ActivitySensor
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.ActivitySensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ActivitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IActivitySensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_ActivitySensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ActivitySensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IActivitySensor;
      m_IID            : aliased WinRt.IID := (3274703790, 59310, 22315, (141, 85, 125, 177, 151, 53, 108, 48 )); -- Windows.Devices.Sensors.ActivitySensor;
      m_HandlerIID     : aliased WinRt.IID := (4211447028, 37849, 23599, (184, 235, 144, 241, 233, 37, 143, 220 ));
      m_Handler        : AsyncOperationCompletedHandler_ActivitySensor.Kind := new AsyncOperationCompletedHandler_ActivitySensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ActivitySensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ActivitySensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ActivitySensor.Kind_Delegate, AsyncOperationCompletedHandler_ActivitySensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ActivitySensor do
         Hr := RoGetActivationFactory (m_hString, IID_IActivitySensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IActivitySensor := new Windows.Devices.Sensors.IActivitySensor;
                     Retval.m_IActivitySensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetSystemHistoryAsync
   (
      fromTime : Windows.Foundation.DateTime
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ActivitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IActivitySensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (3447200642, 30976, 20899, (128, 206, 144, 62, 46, 10, 79, 14 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (396343635, 11608, 22929, (143, 91, 172, 100, 33, 154, 17, 1 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IActivitySensorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetSystemHistoryAsync (fromTime, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   function GetSystemHistoryAsync
   (
      fromTime : Windows.Foundation.DateTime;
      duration : Windows.Foundation.TimeSpan
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ActivitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IActivitySensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (3447200642, 30976, 20899, (128, 206, 144, 62, 46, 10, 79, 14 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (396343635, 11608, 22929, (143, 91, 172, 100, 33, 154, 17, 1 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IActivitySensorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetSystemHistoryAsync (fromTime, duration, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ActivitySensor

   function GetCurrentReadingAsync
   (
      this : in out ActivitySensor
   )
   return WinRt.Windows.Devices.Sensors.ActivitySensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_ActivitySensorReading.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ActivitySensorReading.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IActivitySensorReading;
      m_IID            : aliased WinRt.IID := (2041084265, 12927, 23418, (160, 211, 115, 234, 177, 109, 226, 28 )); -- Windows.Devices.Sensors.ActivitySensorReading;
      m_HandlerIID     : aliased WinRt.IID := (2915339613, 45891, 23128, (132, 84, 110, 43, 194, 224, 71, 92 ));
      m_Handler        : AsyncOperationCompletedHandler_ActivitySensorReading.Kind := new AsyncOperationCompletedHandler_ActivitySensorReading.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ActivitySensorReading.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ActivitySensorReading.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ActivitySensorReading.Kind_Delegate, AsyncOperationCompletedHandler_ActivitySensorReading.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ActivitySensorReading do
         Hr := this.m_IActivitySensor.all.GetCurrentReadingAsync (m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IActivitySensorReading := new Windows.Devices.Sensors.IActivitySensorReading;
                  Retval.m_IActivitySensorReading.all := m_RetVal;
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function get_SubscribedActivities
   (
      this : in out ActivitySensor
   )
   return IVector_ActivityType.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_ActivityType.Kind;
   begin
      Hr := this.m_IActivitySensor.all.get_SubscribedActivities (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVector_ActivityType (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_PowerInMilliwatts
   (
      this : in out ActivitySensor
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IActivitySensor.all.get_PowerInMilliwatts (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_DeviceId
   (
      this : in out ActivitySensor
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IActivitySensor.all.get_DeviceId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SupportedActivities
   (
      this : in out ActivitySensor
   )
   return IVectorView_ActivityType.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_ActivityType.Kind;
   begin
      Hr := this.m_IActivitySensor.all.get_SupportedActivities (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_ActivityType (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_MinimumReportInterval
   (
      this : in out ActivitySensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IActivitySensor.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out ActivitySensor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IActivitySensor.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out ActivitySensor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IActivitySensor.all.remove_ReadingChanged (token);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ActivitySensorReading

   procedure Initialize (this : in out ActivitySensorReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out ActivitySensorReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IActivitySensorReading, IActivitySensorReading_Ptr);
   begin
      if this.m_IActivitySensorReading /= null then
         if this.m_IActivitySensorReading.all /= null then
            RefCount := this.m_IActivitySensorReading.all.Release;
            Free (this.m_IActivitySensorReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ActivitySensorReading

   function get_Timestamp
   (
      this : in out ActivitySensorReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IActivitySensorReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Activity
   (
      this : in out ActivitySensorReading
   )
   return WinRt.Windows.Devices.Sensors.ActivityType is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ActivityType;
   begin
      Hr := this.m_IActivitySensorReading.all.get_Activity (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Confidence
   (
      this : in out ActivitySensorReading
   )
   return WinRt.Windows.Devices.Sensors.ActivitySensorReadingConfidence is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ActivitySensorReadingConfidence;
   begin
      Hr := this.m_IActivitySensorReading.all.get_Confidence (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ActivitySensorReadingChangeReport

   procedure Initialize (this : in out ActivitySensorReadingChangeReport) is
   begin
      null;
   end;

   procedure Finalize (this : in out ActivitySensorReadingChangeReport) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IActivitySensorReadingChangeReport, IActivitySensorReadingChangeReport_Ptr);
   begin
      if this.m_IActivitySensorReadingChangeReport /= null then
         if this.m_IActivitySensorReadingChangeReport.all /= null then
            RefCount := this.m_IActivitySensorReadingChangeReport.all.Release;
            Free (this.m_IActivitySensorReadingChangeReport);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ActivitySensorReadingChangeReport

   function get_Reading
   (
      this : in out ActivitySensorReadingChangeReport
   )
   return WinRt.Windows.Devices.Sensors.ActivitySensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IActivitySensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ActivitySensorReading do
         Hr := this.m_IActivitySensorReadingChangeReport.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IActivitySensorReading := new Windows.Devices.Sensors.IActivitySensorReading;
         Retval.m_IActivitySensorReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ActivitySensorReadingChangedEventArgs

   procedure Initialize (this : in out ActivitySensorReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ActivitySensorReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IActivitySensorReadingChangedEventArgs, IActivitySensorReadingChangedEventArgs_Ptr);
   begin
      if this.m_IActivitySensorReadingChangedEventArgs /= null then
         if this.m_IActivitySensorReadingChangedEventArgs.all /= null then
            RefCount := this.m_IActivitySensorReadingChangedEventArgs.all.Release;
            Free (this.m_IActivitySensorReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ActivitySensorReadingChangedEventArgs

   function get_Reading
   (
      this : in out ActivitySensorReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.ActivitySensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IActivitySensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ActivitySensorReading do
         Hr := this.m_IActivitySensorReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IActivitySensorReading := new Windows.Devices.Sensors.IActivitySensorReading;
         Retval.m_IActivitySensorReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ActivitySensorTriggerDetails

   procedure Initialize (this : in out ActivitySensorTriggerDetails) is
   begin
      null;
   end;

   procedure Finalize (this : in out ActivitySensorTriggerDetails) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IActivitySensorTriggerDetails, IActivitySensorTriggerDetails_Ptr);
   begin
      if this.m_IActivitySensorTriggerDetails /= null then
         if this.m_IActivitySensorTriggerDetails.all /= null then
            RefCount := this.m_IActivitySensorTriggerDetails.all.Release;
            Free (this.m_IActivitySensorTriggerDetails);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ActivitySensorTriggerDetails

   function ReadReports
   (
      this : in out ActivitySensorTriggerDetails
   )
   return IVectorView_IActivitySensorReadingChangeReport.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IActivitySensorReadingChangeReport.Kind;
   begin
      Hr := this.m_IActivitySensorTriggerDetails.all.ReadReports (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IVectorView_IActivitySensorReadingChangeReport (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Altimeter

   procedure Initialize (this : in out Altimeter) is
   begin
      null;
   end;

   procedure Finalize (this : in out Altimeter) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAltimeter, IAltimeter_Ptr);
   begin
      if this.m_IAltimeter /= null then
         if this.m_IAltimeter.all /= null then
            RefCount := this.m_IAltimeter.all.Release;
            Free (this.m_IAltimeter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Altimeter

   function GetDefault
   return WinRt.Windows.Devices.Sensors.Altimeter is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Altimeter");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IAltimeterStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAltimeter;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Altimeter do
         Hr := RoGetActivationFactory (m_hString, IID_IAltimeterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IAltimeter := new Windows.Devices.Sensors.IAltimeter;
            Retval.m_IAltimeter.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Altimeter

   function GetCurrentReading
   (
      this : in out Altimeter
   )
   return WinRt.Windows.Devices.Sensors.AltimeterReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAltimeterReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.AltimeterReading do
         Hr := this.m_IAltimeter.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IAltimeterReading := new Windows.Devices.Sensors.IAltimeterReading;
         Retval.m_IAltimeterReading.all := m_ComRetVal;
      end return;
   end;

   function get_DeviceId
   (
      this : in out Altimeter
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAltimeter.all.get_DeviceId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_MinimumReportInterval
   (
      this : in out Altimeter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IAltimeter.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Altimeter;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAltimeter.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Altimeter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IAltimeter.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Altimeter;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAltimeter.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Altimeter;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAltimeter.all.remove_ReadingChanged (token);
   end;

   procedure put_ReportLatency
   (
      this : in out Altimeter;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAltimeter2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAltimeter_Interface, WinRt.Windows.Devices.Sensors.IAltimeter2, WinRt.Windows.Devices.Sensors.IID_IAltimeter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAltimeter.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out Altimeter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAltimeter2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAltimeter_Interface, WinRt.Windows.Devices.Sensors.IAltimeter2, WinRt.Windows.Devices.Sensors.IID_IAltimeter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAltimeter.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out Altimeter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAltimeter2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAltimeter_Interface, WinRt.Windows.Devices.Sensors.IAltimeter2, WinRt.Windows.Devices.Sensors.IID_IAltimeter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAltimeter.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AltimeterReading

   procedure Initialize (this : in out AltimeterReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out AltimeterReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAltimeterReading, IAltimeterReading_Ptr);
   begin
      if this.m_IAltimeterReading /= null then
         if this.m_IAltimeterReading.all /= null then
            RefCount := this.m_IAltimeterReading.all.Release;
            Free (this.m_IAltimeterReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AltimeterReading

   function get_Timestamp
   (
      this : in out AltimeterReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IAltimeterReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AltitudeChangeInMeters
   (
      this : in out AltimeterReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IAltimeterReading.all.get_AltitudeChangeInMeters (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out AltimeterReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAltimeterReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAltimeterReading_Interface, WinRt.Windows.Devices.Sensors.IAltimeterReading2, WinRt.Windows.Devices.Sensors.IID_IAltimeterReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAltimeterReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out AltimeterReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IAltimeterReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IAltimeterReading_Interface, WinRt.Windows.Devices.Sensors.IAltimeterReading2, WinRt.Windows.Devices.Sensors.IID_IAltimeterReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAltimeterReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AltimeterReadingChangedEventArgs

   procedure Initialize (this : in out AltimeterReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AltimeterReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAltimeterReadingChangedEventArgs, IAltimeterReadingChangedEventArgs_Ptr);
   begin
      if this.m_IAltimeterReadingChangedEventArgs /= null then
         if this.m_IAltimeterReadingChangedEventArgs.all /= null then
            RefCount := this.m_IAltimeterReadingChangedEventArgs.all.Release;
            Free (this.m_IAltimeterReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AltimeterReadingChangedEventArgs

   function get_Reading
   (
      this : in out AltimeterReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.AltimeterReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IAltimeterReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.AltimeterReading do
         Hr := this.m_IAltimeterReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IAltimeterReading := new Windows.Devices.Sensors.IAltimeterReading;
         Retval.m_IAltimeterReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Barometer

   procedure Initialize (this : in out Barometer) is
   begin
      null;
   end;

   procedure Finalize (this : in out Barometer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBarometer, IBarometer_Ptr);
   begin
      if this.m_IBarometer /= null then
         if this.m_IBarometer.all /= null then
            RefCount := this.m_IBarometer.all.Release;
            Free (this.m_IBarometer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Barometer

   function GetDefault
   return WinRt.Windows.Devices.Sensors.Barometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Barometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IBarometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IBarometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Barometer do
         Hr := RoGetActivationFactory (m_hString, IID_IBarometerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IBarometer := new Windows.Devices.Sensors.IBarometer;
            Retval.m_IBarometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function FromIdAsync_Barometer
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.Barometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Barometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IBarometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Barometer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Barometer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IBarometer;
      m_IID            : aliased WinRt.IID := (1367826487, 40758, 23686, (133, 93, 61, 221, 37, 29, 249, 168 )); -- Windows.Devices.Sensors.Barometer;
      m_HandlerIID     : aliased WinRt.IID := (2707300822, 21607, 22796, (175, 225, 156, 129, 50, 220, 216, 164 ));
      m_Handler        : AsyncOperationCompletedHandler_Barometer.Kind := new AsyncOperationCompletedHandler_Barometer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Barometer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Barometer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Barometer.Kind_Delegate, AsyncOperationCompletedHandler_Barometer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Barometer do
         Hr := RoGetActivationFactory (m_hString, IID_IBarometerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IBarometer := new Windows.Devices.Sensors.IBarometer;
                     Retval.m_IBarometer.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDeviceSelector_Barometer
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Barometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IBarometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IBarometerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Barometer

   function GetCurrentReading
   (
      this : in out Barometer
   )
   return WinRt.Windows.Devices.Sensors.BarometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IBarometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.BarometerReading do
         Hr := this.m_IBarometer.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IBarometerReading := new Windows.Devices.Sensors.IBarometerReading;
         Retval.m_IBarometerReading.all := m_ComRetVal;
      end return;
   end;

   function get_DeviceId
   (
      this : in out Barometer
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IBarometer.all.get_DeviceId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_MinimumReportInterval
   (
      this : in out Barometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IBarometer.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Barometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBarometer.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Barometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IBarometer.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Barometer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IBarometer.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Barometer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBarometer.all.remove_ReadingChanged (token);
   end;

   procedure put_ReportLatency
   (
      this : in out Barometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IBarometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IBarometer_Interface, WinRt.Windows.Devices.Sensors.IBarometer2, WinRt.Windows.Devices.Sensors.IID_IBarometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBarometer.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out Barometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IBarometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IBarometer_Interface, WinRt.Windows.Devices.Sensors.IBarometer2, WinRt.Windows.Devices.Sensors.IID_IBarometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBarometer.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out Barometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IBarometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IBarometer_Interface, WinRt.Windows.Devices.Sensors.IBarometer2, WinRt.Windows.Devices.Sensors.IID_IBarometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBarometer.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReportThreshold
   (
      this : in out Barometer
   )
   return WinRt.Windows.Devices.Sensors.BarometerDataThreshold'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IBarometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IBarometerDataThreshold;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IBarometer_Interface, WinRt.Windows.Devices.Sensors.IBarometer3, WinRt.Windows.Devices.Sensors.IID_IBarometer3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.BarometerDataThreshold do
         m_Interface := QInterface (this.m_IBarometer.all);
         Hr := m_Interface.get_ReportThreshold (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IBarometerDataThreshold := new Windows.Devices.Sensors.IBarometerDataThreshold;
         Retval.m_IBarometerDataThreshold.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BarometerDataThreshold

   procedure Initialize (this : in out BarometerDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out BarometerDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBarometerDataThreshold, IBarometerDataThreshold_Ptr);
   begin
      if this.m_IBarometerDataThreshold /= null then
         if this.m_IBarometerDataThreshold.all /= null then
            RefCount := this.m_IBarometerDataThreshold.all.Release;
            Free (this.m_IBarometerDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BarometerDataThreshold

   function get_Hectopascals
   (
      this : in out BarometerDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IBarometerDataThreshold.all.get_Hectopascals (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Hectopascals
   (
      this : in out BarometerDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBarometerDataThreshold.all.put_Hectopascals (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BarometerReading

   procedure Initialize (this : in out BarometerReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out BarometerReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBarometerReading, IBarometerReading_Ptr);
   begin
      if this.m_IBarometerReading /= null then
         if this.m_IBarometerReading.all /= null then
            RefCount := this.m_IBarometerReading.all.Release;
            Free (this.m_IBarometerReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BarometerReading

   function get_Timestamp
   (
      this : in out BarometerReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IBarometerReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_StationPressureInHectopascals
   (
      this : in out BarometerReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IBarometerReading.all.get_StationPressureInHectopascals (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out BarometerReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IBarometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IBarometerReading_Interface, WinRt.Windows.Devices.Sensors.IBarometerReading2, WinRt.Windows.Devices.Sensors.IID_IBarometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBarometerReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out BarometerReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IBarometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IBarometerReading_Interface, WinRt.Windows.Devices.Sensors.IBarometerReading2, WinRt.Windows.Devices.Sensors.IID_IBarometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBarometerReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BarometerReadingChangedEventArgs

   procedure Initialize (this : in out BarometerReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out BarometerReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBarometerReadingChangedEventArgs, IBarometerReadingChangedEventArgs_Ptr);
   begin
      if this.m_IBarometerReadingChangedEventArgs /= null then
         if this.m_IBarometerReadingChangedEventArgs.all /= null then
            RefCount := this.m_IBarometerReadingChangedEventArgs.all.Release;
            Free (this.m_IBarometerReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BarometerReadingChangedEventArgs

   function get_Reading
   (
      this : in out BarometerReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.BarometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IBarometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.BarometerReading do
         Hr := this.m_IBarometerReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IBarometerReading := new Windows.Devices.Sensors.IBarometerReading;
         Retval.m_IBarometerReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Compass

   procedure Initialize (this : in out Compass) is
   begin
      null;
   end;

   procedure Finalize (this : in out Compass) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompass, ICompass_Ptr);
   begin
      if this.m_ICompass /= null then
         if this.m_ICompass.all /= null then
            RefCount := this.m_ICompass.all.Release;
            Free (this.m_ICompass);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Compass

   function GetDefault
   return WinRt.Windows.Devices.Sensors.Compass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Compass");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ICompassStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ICompass;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Compass do
         Hr := RoGetActivationFactory (m_hString, IID_ICompassStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_ICompass := new Windows.Devices.Sensors.ICompass;
            Retval.m_ICompass.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDeviceSelector_Compass
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Compass");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ICompassStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompassStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_Compass
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.Compass is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Compass");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ICompassStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Compass.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Compass.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.ICompass;
      m_IID            : aliased WinRt.IID := (1385677388, 42747, 24067, (164, 248, 238, 20, 60, 67, 93, 248 )); -- Windows.Devices.Sensors.Compass;
      m_HandlerIID     : aliased WinRt.IID := (217179232, 48172, 22652, (152, 34, 66, 11, 160, 77, 5, 81 ));
      m_Handler        : AsyncOperationCompletedHandler_Compass.Kind := new AsyncOperationCompletedHandler_Compass.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Compass.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Compass.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Compass.Kind_Delegate, AsyncOperationCompletedHandler_Compass.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Compass do
         Hr := RoGetActivationFactory (m_hString, IID_ICompassStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_ICompass := new Windows.Devices.Sensors.ICompass;
                     Retval.m_ICompass.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Compass

   function GetCurrentReading
   (
      this : in out Compass
   )
   return WinRt.Windows.Devices.Sensors.CompassReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ICompassReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.CompassReading do
         Hr := this.m_ICompass.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_ICompassReading := new Windows.Devices.Sensors.ICompassReading;
         Retval.m_ICompassReading.all := m_ComRetVal;
      end return;
   end;

   function get_MinimumReportInterval
   (
      this : in out Compass
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICompass.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Compass;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompass.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Compass
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICompass.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Compass;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICompass.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Compass;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompass.all.remove_ReadingChanged (token);
   end;

   function get_DeviceId
   (
      this : in out Compass
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompassDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompass_Interface, WinRt.Windows.Devices.Sensors.ICompassDeviceId, WinRt.Windows.Devices.Sensors.IID_ICompassDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompass.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReadingTransform
   (
      this : in out Compass;
      value : Windows.Graphics.Display.DisplayOrientations
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompass2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompass_Interface, WinRt.Windows.Devices.Sensors.ICompass2, WinRt.Windows.Devices.Sensors.IID_ICompass2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompass.all);
      Hr := m_Interface.put_ReadingTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReadingTransform
   (
      this : in out Compass
   )
   return WinRt.Windows.Graphics.Display.DisplayOrientations is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompass2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.Display.DisplayOrientations;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompass_Interface, WinRt.Windows.Devices.Sensors.ICompass2, WinRt.Windows.Devices.Sensors.IID_ICompass2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompass.all);
      Hr := m_Interface.get_ReadingTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ReportLatency
   (
      this : in out Compass;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompass3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompass_Interface, WinRt.Windows.Devices.Sensors.ICompass3, WinRt.Windows.Devices.Sensors.IID_ICompass3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompass.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out Compass
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompass3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompass_Interface, WinRt.Windows.Devices.Sensors.ICompass3, WinRt.Windows.Devices.Sensors.IID_ICompass3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompass.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out Compass
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompass3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompass_Interface, WinRt.Windows.Devices.Sensors.ICompass3, WinRt.Windows.Devices.Sensors.IID_ICompass3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompass.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReportThreshold
   (
      this : in out Compass
   )
   return WinRt.Windows.Devices.Sensors.CompassDataThreshold'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompass4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ICompassDataThreshold;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompass_Interface, WinRt.Windows.Devices.Sensors.ICompass4, WinRt.Windows.Devices.Sensors.IID_ICompass4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.CompassDataThreshold do
         m_Interface := QInterface (this.m_ICompass.all);
         Hr := m_Interface.get_ReportThreshold (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ICompassDataThreshold := new Windows.Devices.Sensors.ICompassDataThreshold;
         Retval.m_ICompassDataThreshold.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompassDataThreshold

   procedure Initialize (this : in out CompassDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompassDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompassDataThreshold, ICompassDataThreshold_Ptr);
   begin
      if this.m_ICompassDataThreshold /= null then
         if this.m_ICompassDataThreshold.all /= null then
            RefCount := this.m_ICompassDataThreshold.all.Release;
            Free (this.m_ICompassDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompassDataThreshold

   function get_Degrees
   (
      this : in out CompassDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_ICompassDataThreshold.all.get_Degrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Degrees
   (
      this : in out CompassDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompassDataThreshold.all.put_Degrees (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompassReading

   procedure Initialize (this : in out CompassReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompassReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompassReading, ICompassReading_Ptr);
   begin
      if this.m_ICompassReading /= null then
         if this.m_ICompassReading.all /= null then
            RefCount := this.m_ICompassReading.all.Release;
            Free (this.m_ICompassReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompassReading

   function get_Timestamp
   (
      this : in out CompassReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICompassReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_HeadingMagneticNorth
   (
      this : in out CompassReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_ICompassReading.all.get_HeadingMagneticNorth (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_HeadingTrueNorth
   (
      this : in out CompassReading
   )
   return IReference_Double.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Double.Kind;
   begin
      Hr := this.m_ICompassReading.all.get_HeadingTrueNorth (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_Double (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_HeadingAccuracy
   (
      this : in out CompassReading
   )
   return WinRt.Windows.Devices.Sensors.MagnetometerAccuracy is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompassReadingHeadingAccuracy := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.MagnetometerAccuracy;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompassReading_Interface, WinRt.Windows.Devices.Sensors.ICompassReadingHeadingAccuracy, WinRt.Windows.Devices.Sensors.IID_ICompassReadingHeadingAccuracy'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompassReading.all);
      Hr := m_Interface.get_HeadingAccuracy (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out CompassReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompassReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompassReading_Interface, WinRt.Windows.Devices.Sensors.ICompassReading2, WinRt.Windows.Devices.Sensors.IID_ICompassReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompassReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out CompassReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ICompassReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ICompassReading_Interface, WinRt.Windows.Devices.Sensors.ICompassReading2, WinRt.Windows.Devices.Sensors.IID_ICompassReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompassReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompassReadingChangedEventArgs

   procedure Initialize (this : in out CompassReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompassReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompassReadingChangedEventArgs, ICompassReadingChangedEventArgs_Ptr);
   begin
      if this.m_ICompassReadingChangedEventArgs /= null then
         if this.m_ICompassReadingChangedEventArgs.all /= null then
            RefCount := this.m_ICompassReadingChangedEventArgs.all.Release;
            Free (this.m_ICompassReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompassReadingChangedEventArgs

   function get_Reading
   (
      this : in out CompassReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.CompassReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ICompassReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.CompassReading do
         Hr := this.m_ICompassReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_ICompassReading := new Windows.Devices.Sensors.ICompassReading;
         Retval.m_ICompassReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Gyrometer

   procedure Initialize (this : in out Gyrometer) is
   begin
      null;
   end;

   procedure Finalize (this : in out Gyrometer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGyrometer, IGyrometer_Ptr);
   begin
      if this.m_IGyrometer /= null then
         if this.m_IGyrometer.all /= null then
            RefCount := this.m_IGyrometer.all.Release;
            Free (this.m_IGyrometer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Gyrometer

   function GetDeviceSelector_Gyrometer
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Gyrometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IGyrometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGyrometerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_Gyrometer
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.Gyrometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Gyrometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IGyrometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Gyrometer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Gyrometer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IGyrometer;
      m_IID            : aliased WinRt.IID := (4243487423, 7631, 20684, (185, 27, 122, 31, 89, 224, 194, 139 )); -- Windows.Devices.Sensors.Gyrometer;
      m_HandlerIID     : aliased WinRt.IID := (360289537, 38286, 21269, (162, 74, 13, 125, 122, 203, 199, 156 ));
      m_Handler        : AsyncOperationCompletedHandler_Gyrometer.Kind := new AsyncOperationCompletedHandler_Gyrometer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Gyrometer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Gyrometer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Gyrometer.Kind_Delegate, AsyncOperationCompletedHandler_Gyrometer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Gyrometer do
         Hr := RoGetActivationFactory (m_hString, IID_IGyrometerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IGyrometer := new Windows.Devices.Sensors.IGyrometer;
                     Retval.m_IGyrometer.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDefault
   return WinRt.Windows.Devices.Sensors.Gyrometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Gyrometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IGyrometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IGyrometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Gyrometer do
         Hr := RoGetActivationFactory (m_hString, IID_IGyrometerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IGyrometer := new Windows.Devices.Sensors.IGyrometer;
            Retval.m_IGyrometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Gyrometer

   function GetCurrentReading
   (
      this : in out Gyrometer
   )
   return WinRt.Windows.Devices.Sensors.GyrometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IGyrometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.GyrometerReading do
         Hr := this.m_IGyrometer.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IGyrometerReading := new Windows.Devices.Sensors.IGyrometerReading;
         Retval.m_IGyrometerReading.all := m_ComRetVal;
      end return;
   end;

   function get_MinimumReportInterval
   (
      this : in out Gyrometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IGyrometer.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Gyrometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGyrometer.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Gyrometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IGyrometer.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Gyrometer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGyrometer.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Gyrometer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGyrometer.all.remove_ReadingChanged (token);
   end;

   function get_DeviceId
   (
      this : in out Gyrometer
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometerDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometer_Interface, WinRt.Windows.Devices.Sensors.IGyrometerDeviceId, WinRt.Windows.Devices.Sensors.IID_IGyrometerDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometer.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReadingTransform
   (
      this : in out Gyrometer;
      value : Windows.Graphics.Display.DisplayOrientations
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometer_Interface, WinRt.Windows.Devices.Sensors.IGyrometer2, WinRt.Windows.Devices.Sensors.IID_IGyrometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometer.all);
      Hr := m_Interface.put_ReadingTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReadingTransform
   (
      this : in out Gyrometer
   )
   return WinRt.Windows.Graphics.Display.DisplayOrientations is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.Display.DisplayOrientations;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometer_Interface, WinRt.Windows.Devices.Sensors.IGyrometer2, WinRt.Windows.Devices.Sensors.IID_IGyrometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometer.all);
      Hr := m_Interface.get_ReadingTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ReportLatency
   (
      this : in out Gyrometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometer_Interface, WinRt.Windows.Devices.Sensors.IGyrometer3, WinRt.Windows.Devices.Sensors.IID_IGyrometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometer.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out Gyrometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometer_Interface, WinRt.Windows.Devices.Sensors.IGyrometer3, WinRt.Windows.Devices.Sensors.IID_IGyrometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometer.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out Gyrometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometer_Interface, WinRt.Windows.Devices.Sensors.IGyrometer3, WinRt.Windows.Devices.Sensors.IID_IGyrometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometer.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReportThreshold
   (
      this : in out Gyrometer
   )
   return WinRt.Windows.Devices.Sensors.GyrometerDataThreshold'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometer4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IGyrometerDataThreshold;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometer_Interface, WinRt.Windows.Devices.Sensors.IGyrometer4, WinRt.Windows.Devices.Sensors.IID_IGyrometer4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.GyrometerDataThreshold do
         m_Interface := QInterface (this.m_IGyrometer.all);
         Hr := m_Interface.get_ReportThreshold (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IGyrometerDataThreshold := new Windows.Devices.Sensors.IGyrometerDataThreshold;
         Retval.m_IGyrometerDataThreshold.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GyrometerDataThreshold

   procedure Initialize (this : in out GyrometerDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out GyrometerDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGyrometerDataThreshold, IGyrometerDataThreshold_Ptr);
   begin
      if this.m_IGyrometerDataThreshold /= null then
         if this.m_IGyrometerDataThreshold.all /= null then
            RefCount := this.m_IGyrometerDataThreshold.all.Release;
            Free (this.m_IGyrometerDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GyrometerDataThreshold

   function get_XAxisInDegreesPerSecond
   (
      this : in out GyrometerDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGyrometerDataThreshold.all.get_XAxisInDegreesPerSecond (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_XAxisInDegreesPerSecond
   (
      this : in out GyrometerDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGyrometerDataThreshold.all.put_XAxisInDegreesPerSecond (value);
   end;

   function get_YAxisInDegreesPerSecond
   (
      this : in out GyrometerDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGyrometerDataThreshold.all.get_YAxisInDegreesPerSecond (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_YAxisInDegreesPerSecond
   (
      this : in out GyrometerDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGyrometerDataThreshold.all.put_YAxisInDegreesPerSecond (value);
   end;

   function get_ZAxisInDegreesPerSecond
   (
      this : in out GyrometerDataThreshold
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGyrometerDataThreshold.all.get_ZAxisInDegreesPerSecond (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ZAxisInDegreesPerSecond
   (
      this : in out GyrometerDataThreshold;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGyrometerDataThreshold.all.put_ZAxisInDegreesPerSecond (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GyrometerReading

   procedure Initialize (this : in out GyrometerReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out GyrometerReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGyrometerReading, IGyrometerReading_Ptr);
   begin
      if this.m_IGyrometerReading /= null then
         if this.m_IGyrometerReading.all /= null then
            RefCount := this.m_IGyrometerReading.all.Release;
            Free (this.m_IGyrometerReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GyrometerReading

   function get_Timestamp
   (
      this : in out GyrometerReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IGyrometerReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AngularVelocityX
   (
      this : in out GyrometerReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGyrometerReading.all.get_AngularVelocityX (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AngularVelocityY
   (
      this : in out GyrometerReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGyrometerReading.all.get_AngularVelocityY (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AngularVelocityZ
   (
      this : in out GyrometerReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IGyrometerReading.all.get_AngularVelocityZ (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out GyrometerReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometerReading_Interface, WinRt.Windows.Devices.Sensors.IGyrometerReading2, WinRt.Windows.Devices.Sensors.IID_IGyrometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometerReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out GyrometerReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IGyrometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IGyrometerReading_Interface, WinRt.Windows.Devices.Sensors.IGyrometerReading2, WinRt.Windows.Devices.Sensors.IID_IGyrometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGyrometerReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GyrometerReadingChangedEventArgs

   procedure Initialize (this : in out GyrometerReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out GyrometerReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGyrometerReadingChangedEventArgs, IGyrometerReadingChangedEventArgs_Ptr);
   begin
      if this.m_IGyrometerReadingChangedEventArgs /= null then
         if this.m_IGyrometerReadingChangedEventArgs.all /= null then
            RefCount := this.m_IGyrometerReadingChangedEventArgs.all.Release;
            Free (this.m_IGyrometerReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GyrometerReadingChangedEventArgs

   function get_Reading
   (
      this : in out GyrometerReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.GyrometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IGyrometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.GyrometerReading do
         Hr := this.m_IGyrometerReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IGyrometerReading := new Windows.Devices.Sensors.IGyrometerReading;
         Retval.m_IGyrometerReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HingeAngleReading

   procedure Initialize (this : in out HingeAngleReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out HingeAngleReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHingeAngleReading, IHingeAngleReading_Ptr);
   begin
      if this.m_IHingeAngleReading /= null then
         if this.m_IHingeAngleReading.all /= null then
            RefCount := this.m_IHingeAngleReading.all.Release;
            Free (this.m_IHingeAngleReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HingeAngleReading

   function get_Timestamp
   (
      this : in out HingeAngleReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IHingeAngleReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AngleInDegrees
   (
      this : in out HingeAngleReading
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IHingeAngleReading.all.get_AngleInDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out HingeAngleReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
   begin
      Hr := this.m_IHingeAngleReading.all.get_Properties (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HingeAngleSensor

   procedure Initialize (this : in out HingeAngleSensor) is
   begin
      null;
   end;

   procedure Finalize (this : in out HingeAngleSensor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHingeAngleSensor, IHingeAngleSensor_Ptr);
   begin
      if this.m_IHingeAngleSensor /= null then
         if this.m_IHingeAngleSensor.all /= null then
            RefCount := this.m_IHingeAngleSensor.all.Release;
            Free (this.m_IHingeAngleSensor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for HingeAngleSensor

   function GetDeviceSelector_HingeAngleSensor
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.HingeAngleSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IHingeAngleSensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IHingeAngleSensorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetDefaultAsync_HingeAngleSensor
   return WinRt.Windows.Devices.Sensors.HingeAngleSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.HingeAngleSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IHingeAngleSensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_HingeAngleSensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HingeAngleSensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IHingeAngleSensor;
      m_IID            : aliased WinRt.IID := (1335460215, 16512, 22232, (169, 111, 157, 91, 85, 148, 78, 85 )); -- Windows.Devices.Sensors.HingeAngleSensor;
      m_HandlerIID     : aliased WinRt.IID := (2888964289, 15032, 23590, (147, 108, 0, 190, 64, 90, 198, 139 ));
      m_Handler        : AsyncOperationCompletedHandler_HingeAngleSensor.Kind := new AsyncOperationCompletedHandler_HingeAngleSensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HingeAngleSensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HingeAngleSensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HingeAngleSensor.Kind_Delegate, AsyncOperationCompletedHandler_HingeAngleSensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.HingeAngleSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IHingeAngleSensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefaultAsync (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IHingeAngleSensor := new Windows.Devices.Sensors.IHingeAngleSensor;
                     Retval.m_IHingeAngleSensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRelatedToAdjacentPanelsAsync
   (
      firstPanelId : WinRt.WString;
      secondPanelId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.HingeAngleSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.HingeAngleSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IHingeAngleSensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_firstPanelId : WinRt.HString := To_HString (firstPanelId);
      HStr_secondPanelId : WinRt.HString := To_HString (secondPanelId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_HingeAngleSensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HingeAngleSensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IHingeAngleSensor;
      m_IID            : aliased WinRt.IID := (1335460215, 16512, 22232, (169, 111, 157, 91, 85, 148, 78, 85 )); -- Windows.Devices.Sensors.HingeAngleSensor;
      m_HandlerIID     : aliased WinRt.IID := (2888964289, 15032, 23590, (147, 108, 0, 190, 64, 90, 198, 139 ));
      m_Handler        : AsyncOperationCompletedHandler_HingeAngleSensor.Kind := new AsyncOperationCompletedHandler_HingeAngleSensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HingeAngleSensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HingeAngleSensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HingeAngleSensor.Kind_Delegate, AsyncOperationCompletedHandler_HingeAngleSensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.HingeAngleSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IHingeAngleSensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetRelatedToAdjacentPanelsAsync (HStr_firstPanelId, HStr_secondPanelId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IHingeAngleSensor := new Windows.Devices.Sensors.IHingeAngleSensor;
                     Retval.m_IHingeAngleSensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_firstPanelId);
         Hr := WindowsDeleteString (HStr_secondPanelId);
      end return;
   end;

   function FromIdAsync_HingeAngleSensor
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.HingeAngleSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.HingeAngleSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IHingeAngleSensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_HingeAngleSensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HingeAngleSensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IHingeAngleSensor;
      m_IID            : aliased WinRt.IID := (1335460215, 16512, 22232, (169, 111, 157, 91, 85, 148, 78, 85 )); -- Windows.Devices.Sensors.HingeAngleSensor;
      m_HandlerIID     : aliased WinRt.IID := (2888964289, 15032, 23590, (147, 108, 0, 190, 64, 90, 198, 139 ));
      m_Handler        : AsyncOperationCompletedHandler_HingeAngleSensor.Kind := new AsyncOperationCompletedHandler_HingeAngleSensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HingeAngleSensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HingeAngleSensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HingeAngleSensor.Kind_Delegate, AsyncOperationCompletedHandler_HingeAngleSensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.HingeAngleSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IHingeAngleSensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IHingeAngleSensor := new Windows.Devices.Sensors.IHingeAngleSensor;
                     Retval.m_IHingeAngleSensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HingeAngleSensor

   function GetCurrentReadingAsync
   (
      this : in out HingeAngleSensor
   )
   return WinRt.Windows.Devices.Sensors.HingeAngleReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_HingeAngleReading.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HingeAngleReading.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IHingeAngleReading;
      m_IID            : aliased WinRt.IID := (1891943840, 48330, 21031, (150, 240, 23, 250, 83, 83, 155, 232 )); -- Windows.Devices.Sensors.HingeAngleReading;
      m_HandlerIID     : aliased WinRt.IID := (3770200478, 38002, 24573, (155, 222, 238, 230, 77, 239, 124, 79 ));
      m_Handler        : AsyncOperationCompletedHandler_HingeAngleReading.Kind := new AsyncOperationCompletedHandler_HingeAngleReading.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HingeAngleReading.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HingeAngleReading.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HingeAngleReading.Kind_Delegate, AsyncOperationCompletedHandler_HingeAngleReading.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.HingeAngleReading do
         Hr := this.m_IHingeAngleSensor.all.GetCurrentReadingAsync (m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IHingeAngleReading := new Windows.Devices.Sensors.IHingeAngleReading;
                  Retval.m_IHingeAngleReading.all := m_RetVal;
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function get_DeviceId
   (
      this : in out HingeAngleSensor
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IHingeAngleSensor.all.get_DeviceId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_MinReportThresholdInDegrees
   (
      this : in out HingeAngleSensor
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IHingeAngleSensor.all.get_MinReportThresholdInDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_ReportThresholdInDegrees
   (
      this : in out HingeAngleSensor
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IHingeAngleSensor.all.get_ReportThresholdInDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportThresholdInDegrees
   (
      this : in out HingeAngleSensor;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IHingeAngleSensor.all.put_ReportThresholdInDegrees (value);
   end;

   function add_ReadingChanged
   (
      this : in out HingeAngleSensor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHingeAngleSensor.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out HingeAngleSensor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IHingeAngleSensor.all.remove_ReadingChanged (token);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HingeAngleSensorReadingChangedEventArgs

   procedure Initialize (this : in out HingeAngleSensorReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HingeAngleSensorReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHingeAngleSensorReadingChangedEventArgs, IHingeAngleSensorReadingChangedEventArgs_Ptr);
   begin
      if this.m_IHingeAngleSensorReadingChangedEventArgs /= null then
         if this.m_IHingeAngleSensorReadingChangedEventArgs.all /= null then
            RefCount := this.m_IHingeAngleSensorReadingChangedEventArgs.all.Release;
            Free (this.m_IHingeAngleSensorReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HingeAngleSensorReadingChangedEventArgs

   function get_Reading
   (
      this : in out HingeAngleSensorReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.HingeAngleReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IHingeAngleReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.HingeAngleReading do
         Hr := this.m_IHingeAngleSensorReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IHingeAngleReading := new Windows.Devices.Sensors.IHingeAngleReading;
         Retval.m_IHingeAngleReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Inclinometer

   procedure Initialize (this : in out Inclinometer) is
   begin
      null;
   end;

   procedure Finalize (this : in out Inclinometer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInclinometer, IInclinometer_Ptr);
   begin
      if this.m_IInclinometer /= null then
         if this.m_IInclinometer.all /= null then
            RefCount := this.m_IInclinometer.all.Release;
            Free (this.m_IInclinometer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Inclinometer

   function GetDefault
   (
      sensorReadingtype : Windows.Devices.Sensors.SensorReadingType
   )
   return WinRt.Windows.Devices.Sensors.Inclinometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Inclinometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IInclinometerStatics3_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IInclinometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Inclinometer do
         Hr := RoGetActivationFactory (m_hString, IID_IInclinometerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (sensorReadingtype, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IInclinometer := new Windows.Devices.Sensors.IInclinometer;
            Retval.m_IInclinometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDefaultForRelativeReadings
   return WinRt.Windows.Devices.Sensors.Inclinometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Inclinometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IInclinometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IInclinometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Inclinometer do
         Hr := RoGetActivationFactory (m_hString, IID_IInclinometerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefaultForRelativeReadings (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IInclinometer := new Windows.Devices.Sensors.IInclinometer;
            Retval.m_IInclinometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDefault
   return WinRt.Windows.Devices.Sensors.Inclinometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Inclinometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IInclinometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IInclinometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Inclinometer do
         Hr := RoGetActivationFactory (m_hString, IID_IInclinometerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IInclinometer := new Windows.Devices.Sensors.IInclinometer;
            Retval.m_IInclinometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDeviceSelector
   (
      readingType : Windows.Devices.Sensors.SensorReadingType
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Inclinometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IInclinometerStatics4_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IInclinometerStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (readingType, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_Inclinometer
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.Inclinometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Inclinometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IInclinometerStatics4_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Inclinometer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Inclinometer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IInclinometer;
      m_IID            : aliased WinRt.IID := (2230039702, 46746, 21453, (182, 144, 164, 97, 137, 130, 43, 1 )); -- Windows.Devices.Sensors.Inclinometer;
      m_HandlerIID     : aliased WinRt.IID := (2400116266, 11535, 22006, (149, 102, 60, 33, 56, 95, 174, 100 ));
      m_Handler        : AsyncOperationCompletedHandler_Inclinometer.Kind := new AsyncOperationCompletedHandler_Inclinometer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Inclinometer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Inclinometer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Inclinometer.Kind_Delegate, AsyncOperationCompletedHandler_Inclinometer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Inclinometer do
         Hr := RoGetActivationFactory (m_hString, IID_IInclinometerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IInclinometer := new Windows.Devices.Sensors.IInclinometer;
                     Retval.m_IInclinometer.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Inclinometer

   function GetCurrentReading
   (
      this : in out Inclinometer
   )
   return WinRt.Windows.Devices.Sensors.InclinometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IInclinometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.InclinometerReading do
         Hr := this.m_IInclinometer.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IInclinometerReading := new Windows.Devices.Sensors.IInclinometerReading;
         Retval.m_IInclinometerReading.all := m_ComRetVal;
      end return;
   end;

   function get_MinimumReportInterval
   (
      this : in out Inclinometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IInclinometer.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Inclinometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInclinometer.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Inclinometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IInclinometer.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Inclinometer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInclinometer.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Inclinometer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInclinometer.all.remove_ReadingChanged (token);
   end;

   function get_DeviceId
   (
      this : in out Inclinometer
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometerDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometerDeviceId, WinRt.Windows.Devices.Sensors.IID_IInclinometerDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometer.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReadingTransform
   (
      this : in out Inclinometer;
      value : Windows.Graphics.Display.DisplayOrientations
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometer2, WinRt.Windows.Devices.Sensors.IID_IInclinometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometer.all);
      Hr := m_Interface.put_ReadingTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReadingTransform
   (
      this : in out Inclinometer
   )
   return WinRt.Windows.Graphics.Display.DisplayOrientations is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.Display.DisplayOrientations;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometer2, WinRt.Windows.Devices.Sensors.IID_IInclinometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometer.all);
      Hr := m_Interface.get_ReadingTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReadingType
   (
      this : in out Inclinometer
   )
   return WinRt.Windows.Devices.Sensors.SensorReadingType is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.SensorReadingType;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometer2, WinRt.Windows.Devices.Sensors.IID_IInclinometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometer.all);
      Hr := m_Interface.get_ReadingType (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ReportLatency
   (
      this : in out Inclinometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometer3, WinRt.Windows.Devices.Sensors.IID_IInclinometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometer.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out Inclinometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometer3, WinRt.Windows.Devices.Sensors.IID_IInclinometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometer.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out Inclinometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometer3, WinRt.Windows.Devices.Sensors.IID_IInclinometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometer.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReportThreshold
   (
      this : in out Inclinometer
   )
   return WinRt.Windows.Devices.Sensors.InclinometerDataThreshold'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometer4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IInclinometerDataThreshold;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometer_Interface, WinRt.Windows.Devices.Sensors.IInclinometer4, WinRt.Windows.Devices.Sensors.IID_IInclinometer4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.InclinometerDataThreshold do
         m_Interface := QInterface (this.m_IInclinometer.all);
         Hr := m_Interface.get_ReportThreshold (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IInclinometerDataThreshold := new Windows.Devices.Sensors.IInclinometerDataThreshold;
         Retval.m_IInclinometerDataThreshold.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InclinometerDataThreshold

   procedure Initialize (this : in out InclinometerDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out InclinometerDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInclinometerDataThreshold, IInclinometerDataThreshold_Ptr);
   begin
      if this.m_IInclinometerDataThreshold /= null then
         if this.m_IInclinometerDataThreshold.all /= null then
            RefCount := this.m_IInclinometerDataThreshold.all.Release;
            Free (this.m_IInclinometerDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InclinometerDataThreshold

   function get_PitchInDegrees
   (
      this : in out InclinometerDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInclinometerDataThreshold.all.get_PitchInDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_PitchInDegrees
   (
      this : in out InclinometerDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInclinometerDataThreshold.all.put_PitchInDegrees (value);
   end;

   function get_RollInDegrees
   (
      this : in out InclinometerDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInclinometerDataThreshold.all.get_RollInDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RollInDegrees
   (
      this : in out InclinometerDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInclinometerDataThreshold.all.put_RollInDegrees (value);
   end;

   function get_YawInDegrees
   (
      this : in out InclinometerDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInclinometerDataThreshold.all.get_YawInDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_YawInDegrees
   (
      this : in out InclinometerDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInclinometerDataThreshold.all.put_YawInDegrees (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InclinometerReading

   procedure Initialize (this : in out InclinometerReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out InclinometerReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInclinometerReading, IInclinometerReading_Ptr);
   begin
      if this.m_IInclinometerReading /= null then
         if this.m_IInclinometerReading.all /= null then
            RefCount := this.m_IInclinometerReading.all.Release;
            Free (this.m_IInclinometerReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InclinometerReading

   function get_Timestamp
   (
      this : in out InclinometerReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IInclinometerReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PitchDegrees
   (
      this : in out InclinometerReading
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInclinometerReading.all.get_PitchDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_RollDegrees
   (
      this : in out InclinometerReading
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInclinometerReading.all.get_RollDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_YawDegrees
   (
      this : in out InclinometerReading
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInclinometerReading.all.get_YawDegrees (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_YawAccuracy
   (
      this : in out InclinometerReading
   )
   return WinRt.Windows.Devices.Sensors.MagnetometerAccuracy is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometerReadingYawAccuracy := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.MagnetometerAccuracy;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometerReading_Interface, WinRt.Windows.Devices.Sensors.IInclinometerReadingYawAccuracy, WinRt.Windows.Devices.Sensors.IID_IInclinometerReadingYawAccuracy'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometerReading.all);
      Hr := m_Interface.get_YawAccuracy (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out InclinometerReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometerReading_Interface, WinRt.Windows.Devices.Sensors.IInclinometerReading2, WinRt.Windows.Devices.Sensors.IID_IInclinometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometerReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out InclinometerReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IInclinometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IInclinometerReading_Interface, WinRt.Windows.Devices.Sensors.IInclinometerReading2, WinRt.Windows.Devices.Sensors.IID_IInclinometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInclinometerReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InclinometerReadingChangedEventArgs

   procedure Initialize (this : in out InclinometerReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InclinometerReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInclinometerReadingChangedEventArgs, IInclinometerReadingChangedEventArgs_Ptr);
   begin
      if this.m_IInclinometerReadingChangedEventArgs /= null then
         if this.m_IInclinometerReadingChangedEventArgs.all /= null then
            RefCount := this.m_IInclinometerReadingChangedEventArgs.all.Release;
            Free (this.m_IInclinometerReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InclinometerReadingChangedEventArgs

   function get_Reading
   (
      this : in out InclinometerReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.InclinometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IInclinometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.InclinometerReading do
         Hr := this.m_IInclinometerReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IInclinometerReading := new Windows.Devices.Sensors.IInclinometerReading;
         Retval.m_IInclinometerReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LightSensor

   procedure Initialize (this : in out LightSensor) is
   begin
      null;
   end;

   procedure Finalize (this : in out LightSensor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILightSensor, ILightSensor_Ptr);
   begin
      if this.m_ILightSensor /= null then
         if this.m_ILightSensor.all /= null then
            RefCount := this.m_ILightSensor.all.Release;
            Free (this.m_ILightSensor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LightSensor

   function GetDeviceSelector_LightSensor
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.LightSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ILightSensorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ILightSensorStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_LightSensor
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.LightSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.LightSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ILightSensorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_LightSensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_LightSensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.ILightSensor;
      m_IID            : aliased WinRt.IID := (940464428, 18336, 24052, (141, 226, 178, 238, 250, 157, 184, 173 )); -- Windows.Devices.Sensors.LightSensor;
      m_HandlerIID     : aliased WinRt.IID := (1560601279, 20835, 21048, (143, 35, 206, 71, 11, 48, 52, 13 ));
      m_Handler        : AsyncOperationCompletedHandler_LightSensor.Kind := new AsyncOperationCompletedHandler_LightSensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_LightSensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_LightSensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_LightSensor.Kind_Delegate, AsyncOperationCompletedHandler_LightSensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.LightSensor do
         Hr := RoGetActivationFactory (m_hString, IID_ILightSensorStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_ILightSensor := new Windows.Devices.Sensors.ILightSensor;
                     Retval.m_ILightSensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDefault
   return WinRt.Windows.Devices.Sensors.LightSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.LightSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ILightSensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ILightSensor;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.LightSensor do
         Hr := RoGetActivationFactory (m_hString, IID_ILightSensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_ILightSensor := new Windows.Devices.Sensors.ILightSensor;
            Retval.m_ILightSensor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LightSensor

   function GetCurrentReading
   (
      this : in out LightSensor
   )
   return WinRt.Windows.Devices.Sensors.LightSensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ILightSensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.LightSensorReading do
         Hr := this.m_ILightSensor.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_ILightSensorReading := new Windows.Devices.Sensors.ILightSensorReading;
         Retval.m_ILightSensorReading.all := m_ComRetVal;
      end return;
   end;

   function get_MinimumReportInterval
   (
      this : in out LightSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ILightSensor.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out LightSensor;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILightSensor.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out LightSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ILightSensor.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out LightSensor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILightSensor.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out LightSensor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILightSensor.all.remove_ReadingChanged (token);
   end;

   function get_DeviceId
   (
      this : in out LightSensor
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ILightSensorDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ILightSensor_Interface, WinRt.Windows.Devices.Sensors.ILightSensorDeviceId, WinRt.Windows.Devices.Sensors.IID_ILightSensorDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILightSensor.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReportLatency
   (
      this : in out LightSensor;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ILightSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ILightSensor_Interface, WinRt.Windows.Devices.Sensors.ILightSensor2, WinRt.Windows.Devices.Sensors.IID_ILightSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILightSensor.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out LightSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ILightSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ILightSensor_Interface, WinRt.Windows.Devices.Sensors.ILightSensor2, WinRt.Windows.Devices.Sensors.IID_ILightSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILightSensor.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out LightSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ILightSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ILightSensor_Interface, WinRt.Windows.Devices.Sensors.ILightSensor2, WinRt.Windows.Devices.Sensors.IID_ILightSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILightSensor.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReportThreshold
   (
      this : in out LightSensor
   )
   return WinRt.Windows.Devices.Sensors.LightSensorDataThreshold'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ILightSensor3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ILightSensorDataThreshold;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ILightSensor_Interface, WinRt.Windows.Devices.Sensors.ILightSensor3, WinRt.Windows.Devices.Sensors.IID_ILightSensor3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.LightSensorDataThreshold do
         m_Interface := QInterface (this.m_ILightSensor.all);
         Hr := m_Interface.get_ReportThreshold (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ILightSensorDataThreshold := new Windows.Devices.Sensors.ILightSensorDataThreshold;
         Retval.m_ILightSensorDataThreshold.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LightSensorDataThreshold

   procedure Initialize (this : in out LightSensorDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out LightSensorDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILightSensorDataThreshold, ILightSensorDataThreshold_Ptr);
   begin
      if this.m_ILightSensorDataThreshold /= null then
         if this.m_ILightSensorDataThreshold.all /= null then
            RefCount := this.m_ILightSensorDataThreshold.all.Release;
            Free (this.m_ILightSensorDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LightSensorDataThreshold

   function get_LuxPercentage
   (
      this : in out LightSensorDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ILightSensorDataThreshold.all.get_LuxPercentage (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_LuxPercentage
   (
      this : in out LightSensorDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILightSensorDataThreshold.all.put_LuxPercentage (value);
   end;

   function get_AbsoluteLux
   (
      this : in out LightSensorDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ILightSensorDataThreshold.all.get_AbsoluteLux (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AbsoluteLux
   (
      this : in out LightSensorDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILightSensorDataThreshold.all.put_AbsoluteLux (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LightSensorReading

   procedure Initialize (this : in out LightSensorReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out LightSensorReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILightSensorReading, ILightSensorReading_Ptr);
   begin
      if this.m_ILightSensorReading /= null then
         if this.m_ILightSensorReading.all /= null then
            RefCount := this.m_ILightSensorReading.all.Release;
            Free (this.m_ILightSensorReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LightSensorReading

   function get_Timestamp
   (
      this : in out LightSensorReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_ILightSensorReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IlluminanceInLux
   (
      this : in out LightSensorReading
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ILightSensorReading.all.get_IlluminanceInLux (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out LightSensorReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ILightSensorReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ILightSensorReading_Interface, WinRt.Windows.Devices.Sensors.ILightSensorReading2, WinRt.Windows.Devices.Sensors.IID_ILightSensorReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILightSensorReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out LightSensorReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ILightSensorReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ILightSensorReading_Interface, WinRt.Windows.Devices.Sensors.ILightSensorReading2, WinRt.Windows.Devices.Sensors.IID_ILightSensorReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILightSensorReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LightSensorReadingChangedEventArgs

   procedure Initialize (this : in out LightSensorReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out LightSensorReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILightSensorReadingChangedEventArgs, ILightSensorReadingChangedEventArgs_Ptr);
   begin
      if this.m_ILightSensorReadingChangedEventArgs /= null then
         if this.m_ILightSensorReadingChangedEventArgs.all /= null then
            RefCount := this.m_ILightSensorReadingChangedEventArgs.all.Release;
            Free (this.m_ILightSensorReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LightSensorReadingChangedEventArgs

   function get_Reading
   (
      this : in out LightSensorReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.LightSensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ILightSensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.LightSensorReading do
         Hr := this.m_ILightSensorReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_ILightSensorReading := new Windows.Devices.Sensors.ILightSensorReading;
         Retval.m_ILightSensorReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Magnetometer

   procedure Initialize (this : in out Magnetometer) is
   begin
      null;
   end;

   procedure Finalize (this : in out Magnetometer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMagnetometer, IMagnetometer_Ptr);
   begin
      if this.m_IMagnetometer /= null then
         if this.m_IMagnetometer.all /= null then
            RefCount := this.m_IMagnetometer.all.Release;
            Free (this.m_IMagnetometer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Magnetometer

   function GetDeviceSelector_Magnetometer
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Magnetometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IMagnetometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMagnetometerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_Magnetometer
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.Magnetometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Magnetometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IMagnetometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Magnetometer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Magnetometer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IMagnetometer;
      m_IID            : aliased WinRt.IID := (2957333571, 59280, 23203, (135, 103, 73, 50, 3, 34, 116, 238 )); -- Windows.Devices.Sensors.Magnetometer;
      m_HandlerIID     : aliased WinRt.IID := (1189128040, 38469, 20902, (182, 167, 30, 95, 75, 64, 225, 243 ));
      m_Handler        : AsyncOperationCompletedHandler_Magnetometer.Kind := new AsyncOperationCompletedHandler_Magnetometer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Magnetometer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Magnetometer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Magnetometer.Kind_Delegate, AsyncOperationCompletedHandler_Magnetometer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Magnetometer do
         Hr := RoGetActivationFactory (m_hString, IID_IMagnetometerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IMagnetometer := new Windows.Devices.Sensors.IMagnetometer;
                     Retval.m_IMagnetometer.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDefault
   return WinRt.Windows.Devices.Sensors.Magnetometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Magnetometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IMagnetometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IMagnetometer;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Magnetometer do
         Hr := RoGetActivationFactory (m_hString, IID_IMagnetometerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IMagnetometer := new Windows.Devices.Sensors.IMagnetometer;
            Retval.m_IMagnetometer.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Magnetometer

   function GetCurrentReading
   (
      this : in out Magnetometer
   )
   return WinRt.Windows.Devices.Sensors.MagnetometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IMagnetometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.MagnetometerReading do
         Hr := this.m_IMagnetometer.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IMagnetometerReading := new Windows.Devices.Sensors.IMagnetometerReading;
         Retval.m_IMagnetometerReading.all := m_ComRetVal;
      end return;
   end;

   function get_MinimumReportInterval
   (
      this : in out Magnetometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IMagnetometer.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Magnetometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMagnetometer.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Magnetometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IMagnetometer.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Magnetometer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMagnetometer.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Magnetometer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMagnetometer.all.remove_ReadingChanged (token);
   end;

   function get_DeviceId
   (
      this : in out Magnetometer
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometerDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometer_Interface, WinRt.Windows.Devices.Sensors.IMagnetometerDeviceId, WinRt.Windows.Devices.Sensors.IID_IMagnetometerDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometer.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReadingTransform
   (
      this : in out Magnetometer;
      value : Windows.Graphics.Display.DisplayOrientations
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometer_Interface, WinRt.Windows.Devices.Sensors.IMagnetometer2, WinRt.Windows.Devices.Sensors.IID_IMagnetometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometer.all);
      Hr := m_Interface.put_ReadingTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReadingTransform
   (
      this : in out Magnetometer
   )
   return WinRt.Windows.Graphics.Display.DisplayOrientations is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.Display.DisplayOrientations;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometer_Interface, WinRt.Windows.Devices.Sensors.IMagnetometer2, WinRt.Windows.Devices.Sensors.IID_IMagnetometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometer.all);
      Hr := m_Interface.get_ReadingTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ReportLatency
   (
      this : in out Magnetometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometer_Interface, WinRt.Windows.Devices.Sensors.IMagnetometer3, WinRt.Windows.Devices.Sensors.IID_IMagnetometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometer.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out Magnetometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometer_Interface, WinRt.Windows.Devices.Sensors.IMagnetometer3, WinRt.Windows.Devices.Sensors.IID_IMagnetometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometer.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out Magnetometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometer3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometer_Interface, WinRt.Windows.Devices.Sensors.IMagnetometer3, WinRt.Windows.Devices.Sensors.IID_IMagnetometer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometer.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReportThreshold
   (
      this : in out Magnetometer
   )
   return WinRt.Windows.Devices.Sensors.MagnetometerDataThreshold'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometer4 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IMagnetometerDataThreshold;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometer_Interface, WinRt.Windows.Devices.Sensors.IMagnetometer4, WinRt.Windows.Devices.Sensors.IID_IMagnetometer4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.MagnetometerDataThreshold do
         m_Interface := QInterface (this.m_IMagnetometer.all);
         Hr := m_Interface.get_ReportThreshold (m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IMagnetometerDataThreshold := new Windows.Devices.Sensors.IMagnetometerDataThreshold;
         Retval.m_IMagnetometerDataThreshold.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MagnetometerDataThreshold

   procedure Initialize (this : in out MagnetometerDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out MagnetometerDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMagnetometerDataThreshold, IMagnetometerDataThreshold_Ptr);
   begin
      if this.m_IMagnetometerDataThreshold /= null then
         if this.m_IMagnetometerDataThreshold.all /= null then
            RefCount := this.m_IMagnetometerDataThreshold.all.Release;
            Free (this.m_IMagnetometerDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MagnetometerDataThreshold

   function get_XAxisMicroteslas
   (
      this : in out MagnetometerDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMagnetometerDataThreshold.all.get_XAxisMicroteslas (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_XAxisMicroteslas
   (
      this : in out MagnetometerDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMagnetometerDataThreshold.all.put_XAxisMicroteslas (value);
   end;

   function get_YAxisMicroteslas
   (
      this : in out MagnetometerDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMagnetometerDataThreshold.all.get_YAxisMicroteslas (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_YAxisMicroteslas
   (
      this : in out MagnetometerDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMagnetometerDataThreshold.all.put_YAxisMicroteslas (value);
   end;

   function get_ZAxisMicroteslas
   (
      this : in out MagnetometerDataThreshold
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMagnetometerDataThreshold.all.get_ZAxisMicroteslas (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ZAxisMicroteslas
   (
      this : in out MagnetometerDataThreshold;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMagnetometerDataThreshold.all.put_ZAxisMicroteslas (value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MagnetometerReading

   procedure Initialize (this : in out MagnetometerReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out MagnetometerReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMagnetometerReading, IMagnetometerReading_Ptr);
   begin
      if this.m_IMagnetometerReading /= null then
         if this.m_IMagnetometerReading.all /= null then
            RefCount := this.m_IMagnetometerReading.all.Release;
            Free (this.m_IMagnetometerReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MagnetometerReading

   function get_Timestamp
   (
      this : in out MagnetometerReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IMagnetometerReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MagneticFieldX
   (
      this : in out MagnetometerReading
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMagnetometerReading.all.get_MagneticFieldX (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MagneticFieldY
   (
      this : in out MagnetometerReading
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMagnetometerReading.all.get_MagneticFieldY (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MagneticFieldZ
   (
      this : in out MagnetometerReading
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMagnetometerReading.all.get_MagneticFieldZ (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_DirectionalAccuracy
   (
      this : in out MagnetometerReading
   )
   return WinRt.Windows.Devices.Sensors.MagnetometerAccuracy is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.MagnetometerAccuracy;
   begin
      Hr := this.m_IMagnetometerReading.all.get_DirectionalAccuracy (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out MagnetometerReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometerReading_Interface, WinRt.Windows.Devices.Sensors.IMagnetometerReading2, WinRt.Windows.Devices.Sensors.IID_IMagnetometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometerReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out MagnetometerReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IMagnetometerReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IMagnetometerReading_Interface, WinRt.Windows.Devices.Sensors.IMagnetometerReading2, WinRt.Windows.Devices.Sensors.IID_IMagnetometerReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMagnetometerReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MagnetometerReadingChangedEventArgs

   procedure Initialize (this : in out MagnetometerReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out MagnetometerReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMagnetometerReadingChangedEventArgs, IMagnetometerReadingChangedEventArgs_Ptr);
   begin
      if this.m_IMagnetometerReadingChangedEventArgs /= null then
         if this.m_IMagnetometerReadingChangedEventArgs.all /= null then
            RefCount := this.m_IMagnetometerReadingChangedEventArgs.all.Release;
            Free (this.m_IMagnetometerReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MagnetometerReadingChangedEventArgs

   function get_Reading
   (
      this : in out MagnetometerReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.MagnetometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IMagnetometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.MagnetometerReading do
         Hr := this.m_IMagnetometerReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IMagnetometerReading := new Windows.Devices.Sensors.IMagnetometerReading;
         Retval.m_IMagnetometerReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for OrientationSensor

   procedure Initialize (this : in out OrientationSensor) is
   begin
      null;
   end;

   procedure Finalize (this : in out OrientationSensor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IOrientationSensor, IOrientationSensor_Ptr);
   begin
      if this.m_IOrientationSensor /= null then
         if this.m_IOrientationSensor.all /= null then
            RefCount := this.m_IOrientationSensor.all.Release;
            Free (this.m_IOrientationSensor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for OrientationSensor

   function GetDefault
   (
      sensorReadingtype : Windows.Devices.Sensors.SensorReadingType
   )
   return WinRt.Windows.Devices.Sensors.OrientationSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.OrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IOrientationSensorStatics3_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IOrientationSensor;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.OrientationSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IOrientationSensorStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (sensorReadingtype, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IOrientationSensor := new Windows.Devices.Sensors.IOrientationSensor;
            Retval.m_IOrientationSensor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDefault
   (
      sensorReadingType : Windows.Devices.Sensors.SensorReadingType;
      optimizationGoal : Windows.Devices.Sensors.SensorOptimizationGoal
   )
   return WinRt.Windows.Devices.Sensors.OrientationSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.OrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IOrientationSensorStatics3_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IOrientationSensor;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.OrientationSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IOrientationSensorStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (sensorReadingType, optimizationGoal, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IOrientationSensor := new Windows.Devices.Sensors.IOrientationSensor;
            Retval.m_IOrientationSensor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDefaultForRelativeReadings
   return WinRt.Windows.Devices.Sensors.OrientationSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.OrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IOrientationSensorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IOrientationSensor;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.OrientationSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IOrientationSensorStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefaultForRelativeReadings (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IOrientationSensor := new Windows.Devices.Sensors.IOrientationSensor;
            Retval.m_IOrientationSensor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDeviceSelector_OrientationSensor
   (
      readingType : Windows.Devices.Sensors.SensorReadingType
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.OrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IOrientationSensorStatics4_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IOrientationSensorStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (readingType, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetDeviceSelector
   (
      readingType : Windows.Devices.Sensors.SensorReadingType;
      optimizationGoal : Windows.Devices.Sensors.SensorOptimizationGoal
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.OrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IOrientationSensorStatics4_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IOrientationSensorStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (readingType, optimizationGoal, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_OrientationSensor
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.OrientationSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.OrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IOrientationSensorStatics4_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_OrientationSensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_OrientationSensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IOrientationSensor;
      m_IID            : aliased WinRt.IID := (2398317224, 28525, 21387, (164, 43, 55, 175, 115, 105, 4, 158 )); -- Windows.Devices.Sensors.OrientationSensor;
      m_HandlerIID     : aliased WinRt.IID := (2201006883, 26261, 21460, (172, 215, 182, 12, 36, 193, 184, 121 ));
      m_Handler        : AsyncOperationCompletedHandler_OrientationSensor.Kind := new AsyncOperationCompletedHandler_OrientationSensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_OrientationSensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_OrientationSensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_OrientationSensor.Kind_Delegate, AsyncOperationCompletedHandler_OrientationSensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.OrientationSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IOrientationSensorStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IOrientationSensor := new Windows.Devices.Sensors.IOrientationSensor;
                     Retval.m_IOrientationSensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDefault
   return WinRt.Windows.Devices.Sensors.OrientationSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.OrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IOrientationSensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IOrientationSensor;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.OrientationSensor do
         Hr := RoGetActivationFactory (m_hString, IID_IOrientationSensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IOrientationSensor := new Windows.Devices.Sensors.IOrientationSensor;
            Retval.m_IOrientationSensor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for OrientationSensor

   function GetCurrentReading
   (
      this : in out OrientationSensor
   )
   return WinRt.Windows.Devices.Sensors.OrientationSensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IOrientationSensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.OrientationSensorReading do
         Hr := this.m_IOrientationSensor.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IOrientationSensorReading := new Windows.Devices.Sensors.IOrientationSensorReading;
         Retval.m_IOrientationSensorReading.all := m_ComRetVal;
      end return;
   end;

   function get_MinimumReportInterval
   (
      this : in out OrientationSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IOrientationSensor.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out OrientationSensor;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IOrientationSensor.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out OrientationSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IOrientationSensor.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out OrientationSensor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IOrientationSensor.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out OrientationSensor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IOrientationSensor.all.remove_ReadingChanged (token);
   end;

   function get_DeviceId
   (
      this : in out OrientationSensor
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensorDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensorDeviceId, WinRt.Windows.Devices.Sensors.IID_IOrientationSensorDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensor.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReadingTransform
   (
      this : in out OrientationSensor;
      value : Windows.Graphics.Display.DisplayOrientations
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensor2, WinRt.Windows.Devices.Sensors.IID_IOrientationSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensor.all);
      Hr := m_Interface.put_ReadingTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReadingTransform
   (
      this : in out OrientationSensor
   )
   return WinRt.Windows.Graphics.Display.DisplayOrientations is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.Display.DisplayOrientations;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensor2, WinRt.Windows.Devices.Sensors.IID_IOrientationSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensor.all);
      Hr := m_Interface.get_ReadingTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_ReadingType
   (
      this : in out OrientationSensor
   )
   return WinRt.Windows.Devices.Sensors.SensorReadingType is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.SensorReadingType;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensor2, WinRt.Windows.Devices.Sensors.IID_IOrientationSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensor.all);
      Hr := m_Interface.get_ReadingType (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ReportLatency
   (
      this : in out OrientationSensor;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensor3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensor3, WinRt.Windows.Devices.Sensors.IID_IOrientationSensor3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensor.all);
      Hr := m_Interface.put_ReportLatency (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReportLatency
   (
      this : in out OrientationSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensor3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensor3, WinRt.Windows.Devices.Sensors.IID_IOrientationSensor3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensor.all);
      Hr := m_Interface.get_ReportLatency (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_MaxBatchSize
   (
      this : in out OrientationSensor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensor3 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensor3, WinRt.Windows.Devices.Sensors.IID_IOrientationSensor3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensor.all);
      Hr := m_Interface.get_MaxBatchSize (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for OrientationSensorReading

   procedure Initialize (this : in out OrientationSensorReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out OrientationSensorReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IOrientationSensorReading, IOrientationSensorReading_Ptr);
   begin
      if this.m_IOrientationSensorReading /= null then
         if this.m_IOrientationSensorReading.all /= null then
            RefCount := this.m_IOrientationSensorReading.all.Release;
            Free (this.m_IOrientationSensorReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for OrientationSensorReading

   function get_Timestamp
   (
      this : in out OrientationSensorReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IOrientationSensorReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_RotationMatrix
   (
      this : in out OrientationSensorReading
   )
   return WinRt.Windows.Devices.Sensors.SensorRotationMatrix'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ISensorRotationMatrix;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.SensorRotationMatrix do
         Hr := this.m_IOrientationSensorReading.all.get_RotationMatrix (m_ComRetVal'Access);
         Retval.m_ISensorRotationMatrix := new Windows.Devices.Sensors.ISensorRotationMatrix;
         Retval.m_ISensorRotationMatrix.all := m_ComRetVal;
      end return;
   end;

   function get_Quaternion
   (
      this : in out OrientationSensorReading
   )
   return WinRt.Windows.Devices.Sensors.SensorQuaternion'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ISensorQuaternion;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.SensorQuaternion do
         Hr := this.m_IOrientationSensorReading.all.get_Quaternion (m_ComRetVal'Access);
         Retval.m_ISensorQuaternion := new Windows.Devices.Sensors.ISensorQuaternion;
         Retval.m_ISensorQuaternion.all := m_ComRetVal;
      end return;
   end;

   function get_YawAccuracy
   (
      this : in out OrientationSensorReading
   )
   return WinRt.Windows.Devices.Sensors.MagnetometerAccuracy is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensorReadingYawAccuracy := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.MagnetometerAccuracy;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensorReading_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensorReadingYawAccuracy, WinRt.Windows.Devices.Sensors.IID_IOrientationSensorReadingYawAccuracy'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensorReading.all);
      Hr := m_Interface.get_YawAccuracy (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_PerformanceCount
   (
      this : in out OrientationSensorReading
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensorReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensorReading_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensorReading2, WinRt.Windows.Devices.Sensors.IID_IOrientationSensorReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensorReading.all);
      Hr := m_Interface.get_PerformanceCount (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out OrientationSensorReading
   )
   return IMapView_HString_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IOrientationSensorReading2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_HString_IInspectable.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IOrientationSensorReading_Interface, WinRt.Windows.Devices.Sensors.IOrientationSensorReading2, WinRt.Windows.Devices.Sensors.IID_IOrientationSensorReading2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IOrientationSensorReading.all);
      Hr := m_Interface.get_Properties (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_HString_IInspectable (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for OrientationSensorReadingChangedEventArgs

   procedure Initialize (this : in out OrientationSensorReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out OrientationSensorReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IOrientationSensorReadingChangedEventArgs, IOrientationSensorReadingChangedEventArgs_Ptr);
   begin
      if this.m_IOrientationSensorReadingChangedEventArgs /= null then
         if this.m_IOrientationSensorReadingChangedEventArgs.all /= null then
            RefCount := this.m_IOrientationSensorReadingChangedEventArgs.all.Release;
            Free (this.m_IOrientationSensorReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for OrientationSensorReadingChangedEventArgs

   function get_Reading
   (
      this : in out OrientationSensorReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.OrientationSensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IOrientationSensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.OrientationSensorReading do
         Hr := this.m_IOrientationSensorReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IOrientationSensorReading := new Windows.Devices.Sensors.IOrientationSensorReading;
         Retval.m_IOrientationSensorReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Pedometer

   procedure Initialize (this : in out Pedometer) is
   begin
      null;
   end;

   procedure Finalize (this : in out Pedometer) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPedometer, IPedometer_Ptr);
   begin
      if this.m_IPedometer /= null then
         if this.m_IPedometer.all /= null then
            RefCount := this.m_IPedometer.all.Release;
            Free (this.m_IPedometer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Pedometer

   function GetReadingsFromTriggerDetails
   (
      triggerDetails : Windows.Devices.Sensors.SensorDataThresholdTriggerDetails'Class
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Pedometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IPedometerStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPedometerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetReadingsFromTriggerDetails (triggerDetails.m_ISensorDataThresholdTriggerDetails.all, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FromIdAsync_Pedometer
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.Pedometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Pedometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IPedometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Pedometer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Pedometer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IPedometer;
      m_IID            : aliased WinRt.IID := (2484353167, 6974, 22005, (129, 155, 171, 56, 51, 100, 96, 85 )); -- Windows.Devices.Sensors.Pedometer;
      m_HandlerIID     : aliased WinRt.IID := (2788015694, 20958, 23059, (186, 33, 231, 109, 243, 188, 19, 150 ));
      m_Handler        : AsyncOperationCompletedHandler_Pedometer.Kind := new AsyncOperationCompletedHandler_Pedometer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Pedometer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Pedometer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Pedometer.Kind_Delegate, AsyncOperationCompletedHandler_Pedometer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Pedometer do
         Hr := RoGetActivationFactory (m_hString, IID_IPedometerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IPedometer := new Windows.Devices.Sensors.IPedometer;
                     Retval.m_IPedometer.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDefaultAsync_Pedometer
   return WinRt.Windows.Devices.Sensors.Pedometer is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Pedometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IPedometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_Pedometer.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Pedometer.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.IPedometer;
      m_IID            : aliased WinRt.IID := (2484353167, 6974, 22005, (129, 155, 171, 56, 51, 100, 96, 85 )); -- Windows.Devices.Sensors.Pedometer;
      m_HandlerIID     : aliased WinRt.IID := (2788015694, 20958, 23059, (186, 33, 231, 109, 243, 188, 19, 150 ));
      m_Handler        : AsyncOperationCompletedHandler_Pedometer.Kind := new AsyncOperationCompletedHandler_Pedometer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Pedometer.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Pedometer.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Pedometer.Kind_Delegate, AsyncOperationCompletedHandler_Pedometer.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.Pedometer do
         Hr := RoGetActivationFactory (m_hString, IID_IPedometerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefaultAsync (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IPedometer := new Windows.Devices.Sensors.IPedometer;
                     Retval.m_IPedometer.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDeviceSelector_Pedometer
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Pedometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IPedometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPedometerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetSystemHistoryAsync_Pedometer
   (
      fromTime : Windows.Foundation.DateTime
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Pedometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IPedometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (720028931, 41896, 22451, (168, 169, 225, 107, 12, 212, 192, 164 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (1539307584, 23026, 20744, (146, 5, 160, 187, 248, 249, 186, 104 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPedometerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetSystemHistoryAsync (fromTime, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   function GetSystemHistoryAsync_Pedometer
   (
      fromTime : Windows.Foundation.DateTime;
      duration : Windows.Foundation.TimeSpan
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.Pedometer");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IPedometerStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.GenericObject;
      m_IID            : aliased WinRt.IID := (720028931, 41896, 22451, (168, 169, 225, 107, 12, 212, 192, 164 )); -- GenericObject;
      m_HandlerIID     : aliased WinRt.IID := (1539307584, 23026, 20744, (146, 5, 160, 187, 248, 249, 186, 104 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPedometerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetSystemHistoryAsync (fromTime, duration, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            m_RefCount := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
               end if;
               m_RefCount := m_AsyncOperation.Release;
               m_RefCount := m_Handler.Release;
               if m_RefCount = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Pedometer

   function get_DeviceId
   (
      this : in out Pedometer
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPedometer.all.get_DeviceId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_PowerInMilliwatts
   (
      this : in out Pedometer
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IPedometer.all.get_PowerInMilliwatts (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_MinimumReportInterval
   (
      this : in out Pedometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IPedometer.all.get_MinimumReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_ReportInterval
   (
      this : in out Pedometer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPedometer.all.put_ReportInterval (value);
   end;

   function get_ReportInterval
   (
      this : in out Pedometer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IPedometer.all.get_ReportInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_ReadingChanged
   (
      this : in out Pedometer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPedometer.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out Pedometer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPedometer.all.remove_ReadingChanged (token);
   end;

   function GetCurrentReadings
   (
      this : in out Pedometer
   )
   return IMapView_PedometerStepKind_IPedometerReading.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.IPedometer2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_PedometerStepKind_IPedometerReading.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.IPedometer_Interface, WinRt.Windows.Devices.Sensors.IPedometer2, WinRt.Windows.Devices.Sensors.IID_IPedometer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPedometer.all);
      Hr := m_Interface.GetCurrentReadings (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      m_GenericRetVal := QInterface_IMapView_PedometerStepKind_IPedometerReading (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PedometerDataThreshold

   procedure Initialize (this : in out PedometerDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out PedometerDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISensorDataThreshold, ISensorDataThreshold_Ptr);
   begin
      if this.m_ISensorDataThreshold /= null then
         if this.m_ISensorDataThreshold.all /= null then
            RefCount := this.m_ISensorDataThreshold.all.Release;
            Free (this.m_ISensorDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PedometerDataThreshold

   function Constructor
   (
      sensor : Windows.Devices.Sensors.Pedometer'Class;
      stepGoal : WinRt.Int32
   )
   return PedometerDataThreshold is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Sensors.PedometerDataThreshold");
      m_Factory    : access IPedometerDataThresholdFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Sensors.ISensorDataThreshold;
   begin
      return RetVal : PedometerDataThreshold do
         Hr := RoGetActivationFactory (m_hString, IID_IPedometerDataThresholdFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (sensor.m_IPedometer.all, stepGoal, m_ComRetVal'Access);
            Retval.m_ISensorDataThreshold := new Windows.Devices.Sensors.ISensorDataThreshold;
            Retval.m_ISensorDataThreshold.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PedometerDataThreshold

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PedometerReading

   procedure Initialize (this : in out PedometerReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out PedometerReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPedometerReading, IPedometerReading_Ptr);
   begin
      if this.m_IPedometerReading /= null then
         if this.m_IPedometerReading.all /= null then
            RefCount := this.m_IPedometerReading.all.Release;
            Free (this.m_IPedometerReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PedometerReading

   function get_StepKind
   (
      this : in out PedometerReading
   )
   return WinRt.Windows.Devices.Sensors.PedometerStepKind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.PedometerStepKind;
   begin
      Hr := this.m_IPedometerReading.all.get_StepKind (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_CumulativeSteps
   (
      this : in out PedometerReading
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IPedometerReading.all.get_CumulativeSteps (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Timestamp
   (
      this : in out PedometerReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IPedometerReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_CumulativeStepsDuration
   (
      this : in out PedometerReading
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IPedometerReading.all.get_CumulativeStepsDuration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PedometerReadingChangedEventArgs

   procedure Initialize (this : in out PedometerReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PedometerReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPedometerReadingChangedEventArgs, IPedometerReadingChangedEventArgs_Ptr);
   begin
      if this.m_IPedometerReadingChangedEventArgs /= null then
         if this.m_IPedometerReadingChangedEventArgs.all /= null then
            RefCount := this.m_IPedometerReadingChangedEventArgs.all.Release;
            Free (this.m_IPedometerReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PedometerReadingChangedEventArgs

   function get_Reading
   (
      this : in out PedometerReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.PedometerReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IPedometerReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.PedometerReading do
         Hr := this.m_IPedometerReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IPedometerReading := new Windows.Devices.Sensors.IPedometerReading;
         Retval.m_IPedometerReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProximitySensor

   procedure Initialize (this : in out ProximitySensor) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProximitySensor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProximitySensor, IProximitySensor_Ptr);
   begin
      if this.m_IProximitySensor /= null then
         if this.m_IProximitySensor.all /= null then
            RefCount := this.m_IProximitySensor.all.Release;
            Free (this.m_IProximitySensor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ProximitySensor

   function GetDeviceSelector_ProximitySensor
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ProximitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IProximitySensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IProximitySensorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromId
   (
      sensorId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.ProximitySensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ProximitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IProximitySensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IProximitySensor;
      HStr_sensorId : WinRt.HString := To_HString (sensorId);
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ProximitySensor do
         Hr := RoGetActivationFactory (m_hString, IID_IProximitySensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromId (HStr_sensorId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IProximitySensor := new Windows.Devices.Sensors.IProximitySensor;
            Retval.m_IProximitySensor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_sensorId);
      end return;
   end;

   function GetReadingsFromTriggerDetails_ProximitySensor
   (
      triggerDetails : Windows.Devices.Sensors.SensorDataThresholdTriggerDetails'Class
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.ProximitySensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.IProximitySensorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IProximitySensorStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetReadingsFromTriggerDetails (triggerDetails.m_ISensorDataThresholdTriggerDetails.all, m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProximitySensor

   function get_DeviceId
   (
      this : in out ProximitySensor
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IProximitySensor.all.get_DeviceId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_MaxDistanceInMillimeters
   (
      this : in out ProximitySensor
   )
   return IReference_UInt32.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_UInt32.Kind;
   begin
      Hr := this.m_IProximitySensor.all.get_MaxDistanceInMillimeters (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_UInt32 (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_MinDistanceInMillimeters
   (
      this : in out ProximitySensor
   )
   return IReference_UInt32.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_UInt32.Kind;
   begin
      Hr := this.m_IProximitySensor.all.get_MinDistanceInMillimeters (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_UInt32 (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetCurrentReading
   (
      this : in out ProximitySensor
   )
   return WinRt.Windows.Devices.Sensors.ProximitySensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IProximitySensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ProximitySensorReading do
         Hr := this.m_IProximitySensor.all.GetCurrentReading (m_ComRetVal'Access);
         Retval.m_IProximitySensorReading := new Windows.Devices.Sensors.IProximitySensorReading;
         Retval.m_IProximitySensorReading.all := m_ComRetVal;
      end return;
   end;

   function add_ReadingChanged
   (
      this : in out ProximitySensor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IProximitySensor.all.add_ReadingChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_ReadingChanged
   (
      this : in out ProximitySensor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IProximitySensor.all.remove_ReadingChanged (token);
   end;

   function CreateDisplayOnOffController
   (
      this : in out ProximitySensor
   )
   return WinRt.Windows.Devices.Sensors.ProximitySensorDisplayOnOffController'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.IClosable;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ProximitySensorDisplayOnOffController do
         Hr := this.m_IProximitySensor.all.CreateDisplayOnOffController (m_ComRetVal'Access);
         Retval.m_IClosable := new Windows.Foundation.IClosable;
         Retval.m_IClosable.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProximitySensorDataThreshold

   procedure Initialize (this : in out ProximitySensorDataThreshold) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProximitySensorDataThreshold) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISensorDataThreshold, ISensorDataThreshold_Ptr);
   begin
      if this.m_ISensorDataThreshold /= null then
         if this.m_ISensorDataThreshold.all /= null then
            RefCount := this.m_ISensorDataThreshold.all.Release;
            Free (this.m_ISensorDataThreshold);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ProximitySensorDataThreshold

   function Constructor
   (
      sensor : Windows.Devices.Sensors.ProximitySensor'Class
   )
   return ProximitySensorDataThreshold is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Sensors.ProximitySensorDataThreshold");
      m_Factory    : access IProximitySensorDataThresholdFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Sensors.ISensorDataThreshold;
   begin
      return RetVal : ProximitySensorDataThreshold do
         Hr := RoGetActivationFactory (m_hString, IID_IProximitySensorDataThresholdFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (sensor.m_IProximitySensor.all, m_ComRetVal'Access);
            Retval.m_ISensorDataThreshold := new Windows.Devices.Sensors.ISensorDataThreshold;
            Retval.m_ISensorDataThreshold.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProximitySensorDataThreshold

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProximitySensorDisplayOnOffController

   procedure Initialize (this : in out ProximitySensorDisplayOnOffController) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProximitySensorDisplayOnOffController) is
      RefCount : WinRt.UInt32 := 0;
      use type WinRt.Windows.Foundation.IClosable;
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IClosable_Ptr);
   begin
      if this.m_IClosable /= null then
         if this.m_IClosable.all /= null then
            RefCount := this.m_IClosable.all.Release;
            Free (this.m_IClosable);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProximitySensorDisplayOnOffController

   procedure Close
   (
      this : in out ProximitySensorDisplayOnOffController
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IClosable.all.Close;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProximitySensorReading

   procedure Initialize (this : in out ProximitySensorReading) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProximitySensorReading) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProximitySensorReading, IProximitySensorReading_Ptr);
   begin
      if this.m_IProximitySensorReading /= null then
         if this.m_IProximitySensorReading.all /= null then
            RefCount := this.m_IProximitySensorReading.all.Release;
            Free (this.m_IProximitySensorReading);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProximitySensorReading

   function get_Timestamp
   (
      this : in out ProximitySensorReading
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_IProximitySensorReading.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_IsDetected
   (
      this : in out ProximitySensorReading
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IProximitySensorReading.all.get_IsDetected (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_DistanceInMillimeters
   (
      this : in out ProximitySensorReading
   )
   return IReference_UInt32.Kind is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_UInt32.Kind;
   begin
      Hr := this.m_IProximitySensorReading.all.get_DistanceInMillimeters (m_ComRetVal'Access);
      m_GenericRetVal := QInterface_IReference_UInt32 (m_ComRetVal);
      m_RefCount := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProximitySensorReadingChangedEventArgs

   procedure Initialize (this : in out ProximitySensorReadingChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProximitySensorReadingChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProximitySensorReadingChangedEventArgs, IProximitySensorReadingChangedEventArgs_Ptr);
   begin
      if this.m_IProximitySensorReadingChangedEventArgs /= null then
         if this.m_IProximitySensorReadingChangedEventArgs.all /= null then
            RefCount := this.m_IProximitySensorReadingChangedEventArgs.all.Release;
            Free (this.m_IProximitySensorReadingChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProximitySensorReadingChangedEventArgs

   function get_Reading
   (
      this : in out ProximitySensorReadingChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.ProximitySensorReading'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.IProximitySensorReading;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.ProximitySensorReading do
         Hr := this.m_IProximitySensorReadingChangedEventArgs.all.get_Reading (m_ComRetVal'Access);
         Retval.m_IProximitySensorReading := new Windows.Devices.Sensors.IProximitySensorReading;
         Retval.m_IProximitySensorReading.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SensorDataThresholdTriggerDetails

   procedure Initialize (this : in out SensorDataThresholdTriggerDetails) is
   begin
      null;
   end;

   procedure Finalize (this : in out SensorDataThresholdTriggerDetails) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISensorDataThresholdTriggerDetails, ISensorDataThresholdTriggerDetails_Ptr);
   begin
      if this.m_ISensorDataThresholdTriggerDetails /= null then
         if this.m_ISensorDataThresholdTriggerDetails.all /= null then
            RefCount := this.m_ISensorDataThresholdTriggerDetails.all.Release;
            Free (this.m_ISensorDataThresholdTriggerDetails);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SensorDataThresholdTriggerDetails

   function get_DeviceId
   (
      this : in out SensorDataThresholdTriggerDetails
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISensorDataThresholdTriggerDetails.all.get_DeviceId (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SensorType
   (
      this : in out SensorDataThresholdTriggerDetails
   )
   return WinRt.Windows.Devices.Sensors.SensorType is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.SensorType;
   begin
      Hr := this.m_ISensorDataThresholdTriggerDetails.all.get_SensorType (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SensorQuaternion

   procedure Initialize (this : in out SensorQuaternion) is
   begin
      null;
   end;

   procedure Finalize (this : in out SensorQuaternion) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISensorQuaternion, ISensorQuaternion_Ptr);
   begin
      if this.m_ISensorQuaternion /= null then
         if this.m_ISensorQuaternion.all /= null then
            RefCount := this.m_ISensorQuaternion.all.Release;
            Free (this.m_ISensorQuaternion);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SensorQuaternion

   function get_W
   (
      this : in out SensorQuaternion
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorQuaternion.all.get_W (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_X
   (
      this : in out SensorQuaternion
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorQuaternion.all.get_X (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Y
   (
      this : in out SensorQuaternion
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorQuaternion.all.get_Y (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Z
   (
      this : in out SensorQuaternion
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorQuaternion.all.get_Z (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SensorRotationMatrix

   procedure Initialize (this : in out SensorRotationMatrix) is
   begin
      null;
   end;

   procedure Finalize (this : in out SensorRotationMatrix) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISensorRotationMatrix, ISensorRotationMatrix_Ptr);
   begin
      if this.m_ISensorRotationMatrix /= null then
         if this.m_ISensorRotationMatrix.all /= null then
            RefCount := this.m_ISensorRotationMatrix.all.Release;
            Free (this.m_ISensorRotationMatrix);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SensorRotationMatrix

   function get_M11
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M11 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M12
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M12 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M13
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M13 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M21
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M21 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M22
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M22 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M23
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M23 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M31
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M31 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M32
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M32 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_M33
   (
      this : in out SensorRotationMatrix
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISensorRotationMatrix.all.get_M33 (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SimpleOrientationSensor

   procedure Initialize (this : in out SimpleOrientationSensor) is
   begin
      null;
   end;

   procedure Finalize (this : in out SimpleOrientationSensor) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISimpleOrientationSensor, ISimpleOrientationSensor_Ptr);
   begin
      if this.m_ISimpleOrientationSensor /= null then
         if this.m_ISimpleOrientationSensor.all /= null then
            RefCount := this.m_ISimpleOrientationSensor.all.Release;
            Free (this.m_ISimpleOrientationSensor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SimpleOrientationSensor

   function GetDeviceSelector_SimpleOrientationSensor
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.SimpleOrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ISimpleOrientationSensorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ISimpleOrientationSensorStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDeviceSelector (m_ComRetVal'Access);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function FromIdAsync_SimpleOrientationSensor
   (
      deviceId : WinRt.WString
   )
   return WinRt.Windows.Devices.Sensors.SimpleOrientationSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.SimpleOrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ISimpleOrientationSensorStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      HStr_deviceId : WinRt.HString := To_HString (deviceId);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type WinRt.Windows.Foundation.AsyncStatus;
      use type IAsyncOperation_SimpleOrientationSensor.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_SimpleOrientationSensor.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor;
      m_IID            : aliased WinRt.IID := (1803012601, 56567, 22087, (173, 199, 247, 12, 249, 146, 112, 68 )); -- Windows.Devices.Sensors.SimpleOrientationSensor;
      m_HandlerIID     : aliased WinRt.IID := (1774094916, 11467, 21365, (168, 248, 248, 148, 239, 186, 51, 235 ));
      m_Handler        : AsyncOperationCompletedHandler_SimpleOrientationSensor.Kind := new AsyncOperationCompletedHandler_SimpleOrientationSensor.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_SimpleOrientationSensor.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_SimpleOrientationSensor.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_SimpleOrientationSensor.Kind_Delegate, AsyncOperationCompletedHandler_SimpleOrientationSensor.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         Hr        : WinRt.HResult := 0;
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Devices.Sensors.SimpleOrientationSensor do
         Hr := RoGetActivationFactory (m_hString, IID_ISimpleOrientationSensorStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromIdAsync (HStr_deviceId, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_ISimpleOrientationSensor := new Windows.Devices.Sensors.ISimpleOrientationSensor;
                     Retval.m_ISimpleOrientationSensor.all := m_RetVal;
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_deviceId);
      end return;
   end;

   function GetDefault
   return WinRt.Windows.Devices.Sensors.SimpleOrientationSensor is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Sensors.SimpleOrientationSensor");
      m_Factory        : access WinRt.Windows.Devices.Sensors.ISimpleOrientationSensorStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.ISimpleOrientationSensor;
   begin
      return RetVal : WinRt.Windows.Devices.Sensors.SimpleOrientationSensor do
         Hr := RoGetActivationFactory (m_hString, IID_ISimpleOrientationSensorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_ISimpleOrientationSensor := new Windows.Devices.Sensors.ISimpleOrientationSensor;
            Retval.m_ISimpleOrientationSensor.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SimpleOrientationSensor

   function GetCurrentOrientation
   (
      this : in out SimpleOrientationSensor
   )
   return WinRt.Windows.Devices.Sensors.SimpleOrientation is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.SimpleOrientation;
   begin
      Hr := this.m_ISimpleOrientationSensor.all.GetCurrentOrientation (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_OrientationChanged
   (
      this : in out SimpleOrientationSensor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISimpleOrientationSensor.all.add_OrientationChanged (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_OrientationChanged
   (
      this : in out SimpleOrientationSensor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISimpleOrientationSensor.all.remove_OrientationChanged (token);
   end;

   function get_DeviceId
   (
      this : in out SimpleOrientationSensor
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ISimpleOrientationSensorDeviceId := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.ISimpleOrientationSensorDeviceId, WinRt.Windows.Devices.Sensors.IID_ISimpleOrientationSensorDeviceId'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISimpleOrientationSensor.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ReadingTransform
   (
      this : in out SimpleOrientationSensor;
      value : Windows.Graphics.Display.DisplayOrientations
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor2, WinRt.Windows.Devices.Sensors.IID_ISimpleOrientationSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISimpleOrientationSensor.all);
      Hr := m_Interface.put_ReadingTransform (value);
      m_RefCount := m_Interface.Release;
   end;

   function get_ReadingTransform
   (
      this : in out SimpleOrientationSensor
   )
   return WinRt.Windows.Graphics.Display.DisplayOrientations is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.Display.DisplayOrientations;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor_Interface, WinRt.Windows.Devices.Sensors.ISimpleOrientationSensor2, WinRt.Windows.Devices.Sensors.IID_ISimpleOrientationSensor2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISimpleOrientationSensor.all);
      Hr := m_Interface.get_ReadingTransform (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SimpleOrientationSensorOrientationChangedEventArgs

   procedure Initialize (this : in out SimpleOrientationSensorOrientationChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SimpleOrientationSensorOrientationChangedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISimpleOrientationSensorOrientationChangedEventArgs, ISimpleOrientationSensorOrientationChangedEventArgs_Ptr);
   begin
      if this.m_ISimpleOrientationSensorOrientationChangedEventArgs /= null then
         if this.m_ISimpleOrientationSensorOrientationChangedEventArgs.all /= null then
            RefCount := this.m_ISimpleOrientationSensorOrientationChangedEventArgs.all.Release;
            Free (this.m_ISimpleOrientationSensorOrientationChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SimpleOrientationSensorOrientationChangedEventArgs

   function get_Timestamp
   (
      this : in out SimpleOrientationSensorOrientationChangedEventArgs
   )
   return WinRt.Windows.Foundation.DateTime is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.DateTime;
   begin
      Hr := this.m_ISimpleOrientationSensorOrientationChangedEventArgs.all.get_Timestamp (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Orientation
   (
      this : in out SimpleOrientationSensorOrientationChangedEventArgs
   )
   return WinRt.Windows.Devices.Sensors.SimpleOrientation is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Sensors.SimpleOrientation;
   begin
      Hr := this.m_ISimpleOrientationSensorOrientationChangedEventArgs.all.get_Orientation (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

end;
