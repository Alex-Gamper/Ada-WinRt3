--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with Ada.Unchecked_Conversion;
with System;
with System.Storage_Elements;
with Ada.Strings.Wide_Unbounded;
--------------------------------------------------------------------------------
package body WinRt is

   -----------------------------------------------------------------------------
   function To_HString (Value : Wide_String) return WinRt.HString is
      Hr        : WinRt.HResult := 0;
      RetVal    : aliased WinRt.HString;
   begin
      Hr := WindowsCreateString(Value'Address , Value'Length, RetVal'Access);
      return RetVal;
   end;

   -----------------------------------------------------------------------------
   function To_HString (Value : WString) return WinRt.HString is
      Hr        : WinRt.HResult := 0;
      RetVal    : aliased WinRt.HString;
      Tmp       : Wide_String := Ada.Strings.Wide_Unbounded.To_Wide_String(Value);
   begin
      Hr := WindowsCreateString(Tmp'Address , Tmp'Length, RetVal'Access);
      return RetVal;
   end;

   -----------------------------------------------------------------------------
   function To_HString_Array (Value : WString_Array) return WinRt.HString_Array is
      RetVal    : aliased WinRt.HString_Array(1..Value'Length);
   begin
      for i in RetVal'Range loop
         Retval(i) := To_HString (Value(i));
      end loop;
      return RetVal;
   end;

   -----------------------------------------------------------------------------
   function To_Ada (Value : WinRt.HString) return WString is

      function Convert is new Ada.Unchecked_Conversion(System.Address, Wide_Char_Ptr);
      function Convert is new Ada.Unchecked_Conversion(Wide_Char_Ptr, System.Address);

      function Peek(From : System.Address) return Wide_Char is
         Item    : Wide_Char_Ptr := Convert(From);
      begin
         return Item.all;
      end;

      use type System.Address;
      use type System.Storage_Elements.Storage_Offset;

   begin
      if Value = System.Null_Address then
         return Ada.Strings.Wide_Unbounded.To_Unbounded_Wide_String("");
      end if;

      declare
         BufferLen  : aliased UInt32 := 0;
         Buffer     : Wide_Char_Ptr:= WindowsGetStringRawBuffer(Value, BufferLen'access);
      begin
         if BufferLen > 0 then
            declare
               RetVal   : Wide_String(1..Integer(BufferLen));
            begin
               for i in RetVal'Range loop
                  RetVal(i) := Peek(Convert(Buffer) + System.Storage_Elements.Storage_Offset((i - 1) * 2));
               end loop;
               return Ada.Strings.Wide_Unbounded.To_Unbounded_Wide_String(RetVal);
            end;
         else
            return Ada.Strings.Wide_Unbounded.To_Unbounded_Wide_String("");
         end if;
      end;
   end;

   -----------------------------------------------------------------------------
   function InterlockedIncrement (Ptr : System.Address; Val : WinRt.UInt32 := 1; Model : Integer := 5) return WinRt.UInt32;
   pragma Import(Intrinsic, InterlockedIncrement, "__atomic_add_fetch_4");

   -----------------------------------------------------------------------------
   function InterlockedDecriment (Ptr : System.Address; Val : WinRt.UInt32 := 1; Model : Integer := 5) return WinRt.UInt32;
   pragma Import(Intrinsic, InterlockedDecriment, "__atomic_sub_fetch_4");

   -----------------------------------------------------------------------------
   function QueryInterface (This : access IMulticastDelegate_Interface; riid : in WinRt.GUID_Ptr; ppvObject : not null access IUnknown) return WinRt.HResult is
      Hr : WinRt.HResult := E_NOTIMPL;
      RefCount   : WinRt.UInt32;
      m_IUnknown : aliased IUnknown;
      pragma suppress(Accessibility_Check); -- This can be called from WinRt.
   begin
      if riid.all = This.m_IID.all or (This.m_Generic_IID /= null and then riid.all = This.m_Generic_IID.all) or riid.all = IID_IUnknown or riid.all = IID_IAgileObject then
         RefCount := This.AddRef;
         ppvObject.all := This;
         Hr := S_OK;
      end if;
      return Hr;
   end;

   function Addref (This : access IMulticastDelegate_Interface) return WinRt.UInt32 is
   begin
      return InterlockedIncrement (This.m_RefCount'Address);
   end;

   function Release (This : access IMulticastDelegate_Interface) return WinRt.UInt32 is
   begin
      return InterlockedDecriment (This.m_RefCount'Address);
   end;

   -----------------------------------------------------------------------------
   function Generic_QueryInterface (Object : access ISource'Class) return IDestination is
      Hr     : HResult;
      RetVal : aliased IUnknown;
      function Convert is new Ada.Unchecked_Conversion (IUnknown, IDestination);
   begin
      Hr := Object.QueryInterface (IID_Destination, RetVal'access);
      return Convert (RetVal);
   end;

   -----------------------------------------------------------------------------
   function To_Ada_Type (Data : T_Ptr; Index: Integer) return T is

      function Convert is new Ada.Unchecked_Conversion(System.Address, T_Ptr);
      function Convert is new Ada.Unchecked_Conversion(T_Ptr, System.Address);

      function Peek(From : System.Address) return T is
         Item    : T_Ptr:= Convert(From);
      begin
         return Item.all;
      end;

      use type System.Address;
      use type System.Storage_Elements.Storage_Offset;

   begin
      return Peek(Convert(Data) + System.Storage_Elements.Storage_Offset((Index - 1) * (T'Size / 8)));
   end;

end;
