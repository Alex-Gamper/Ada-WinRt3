--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.System.Power.Thermal is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PowerThermalChannelConfiguration

   procedure Initialize (this : in out PowerThermalChannelConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out PowerThermalChannelConfiguration) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPowerThermalChannelConfiguration, IPowerThermalChannelConfiguration_Ptr);
   begin
      if this.m_IPowerThermalChannelConfiguration /= null then
         if this.m_IPowerThermalChannelConfiguration.all /= null then
            temp := this.m_IPowerThermalChannelConfiguration.all.Release;
            Free (this.m_IPowerThermalChannelConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PowerThermalChannelConfiguration

   function get_Id
   (
      this : in out PowerThermalChannelConfiguration
   )
   return WinRt.Windows.System.Power.Thermal.PowerThermalChannelId is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalChannelId;
   begin
      Hr := this.m_IPowerThermalChannelConfiguration.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ConfigurationString
   (
      this : in out PowerThermalChannelConfiguration
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPowerThermalChannelConfiguration.all.get_ConfigurationString (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function GetConfigurationNumericParameters
   (
      this : in out PowerThermalChannelConfiguration
   )
   return WinRt.Int32_Array is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelConfiguration.all.GetConfigurationNumericParameters (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinRt.Int32_Array (1..Integer(m_ComRetValSize));
         function To_Ada_Int32 is new To_Ada_Type (WinRt.Int32, WinRt.Int32_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_Int32 (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PowerThermalChannelDataConsumer

   procedure Initialize (this : in out PowerThermalChannelDataConsumer) is
   begin
      null;
   end;

   procedure Finalize (this : in out PowerThermalChannelDataConsumer) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPowerThermalChannelDataConsumer, IPowerThermalChannelDataConsumer_Ptr);
   begin
      if this.m_IPowerThermalChannelDataConsumer /= null then
         if this.m_IPowerThermalChannelDataConsumer.all /= null then
            temp := this.m_IPowerThermalChannelDataConsumer.all.Release;
            Free (this.m_IPowerThermalChannelDataConsumer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PowerThermalChannelDataConsumer

   function Constructor
   (
      channelIds : Windows.System.Power.Thermal.PowerThermalChannelId_Array
   )
   return PowerThermalChannelDataConsumer is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.System.Power.Thermal.PowerThermalChannelDataConsumer");
      m_Factory    : access IPowerThermalChannelDataConsumerFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.System.Power.Thermal.IPowerThermalChannelDataConsumer;
      function Convert_channelIds is new Ada.Unchecked_Conversion (Address, WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Ptr);
   begin
      return RetVal : PowerThermalChannelDataConsumer do
         Hr := RoGetActivationFactory (m_hString, IID_IPowerThermalChannelDataConsumerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (WinRt.UInt32(channelIds'Length), Convert_channelIds (channelIds (channelIds'First)'Address), m_ComRetVal'Access);
            Retval.m_IPowerThermalChannelDataConsumer := new Windows.System.Power.Thermal.IPowerThermalChannelDataConsumer;
            Retval.m_IPowerThermalChannelDataConsumer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PowerThermalChannelDataConsumer

   function GetChannelIds
   (
      this : in out PowerThermalChannelDataConsumer
   )
   return WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Array is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalChannelId_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.GetChannelIds (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Array (1..Integer(m_ComRetValSize));
         function To_Ada_PowerThermalChannelId is new To_Ada_Type (WinRt.Windows.System.Power.Thermal.PowerThermalChannelId, WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_PowerThermalChannelId (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function GetChannelConfigurations
   (
      this : in out PowerThermalChannelDataConsumer
   )
   return IMapView_PowerThermalChannelId_IPowerThermalChannelConfiguration.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_PowerThermalChannelId_IPowerThermalChannelConfiguration.Kind;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.GetChannelConfigurations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_PowerThermalChannelId_IPowerThermalChannelConfiguration (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure Start
   (
      this : in out PowerThermalChannelDataConsumer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.Start;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out PowerThermalChannelDataConsumer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ChannelDataReceived
   (
      this : in out PowerThermalChannelDataConsumer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.add_ChannelDataReceived (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ChannelDataReceived
   (
      this : in out PowerThermalChannelDataConsumer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.remove_ChannelDataReceived (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackEndStatus
   (
      this : in out PowerThermalChannelDataConsumer
   )
   return WinRt.Windows.System.Power.Thermal.PowerThermalBackEndStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalBackEndStatus;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.get_BackEndStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_BackEndStatusChanged
   (
      this : in out PowerThermalChannelDataConsumer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.add_BackEndStatusChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BackEndStatusChanged
   (
      this : in out PowerThermalChannelDataConsumer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataConsumer.all.remove_BackEndStatusChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out PowerThermalChannelDataConsumer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.System.Power.Thermal.IPowerThermalChannelDataConsumer_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPowerThermalChannelDataConsumer.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PowerThermalChannelDataProducer

   procedure Initialize (this : in out PowerThermalChannelDataProducer) is
   begin
      null;
   end;

   procedure Finalize (this : in out PowerThermalChannelDataProducer) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPowerThermalChannelDataProducer, IPowerThermalChannelDataProducer_Ptr);
   begin
      if this.m_IPowerThermalChannelDataProducer /= null then
         if this.m_IPowerThermalChannelDataProducer.all /= null then
            temp := this.m_IPowerThermalChannelDataProducer.all.Release;
            Free (this.m_IPowerThermalChannelDataProducer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PowerThermalChannelDataProducer

   function Constructor
   (
      channelIds : Windows.System.Power.Thermal.PowerThermalChannelId_Array
   )
   return PowerThermalChannelDataProducer is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.System.Power.Thermal.PowerThermalChannelDataProducer");
      m_Factory    : access IPowerThermalChannelDataProducerFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.System.Power.Thermal.IPowerThermalChannelDataProducer;
      function Convert_channelIds is new Ada.Unchecked_Conversion (Address, WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Ptr);
   begin
      return RetVal : PowerThermalChannelDataProducer do
         Hr := RoGetActivationFactory (m_hString, IID_IPowerThermalChannelDataProducerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (WinRt.UInt32(channelIds'Length), Convert_channelIds (channelIds (channelIds'First)'Address), m_ComRetVal'Access);
            Retval.m_IPowerThermalChannelDataProducer := new Windows.System.Power.Thermal.IPowerThermalChannelDataProducer;
            Retval.m_IPowerThermalChannelDataProducer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PowerThermalChannelDataProducer

   function GetChannelIds
   (
      this : in out PowerThermalChannelDataProducer
   )
   return WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Array is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalChannelId_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.GetChannelIds (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Array (1..Integer(m_ComRetValSize));
         function To_Ada_PowerThermalChannelId is new To_Ada_Type (WinRt.Windows.System.Power.Thermal.PowerThermalChannelId, WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_PowerThermalChannelId (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   function GetChannelConfigurations
   (
      this : in out PowerThermalChannelDataProducer
   )
   return IMapView_PowerThermalChannelId_IPowerThermalChannelConfiguration.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_PowerThermalChannelId_IPowerThermalChannelConfiguration.Kind;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.GetChannelConfigurations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_PowerThermalChannelId_IPowerThermalChannelConfiguration (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure DisableChannel
   (
      this : in out PowerThermalChannelDataProducer;
      channelId : Windows.System.Power.Thermal.PowerThermalChannelId
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.DisableChannel (channelId);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Start
   (
      this : in out PowerThermalChannelDataProducer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.Start;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out PowerThermalChannelDataProducer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PublishInputChannelData
   (
      this : in out PowerThermalChannelDataProducer;
      data : Windows.System.Power.Thermal.PowerThermalChannelData_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      function Convert_data is new Ada.Unchecked_Conversion (Address, WinRt.Windows.System.Power.Thermal.PowerThermalChannelData_Ptr);
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.PublishInputChannelData (WinRt.UInt32(data'Length), Convert_data (data (data'First)'Address));
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackEndStatus
   (
      this : in out PowerThermalChannelDataProducer
   )
   return WinRt.Windows.System.Power.Thermal.PowerThermalBackEndStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalBackEndStatus;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.get_BackEndStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_BackEndStatusChanged
   (
      this : in out PowerThermalChannelDataProducer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.add_BackEndStatusChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BackEndStatusChanged
   (
      this : in out PowerThermalChannelDataProducer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataProducer.all.remove_BackEndStatusChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out PowerThermalChannelDataProducer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.System.Power.Thermal.IPowerThermalChannelDataProducer_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPowerThermalChannelDataProducer.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PowerThermalChannelDataReceivedEventArgs

   procedure Initialize (this : in out PowerThermalChannelDataReceivedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PowerThermalChannelDataReceivedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPowerThermalChannelDataReceivedEventArgs, IPowerThermalChannelDataReceivedEventArgs_Ptr);
   begin
      if this.m_IPowerThermalChannelDataReceivedEventArgs /= null then
         if this.m_IPowerThermalChannelDataReceivedEventArgs.all /= null then
            temp := this.m_IPowerThermalChannelDataReceivedEventArgs.all.Release;
            Free (this.m_IPowerThermalChannelDataReceivedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PowerThermalChannelDataReceivedEventArgs

   function GetData
   (
      this : in out PowerThermalChannelDataReceivedEventArgs
   )
   return WinRt.Windows.System.Power.Thermal.PowerThermalChannelData_Array is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalChannelData_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPowerThermalChannelDataReceivedEventArgs.all.GetData (m_ComRetValSize'Access, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      declare
         ArrayRetVal : WinRt.Windows.System.Power.Thermal.PowerThermalChannelData_Array (1..Integer(m_ComRetValSize));
         function To_Ada_PowerThermalChannelData is new To_Ada_Type (WinRt.Windows.System.Power.Thermal.PowerThermalChannelData, WinRt.Windows.System.Power.Thermal.PowerThermalChannelData_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_PowerThermalChannelData (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PowerThermalChannelDiagnostics

   procedure Initialize (this : in out PowerThermalChannelDiagnostics) is
   begin
      null;
   end;

   procedure Finalize (this : in out PowerThermalChannelDiagnostics) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPowerThermalChannelDiagnostics, IPowerThermalChannelDiagnostics_Ptr);
   begin
      if this.m_IPowerThermalChannelDiagnostics /= null then
         if this.m_IPowerThermalChannelDiagnostics.all /= null then
            temp := this.m_IPowerThermalChannelDiagnostics.all.Release;
            Free (this.m_IPowerThermalChannelDiagnostics);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PowerThermalChannelDiagnostics

   function get_Current
   return WinRt.Windows.System.Power.Thermal.PowerThermalChannelDiagnostics is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.System.Power.Thermal.PowerThermalChannelDiagnostics");
      m_Factory        : access WinRt.Windows.System.Power.Thermal.IPowerThermalChannelDiagnosticsStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.IPowerThermalChannelDiagnostics;
   begin
      return RetVal : WinRt.Windows.System.Power.Thermal.PowerThermalChannelDiagnostics do
         Hr := RoGetActivationFactory (m_hString, IID_IPowerThermalChannelDiagnosticsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Current (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPowerThermalChannelDiagnostics := new Windows.System.Power.Thermal.IPowerThermalChannelDiagnostics;
            Retval.m_IPowerThermalChannelDiagnostics.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDataForChannels
   (
      channelIds : Windows.System.Power.Thermal.PowerThermalChannelId_Array
   )
   return WinRt.Windows.System.Power.Thermal.PowerThermalChannelData_Array is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.System.Power.Thermal.PowerThermalChannelDiagnostics");
      m_Factory        : access WinRt.Windows.System.Power.Thermal.IPowerThermalChannelDiagnosticsStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalChannelData_Ptr;
      m_ComRetValSize  : aliased WinRt.UInt32 := 0;
      function Convert_channelIds is new Ada.Unchecked_Conversion (Address, WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Ptr);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPowerThermalChannelDiagnosticsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDataForChannels (WinRt.UInt32(channelIds'Length), Convert_channelIds (channelIds (channelIds'First)'Address), m_ComRetValSize'Access, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      declare
         ArrayRetVal : WinRt.Windows.System.Power.Thermal.PowerThermalChannelData_Array (1..Integer(m_ComRetValSize));
         function To_Ada_PowerThermalChannelData is new To_Ada_Type (WinRt.Windows.System.Power.Thermal.PowerThermalChannelData, WinRt.Windows.System.Power.Thermal.PowerThermalChannelData_Ptr); 
      begin
         for i in ArrayRetVal'Range loop
            ArrayRetval (i) := To_Ada_PowerThermalChannelData (m_ComRetVal, i);
         end loop;
         return ArrayRetVal;
      end;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PowerThermalChannelDiagnostics

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body PowerThermalChannelFinder is

      function FindChannels
      (
         channelInterfaceType : WinRt.Guid
      )
      return WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Array is
         Hr               : WinRt.HResult := S_OK;
         tmp              : WinRt.HResult := S_OK;
         m_hString        : constant WinRt.HString := To_HString ("Windows.System.Power.Thermal.PowerThermalChannelFinder");
         m_Factory        : access WinRt.Windows.System.Power.Thermal.IPowerThermalChannelFinderStatics_Interface'Class := null;
         temp             : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.System.Power.Thermal.PowerThermalChannelId_Ptr;
         m_ComRetValSize  : aliased WinRt.UInt32 := 0;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IPowerThermalChannelFinderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindChannels (channelInterfaceType, m_ComRetValSize'Access, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         declare
            ArrayRetVal : WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Array (1..Integer(m_ComRetValSize));
            function To_Ada_PowerThermalChannelId is new To_Ada_Type (WinRt.Windows.System.Power.Thermal.PowerThermalChannelId, WinRt.Windows.System.Power.Thermal.PowerThermalChannelId_Ptr); 
         begin
            for i in ArrayRetVal'Range loop
               ArrayRetval (i) := To_Ada_PowerThermalChannelId (m_ComRetVal, i);
            end loop;
            return ArrayRetVal;
         end;
      end;

   end PowerThermalChannelFinder;

end WinRt.Windows.System.Power.Thermal;
