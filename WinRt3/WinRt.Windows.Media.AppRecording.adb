--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Storage;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Media.AppRecording is

   package IAsyncOperation_AppRecordingResult is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Media.AppRecording.IAppRecordingResult);
   package AsyncOperationCompletedHandler_AppRecordingResult is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Media.AppRecording.IAppRecordingResult);

   package IAsyncOperation_AppRecordingSaveScreenshotResult is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Media.AppRecording.IAppRecordingSaveScreenshotResult);
   package AsyncOperationCompletedHandler_AppRecordingSaveScreenshotResult is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Media.AppRecording.IAppRecordingSaveScreenshotResult);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppRecordingManager

   procedure Initialize (this : in out AppRecordingManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppRecordingManager) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppRecordingManager, IAppRecordingManager_Ptr);
   begin
      if this.m_IAppRecordingManager /= null then
         if this.m_IAppRecordingManager.all /= null then
            temp := this.m_IAppRecordingManager.all.Release;
            if temp < 1 then
               Free (this.m_IAppRecordingManager);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppRecordingManager

   function GetDefault
   return WinRt.Windows.Media.AppRecording.AppRecordingManager is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Media.AppRecording.AppRecordingManager");
      m_Factory        : access WinRt.Windows.Media.AppRecording.IAppRecordingManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Media.AppRecording.IAppRecordingManager;
   begin
      return RetVal : WinRt.Windows.Media.AppRecording.AppRecordingManager do
         Hr := RoGetActivationFactory (m_hString, IID_IAppRecordingManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetDefault (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IAppRecordingManager := new WinRt.Windows.Media.AppRecording.IAppRecordingManager;
            Retval.m_IAppRecordingManager.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppRecordingManager

   function GetStatus
   (
      this : in out AppRecordingManager
   )
   return WinRt.Windows.Media.AppRecording.AppRecordingStatus'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Media.AppRecording.IAppRecordingStatus;
   begin
      return RetVal : WinRt.Windows.Media.AppRecording.AppRecordingStatus do
         Hr := this.m_IAppRecordingManager.all.GetStatus (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppRecordingStatus := new WinRt.Windows.Media.AppRecording.IAppRecordingStatus;
         Retval.m_IAppRecordingStatus.all := m_ComRetVal;
      end return;
   end;

   function StartRecordingToFileAsync
   (
      this : in out AppRecordingManager;
      file : WinRt.Windows.Storage.StorageFile'Class
   )
   return WinRt.Windows.Media.AppRecording.AppRecordingResult'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_AppRecordingResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_AppRecordingResult.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Media.AppRecording.IAppRecordingResult;
      m_IID            : aliased WinRt.IID := (745719574, 12522, 21804, (170, 202, 81, 209, 35, 35, 78, 227 )); -- Windows.Media.AppRecording.AppRecordingResult;
      m_HandlerIID     : aliased WinRt.IID := (527386511, 27819, 22757, (129, 148, 152, 8, 60, 114, 221, 252 ));
      m_Handler        : AsyncOperationCompletedHandler_AppRecordingResult.Kind := new AsyncOperationCompletedHandler_AppRecordingResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_AppRecordingResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_AppRecordingResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_AppRecordingResult.Kind_Delegate, AsyncOperationCompletedHandler_AppRecordingResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Media.AppRecording.AppRecordingResult do
         Hr := this.m_IAppRecordingManager.all.StartRecordingToFileAsync (file.m_IStorageFile.all, m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            temp := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IAppRecordingResult := new WinRt.Windows.Media.AppRecording.IAppRecordingResult;
                  Retval.m_IAppRecordingResult.all := m_RetVal;
               end if;
               temp := m_AsyncOperation.Release;
               temp := m_Handler.Release;
               if temp = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function RecordTimeSpanToFileAsync
   (
      this : in out AppRecordingManager;
      startTime : WinRt.Windows.Foundation.DateTime;
      duration : WinRt.Windows.Foundation.TimeSpan;
      file : WinRt.Windows.Storage.StorageFile'Class
   )
   return WinRt.Windows.Media.AppRecording.AppRecordingResult'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_AppRecordingResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_AppRecordingResult.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Media.AppRecording.IAppRecordingResult;
      m_IID            : aliased WinRt.IID := (745719574, 12522, 21804, (170, 202, 81, 209, 35, 35, 78, 227 )); -- Windows.Media.AppRecording.AppRecordingResult;
      m_HandlerIID     : aliased WinRt.IID := (527386511, 27819, 22757, (129, 148, 152, 8, 60, 114, 221, 252 ));
      m_Handler        : AsyncOperationCompletedHandler_AppRecordingResult.Kind := new AsyncOperationCompletedHandler_AppRecordingResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_AppRecordingResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_AppRecordingResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_AppRecordingResult.Kind_Delegate, AsyncOperationCompletedHandler_AppRecordingResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Media.AppRecording.AppRecordingResult do
         Hr := this.m_IAppRecordingManager.all.RecordTimeSpanToFileAsync (startTime, duration, file.m_IStorageFile.all, m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            temp := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IAppRecordingResult := new WinRt.Windows.Media.AppRecording.IAppRecordingResult;
                  Retval.m_IAppRecordingResult.all := m_RetVal;
               end if;
               temp := m_AsyncOperation.Release;
               temp := m_Handler.Release;
               if temp = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   function get_SupportedScreenshotMediaEncodingSubtypes
   (
      this : in out AppRecordingManager
   )
   return IVectorView_HString.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
   begin
      Hr := this.m_IAppRecordingManager.all.get_SupportedScreenshotMediaEncodingSubtypes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function SaveScreenshotToFilesAsync
   (
      this : in out AppRecordingManager;
      folder : WinRt.Windows.Storage.StorageFolder'Class;
      filenamePrefix : WinRt.WString;
      option : WinRt.Windows.Media.AppRecording.AppRecordingSaveScreenshotOption;
      requestedFormats : GenericObject
   )
   return WinRt.Windows.Media.AppRecording.AppRecordingSaveScreenshotResult'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_filenamePrefix : constant WinRt.HString := To_HString (filenamePrefix);
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_AppRecordingSaveScreenshotResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_AppRecordingSaveScreenshotResult.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.Media.AppRecording.IAppRecordingSaveScreenshotResult;
      m_IID            : aliased WinRt.IID := (2689123646, 58916, 20779, (142, 7, 172, 78, 100, 57, 27, 42 )); -- Windows.Media.AppRecording.AppRecordingSaveScreenshotResult;
      m_HandlerIID     : aliased WinRt.IID := (2384480195, 19677, 21508, (159, 104, 82, 157, 10, 53, 190, 101 ));
      m_Handler        : AsyncOperationCompletedHandler_AppRecordingSaveScreenshotResult.Kind := new AsyncOperationCompletedHandler_AppRecordingSaveScreenshotResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_AppRecordingSaveScreenshotResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_AppRecordingSaveScreenshotResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_AppRecordingSaveScreenshotResult.Kind_Delegate, AsyncOperationCompletedHandler_AppRecordingSaveScreenshotResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.Media.AppRecording.AppRecordingSaveScreenshotResult do
         Hr := this.m_IAppRecordingManager.all.SaveScreenshotToFilesAsync (folder.m_IStorageFolder.all, HStr_filenamePrefix, option, requestedFormats, m_ComRetVal'Access);
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            temp := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IAppRecordingSaveScreenshotResult := new WinRt.Windows.Media.AppRecording.IAppRecordingSaveScreenshotResult;
                  Retval.m_IAppRecordingSaveScreenshotResult.all := m_RetVal;
               end if;
               temp := m_AsyncOperation.Release;
               temp := m_Handler.Release;
               if temp = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (HStr_filenamePrefix);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppRecordingResult

   procedure Initialize (this : in out AppRecordingResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppRecordingResult) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppRecordingResult, IAppRecordingResult_Ptr);
   begin
      if this.m_IAppRecordingResult /= null then
         if this.m_IAppRecordingResult.all /= null then
            temp := this.m_IAppRecordingResult.all.Release;
            if temp < 1 then
               Free (this.m_IAppRecordingResult);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppRecordingResult

   function get_Succeeded
   (
      this : in out AppRecordingResult
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingResult.all.get_Succeeded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtendedError
   (
      this : in out AppRecordingResult
   )
   return WinRt.Windows.Foundation.HResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.HResult;
   begin
      Hr := this.m_IAppRecordingResult.all.get_ExtendedError (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Duration
   (
      this : in out AppRecordingResult
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IAppRecordingResult.all.get_Duration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsFileTruncated
   (
      this : in out AppRecordingResult
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingResult.all.get_IsFileTruncated (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppRecordingSaveScreenshotResult

   procedure Initialize (this : in out AppRecordingSaveScreenshotResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppRecordingSaveScreenshotResult) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppRecordingSaveScreenshotResult, IAppRecordingSaveScreenshotResult_Ptr);
   begin
      if this.m_IAppRecordingSaveScreenshotResult /= null then
         if this.m_IAppRecordingSaveScreenshotResult.all /= null then
            temp := this.m_IAppRecordingSaveScreenshotResult.all.Release;
            if temp < 1 then
               Free (this.m_IAppRecordingSaveScreenshotResult);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppRecordingSaveScreenshotResult

   function get_Succeeded
   (
      this : in out AppRecordingSaveScreenshotResult
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingSaveScreenshotResult.all.get_Succeeded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtendedError
   (
      this : in out AppRecordingSaveScreenshotResult
   )
   return WinRt.Windows.Foundation.HResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.HResult;
   begin
      Hr := this.m_IAppRecordingSaveScreenshotResult.all.get_ExtendedError (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SavedScreenshotInfos
   (
      this : in out AppRecordingSaveScreenshotResult
   )
   return IVectorView_IAppRecordingSavedScreenshotInfo.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IVectorView_IAppRecordingSavedScreenshotInfo.Kind;
   begin
      Hr := this.m_IAppRecordingSaveScreenshotResult.all.get_SavedScreenshotInfos (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IAppRecordingSavedScreenshotInfo (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppRecordingSavedScreenshotInfo

   procedure Initialize (this : in out AppRecordingSavedScreenshotInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppRecordingSavedScreenshotInfo) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppRecordingSavedScreenshotInfo, IAppRecordingSavedScreenshotInfo_Ptr);
   begin
      if this.m_IAppRecordingSavedScreenshotInfo /= null then
         if this.m_IAppRecordingSavedScreenshotInfo.all /= null then
            temp := this.m_IAppRecordingSavedScreenshotInfo.all.Release;
            if temp < 1 then
               Free (this.m_IAppRecordingSavedScreenshotInfo);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppRecordingSavedScreenshotInfo

   function get_File
   (
      this : in out AppRecordingSavedScreenshotInfo
   )
   return WinRt.Windows.Storage.StorageFile'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Storage.IStorageFile;
   begin
      return RetVal : WinRt.Windows.Storage.StorageFile do
         Hr := this.m_IAppRecordingSavedScreenshotInfo.all.get_File (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStorageFile := new WinRt.Windows.Storage.IStorageFile;
         Retval.m_IStorageFile.all := m_ComRetVal;
      end return;
   end;

   function get_MediaEncodingSubtype
   (
      this : in out AppRecordingSavedScreenshotInfo
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppRecordingSavedScreenshotInfo.all.get_MediaEncodingSubtype (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppRecordingStatus

   procedure Initialize (this : in out AppRecordingStatus) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppRecordingStatus) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppRecordingStatus, IAppRecordingStatus_Ptr);
   begin
      if this.m_IAppRecordingStatus /= null then
         if this.m_IAppRecordingStatus.all /= null then
            temp := this.m_IAppRecordingStatus.all.Release;
            if temp < 1 then
               Free (this.m_IAppRecordingStatus);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppRecordingStatus

   function get_CanRecord
   (
      this : in out AppRecordingStatus
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatus.all.get_CanRecord (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanRecordTimeSpan
   (
      this : in out AppRecordingStatus
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatus.all.get_CanRecordTimeSpan (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HistoricalBufferDuration
   (
      this : in out AppRecordingStatus
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IAppRecordingStatus.all.get_HistoricalBufferDuration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Details
   (
      this : in out AppRecordingStatus
   )
   return WinRt.Windows.Media.AppRecording.AppRecordingStatusDetails'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Media.AppRecording.IAppRecordingStatusDetails;
   begin
      return RetVal : WinRt.Windows.Media.AppRecording.AppRecordingStatusDetails do
         Hr := this.m_IAppRecordingStatus.all.get_Details (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppRecordingStatusDetails := new WinRt.Windows.Media.AppRecording.IAppRecordingStatusDetails;
         Retval.m_IAppRecordingStatusDetails.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppRecordingStatusDetails

   procedure Initialize (this : in out AppRecordingStatusDetails) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppRecordingStatusDetails) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppRecordingStatusDetails, IAppRecordingStatusDetails_Ptr);
   begin
      if this.m_IAppRecordingStatusDetails /= null then
         if this.m_IAppRecordingStatusDetails.all /= null then
            temp := this.m_IAppRecordingStatusDetails.all.Release;
            if temp < 1 then
               Free (this.m_IAppRecordingStatusDetails);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppRecordingStatusDetails

   function get_IsAnyAppBroadcasting
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsAnyAppBroadcasting (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsCaptureResourceUnavailable
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsCaptureResourceUnavailable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsGameStreamInProgress
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsGameStreamInProgress (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsTimeSpanRecordingDisabled
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsTimeSpanRecordingDisabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsGpuConstrained
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsGpuConstrained (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsAppInactive
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsAppInactive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsBlockedForApp
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsBlockedForApp (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsDisabledByUser
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsDisabledByUser (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsDisabledBySystem
   (
      this : in out AppRecordingStatusDetails
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppRecordingStatusDetails.all.get_IsDisabledBySystem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

end WinRt.Windows.Media.AppRecording;
