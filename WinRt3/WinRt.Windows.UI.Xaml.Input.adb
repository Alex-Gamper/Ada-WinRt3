--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Devices.Input;
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.System;
with WinRt.Windows.UI.Core;
with WinRt.Windows.UI.Input;
with WinRt.Windows.UI.Xaml.Controls;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.Xaml.Input is

   package IAsyncOperation_FocusMovementResult is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.UI.Xaml.Input.IFocusMovementResult);
   package AsyncOperationCompletedHandler_FocusMovementResult is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.UI.Xaml.Input.IFocusMovementResult);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccessKeyDisplayDismissedEventArgs

   procedure Initialize (this : in out AccessKeyDisplayDismissedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccessKeyDisplayDismissedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccessKeyDisplayDismissedEventArgs, IAccessKeyDisplayDismissedEventArgs_Ptr);
   begin
      if this.m_IAccessKeyDisplayDismissedEventArgs /= null then
         if this.m_IAccessKeyDisplayDismissedEventArgs.all /= null then
            temp := this.m_IAccessKeyDisplayDismissedEventArgs.all.Release;
            Free (this.m_IAccessKeyDisplayDismissedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AccessKeyDisplayDismissedEventArgs

   function Constructor return AccessKeyDisplayDismissedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IAccessKeyDisplayDismissedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IAccessKeyDisplayDismissedEventArgs;
   begin
      return RetVal : AccessKeyDisplayDismissedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAccessKeyDisplayDismissedEventArgs := new WinRt.Windows.UI.Xaml.Input.IAccessKeyDisplayDismissedEventArgs;
            Retval.m_IAccessKeyDisplayDismissedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccessKeyDisplayDismissedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccessKeyDisplayRequestedEventArgs

   procedure Initialize (this : in out AccessKeyDisplayRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccessKeyDisplayRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccessKeyDisplayRequestedEventArgs, IAccessKeyDisplayRequestedEventArgs_Ptr);
   begin
      if this.m_IAccessKeyDisplayRequestedEventArgs /= null then
         if this.m_IAccessKeyDisplayRequestedEventArgs.all /= null then
            temp := this.m_IAccessKeyDisplayRequestedEventArgs.all.Release;
            Free (this.m_IAccessKeyDisplayRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AccessKeyDisplayRequestedEventArgs

   function Constructor return AccessKeyDisplayRequestedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IAccessKeyDisplayRequestedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IAccessKeyDisplayRequestedEventArgs;
   begin
      return RetVal : AccessKeyDisplayRequestedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAccessKeyDisplayRequestedEventArgs := new WinRt.Windows.UI.Xaml.Input.IAccessKeyDisplayRequestedEventArgs;
            Retval.m_IAccessKeyDisplayRequestedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccessKeyDisplayRequestedEventArgs

   function get_PressedKeys
   (
      this : in out AccessKeyDisplayRequestedEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAccessKeyDisplayRequestedEventArgs.all.get_PressedKeys (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccessKeyInvokedEventArgs

   procedure Initialize (this : in out AccessKeyInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccessKeyInvokedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccessKeyInvokedEventArgs, IAccessKeyInvokedEventArgs_Ptr);
   begin
      if this.m_IAccessKeyInvokedEventArgs /= null then
         if this.m_IAccessKeyInvokedEventArgs.all /= null then
            temp := this.m_IAccessKeyInvokedEventArgs.all.Release;
            Free (this.m_IAccessKeyInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AccessKeyInvokedEventArgs

   function Constructor return AccessKeyInvokedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IAccessKeyInvokedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IAccessKeyInvokedEventArgs;
   begin
      return RetVal : AccessKeyInvokedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAccessKeyInvokedEventArgs := new WinRt.Windows.UI.Xaml.Input.IAccessKeyInvokedEventArgs;
            Retval.m_IAccessKeyInvokedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccessKeyInvokedEventArgs

   function get_Handled
   (
      this : in out AccessKeyInvokedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAccessKeyInvokedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out AccessKeyInvokedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAccessKeyInvokedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AccessKeyManager

   procedure Initialize (this : in out AccessKeyManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out AccessKeyManager) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAccessKeyManager, IAccessKeyManager_Ptr);
   begin
      if this.m_IAccessKeyManager /= null then
         if this.m_IAccessKeyManager.all /= null then
            temp := this.m_IAccessKeyManager.all.Release;
            Free (this.m_IAccessKeyManager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AccessKeyManager

   function get_AreKeyTipsEnabled
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.AccessKeyManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IAccessKeyManagerStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAccessKeyManagerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_AreKeyTipsEnabled (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure put_AreKeyTipsEnabled
   (
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.AccessKeyManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IAccessKeyManagerStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAccessKeyManagerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_AreKeyTipsEnabled (value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsDisplayModeEnabled
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.AccessKeyManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IAccessKeyManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAccessKeyManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_IsDisplayModeEnabled (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function add_IsDisplayModeEnabledChanged
   (
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.AccessKeyManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IAccessKeyManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAccessKeyManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_IsDisplayModeEnabledChanged (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_IsDisplayModeEnabledChanged
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.AccessKeyManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IAccessKeyManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAccessKeyManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_IsDisplayModeEnabledChanged (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   procedure ExitDisplayMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.AccessKeyManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IAccessKeyManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAccessKeyManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.ExitDisplayMode;
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AccessKeyManager

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CanExecuteRequestedEventArgs

   procedure Initialize (this : in out CanExecuteRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CanExecuteRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICanExecuteRequestedEventArgs, ICanExecuteRequestedEventArgs_Ptr);
   begin
      if this.m_ICanExecuteRequestedEventArgs /= null then
         if this.m_ICanExecuteRequestedEventArgs.all /= null then
            temp := this.m_ICanExecuteRequestedEventArgs.all.Release;
            Free (this.m_ICanExecuteRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CanExecuteRequestedEventArgs

   function get_Parameter
   (
      this : in out CanExecuteRequestedEventArgs
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := this.m_ICanExecuteRequestedEventArgs.all.get_Parameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanExecute
   (
      this : in out CanExecuteRequestedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICanExecuteRequestedEventArgs.all.get_CanExecute (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanExecute
   (
      this : in out CanExecuteRequestedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICanExecuteRequestedEventArgs.all.put_CanExecute (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CharacterReceivedRoutedEventArgs

   procedure Initialize (this : in out CharacterReceivedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CharacterReceivedRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICharacterReceivedRoutedEventArgs, ICharacterReceivedRoutedEventArgs_Ptr);
   begin
      if this.m_ICharacterReceivedRoutedEventArgs /= null then
         if this.m_ICharacterReceivedRoutedEventArgs.all /= null then
            temp := this.m_ICharacterReceivedRoutedEventArgs.all.Release;
            Free (this.m_ICharacterReceivedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CharacterReceivedRoutedEventArgs

   function get_Character
   (
      this : in out CharacterReceivedRoutedEventArgs
   )
   return WinRt.Wide_Char is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Wide_Char;
   begin
      Hr := this.m_ICharacterReceivedRoutedEventArgs.all.get_Character (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KeyStatus
   (
      this : in out CharacterReceivedRoutedEventArgs
   )
   return WinRt.Windows.UI.Core.CorePhysicalKeyStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CorePhysicalKeyStatus;
   begin
      Hr := this.m_ICharacterReceivedRoutedEventArgs.all.get_KeyStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out CharacterReceivedRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICharacterReceivedRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out CharacterReceivedRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICharacterReceivedRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContextRequestedEventArgs

   procedure Initialize (this : in out ContextRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContextRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContextRequestedEventArgs, IContextRequestedEventArgs_Ptr);
   begin
      if this.m_IContextRequestedEventArgs /= null then
         if this.m_IContextRequestedEventArgs.all /= null then
            temp := this.m_IContextRequestedEventArgs.all.Release;
            Free (this.m_IContextRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContextRequestedEventArgs

   function Constructor return ContextRequestedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IContextRequestedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IContextRequestedEventArgs;
   begin
      return RetVal : ContextRequestedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IContextRequestedEventArgs := new WinRt.Windows.UI.Xaml.Input.IContextRequestedEventArgs;
            Retval.m_IContextRequestedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContextRequestedEventArgs

   function get_Handled
   (
      this : in out ContextRequestedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IContextRequestedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ContextRequestedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IContextRequestedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryGetPosition
   (
      this : in out ContextRequestedEventArgs;
      relativeTo : WinRt.Windows.UI.Xaml.UIElement'Class;
      point : WinRt.Windows.Foundation.Point_Ptr
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IContextRequestedEventArgs.all.TryGetPosition (relativeTo.m_IUIElement.all, point, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DoubleTappedEventHandler

   function Invoke
   (
      this : access DoubleTappedEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IDoubleTappedRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DoubleTappedRoutedEventArgs

   procedure Initialize (this : in out DoubleTappedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DoubleTappedRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDoubleTappedRoutedEventArgs, IDoubleTappedRoutedEventArgs_Ptr);
   begin
      if this.m_IDoubleTappedRoutedEventArgs /= null then
         if this.m_IDoubleTappedRoutedEventArgs.all /= null then
            temp := this.m_IDoubleTappedRoutedEventArgs.all.Release;
            Free (this.m_IDoubleTappedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DoubleTappedRoutedEventArgs

   function Constructor return DoubleTappedRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IDoubleTappedRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IDoubleTappedRoutedEventArgs;
   begin
      return RetVal : DoubleTappedRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDoubleTappedRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IDoubleTappedRoutedEventArgs;
            Retval.m_IDoubleTappedRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DoubleTappedRoutedEventArgs

   function get_PointerDeviceType
   (
      this : in out DoubleTappedRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IDoubleTappedRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out DoubleTappedRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDoubleTappedRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DoubleTappedRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDoubleTappedRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPosition
   (
      this : in out DoubleTappedRoutedEventArgs;
      relativeTo : WinRt.Windows.UI.Xaml.UIElement'Class
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IDoubleTappedRoutedEventArgs.all.GetPosition (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExecuteRequestedEventArgs

   procedure Initialize (this : in out ExecuteRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExecuteRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExecuteRequestedEventArgs, IExecuteRequestedEventArgs_Ptr);
   begin
      if this.m_IExecuteRequestedEventArgs /= null then
         if this.m_IExecuteRequestedEventArgs.all /= null then
            temp := this.m_IExecuteRequestedEventArgs.all.Release;
            Free (this.m_IExecuteRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExecuteRequestedEventArgs

   function get_Parameter
   (
      this : in out ExecuteRequestedEventArgs
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := this.m_IExecuteRequestedEventArgs.all.get_Parameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FindNextElementOptions

   procedure Initialize (this : in out FindNextElementOptions) is
   begin
      null;
   end;

   procedure Finalize (this : in out FindNextElementOptions) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFindNextElementOptions, IFindNextElementOptions_Ptr);
   begin
      if this.m_IFindNextElementOptions /= null then
         if this.m_IFindNextElementOptions.all /= null then
            temp := this.m_IFindNextElementOptions.all.Release;
            Free (this.m_IFindNextElementOptions);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FindNextElementOptions

   function Constructor return FindNextElementOptions is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IFindNextElementOptions");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IFindNextElementOptions;
   begin
      return RetVal : FindNextElementOptions do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IFindNextElementOptions := new WinRt.Windows.UI.Xaml.Input.IFindNextElementOptions;
            Retval.m_IFindNextElementOptions.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FindNextElementOptions

   function get_SearchRoot
   (
      this : in out FindNextElementOptions
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IFindNextElementOptions.all.get_SearchRoot (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_SearchRoot
   (
      this : in out FindNextElementOptions;
      value : WinRt.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IFindNextElementOptions.all.put_SearchRoot (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExclusionRect
   (
      this : in out FindNextElementOptions
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Rect;
   begin
      Hr := this.m_IFindNextElementOptions.all.get_ExclusionRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExclusionRect
   (
      this : in out FindNextElementOptions;
      value : WinRt.Windows.Foundation.Rect
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IFindNextElementOptions.all.put_ExclusionRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HintRect
   (
      this : in out FindNextElementOptions
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Rect;
   begin
      Hr := this.m_IFindNextElementOptions.all.get_HintRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HintRect
   (
      this : in out FindNextElementOptions;
      value : WinRt.Windows.Foundation.Rect
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IFindNextElementOptions.all.put_HintRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusNavigationStrategyOverride
   (
      this : in out FindNextElementOptions
   )
   return WinRt.Windows.UI.Xaml.Input.XYFocusNavigationStrategyOverride is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.XYFocusNavigationStrategyOverride;
   begin
      Hr := this.m_IFindNextElementOptions.all.get_XYFocusNavigationStrategyOverride (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_XYFocusNavigationStrategyOverride
   (
      this : in out FindNextElementOptions;
      value : WinRt.Windows.UI.Xaml.Input.XYFocusNavigationStrategyOverride
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IFindNextElementOptions.all.put_XYFocusNavigationStrategyOverride (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusManager

   procedure Initialize (this : in out FocusManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusManager) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusManager, IFocusManager_Ptr);
   begin
      if this.m_IFocusManager /= null then
         if this.m_IFocusManager.all /= null then
            temp := this.m_IFocusManager.all.Release;
            Free (this.m_IFocusManager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FocusManager

   function TryMoveFocus
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection;
      focusNavigationOptions : WinRt.Windows.UI.Xaml.Input.FindNextElementOptions'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.TryMoveFocus (focusNavigationDirection, focusNavigationOptions.m_IFindNextElementOptions.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FindNextElement
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection
   )
   return WinRt.Windows.UI.Xaml.DependencyObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindNextElement (focusNavigationDirection, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
            Retval.m_IDependencyObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function FindFirstFocusableElement
   (
      searchScope : WinRt.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinRt.Windows.UI.Xaml.DependencyObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindFirstFocusableElement (searchScope.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
            Retval.m_IDependencyObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function FindLastFocusableElement
   (
      searchScope : WinRt.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinRt.Windows.UI.Xaml.DependencyObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindLastFocusableElement (searchScope.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
            Retval.m_IDependencyObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function FindNextElement
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection;
      focusNavigationOptions : WinRt.Windows.UI.Xaml.Input.FindNextElementOptions'Class
   )
   return WinRt.Windows.UI.Xaml.DependencyObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics4_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindNextElement (focusNavigationDirection, focusNavigationOptions.m_IFindNextElementOptions.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
            Retval.m_IDependencyObject.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetFocusedElement
   (
      xamlRoot : WinRt.Windows.UI.Xaml.XamlRoot'Class
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics7_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics7'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetFocusedElement (xamlRoot.m_IXamlRoot.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetFocusedElement
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetFocusedElement (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FindNextFocusableElement
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection
   )
   return WinRt.Windows.UI.Xaml.UIElement is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics3_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.UIElement do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindNextFocusableElement (focusNavigationDirection, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IUIElement := new WinRt.Windows.UI.Xaml.IUIElement;
            Retval.m_IUIElement.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function FindNextFocusableElement
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection;
      hintRect : WinRt.Windows.Foundation.Rect
   )
   return WinRt.Windows.UI.Xaml.UIElement is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics3_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.UIElement do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FindNextFocusableElement (focusNavigationDirection, hintRect, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IUIElement := new WinRt.Windows.UI.Xaml.IUIElement;
            Retval.m_IUIElement.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function TryFocusAsync
   (
      element : WinRt.Windows.UI.Xaml.DependencyObject'Class;
      value : WinRt.Windows.UI.Xaml.FocusState
   )
   return WinRt.Windows.UI.Xaml.Input.FocusMovementResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics5_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_FocusMovementResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_FocusMovementResult.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Xaml.Input.IFocusMovementResult;
      m_IID            : aliased WinRt.IID := (245647723, 14302, 24152, (139, 13, 44, 57, 144, 196, 203, 178 )); -- Windows.UI.Xaml.Input.FocusMovementResult;
      m_HandlerIID     : aliased WinRt.IID := (464124808, 64573, 23133, (174, 132, 167, 69, 207, 180, 57, 123 ));
      m_Handler        : AsyncOperationCompletedHandler_FocusMovementResult.Kind := new AsyncOperationCompletedHandler_FocusMovementResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_FocusMovementResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_FocusMovementResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_FocusMovementResult.Kind_Delegate, AsyncOperationCompletedHandler_FocusMovementResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.FocusMovementResult do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryFocusAsync (element.m_IDependencyObject.all, value, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IFocusMovementResult := new WinRt.Windows.UI.Xaml.Input.IFocusMovementResult;
                     Retval.m_IFocusMovementResult.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function TryMoveFocusAsync
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection
   )
   return WinRt.Windows.UI.Xaml.Input.FocusMovementResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics5_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_FocusMovementResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_FocusMovementResult.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Xaml.Input.IFocusMovementResult;
      m_IID            : aliased WinRt.IID := (245647723, 14302, 24152, (139, 13, 44, 57, 144, 196, 203, 178 )); -- Windows.UI.Xaml.Input.FocusMovementResult;
      m_HandlerIID     : aliased WinRt.IID := (464124808, 64573, 23133, (174, 132, 167, 69, 207, 180, 57, 123 ));
      m_Handler        : AsyncOperationCompletedHandler_FocusMovementResult.Kind := new AsyncOperationCompletedHandler_FocusMovementResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_FocusMovementResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_FocusMovementResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_FocusMovementResult.Kind_Delegate, AsyncOperationCompletedHandler_FocusMovementResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.FocusMovementResult do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryMoveFocusAsync (focusNavigationDirection, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IFocusMovementResult := new WinRt.Windows.UI.Xaml.Input.IFocusMovementResult;
                     Retval.m_IFocusMovementResult.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function TryMoveFocusAsync
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection;
      focusNavigationOptions : WinRt.Windows.UI.Xaml.Input.FindNextElementOptions'Class
   )
   return WinRt.Windows.UI.Xaml.Input.FocusMovementResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics5_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_FocusMovementResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_FocusMovementResult.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Xaml.Input.IFocusMovementResult;
      m_IID            : aliased WinRt.IID := (245647723, 14302, 24152, (139, 13, 44, 57, 144, 196, 203, 178 )); -- Windows.UI.Xaml.Input.FocusMovementResult;
      m_HandlerIID     : aliased WinRt.IID := (464124808, 64573, 23133, (174, 132, 167, 69, 207, 180, 57, 123 ));
      m_Handler        : AsyncOperationCompletedHandler_FocusMovementResult.Kind := new AsyncOperationCompletedHandler_FocusMovementResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_FocusMovementResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_FocusMovementResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_FocusMovementResult.Kind_Delegate, AsyncOperationCompletedHandler_FocusMovementResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.FocusMovementResult do
         Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryMoveFocusAsync (focusNavigationDirection, focusNavigationOptions.m_IFindNextElementOptions.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IFocusMovementResult := new WinRt.Windows.UI.Xaml.Input.IFocusMovementResult;
                     Retval.m_IFocusMovementResult.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function add_GotFocus
   (
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_GotFocus (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_GotFocus
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_GotFocus (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_LostFocus
   (
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_LostFocus (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_LostFocus
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_LostFocus (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_GettingFocus
   (
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_GettingFocus (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_GettingFocus
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_GettingFocus (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function add_LosingFocus
   (
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.add_LosingFocus (handler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure remove_LosingFocus
   (
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics6_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics6'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.remove_LosingFocus (token);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function TryMoveFocus
   (
      focusNavigationDirection : WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.FocusManager");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IFocusManagerStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFocusManagerStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.TryMoveFocus (focusNavigationDirection, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusManager

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusManagerGotFocusEventArgs

   procedure Initialize (this : in out FocusManagerGotFocusEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusManagerGotFocusEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusManagerGotFocusEventArgs, IFocusManagerGotFocusEventArgs_Ptr);
   begin
      if this.m_IFocusManagerGotFocusEventArgs /= null then
         if this.m_IFocusManagerGotFocusEventArgs.all /= null then
            temp := this.m_IFocusManagerGotFocusEventArgs.all.Release;
            Free (this.m_IFocusManagerGotFocusEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusManagerGotFocusEventArgs

   function get_NewFocusedElement
   (
      this : in out FocusManagerGotFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IFocusManagerGotFocusEventArgs.all.get_NewFocusedElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_CorrelationId
   (
      this : in out FocusManagerGotFocusEventArgs
   )
   return WinRt.Guid is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Guid;
   begin
      Hr := this.m_IFocusManagerGotFocusEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusManagerLostFocusEventArgs

   procedure Initialize (this : in out FocusManagerLostFocusEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusManagerLostFocusEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusManagerLostFocusEventArgs, IFocusManagerLostFocusEventArgs_Ptr);
   begin
      if this.m_IFocusManagerLostFocusEventArgs /= null then
         if this.m_IFocusManagerLostFocusEventArgs.all /= null then
            temp := this.m_IFocusManagerLostFocusEventArgs.all.Release;
            Free (this.m_IFocusManagerLostFocusEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusManagerLostFocusEventArgs

   function get_OldFocusedElement
   (
      this : in out FocusManagerLostFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IFocusManagerLostFocusEventArgs.all.get_OldFocusedElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_CorrelationId
   (
      this : in out FocusManagerLostFocusEventArgs
   )
   return WinRt.Guid is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Guid;
   begin
      Hr := this.m_IFocusManagerLostFocusEventArgs.all.get_CorrelationId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusMovementResult

   procedure Initialize (this : in out FocusMovementResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusMovementResult) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusMovementResult, IFocusMovementResult_Ptr);
   begin
      if this.m_IFocusMovementResult /= null then
         if this.m_IFocusMovementResult.all /= null then
            temp := this.m_IFocusMovementResult.all.Release;
            Free (this.m_IFocusMovementResult);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusMovementResult

   function get_Succeeded
   (
      this : in out FocusMovementResult
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IFocusMovementResult.all.get_Succeeded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GettingFocusEventArgs

   procedure Initialize (this : in out GettingFocusEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out GettingFocusEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGettingFocusEventArgs, IGettingFocusEventArgs_Ptr);
   begin
      if this.m_IGettingFocusEventArgs /= null then
         if this.m_IGettingFocusEventArgs.all /= null then
            temp := this.m_IGettingFocusEventArgs.all.Release;
            Free (this.m_IGettingFocusEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GettingFocusEventArgs

   function get_OldFocusedElement
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IGettingFocusEventArgs.all.get_OldFocusedElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_NewFocusedElement
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IGettingFocusEventArgs.all.get_NewFocusedElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_NewFocusedElement
   (
      this : in out GettingFocusEventArgs;
      value : WinRt.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.put_NewFocusedElement (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusState
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.FocusState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.FocusState;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.get_FocusState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Direction
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.get_Direction (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out GettingFocusEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputDevice
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.FocusInputDeviceKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.FocusInputDeviceKind;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.get_InputDevice (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out GettingFocusEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGettingFocusEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryCancel
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs2, WinRt.Windows.UI.Xaml.Input.IID_IGettingFocusEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGettingFocusEventArgs.all);
      Hr := m_Interface.TryCancel (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TrySetNewFocusedElement
   (
      this : in out GettingFocusEventArgs;
      element : WinRt.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs2, WinRt.Windows.UI.Xaml.Input.IID_IGettingFocusEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGettingFocusEventArgs.all);
      Hr := m_Interface.TrySetNewFocusedElement (element.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CorrelationId
   (
      this : in out GettingFocusEventArgs
   )
   return WinRt.Guid is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Guid;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.IGettingFocusEventArgs3, WinRt.Windows.UI.Xaml.Input.IID_IGettingFocusEventArgs3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGettingFocusEventArgs.all);
      Hr := m_Interface.get_CorrelationId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate HoldingEventHandler

   function Invoke
   (
      this : access HoldingEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IHoldingRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HoldingRoutedEventArgs

   procedure Initialize (this : in out HoldingRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HoldingRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHoldingRoutedEventArgs, IHoldingRoutedEventArgs_Ptr);
   begin
      if this.m_IHoldingRoutedEventArgs /= null then
         if this.m_IHoldingRoutedEventArgs.all /= null then
            temp := this.m_IHoldingRoutedEventArgs.all.Release;
            Free (this.m_IHoldingRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HoldingRoutedEventArgs

   function Constructor return HoldingRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IHoldingRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IHoldingRoutedEventArgs;
   begin
      return RetVal : HoldingRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IHoldingRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IHoldingRoutedEventArgs;
            Retval.m_IHoldingRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HoldingRoutedEventArgs

   function get_PointerDeviceType
   (
      this : in out HoldingRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IHoldingRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HoldingState
   (
      this : in out HoldingRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.HoldingState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.HoldingState;
   begin
      Hr := this.m_IHoldingRoutedEventArgs.all.get_HoldingState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out HoldingRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IHoldingRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out HoldingRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IHoldingRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPosition
   (
      this : in out HoldingRoutedEventArgs;
      relativeTo : WinRt.Windows.UI.Xaml.UIElement'Class
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IHoldingRoutedEventArgs.all.GetPosition (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InertiaExpansionBehavior

   procedure Initialize (this : in out InertiaExpansionBehavior) is
   begin
      null;
   end;

   procedure Finalize (this : in out InertiaExpansionBehavior) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInertiaExpansionBehavior, IInertiaExpansionBehavior_Ptr);
   begin
      if this.m_IInertiaExpansionBehavior /= null then
         if this.m_IInertiaExpansionBehavior.all /= null then
            temp := this.m_IInertiaExpansionBehavior.all.Release;
            Free (this.m_IInertiaExpansionBehavior);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InertiaExpansionBehavior

   function get_DesiredDeceleration
   (
      this : in out InertiaExpansionBehavior
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInertiaExpansionBehavior.all.get_DesiredDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredDeceleration
   (
      this : in out InertiaExpansionBehavior;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInertiaExpansionBehavior.all.put_DesiredDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredExpansion
   (
      this : in out InertiaExpansionBehavior
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInertiaExpansionBehavior.all.get_DesiredExpansion (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredExpansion
   (
      this : in out InertiaExpansionBehavior;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInertiaExpansionBehavior.all.put_DesiredExpansion (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InertiaRotationBehavior

   procedure Initialize (this : in out InertiaRotationBehavior) is
   begin
      null;
   end;

   procedure Finalize (this : in out InertiaRotationBehavior) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInertiaRotationBehavior, IInertiaRotationBehavior_Ptr);
   begin
      if this.m_IInertiaRotationBehavior /= null then
         if this.m_IInertiaRotationBehavior.all /= null then
            temp := this.m_IInertiaRotationBehavior.all.Release;
            Free (this.m_IInertiaRotationBehavior);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InertiaRotationBehavior

   function get_DesiredDeceleration
   (
      this : in out InertiaRotationBehavior
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInertiaRotationBehavior.all.get_DesiredDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredDeceleration
   (
      this : in out InertiaRotationBehavior;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInertiaRotationBehavior.all.put_DesiredDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredRotation
   (
      this : in out InertiaRotationBehavior
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInertiaRotationBehavior.all.get_DesiredRotation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredRotation
   (
      this : in out InertiaRotationBehavior;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInertiaRotationBehavior.all.put_DesiredRotation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InertiaTranslationBehavior

   procedure Initialize (this : in out InertiaTranslationBehavior) is
   begin
      null;
   end;

   procedure Finalize (this : in out InertiaTranslationBehavior) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInertiaTranslationBehavior, IInertiaTranslationBehavior_Ptr);
   begin
      if this.m_IInertiaTranslationBehavior /= null then
         if this.m_IInertiaTranslationBehavior.all /= null then
            temp := this.m_IInertiaTranslationBehavior.all.Release;
            Free (this.m_IInertiaTranslationBehavior);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InertiaTranslationBehavior

   function get_DesiredDeceleration
   (
      this : in out InertiaTranslationBehavior
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInertiaTranslationBehavior.all.get_DesiredDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredDeceleration
   (
      this : in out InertiaTranslationBehavior;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInertiaTranslationBehavior.all.put_DesiredDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredDisplacement
   (
      this : in out InertiaTranslationBehavior
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IInertiaTranslationBehavior.all.get_DesiredDisplacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredDisplacement
   (
      this : in out InertiaTranslationBehavior;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInertiaTranslationBehavior.all.put_DesiredDisplacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputScope

   procedure Initialize (this : in out InputScope) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputScope) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputScope, IInputScope_Ptr);
   begin
      if this.m_IInputScope /= null then
         if this.m_IInputScope.all /= null then
            temp := this.m_IInputScope.all.Release;
            Free (this.m_IInputScope);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InputScope

   function Constructor return InputScope is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IInputScope");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IInputScope;
   begin
      return RetVal : InputScope do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInputScope := new WinRt.Windows.UI.Xaml.Input.IInputScope;
            Retval.m_IInputScope.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputScope

   function get_Names
   (
      this : in out InputScope
   )
   return IVector_IInputScopeName.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IVector_IInputScopeName.Kind;
   begin
      Hr := this.m_IInputScope.all.get_Names (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInputScopeName (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputScopeName

   procedure Initialize (this : in out InputScopeName) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputScopeName) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputScopeName, IInputScopeName_Ptr);
   begin
      if this.m_IInputScopeName /= null then
         if this.m_IInputScopeName.all /= null then
            temp := this.m_IInputScopeName.all.Release;
            Free (this.m_IInputScopeName);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InputScopeName

   function Constructor
   (
      nameValue : WinRt.Windows.UI.Xaml.Input.InputScopeNameValue
   )
   return InputScopeName is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IInputScopeName");
      m_Factory    : access IInputScopeNameFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IInputScopeName;
   begin
      return RetVal : InputScopeName do
         Hr := RoGetActivationFactory (m_hString, IID_IInputScopeNameFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (nameValue, m_ComRetVal'Access);
            Retval.m_IInputScopeName := new WinRt.Windows.UI.Xaml.Input.IInputScopeName;
            Retval.m_IInputScopeName.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor return InputScopeName is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IInputScopeName");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IInputScopeName;
   begin
      return RetVal : InputScopeName do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInputScopeName := new WinRt.Windows.UI.Xaml.Input.IInputScopeName;
            Retval.m_IInputScopeName.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputScopeName

   function get_NameValue
   (
      this : in out InputScopeName
   )
   return WinRt.Windows.UI.Xaml.Input.InputScopeNameValue is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.InputScopeNameValue;
   begin
      Hr := this.m_IInputScopeName.all.get_NameValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NameValue
   (
      this : in out InputScopeName;
      value : WinRt.Windows.UI.Xaml.Input.InputScopeNameValue
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInputScopeName.all.put_NameValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate KeyEventHandler

   function Invoke
   (
      this : access KeyEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IKeyRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyRoutedEventArgs

   procedure Initialize (this : in out KeyRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyRoutedEventArgs, IKeyRoutedEventArgs_Ptr);
   begin
      if this.m_IKeyRoutedEventArgs /= null then
         if this.m_IKeyRoutedEventArgs.all /= null then
            temp := this.m_IKeyRoutedEventArgs.all.Release;
            Free (this.m_IKeyRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyRoutedEventArgs

   function get_Key
   (
      this : in out KeyRoutedEventArgs
   )
   return WinRt.Windows.System.VirtualKey is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKey;
   begin
      Hr := this.m_IKeyRoutedEventArgs.all.get_Key (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KeyStatus
   (
      this : in out KeyRoutedEventArgs
   )
   return WinRt.Windows.UI.Core.CorePhysicalKeyStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CorePhysicalKeyStatus;
   begin
      Hr := this.m_IKeyRoutedEventArgs.all.get_KeyStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out KeyRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IKeyRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out KeyRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OriginalKey
   (
      this : in out KeyRoutedEventArgs
   )
   return WinRt.Windows.System.VirtualKey is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IKeyRoutedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKey;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IKeyRoutedEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.IKeyRoutedEventArgs2, WinRt.Windows.UI.Xaml.Input.IID_IKeyRoutedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyRoutedEventArgs.all);
      Hr := m_Interface.get_OriginalKey (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DeviceId
   (
      this : in out KeyRoutedEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IKeyRoutedEventArgs3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IKeyRoutedEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.IKeyRoutedEventArgs3, WinRt.Windows.UI.Xaml.Input.IID_IKeyRoutedEventArgs3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyRoutedEventArgs.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyboardAccelerator

   procedure Initialize (this : in out KeyboardAccelerator) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyboardAccelerator) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyboardAccelerator, IKeyboardAccelerator_Ptr);
   begin
      if this.m_IKeyboardAccelerator /= null then
         if this.m_IKeyboardAccelerator.all /= null then
            temp := this.m_IKeyboardAccelerator.all.Release;
            Free (this.m_IKeyboardAccelerator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for KeyboardAccelerator

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return KeyboardAccelerator is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IKeyboardAccelerator");
      m_Factory    : access IKeyboardAcceleratorFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IKeyboardAccelerator;
   begin
      return RetVal : KeyboardAccelerator do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyboardAcceleratorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IKeyboardAccelerator := new WinRt.Windows.UI.Xaml.Input.IKeyboardAccelerator;
            Retval.m_IKeyboardAccelerator.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for KeyboardAccelerator

   function get_KeyProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.KeyboardAccelerator");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IKeyboardAcceleratorStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyboardAcceleratorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ModifiersProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.KeyboardAccelerator");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IKeyboardAcceleratorStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyboardAcceleratorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ModifiersProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsEnabledProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.KeyboardAccelerator");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IKeyboardAcceleratorStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyboardAcceleratorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScopeOwnerProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.KeyboardAccelerator");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IKeyboardAcceleratorStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyboardAcceleratorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScopeOwnerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyboardAccelerator

   function get_Key
   (
      this : in out KeyboardAccelerator
   )
   return WinRt.Windows.System.VirtualKey is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKey;
   begin
      Hr := this.m_IKeyboardAccelerator.all.get_Key (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Key
   (
      this : in out KeyboardAccelerator;
      value : WinRt.Windows.System.VirtualKey
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardAccelerator.all.put_Key (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Modifiers
   (
      this : in out KeyboardAccelerator
   )
   return WinRt.Windows.System.VirtualKeyModifiers is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKeyModifiers;
   begin
      Hr := this.m_IKeyboardAccelerator.all.get_Modifiers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Modifiers
   (
      this : in out KeyboardAccelerator;
      value : WinRt.Windows.System.VirtualKeyModifiers
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardAccelerator.all.put_Modifiers (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsEnabled
   (
      this : in out KeyboardAccelerator
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IKeyboardAccelerator.all.get_IsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsEnabled
   (
      this : in out KeyboardAccelerator;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardAccelerator.all.put_IsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ScopeOwner
   (
      this : in out KeyboardAccelerator
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IKeyboardAccelerator.all.get_ScopeOwner (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ScopeOwner
   (
      this : in out KeyboardAccelerator;
      value : WinRt.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardAccelerator.all.put_ScopeOwner (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Invoked
   (
      this : in out KeyboardAccelerator;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IKeyboardAccelerator.all.add_Invoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Invoked
   (
      this : in out KeyboardAccelerator;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardAccelerator.all.remove_Invoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyboardAcceleratorInvokedEventArgs

   procedure Initialize (this : in out KeyboardAcceleratorInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyboardAcceleratorInvokedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyboardAcceleratorInvokedEventArgs, IKeyboardAcceleratorInvokedEventArgs_Ptr);
   begin
      if this.m_IKeyboardAcceleratorInvokedEventArgs /= null then
         if this.m_IKeyboardAcceleratorInvokedEventArgs.all /= null then
            temp := this.m_IKeyboardAcceleratorInvokedEventArgs.all.Release;
            Free (this.m_IKeyboardAcceleratorInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyboardAcceleratorInvokedEventArgs

   function get_Handled
   (
      this : in out KeyboardAcceleratorInvokedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IKeyboardAcceleratorInvokedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out KeyboardAcceleratorInvokedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardAcceleratorInvokedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Element
   (
      this : in out KeyboardAcceleratorInvokedEventArgs
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IKeyboardAcceleratorInvokedEventArgs.all.get_Element (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_KeyboardAccelerator
   (
      this : in out KeyboardAcceleratorInvokedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.KeyboardAccelerator'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IKeyboardAcceleratorInvokedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.IKeyboardAccelerator;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IKeyboardAcceleratorInvokedEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.IKeyboardAcceleratorInvokedEventArgs2, WinRt.Windows.UI.Xaml.Input.IID_IKeyboardAcceleratorInvokedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.KeyboardAccelerator do
         m_Interface := QInterface (this.m_IKeyboardAcceleratorInvokedEventArgs.all);
         Hr := m_Interface.get_KeyboardAccelerator (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IKeyboardAccelerator := new WinRt.Windows.UI.Xaml.Input.IKeyboardAccelerator;
         Retval.m_IKeyboardAccelerator.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LosingFocusEventArgs

   procedure Initialize (this : in out LosingFocusEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out LosingFocusEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILosingFocusEventArgs, ILosingFocusEventArgs_Ptr);
   begin
      if this.m_ILosingFocusEventArgs /= null then
         if this.m_ILosingFocusEventArgs.all /= null then
            temp := this.m_ILosingFocusEventArgs.all.Release;
            Free (this.m_ILosingFocusEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LosingFocusEventArgs

   function get_OldFocusedElement
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ILosingFocusEventArgs.all.get_OldFocusedElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_NewFocusedElement
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_ILosingFocusEventArgs.all.get_NewFocusedElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinRt.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_NewFocusedElement
   (
      this : in out LosingFocusEventArgs;
      value : WinRt.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.put_NewFocusedElement (value.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusState
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.FocusState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.FocusState;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.get_FocusState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Direction
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.get_Direction (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out LosingFocusEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputDevice
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.FocusInputDeviceKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.FocusInputDeviceKind;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.get_InputDevice (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out LosingFocusEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILosingFocusEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryCancel
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs2, WinRt.Windows.UI.Xaml.Input.IID_ILosingFocusEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILosingFocusEventArgs.all);
      Hr := m_Interface.TryCancel (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TrySetNewFocusedElement
   (
      this : in out LosingFocusEventArgs;
      element : WinRt.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs2, WinRt.Windows.UI.Xaml.Input.IID_ILosingFocusEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILosingFocusEventArgs.all);
      Hr := m_Interface.TrySetNewFocusedElement (element.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CorrelationId
   (
      this : in out LosingFocusEventArgs
   )
   return WinRt.Guid is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Guid;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.ILosingFocusEventArgs3, WinRt.Windows.UI.Xaml.Input.IID_ILosingFocusEventArgs3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILosingFocusEventArgs.all);
      Hr := m_Interface.get_CorrelationId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ManipulationCompletedEventHandler

   function Invoke
   (
      this : access ManipulationCompletedEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IManipulationCompletedRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationCompletedRoutedEventArgs

   procedure Initialize (this : in out ManipulationCompletedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationCompletedRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationCompletedRoutedEventArgs, IManipulationCompletedRoutedEventArgs_Ptr);
   begin
      if this.m_IManipulationCompletedRoutedEventArgs /= null then
         if this.m_IManipulationCompletedRoutedEventArgs.all /= null then
            temp := this.m_IManipulationCompletedRoutedEventArgs.all.Release;
            Free (this.m_IManipulationCompletedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ManipulationCompletedRoutedEventArgs

   function Constructor return ManipulationCompletedRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IManipulationCompletedRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IManipulationCompletedRoutedEventArgs;
   begin
      return RetVal : ManipulationCompletedRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IManipulationCompletedRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IManipulationCompletedRoutedEventArgs;
            Retval.m_IManipulationCompletedRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationCompletedRoutedEventArgs

   function get_Container
   (
      this : in out ManipulationCompletedRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.UIElement do
         Hr := this.m_IManipulationCompletedRoutedEventArgs.all.get_Container (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinRt.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Position
   (
      this : in out ManipulationCompletedRoutedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationCompletedRoutedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInertial
   (
      this : in out ManipulationCompletedRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IManipulationCompletedRoutedEventArgs.all.get_IsInertial (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationCompletedRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationCompletedRoutedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationCompletedRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationVelocities is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationCompletedRoutedEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out ManipulationCompletedRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IManipulationCompletedRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ManipulationCompletedRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationCompletedRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationCompletedRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationCompletedRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ManipulationDeltaEventHandler

   function Invoke
   (
      this : access ManipulationDeltaEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IManipulationDeltaRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationDeltaRoutedEventArgs

   procedure Initialize (this : in out ManipulationDeltaRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationDeltaRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationDeltaRoutedEventArgs, IManipulationDeltaRoutedEventArgs_Ptr);
   begin
      if this.m_IManipulationDeltaRoutedEventArgs /= null then
         if this.m_IManipulationDeltaRoutedEventArgs.all /= null then
            temp := this.m_IManipulationDeltaRoutedEventArgs.all.Release;
            Free (this.m_IManipulationDeltaRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ManipulationDeltaRoutedEventArgs

   function Constructor return ManipulationDeltaRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IManipulationDeltaRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IManipulationDeltaRoutedEventArgs;
   begin
      return RetVal : ManipulationDeltaRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IManipulationDeltaRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IManipulationDeltaRoutedEventArgs;
            Retval.m_IManipulationDeltaRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationDeltaRoutedEventArgs

   function get_Container
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.UIElement do
         Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_Container (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinRt.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Position
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInertial
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_IsInertial (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Delta
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_Delta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationVelocities is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ManipulationDeltaRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationDeltaRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Complete
   (
      this : in out ManipulationDeltaRoutedEventArgs
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationDeltaRoutedEventArgs.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ManipulationInertiaStartingEventHandler

   function Invoke
   (
      this : access ManipulationInertiaStartingEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationInertiaStartingRoutedEventArgs

   procedure Initialize (this : in out ManipulationInertiaStartingRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationInertiaStartingRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationInertiaStartingRoutedEventArgs, IManipulationInertiaStartingRoutedEventArgs_Ptr);
   begin
      if this.m_IManipulationInertiaStartingRoutedEventArgs /= null then
         if this.m_IManipulationInertiaStartingRoutedEventArgs.all /= null then
            temp := this.m_IManipulationInertiaStartingRoutedEventArgs.all.Release;
            Free (this.m_IManipulationInertiaStartingRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ManipulationInertiaStartingRoutedEventArgs

   function Constructor return ManipulationInertiaStartingRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IManipulationInertiaStartingRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IManipulationInertiaStartingRoutedEventArgs;
   begin
      return RetVal : ManipulationInertiaStartingRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IManipulationInertiaStartingRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IManipulationInertiaStartingRoutedEventArgs;
            Retval.m_IManipulationInertiaStartingRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationInertiaStartingRoutedEventArgs

   function get_Container
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.UIElement do
         Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_Container (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinRt.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_ExpansionBehavior
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.InertiaExpansionBehavior'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.IInertiaExpansionBehavior;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.InertiaExpansionBehavior do
         Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_ExpansionBehavior (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInertiaExpansionBehavior := new WinRt.Windows.UI.Xaml.Input.IInertiaExpansionBehavior;
         Retval.m_IInertiaExpansionBehavior.all := m_ComRetVal;
      end return;
   end;

   procedure put_ExpansionBehavior
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs;
      value : WinRt.Windows.UI.Xaml.Input.InertiaExpansionBehavior'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.put_ExpansionBehavior (value.m_IInertiaExpansionBehavior.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationBehavior
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.InertiaRotationBehavior'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.IInertiaRotationBehavior;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.InertiaRotationBehavior do
         Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_RotationBehavior (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInertiaRotationBehavior := new WinRt.Windows.UI.Xaml.Input.IInertiaRotationBehavior;
         Retval.m_IInertiaRotationBehavior.all := m_ComRetVal;
      end return;
   end;

   procedure put_RotationBehavior
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs;
      value : WinRt.Windows.UI.Xaml.Input.InertiaRotationBehavior'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.put_RotationBehavior (value.m_IInertiaRotationBehavior.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TranslationBehavior
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.InertiaTranslationBehavior'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.IInertiaTranslationBehavior;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.InertiaTranslationBehavior do
         Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_TranslationBehavior (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInertiaTranslationBehavior := new WinRt.Windows.UI.Xaml.Input.IInertiaTranslationBehavior;
         Retval.m_IInertiaTranslationBehavior.all := m_ComRetVal;
      end return;
   end;

   procedure put_TranslationBehavior
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs;
      value : WinRt.Windows.UI.Xaml.Input.InertiaTranslationBehavior'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.put_TranslationBehavior (value.m_IInertiaTranslationBehavior.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Handled
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Delta
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_Delta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationInertiaStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationVelocities is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationInertiaStartingRoutedEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationPivot

   procedure Initialize (this : in out ManipulationPivot) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationPivot) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationPivot, IManipulationPivot_Ptr);
   begin
      if this.m_IManipulationPivot /= null then
         if this.m_IManipulationPivot.all /= null then
            temp := this.m_IManipulationPivot.all.Release;
            Free (this.m_IManipulationPivot);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ManipulationPivot

   function Constructor return ManipulationPivot is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IManipulationPivot");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IManipulationPivot;
   begin
      return RetVal : ManipulationPivot do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IManipulationPivot := new WinRt.Windows.UI.Xaml.Input.IManipulationPivot;
            Retval.m_IManipulationPivot.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      center : WinRt.Windows.Foundation.Point;
      radius : WinRt.Double
   )
   return ManipulationPivot is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IManipulationPivot");
      m_Factory    : access IManipulationPivotFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IManipulationPivot;
   begin
      return RetVal : ManipulationPivot do
         Hr := RoGetActivationFactory (m_hString, IID_IManipulationPivotFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithCenterAndRadius (center, radius, m_ComRetVal'Access);
            Retval.m_IManipulationPivot := new WinRt.Windows.UI.Xaml.Input.IManipulationPivot;
            Retval.m_IManipulationPivot.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationPivot

   function get_Center
   (
      this : in out ManipulationPivot
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationPivot.all.get_Center (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Center
   (
      this : in out ManipulationPivot;
      value : WinRt.Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationPivot.all.put_Center (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Radius
   (
      this : in out ManipulationPivot
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IManipulationPivot.all.get_Radius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Radius
   (
      this : in out ManipulationPivot;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationPivot.all.put_Radius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ManipulationStartedEventHandler

   function Invoke
   (
      this : access ManipulationStartedEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IManipulationStartedRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationStartedRoutedEventArgs

   procedure Initialize (this : in out ManipulationStartedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationStartedRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationStartedRoutedEventArgs, IManipulationStartedRoutedEventArgs_Ptr);
   begin
      if this.m_IManipulationStartedRoutedEventArgs /= null then
         if this.m_IManipulationStartedRoutedEventArgs.all /= null then
            temp := this.m_IManipulationStartedRoutedEventArgs.all.Release;
            Free (this.m_IManipulationStartedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ManipulationStartedRoutedEventArgs

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return ManipulationStartedRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IManipulationStartedRoutedEventArgs");
      m_Factory    : access IManipulationStartedRoutedEventArgsFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IManipulationStartedRoutedEventArgs;
   begin
      return RetVal : ManipulationStartedRoutedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_IManipulationStartedRoutedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IManipulationStartedRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IManipulationStartedRoutedEventArgs;
            Retval.m_IManipulationStartedRoutedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationStartedRoutedEventArgs

   function get_Container
   (
      this : in out ManipulationStartedRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.UIElement do
         Hr := this.m_IManipulationStartedRoutedEventArgs.all.get_Container (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinRt.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Position
   (
      this : in out ManipulationStartedRoutedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationStartedRoutedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out ManipulationStartedRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IManipulationStartedRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ManipulationStartedRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationStartedRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerDeviceType
   (
      this : in out ManipulationStartedRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationStartedRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationStartedRoutedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationStartedRoutedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Complete
   (
      this : in out ManipulationStartedRoutedEventArgs
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationStartedRoutedEventArgs.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ManipulationStartingEventHandler

   function Invoke
   (
      this : access ManipulationStartingEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IManipulationStartingRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationStartingRoutedEventArgs

   procedure Initialize (this : in out ManipulationStartingRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationStartingRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationStartingRoutedEventArgs, IManipulationStartingRoutedEventArgs_Ptr);
   begin
      if this.m_IManipulationStartingRoutedEventArgs /= null then
         if this.m_IManipulationStartingRoutedEventArgs.all /= null then
            temp := this.m_IManipulationStartingRoutedEventArgs.all.Release;
            Free (this.m_IManipulationStartingRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ManipulationStartingRoutedEventArgs

   function Constructor return ManipulationStartingRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IManipulationStartingRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IManipulationStartingRoutedEventArgs;
   begin
      return RetVal : ManipulationStartingRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IManipulationStartingRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IManipulationStartingRoutedEventArgs;
            Retval.m_IManipulationStartingRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationStartingRoutedEventArgs

   function get_Mode
   (
      this : in out ManipulationStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.ManipulationModes is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.ManipulationModes;
   begin
      Hr := this.m_IManipulationStartingRoutedEventArgs.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Mode
   (
      this : in out ManipulationStartingRoutedEventArgs;
      value : WinRt.Windows.UI.Xaml.Input.ManipulationModes
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationStartingRoutedEventArgs.all.put_Mode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Container
   (
      this : in out ManipulationStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.UIElement do
         Hr := this.m_IManipulationStartingRoutedEventArgs.all.get_Container (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinRt.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Container
   (
      this : in out ManipulationStartingRoutedEventArgs;
      value : WinRt.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationStartingRoutedEventArgs.all.put_Container (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pivot
   (
      this : in out ManipulationStartingRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.ManipulationPivot'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.IManipulationPivot;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.ManipulationPivot do
         Hr := this.m_IManipulationStartingRoutedEventArgs.all.get_Pivot (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IManipulationPivot := new WinRt.Windows.UI.Xaml.Input.IManipulationPivot;
         Retval.m_IManipulationPivot.all := m_ComRetVal;
      end return;
   end;

   procedure put_Pivot
   (
      this : in out ManipulationStartingRoutedEventArgs;
      value : WinRt.Windows.UI.Xaml.Input.ManipulationPivot'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationStartingRoutedEventArgs.all.put_Pivot (value.m_IManipulationPivot.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Handled
   (
      this : in out ManipulationStartingRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IManipulationStartingRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ManipulationStartingRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IManipulationStartingRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NoFocusCandidateFoundEventArgs

   procedure Initialize (this : in out NoFocusCandidateFoundEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NoFocusCandidateFoundEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INoFocusCandidateFoundEventArgs, INoFocusCandidateFoundEventArgs_Ptr);
   begin
      if this.m_INoFocusCandidateFoundEventArgs /= null then
         if this.m_INoFocusCandidateFoundEventArgs.all /= null then
            temp := this.m_INoFocusCandidateFoundEventArgs.all.Release;
            Free (this.m_INoFocusCandidateFoundEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NoFocusCandidateFoundEventArgs

   function get_Direction
   (
      this : in out NoFocusCandidateFoundEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.FocusNavigationDirection;
   begin
      Hr := this.m_INoFocusCandidateFoundEventArgs.all.get_Direction (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out NoFocusCandidateFoundEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_INoFocusCandidateFoundEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out NoFocusCandidateFoundEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_INoFocusCandidateFoundEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputDevice
   (
      this : in out NoFocusCandidateFoundEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.FocusInputDeviceKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.FocusInputDeviceKind;
   begin
      Hr := this.m_INoFocusCandidateFoundEventArgs.all.get_InputDevice (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Pointer

   procedure Initialize (this : in out Pointer) is
   begin
      null;
   end;

   procedure Finalize (this : in out Pointer) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointer, IPointer_Ptr);
   begin
      if this.m_IPointer /= null then
         if this.m_IPointer.all /= null then
            temp := this.m_IPointer.all.Release;
            Free (this.m_IPointer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Pointer

   function get_PointerId
   (
      this : in out Pointer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IPointer.all.get_PointerId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerDeviceType
   (
      this : in out Pointer
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IPointer.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInContact
   (
      this : in out Pointer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointer.all.get_IsInContact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInRange
   (
      this : in out Pointer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointer.all.get_IsInRange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate PointerEventHandler

   function Invoke
   (
      this : access PointerEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IPointerRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerRoutedEventArgs

   procedure Initialize (this : in out PointerRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerRoutedEventArgs, IPointerRoutedEventArgs_Ptr);
   begin
      if this.m_IPointerRoutedEventArgs /= null then
         if this.m_IPointerRoutedEventArgs.all /= null then
            temp := this.m_IPointerRoutedEventArgs.all.Release;
            Free (this.m_IPointerRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerRoutedEventArgs

   function get_Pointer
   (
      this : in out PointerRoutedEventArgs
   )
   return WinRt.Windows.UI.Xaml.Input.Pointer'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.IPointer;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Input.Pointer do
         Hr := this.m_IPointerRoutedEventArgs.all.get_Pointer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointer := new WinRt.Windows.UI.Xaml.Input.IPointer;
         Retval.m_IPointer.all := m_ComRetVal;
      end return;
   end;

   function get_KeyModifiers
   (
      this : in out PointerRoutedEventArgs
   )
   return WinRt.Windows.System.VirtualKeyModifiers is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKeyModifiers;
   begin
      Hr := this.m_IPointerRoutedEventArgs.all.get_KeyModifiers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out PointerRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out PointerRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointerRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetCurrentPoint
   (
      this : in out PointerRoutedEventArgs;
      relativeTo : WinRt.Windows.UI.Xaml.UIElement'Class
   )
   return WinRt.Windows.UI.Input.PointerPoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.IPointerPoint;
   begin
      return RetVal : WinRt.Windows.UI.Input.PointerPoint do
         Hr := this.m_IPointerRoutedEventArgs.all.GetCurrentPoint (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerPoint := new WinRt.Windows.UI.Input.IPointerPoint;
         Retval.m_IPointerPoint.all := m_ComRetVal;
      end return;
   end;

   function GetIntermediatePoints
   (
      this : in out PointerRoutedEventArgs;
      relativeTo : WinRt.Windows.UI.Xaml.UIElement'Class
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := this.m_IPointerRoutedEventArgs.all.GetIntermediatePoints (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsGenerated
   (
      this : in out PointerRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IPointerRoutedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IPointerRoutedEventArgs_Interface, WinRt.Windows.UI.Xaml.Input.IPointerRoutedEventArgs2, WinRt.Windows.UI.Xaml.Input.IID_IPointerRoutedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointerRoutedEventArgs.all);
      Hr := m_Interface.get_IsGenerated (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProcessKeyboardAcceleratorEventArgs

   procedure Initialize (this : in out ProcessKeyboardAcceleratorEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProcessKeyboardAcceleratorEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProcessKeyboardAcceleratorEventArgs, IProcessKeyboardAcceleratorEventArgs_Ptr);
   begin
      if this.m_IProcessKeyboardAcceleratorEventArgs /= null then
         if this.m_IProcessKeyboardAcceleratorEventArgs.all /= null then
            temp := this.m_IProcessKeyboardAcceleratorEventArgs.all.Release;
            Free (this.m_IProcessKeyboardAcceleratorEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProcessKeyboardAcceleratorEventArgs

   function get_Key
   (
      this : in out ProcessKeyboardAcceleratorEventArgs
   )
   return WinRt.Windows.System.VirtualKey is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKey;
   begin
      Hr := this.m_IProcessKeyboardAcceleratorEventArgs.all.get_Key (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Modifiers
   (
      this : in out ProcessKeyboardAcceleratorEventArgs
   )
   return WinRt.Windows.System.VirtualKeyModifiers is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKeyModifiers;
   begin
      Hr := this.m_IProcessKeyboardAcceleratorEventArgs.all.get_Modifiers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out ProcessKeyboardAcceleratorEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IProcessKeyboardAcceleratorEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ProcessKeyboardAcceleratorEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IProcessKeyboardAcceleratorEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate RightTappedEventHandler

   function Invoke
   (
      this : access RightTappedEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.IRightTappedRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RightTappedRoutedEventArgs

   procedure Initialize (this : in out RightTappedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RightTappedRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRightTappedRoutedEventArgs, IRightTappedRoutedEventArgs_Ptr);
   begin
      if this.m_IRightTappedRoutedEventArgs /= null then
         if this.m_IRightTappedRoutedEventArgs.all /= null then
            temp := this.m_IRightTappedRoutedEventArgs.all.Release;
            Free (this.m_IRightTappedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RightTappedRoutedEventArgs

   function Constructor return RightTappedRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IRightTappedRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IRightTappedRoutedEventArgs;
   begin
      return RetVal : RightTappedRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRightTappedRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.IRightTappedRoutedEventArgs;
            Retval.m_IRightTappedRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RightTappedRoutedEventArgs

   function get_PointerDeviceType
   (
      this : in out RightTappedRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IRightTappedRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out RightTappedRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRightTappedRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out RightTappedRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRightTappedRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPosition
   (
      this : in out RightTappedRoutedEventArgs;
      relativeTo : WinRt.Windows.UI.Xaml.UIElement'Class
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IRightTappedRoutedEventArgs.all.GetPosition (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for XamlUICommand

   procedure Initialize (this : in out XamlUICommand) is
   begin
      null;
   end;

   procedure Finalize (this : in out XamlUICommand) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IXamlUICommand, IXamlUICommand_Ptr);
   begin
      if this.m_IXamlUICommand /= null then
         if this.m_IXamlUICommand.all /= null then
            temp := this.m_IXamlUICommand.all.Release;
            Free (this.m_IXamlUICommand);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for XamlUICommand

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return XamlUICommand is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IXamlUICommand");
      m_Factory    : access IXamlUICommandFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IXamlUICommand;
   begin
      return RetVal : XamlUICommand do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlUICommandFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IXamlUICommand := new WinRt.Windows.UI.Xaml.Input.IXamlUICommand;
            Retval.m_IXamlUICommand.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for XamlUICommand

   function get_LabelProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.XamlUICommand");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IXamlUICommandStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlUICommandStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconSourceProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.XamlUICommand");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IXamlUICommandStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlUICommandStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorsProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.XamlUICommand");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IXamlUICommandStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlUICommandStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AccessKeyProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.XamlUICommand");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IXamlUICommandStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlUICommandStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AccessKeyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.XamlUICommand");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IXamlUICommandStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlUICommandStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.XamlUICommand");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IXamlUICommandStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IXamlUICommandStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for XamlUICommand

   function get_Label
   (
      this : in out XamlUICommand
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IXamlUICommand.all.get_Label (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Label
   (
      this : in out XamlUICommand;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IXamlUICommand.all.put_Label (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IconSource
   (
      this : in out XamlUICommand
   )
   return WinRt.Windows.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.Controls.IconSource do
         Hr := this.m_IXamlUICommand.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinRt.Windows.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out XamlUICommand;
      value : WinRt.Windows.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IXamlUICommand.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAccelerators
   (
      this : in out XamlUICommand
   )
   return IVector_IKeyboardAccelerator.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IVector_IKeyboardAccelerator.Kind;
   begin
      Hr := this.m_IXamlUICommand.all.get_KeyboardAccelerators (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IKeyboardAccelerator (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_AccessKey
   (
      this : in out XamlUICommand
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IXamlUICommand.all.get_AccessKey (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_AccessKey
   (
      this : in out XamlUICommand;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IXamlUICommand.all.put_AccessKey (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Description
   (
      this : in out XamlUICommand
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IXamlUICommand.all.get_Description (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Description
   (
      this : in out XamlUICommand;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IXamlUICommand.all.put_Description (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Command
   (
      this : in out XamlUICommand
   )
   return WinRt.Windows.UI.Xaml.Input.ICommand is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IXamlUICommand.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out XamlUICommand;
      value : WinRt.Windows.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IXamlUICommand.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ExecuteRequested
   (
      this : in out XamlUICommand;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IXamlUICommand.all.add_ExecuteRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ExecuteRequested
   (
      this : in out XamlUICommand;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IXamlUICommand.all.remove_ExecuteRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CanExecuteRequested
   (
      this : in out XamlUICommand;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IXamlUICommand.all.add_CanExecuteRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CanExecuteRequested
   (
      this : in out XamlUICommand;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IXamlUICommand.all.remove_CanExecuteRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure NotifyCanExecuteChanged
   (
      this : in out XamlUICommand
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IXamlUICommand.all.NotifyCanExecuteChanged;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CanExecuteChanged
   (
      this : in out XamlUICommand;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.ICommand := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IXamlUICommand_Interface, WinRt.Windows.UI.Xaml.Input.ICommand, WinRt.Windows.UI.Xaml.Input.IID_ICommand'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlUICommand.all);
      Hr := m_Interface.add_CanExecuteChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CanExecuteChanged
   (
      this : in out XamlUICommand;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.ICommand := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IXamlUICommand_Interface, WinRt.Windows.UI.Xaml.Input.ICommand, WinRt.Windows.UI.Xaml.Input.IID_ICommand'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlUICommand.all);
      Hr := m_Interface.remove_CanExecuteChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CanExecute
   (
      this : in out XamlUICommand;
      parameter : WinRt.IInspectable
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.ICommand := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IXamlUICommand_Interface, WinRt.Windows.UI.Xaml.Input.ICommand, WinRt.Windows.UI.Xaml.Input.IID_ICommand'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlUICommand.all);
      Hr := m_Interface.CanExecute (parameter, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Execute
   (
      this : in out XamlUICommand;
      parameter : WinRt.IInspectable
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.ICommand := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IXamlUICommand_Interface, WinRt.Windows.UI.Xaml.Input.ICommand, WinRt.Windows.UI.Xaml.Input.IID_ICommand'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IXamlUICommand.all);
      Hr := m_Interface.Execute (parameter);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StandardUICommand

   procedure Initialize (this : in out StandardUICommand) is
   begin
      null;
   end;

   procedure Finalize (this : in out StandardUICommand) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStandardUICommand, IStandardUICommand_Ptr);
   begin
      if this.m_IStandardUICommand /= null then
         if this.m_IStandardUICommand.all /= null then
            temp := this.m_IStandardUICommand.all.Release;
            Free (this.m_IStandardUICommand);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StandardUICommand

   function Constructor
   (
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return StandardUICommand is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IStandardUICommand");
      m_Factory    : access IStandardUICommandFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IStandardUICommand;
   begin
      return RetVal : StandardUICommand do
         Hr := RoGetActivationFactory (m_hString, IID_IStandardUICommandFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStandardUICommand := new WinRt.Windows.UI.Xaml.Input.IStandardUICommand;
            Retval.m_IStandardUICommand.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      kind : WinRt.Windows.UI.Xaml.Input.StandardUICommandKind;
      baseInterface : WinRt.IInspectable;
      innerInterface : access WinRt.IInspectable
   )
   return StandardUICommand is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.IStandardUICommand");
      m_Factory    : access IStandardUICommandFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.IStandardUICommand;
   begin
      return RetVal : StandardUICommand do
         Hr := RoGetActivationFactory (m_hString, IID_IStandardUICommandFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithKind (kind, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStandardUICommand := new WinRt.Windows.UI.Xaml.Input.IStandardUICommand;
            Retval.m_IStandardUICommand.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for StandardUICommand

   function get_KindProperty
   return WinRt.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.StandardUICommand");
      m_Factory        : access WinRt.Windows.UI.Xaml.Input.IStandardUICommandStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinRt.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStandardUICommandStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KindProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinRt.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StandardUICommand

   function get_Kind
   (
      this : in out StandardUICommand
   )
   return WinRt.Windows.UI.Xaml.Input.StandardUICommandKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Xaml.Input.StandardUICommandKind;
   begin
      Hr := this.m_IStandardUICommand.all.get_Kind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Kind
   (
      this : in out StandardUICommand;
      value : WinRt.Windows.UI.Xaml.Input.StandardUICommandKind
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Xaml.Input.IStandardUICommand2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Xaml.Input.IStandardUICommand_Interface, WinRt.Windows.UI.Xaml.Input.IStandardUICommand2, WinRt.Windows.UI.Xaml.Input.IID_IStandardUICommand2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStandardUICommand.all);
      Hr := m_Interface.put_Kind (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate TappedEventHandler

   function Invoke
   (
      this : access TappedEventHandler_Delegate;
      sender : WinRt.IInspectable;
      e : WinRt.Windows.UI.Xaml.Input.ITappedRoutedEventArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TappedRoutedEventArgs

   procedure Initialize (this : in out TappedRoutedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TappedRoutedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITappedRoutedEventArgs, ITappedRoutedEventArgs_Ptr);
   begin
      if this.m_ITappedRoutedEventArgs /= null then
         if this.m_ITappedRoutedEventArgs.all /= null then
            temp := this.m_ITappedRoutedEventArgs.all.Release;
            Free (this.m_ITappedRoutedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TappedRoutedEventArgs

   function Constructor return TappedRoutedEventArgs is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Xaml.Input.ITappedRoutedEventArgs");
      m_ComRetVal  : aliased WinRt.Windows.UI.Xaml.Input.ITappedRoutedEventArgs;
   begin
      return RetVal : TappedRoutedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITappedRoutedEventArgs := new WinRt.Windows.UI.Xaml.Input.ITappedRoutedEventArgs;
            Retval.m_ITappedRoutedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TappedRoutedEventArgs

   function get_PointerDeviceType
   (
      this : in out TappedRoutedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_ITappedRoutedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out TappedRoutedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ITappedRoutedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TappedRoutedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ITappedRoutedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPosition
   (
      this : in out TappedRoutedEventArgs;
      relativeTo : WinRt.Windows.UI.Xaml.UIElement'Class
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_ITappedRoutedEventArgs.all.GetPosition (relativeTo.m_IUIElement.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

end WinRt.Windows.UI.Xaml.Input;
