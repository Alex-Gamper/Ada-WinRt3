--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.Security.Cryptography.Certificates;
with WinRt.Windows.Storage.Streams;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Security.Cryptography.Core is

   package IAsyncOperation_IBuffer is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Storage.Streams.IBuffer);
   package AsyncOperationCompletedHandler_IBuffer is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Storage.Streams.IBuffer);

   package IAsyncOperation_CryptographicKey is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.Security.Cryptography.Core.ICryptographicKey);
   package AsyncOperationCompletedHandler_CryptographicKey is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.Security.Cryptography.Core.ICryptographicKey);

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body AsymmetricAlgorithmNames is

      function get_EcdsaSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EcdsaSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_EcdsaSha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EcdsaSha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_EcdsaSha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EcdsaSha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaPkcs1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaPkcs1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaOaepSha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaOaepSha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaOaepSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaOaepSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaOaepSha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaOaepSha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaOaepSha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaOaepSha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_EcdsaP256Sha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EcdsaP256Sha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_EcdsaP384Sha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EcdsaP384Sha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_EcdsaP521Sha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_EcdsaP521Sha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_DsaSha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DsaSha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_DsaSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DsaSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPkcs1Sha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPkcs1Sha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPkcs1Sha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPkcs1Sha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPkcs1Sha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPkcs1Sha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPkcs1Sha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPkcs1Sha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPssSha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPssSha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPssSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPssSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPssSha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPssSha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_RsaSignPssSha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RsaSignPssSha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end AsymmetricAlgorithmNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AsymmetricKeyAlgorithmProvider

   procedure Initialize (this : in out AsymmetricKeyAlgorithmProvider) is
   begin
      null;
   end;

   procedure Finalize (this : in out AsymmetricKeyAlgorithmProvider) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAsymmetricKeyAlgorithmProvider, IAsymmetricKeyAlgorithmProvider_Ptr);
   begin
      if this.m_IAsymmetricKeyAlgorithmProvider /= null then
         if this.m_IAsymmetricKeyAlgorithmProvider.all /= null then
            RefCount := this.m_IAsymmetricKeyAlgorithmProvider.all.Release;
            Free (this.m_IAsymmetricKeyAlgorithmProvider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AsymmetricKeyAlgorithmProvider

   function OpenAlgorithm
   (
      algorithm : WinRt.WString
   )
   return WinRt.Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProviderStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider;
      HStr_algorithm : WinRt.HString := To_HString (algorithm);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider do
         Hr := RoGetActivationFactory (m_hString, IID_IAsymmetricKeyAlgorithmProviderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.OpenAlgorithm (HStr_algorithm, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IAsymmetricKeyAlgorithmProvider := new Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider;
            Retval.m_IAsymmetricKeyAlgorithmProvider.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_algorithm);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AsymmetricKeyAlgorithmProvider

   function get_AlgorithmName
   (
      this : in out AsymmetricKeyAlgorithmProvider
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAsymmetricKeyAlgorithmProvider.all.get_AlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function CreateKeyPair
   (
      this : in out AsymmetricKeyAlgorithmProvider;
      keySize : WinRt.UInt32
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_IAsymmetricKeyAlgorithmProvider.all.CreateKeyPair (keySize, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   function ImportKeyPair
   (
      this : in out AsymmetricKeyAlgorithmProvider;
      keyBlob : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_IAsymmetricKeyAlgorithmProvider.all.ImportKeyPair (keyBlob, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   function ImportKeyPair
   (
      this : in out AsymmetricKeyAlgorithmProvider;
      keyBlob : Windows.Storage.Streams.IBuffer;
      BlobType : Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_IAsymmetricKeyAlgorithmProvider.all.ImportKeyPair (keyBlob, BlobType, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   function ImportPublicKey
   (
      this : in out AsymmetricKeyAlgorithmProvider;
      keyBlob : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_IAsymmetricKeyAlgorithmProvider.all.ImportPublicKey (keyBlob, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   function ImportPublicKey
   (
      this : in out AsymmetricKeyAlgorithmProvider;
      keyBlob : Windows.Storage.Streams.IBuffer;
      BlobType : Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_IAsymmetricKeyAlgorithmProvider.all.ImportPublicKey (keyBlob, BlobType, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   function CreateKeyPairWithCurveName
   (
      this : in out AsymmetricKeyAlgorithmProvider;
      curveName : WinRt.WString
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
      HStr_curveName : WinRt.HString := To_HString (curveName);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider_Interface, WinRt.Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider2, WinRt.Windows.Security.Cryptography.Core.IID_IAsymmetricKeyAlgorithmProvider2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         m_Interface := QInterface (this.m_IAsymmetricKeyAlgorithmProvider.all);
         Hr := m_Interface.CreateKeyPairWithCurveName (HStr_curveName, m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
         Hr := WindowsDeleteString (HStr_curveName);
      end return;
   end;

   function CreateKeyPairWithCurveParameters
   (
      this : in out AsymmetricKeyAlgorithmProvider;
      parameters : WinRt.Byte_Array
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider_Interface, WinRt.Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider2, WinRt.Windows.Security.Cryptography.Core.IID_IAsymmetricKeyAlgorithmProvider2'Unchecked_Access);
      function Convert_parameters is new Ada.Unchecked_Conversion (Address, WinRt.Byte_Ptr);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         m_Interface := QInterface (this.m_IAsymmetricKeyAlgorithmProvider.all);
         Hr := m_Interface.CreateKeyPairWithCurveParameters (WinRt.UInt32(parameters'Length), Convert_parameters (parameters (parameters'First)'Address), m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body CryptographicEngine is

      function SignHashedData
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.SignHashedData (key.m_ICryptographicKey.all, data, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function VerifySignatureWithHashInput
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer;
         signature : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.VerifySignatureWithHashInput (key.m_ICryptographicKey.all, data, signature, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function DecryptAsync
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer;
         iv : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_IBuffer.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Storage.Streams.IBuffer;
         m_IID            : aliased WinRt.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
         m_HandlerIID     : aliased WinRt.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
         m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.DecryptAsync (key.m_ICryptographicKey.all, data, iv, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_RetVal;
      end;

      function SignAsync
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_IBuffer.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Storage.Streams.IBuffer;
         m_IID            : aliased WinRt.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
         m_HandlerIID     : aliased WinRt.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
         m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.SignAsync (key.m_ICryptographicKey.all, data, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_RetVal;
      end;

      function SignHashedDataAsync
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_IBuffer.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_IBuffer.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Storage.Streams.IBuffer;
         m_IID            : aliased WinRt.IID := (1005488180, 47527, 23168, (167, 70, 94, 240, 151, 34, 120, 120 )); -- Windows.Storage.Streams.IBuffer;
         m_HandlerIID     : aliased WinRt.IID := (1371788029, 47265, 22048, (183, 70, 126, 230, 213, 51, 172, 163 ));
         m_Handler        : AsyncOperationCompletedHandler_IBuffer.Kind := new AsyncOperationCompletedHandler_IBuffer.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IBuffer.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IBuffer.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IBuffer.Kind_Delegate, AsyncOperationCompletedHandler_IBuffer.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.SignHashedDataAsync (key.m_ICryptographicKey.all, data, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               m_RefCount := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  end if;
                  m_RefCount := m_AsyncOperation.Release;
                  m_RefCount := m_Handler.Release;
                  if m_RefCount = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_RetVal;
      end;

      function Encrypt
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer;
         iv : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Encrypt (key.m_ICryptographicKey.all, data, iv, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function Decrypt
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer;
         iv : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Decrypt (key.m_ICryptographicKey.all, data, iv, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function EncryptAndAuthenticate
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer;
         nonce : Windows.Storage.Streams.IBuffer;
         authenticatedData : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IEncryptedAndAuthenticatedData;
      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData do
            Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.EncryptAndAuthenticate (key.m_ICryptographicKey.all, data, nonce, authenticatedData, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               Retval.m_IEncryptedAndAuthenticatedData := new Windows.Security.Cryptography.Core.IEncryptedAndAuthenticatedData;
               Retval.m_IEncryptedAndAuthenticatedData.all := m_ComRetVal;
            end if;
            Hr := WindowsDeleteString (m_hString);
         end return;
      end;

      function DecryptAndAuthenticate
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer;
         nonce : Windows.Storage.Streams.IBuffer;
         authenticationTag : Windows.Storage.Streams.IBuffer;
         authenticatedData : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.DecryptAndAuthenticate (key.m_ICryptographicKey.all, data, nonce, authenticationTag, authenticatedData, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function Sign
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Sign (key.m_ICryptographicKey.all, data, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function VerifySignature
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         data : Windows.Storage.Streams.IBuffer;
         signature : Windows.Storage.Streams.IBuffer
      )
      return WinRt.Boolean is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.Boolean;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.VerifySignature (key.m_ICryptographicKey.all, data, signature, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function DeriveKeyMaterial
      (
         key : Windows.Security.Cryptography.Core.CryptographicKey'Class;
         parameters : Windows.Security.Cryptography.Core.KeyDerivationParameters'Class;
         desiredKeySize : WinRt.UInt32
      )
      return WinRt.Windows.Storage.Streams.IBuffer is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.CryptographicEngine");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ICryptographicEngineStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ICryptographicEngineStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.DeriveKeyMaterial (key.m_ICryptographicKey.all, parameters.m_IKeyDerivationParameters.all, desiredKeySize, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

   end CryptographicEngine;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CryptographicHash

   procedure Initialize (this : in out CryptographicHash) is
   begin
      null;
   end;

   procedure Finalize (this : in out CryptographicHash) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHashComputation, IHashComputation_Ptr);
   begin
      if this.m_IHashComputation /= null then
         if this.m_IHashComputation.all /= null then
            RefCount := this.m_IHashComputation.all.Release;
            Free (this.m_IHashComputation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CryptographicHash

   procedure Append
   (
      this : in out CryptographicHash;
      data : Windows.Storage.Streams.IBuffer
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IHashComputation.all.Append (data);
   end;

   function GetValueAndReset
   (
      this : in out CryptographicHash
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IHashComputation.all.GetValueAndReset (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CryptographicKey

   procedure Initialize (this : in out CryptographicKey) is
   begin
      null;
   end;

   procedure Finalize (this : in out CryptographicKey) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICryptographicKey, ICryptographicKey_Ptr);
   begin
      if this.m_ICryptographicKey /= null then
         if this.m_ICryptographicKey.all /= null then
            RefCount := this.m_ICryptographicKey.all.Release;
            Free (this.m_ICryptographicKey);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CryptographicKey

   function get_KeySize
   (
      this : in out CryptographicKey
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICryptographicKey.all.get_KeySize (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function Export
   (
      this : in out CryptographicKey
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_ICryptographicKey.all.Export (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function Export
   (
      this : in out CryptographicKey;
      BlobType : Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_ICryptographicKey.all.Export (BlobType, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function ExportPublicKey
   (
      this : in out CryptographicKey
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_ICryptographicKey.all.ExportPublicKey (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function ExportPublicKey
   (
      this : in out CryptographicKey;
      BlobType : Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_ICryptographicKey.all.ExportPublicKey (BlobType, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body EccCurveNames is

      function get_BrainpoolP160r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP160r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP160t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP160t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP192r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP192r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP192t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP192t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP224r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP224r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP224t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP224t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP256r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP256r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP256t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP256t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP320r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP320r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP320t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP320t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP384r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP384r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP384t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP384t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP512r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP512r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_BrainpoolP512t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BrainpoolP512t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Curve25519
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Curve25519 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Ec192wapi
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Ec192wapi (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NistP192
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NistP192 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NistP224
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NistP224 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NistP256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NistP256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NistP384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NistP384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NistP521
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NistP521 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NumsP256t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NumsP256t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NumsP384t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NumsP384t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_NumsP512t1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NumsP512t1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP160k1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP160k1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP160r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP160r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP160r2
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP160r2 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP192k1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP192k1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP192r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP192r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP224k1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP224k1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP224r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP224r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP256k1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP256k1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP256r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP256r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP384r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP384r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_SecP521r1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecP521r1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Wtls7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Wtls7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Wtls9
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Wtls9 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Wtls12
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Wtls12 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_X962P192v1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_X962P192v1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_X962P192v2
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_X962P192v2 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_X962P192v3
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_X962P192v3 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_X962P239v1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_X962P239v1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_X962P239v2
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_X962P239v2 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_X962P239v3
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_X962P239v3 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_X962P256v1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_X962P256v1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AllEccCurveNames
      return WinRt.GenericObject is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.EccCurveNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IEccCurveNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased GenericObject;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IEccCurveNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllEccCurveNames (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

   end EccCurveNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EncryptedAndAuthenticatedData

   procedure Initialize (this : in out EncryptedAndAuthenticatedData) is
   begin
      null;
   end;

   procedure Finalize (this : in out EncryptedAndAuthenticatedData) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEncryptedAndAuthenticatedData, IEncryptedAndAuthenticatedData_Ptr);
   begin
      if this.m_IEncryptedAndAuthenticatedData /= null then
         if this.m_IEncryptedAndAuthenticatedData.all /= null then
            RefCount := this.m_IEncryptedAndAuthenticatedData.all.Release;
            Free (this.m_IEncryptedAndAuthenticatedData);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EncryptedAndAuthenticatedData

   function get_EncryptedData
   (
      this : in out EncryptedAndAuthenticatedData
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IEncryptedAndAuthenticatedData.all.get_EncryptedData (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_AuthenticationTag
   (
      this : in out EncryptedAndAuthenticatedData
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IEncryptedAndAuthenticatedData.all.get_AuthenticationTag (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body HashAlgorithmNames is

      function get_Md5
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.HashAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IHashAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IHashAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Md5 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.HashAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IHashAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IHashAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.HashAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IHashAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IHashAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.HashAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IHashAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IHashAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.HashAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IHashAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IHashAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end HashAlgorithmNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HashAlgorithmProvider

   procedure Initialize (this : in out HashAlgorithmProvider) is
   begin
      null;
   end;

   procedure Finalize (this : in out HashAlgorithmProvider) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHashAlgorithmProvider, IHashAlgorithmProvider_Ptr);
   begin
      if this.m_IHashAlgorithmProvider /= null then
         if this.m_IHashAlgorithmProvider.all /= null then
            RefCount := this.m_IHashAlgorithmProvider.all.Release;
            Free (this.m_IHashAlgorithmProvider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for HashAlgorithmProvider

   function OpenAlgorithm
   (
      algorithm : WinRt.WString
   )
   return WinRt.Windows.Security.Cryptography.Core.HashAlgorithmProvider is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.HashAlgorithmProvider");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IHashAlgorithmProviderStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IHashAlgorithmProvider;
      HStr_algorithm : WinRt.HString := To_HString (algorithm);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.HashAlgorithmProvider do
         Hr := RoGetActivationFactory (m_hString, IID_IHashAlgorithmProviderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.OpenAlgorithm (HStr_algorithm, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IHashAlgorithmProvider := new Windows.Security.Cryptography.Core.IHashAlgorithmProvider;
            Retval.m_IHashAlgorithmProvider.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_algorithm);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HashAlgorithmProvider

   function get_AlgorithmName
   (
      this : in out HashAlgorithmProvider
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IHashAlgorithmProvider.all.get_AlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_HashLength
   (
      this : in out HashAlgorithmProvider
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IHashAlgorithmProvider.all.get_HashLength (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function HashData
   (
      this : in out HashAlgorithmProvider;
      data : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IHashAlgorithmProvider.all.HashData (data, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function CreateHash
   (
      this : in out HashAlgorithmProvider
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicHash'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IHashComputation;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicHash do
         Hr := this.m_IHashAlgorithmProvider.all.CreateHash (m_ComRetVal'Access);
         Retval.m_IHashComputation := new Windows.Security.Cryptography.Core.IHashComputation;
         Retval.m_IHashComputation.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body KeyDerivationAlgorithmNames is

      function get_CapiKdfMd5
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CapiKdfMd5 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_CapiKdfSha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CapiKdfSha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_CapiKdfSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CapiKdfSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_CapiKdfSha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CapiKdfSha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_CapiKdfSha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics2_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CapiKdfSha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Pbkdf2Md5
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pbkdf2Md5 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Pbkdf2Sha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pbkdf2Sha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Pbkdf2Sha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pbkdf2Sha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Pbkdf2Sha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pbkdf2Sha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Pbkdf2Sha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pbkdf2Sha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp800108CtrHmacMd5
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp800108CtrHmacMd5 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp800108CtrHmacSha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp800108CtrHmacSha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp800108CtrHmacSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp800108CtrHmacSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp800108CtrHmacSha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp800108CtrHmacSha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp800108CtrHmacSha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp800108CtrHmacSha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp80056aConcatMd5
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp80056aConcatMd5 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp80056aConcatSha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp80056aConcatSha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp80056aConcatSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp80056aConcatSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp80056aConcatSha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp80056aConcatSha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Sp80056aConcatSha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Sp80056aConcatSha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end KeyDerivationAlgorithmNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyDerivationAlgorithmProvider

   procedure Initialize (this : in out KeyDerivationAlgorithmProvider) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyDerivationAlgorithmProvider) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyDerivationAlgorithmProvider, IKeyDerivationAlgorithmProvider_Ptr);
   begin
      if this.m_IKeyDerivationAlgorithmProvider /= null then
         if this.m_IKeyDerivationAlgorithmProvider.all /= null then
            RefCount := this.m_IKeyDerivationAlgorithmProvider.all.Release;
            Free (this.m_IKeyDerivationAlgorithmProvider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for KeyDerivationAlgorithmProvider

   function OpenAlgorithm
   (
      algorithm : WinRt.WString
   )
   return WinRt.Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmProviderStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmProvider;
      HStr_algorithm : WinRt.HString := To_HString (algorithm);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationAlgorithmProviderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.OpenAlgorithm (HStr_algorithm, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IKeyDerivationAlgorithmProvider := new Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmProvider;
            Retval.m_IKeyDerivationAlgorithmProvider.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_algorithm);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyDerivationAlgorithmProvider

   function get_AlgorithmName
   (
      this : in out KeyDerivationAlgorithmProvider
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IKeyDerivationAlgorithmProvider.all.get_AlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function CreateKey
   (
      this : in out KeyDerivationAlgorithmProvider;
      keyMaterial : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_IKeyDerivationAlgorithmProvider.all.CreateKey (keyMaterial, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyDerivationParameters

   procedure Initialize (this : in out KeyDerivationParameters) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyDerivationParameters) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyDerivationParameters, IKeyDerivationParameters_Ptr);
   begin
      if this.m_IKeyDerivationParameters /= null then
         if this.m_IKeyDerivationParameters.all /= null then
            RefCount := this.m_IKeyDerivationParameters.all.Release;
            Free (this.m_IKeyDerivationParameters);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for KeyDerivationParameters

   function BuildForCapi1Kdf
   (
      capi1KdfTargetAlgorithm : Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm
   )
   return WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationParameters");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParametersStatics2_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IKeyDerivationParameters;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationParametersStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.BuildForCapi1Kdf (capi1KdfTargetAlgorithm, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IKeyDerivationParameters := new Windows.Security.Cryptography.Core.IKeyDerivationParameters;
            Retval.m_IKeyDerivationParameters.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function BuildForPbkdf2
   (
      pbkdf2Salt : Windows.Storage.Streams.IBuffer;
      iterationCount : WinRt.UInt32
   )
   return WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationParameters");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParametersStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IKeyDerivationParameters;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationParametersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.BuildForPbkdf2 (pbkdf2Salt, iterationCount, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IKeyDerivationParameters := new Windows.Security.Cryptography.Core.IKeyDerivationParameters;
            Retval.m_IKeyDerivationParameters.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function BuildForSP800108
   (
      label : Windows.Storage.Streams.IBuffer;
      context : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationParameters");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParametersStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IKeyDerivationParameters;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationParametersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.BuildForSP800108 (label, context, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IKeyDerivationParameters := new Windows.Security.Cryptography.Core.IKeyDerivationParameters;
            Retval.m_IKeyDerivationParameters.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   function BuildForSP80056a
   (
      algorithmId : Windows.Storage.Streams.IBuffer;
      partyUInfo : Windows.Storage.Streams.IBuffer;
      partyVInfo : Windows.Storage.Streams.IBuffer;
      suppPubInfo : Windows.Storage.Streams.IBuffer;
      suppPrivInfo : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.KeyDerivationParameters");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParametersStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IKeyDerivationParameters;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.KeyDerivationParameters do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyDerivationParametersStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.BuildForSP80056a (algorithmId, partyUInfo, partyVInfo, suppPubInfo, suppPrivInfo, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IKeyDerivationParameters := new Windows.Security.Cryptography.Core.IKeyDerivationParameters;
            Retval.m_IKeyDerivationParameters.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyDerivationParameters

   function get_KdfGenericBinary
   (
      this : in out KeyDerivationParameters
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IKeyDerivationParameters.all.get_KdfGenericBinary (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_KdfGenericBinary
   (
      this : in out KeyDerivationParameters;
      value : Windows.Storage.Streams.IBuffer
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyDerivationParameters.all.put_KdfGenericBinary (value);
   end;

   function get_IterationCount
   (
      this : in out KeyDerivationParameters
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IKeyDerivationParameters.all.get_IterationCount (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function get_Capi1KdfTargetAlgorithm
   (
      this : in out KeyDerivationParameters
   )
   return WinRt.Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParameters2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParameters_Interface, WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParameters2, WinRt.Windows.Security.Cryptography.Core.IID_IKeyDerivationParameters2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyDerivationParameters.all);
      Hr := m_Interface.get_Capi1KdfTargetAlgorithm (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_Capi1KdfTargetAlgorithm
   (
      this : in out KeyDerivationParameters;
      value : Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParameters2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParameters_Interface, WinRt.Windows.Security.Cryptography.Core.IKeyDerivationParameters2, WinRt.Windows.Security.Cryptography.Core.IID_IKeyDerivationParameters2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyDerivationParameters.all);
      Hr := m_Interface.put_Capi1KdfTargetAlgorithm (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body MacAlgorithmNames is

      function get_HmacMd5
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.MacAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMacAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HmacMd5 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_HmacSha1
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.MacAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMacAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HmacSha1 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_HmacSha256
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.MacAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMacAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HmacSha256 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_HmacSha384
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.MacAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMacAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HmacSha384 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_HmacSha512
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.MacAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMacAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HmacSha512 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AesCmac
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.MacAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_IMacAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AesCmac (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end MacAlgorithmNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MacAlgorithmProvider

   procedure Initialize (this : in out MacAlgorithmProvider) is
   begin
      null;
   end;

   procedure Finalize (this : in out MacAlgorithmProvider) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMacAlgorithmProvider, IMacAlgorithmProvider_Ptr);
   begin
      if this.m_IMacAlgorithmProvider /= null then
         if this.m_IMacAlgorithmProvider.all /= null then
            RefCount := this.m_IMacAlgorithmProvider.all.Release;
            Free (this.m_IMacAlgorithmProvider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MacAlgorithmProvider

   function OpenAlgorithm
   (
      algorithm : WinRt.WString
   )
   return WinRt.Windows.Security.Cryptography.Core.MacAlgorithmProvider is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.MacAlgorithmProvider");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmProviderStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IMacAlgorithmProvider;
      HStr_algorithm : WinRt.HString := To_HString (algorithm);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.MacAlgorithmProvider do
         Hr := RoGetActivationFactory (m_hString, IID_IMacAlgorithmProviderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.OpenAlgorithm (HStr_algorithm, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_IMacAlgorithmProvider := new Windows.Security.Cryptography.Core.IMacAlgorithmProvider;
            Retval.m_IMacAlgorithmProvider.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_algorithm);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MacAlgorithmProvider

   function get_AlgorithmName
   (
      this : in out MacAlgorithmProvider
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMacAlgorithmProvider.all.get_AlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_MacLength
   (
      this : in out MacAlgorithmProvider
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IMacAlgorithmProvider.all.get_MacLength (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function CreateKey
   (
      this : in out MacAlgorithmProvider;
      keyMaterial : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_IMacAlgorithmProvider.all.CreateKey (keyMaterial, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

   function CreateHash
   (
      this : in out MacAlgorithmProvider;
      keyMaterial : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicHash'Class is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmProvider2 := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.IHashComputation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmProvider_Interface, WinRt.Windows.Security.Cryptography.Core.IMacAlgorithmProvider2, WinRt.Windows.Security.Cryptography.Core.IID_IMacAlgorithmProvider2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicHash do
         m_Interface := QInterface (this.m_IMacAlgorithmProvider.all);
         Hr := m_Interface.CreateHash (keyMaterial, m_ComRetVal'Access);
         m_RefCount := m_Interface.Release;
         Retval.m_IHashComputation := new Windows.Security.Cryptography.Core.IHashComputation;
         Retval.m_IHashComputation.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body PersistedKeyProvider is

      function OpenKeyPairFromCertificateAsync
      (
         certificate : Windows.Security.Cryptography.Certificates.Certificate'Class;
         hashAlgorithmName : WinRt.WString;
         padding : Windows.Security.Cryptography.Core.CryptographicPadding
      )
      return WinRt.Windows.Security.Cryptography.Core.CryptographicKey is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.PersistedKeyProvider");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IPersistedKeyProviderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         HStr_hashAlgorithmName : WinRt.HString := To_HString (hashAlgorithmName);
         m_Temp           : WinRt.Int32 := 0;
         m_Completed      : WinRt.UInt32 := 0;
         m_Captured       : WinRt.UInt32 := 0;
         m_Compare        : constant WinRt.UInt32 := 0;

         use type WinRt.Windows.Foundation.AsyncStatus;
         use type IAsyncOperation_CryptographicKey.Kind;

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

         m_AsyncOperation : aliased IAsyncOperation_CryptographicKey.Kind;
         m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
         m_ComRetVal      : aliased WinRt.GenericObject := null;
         m_RetVal         : aliased WinRt.Windows.Security.Cryptography.Core.ICryptographicKey;
         m_IID            : aliased WinRt.IID := (2177530011, 39135, 23658, (149, 49, 150, 98, 56, 227, 231, 174 )); -- Windows.Security.Cryptography.Core.CryptographicKey;
         m_HandlerIID     : aliased WinRt.IID := (80364408, 62868, 24038, (165, 85, 48, 79, 98, 203, 79, 175 ));
         m_Handler        : AsyncOperationCompletedHandler_CryptographicKey.Kind := new AsyncOperationCompletedHandler_CryptographicKey.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

         function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_CryptographicKey.Kind, m_IID'Unchecked_Access);
         function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_CryptographicKey.Kind, GenericObject);
         procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_CryptographicKey.Kind_Delegate, AsyncOperationCompletedHandler_CryptographicKey.Kind);

         procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
            Hr        : WinRt.HResult := 0;
         begin
            if asyncStatus = Completed_e then
               m_AsyncStatus := AsyncStatus;
            end if;
            m_Completed := 1;
            WakeByAddressSingle (m_Completed'Address);
         end;

      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
            Hr := RoGetActivationFactory (m_hString, IID_IPersistedKeyProviderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.OpenKeyPairFromCertificateAsync (certificate.m_ICertificate.all, HStr_hashAlgorithmName, padding, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               if Hr = S_OK then
                  m_AsyncOperation := QI (m_ComRetVal);
                  m_RefCount := m_ComRetVal.Release;
                  if m_AsyncOperation /= null then
                     Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                     while m_Captured = m_Compare loop
                        m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                        m_Captured := m_Completed;
                     end loop;
                     if m_AsyncStatus = Completed_e then
                        Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                        Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
                        Retval.m_ICryptographicKey.all := m_RetVal;
                     end if;
                     m_RefCount := m_AsyncOperation.Release;
                     m_RefCount := m_Handler.Release;
                     if m_RefCount = 0 then
                        Free (m_Handler);
                     end if;
                  end if;
               end if;
            end if;
            Hr := WindowsDeleteString (m_hString);
            Hr := WindowsDeleteString (HStr_hashAlgorithmName);
         end return;
      end;

      function OpenPublicKeyFromCertificate
      (
         certificate : Windows.Security.Cryptography.Certificates.Certificate'Class;
         hashAlgorithmName : WinRt.WString;
         padding : Windows.Security.Cryptography.Core.CryptographicPadding
      )
      return WinRt.Windows.Security.Cryptography.Core.CryptographicKey is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.PersistedKeyProvider");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.IPersistedKeyProviderStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
         HStr_hashAlgorithmName : WinRt.HString := To_HString (hashAlgorithmName);
      begin
         return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
            Hr := RoGetActivationFactory (m_hString, IID_IPersistedKeyProviderStatics'Access , m_Factory'Address);
            if Hr = S_OK then
               Hr := m_Factory.OpenPublicKeyFromCertificate (certificate.m_ICertificate.all, HStr_hashAlgorithmName, padding, m_ComRetVal'Access);
               m_RefCount := m_Factory.Release;
               Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
               Retval.m_ICryptographicKey.all := m_ComRetVal;
            end if;
            Hr := WindowsDeleteString (m_hString);
            Hr := WindowsDeleteString (HStr_hashAlgorithmName);
         end return;
      end;

   end PersistedKeyProvider;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body SymmetricAlgorithmNames is

      function get_DesCbc
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesCbc (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_DesEcb
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesEcb (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_TripleDesCbc
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TripleDesCbc (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_TripleDesEcb
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TripleDesEcb (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Rc2Cbc
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Rc2Cbc (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Rc2Ecb
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Rc2Ecb (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AesCbc
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AesCbc (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AesEcb
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AesEcb (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AesGcm
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AesGcm (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AesCcm
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AesCcm (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AesCbcPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AesCbcPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_AesEcbPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AesEcbPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_DesCbcPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesCbcPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_DesEcbPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesEcbPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_TripleDesCbcPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TripleDesCbcPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_TripleDesEcbPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TripleDesEcbPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Rc2CbcPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Rc2CbcPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Rc2EcbPkcs7
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Rc2EcbPkcs7 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

      function get_Rc4
      return WinRt.WString is
         Hr               : WinRt.HResult := S_OK;
         m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricAlgorithmNames");
         m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricAlgorithmNamesStatics_Interface'Class := null;
         m_RefCount       : WinRt.UInt32 := 0;
         m_ComRetVal      : aliased WinRt.HString;
         AdaRetval        : WString;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricAlgorithmNamesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Rc4 (m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
         AdaRetval := To_Ada (m_ComRetVal);
         Hr := WindowsDeleteString (m_ComRetVal);
         return AdaRetVal;
      end;

   end SymmetricAlgorithmNames;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SymmetricKeyAlgorithmProvider

   procedure Initialize (this : in out SymmetricKeyAlgorithmProvider) is
   begin
      null;
   end;

   procedure Finalize (this : in out SymmetricKeyAlgorithmProvider) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISymmetricKeyAlgorithmProvider, ISymmetricKeyAlgorithmProvider_Ptr);
   begin
      if this.m_ISymmetricKeyAlgorithmProvider /= null then
         if this.m_ISymmetricKeyAlgorithmProvider.all /= null then
            RefCount := this.m_ISymmetricKeyAlgorithmProvider.all.Release;
            Free (this.m_ISymmetricKeyAlgorithmProvider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SymmetricKeyAlgorithmProvider

   function OpenAlgorithm
   (
      algorithm : WinRt.WString
   )
   return WinRt.Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider");
      m_Factory        : access WinRt.Windows.Security.Cryptography.Core.ISymmetricKeyAlgorithmProviderStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ISymmetricKeyAlgorithmProvider;
      HStr_algorithm : WinRt.HString := To_HString (algorithm);
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider do
         Hr := RoGetActivationFactory (m_hString, IID_ISymmetricKeyAlgorithmProviderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.OpenAlgorithm (HStr_algorithm, m_ComRetVal'Access);
            m_RefCount := m_Factory.Release;
            Retval.m_ISymmetricKeyAlgorithmProvider := new Windows.Security.Cryptography.Core.ISymmetricKeyAlgorithmProvider;
            Retval.m_ISymmetricKeyAlgorithmProvider.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
         Hr := WindowsDeleteString (HStr_algorithm);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SymmetricKeyAlgorithmProvider

   function get_AlgorithmName
   (
      this : in out SymmetricKeyAlgorithmProvider
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISymmetricKeyAlgorithmProvider.all.get_AlgorithmName (m_ComRetVal'Access);
      AdaRetval := To_Ada (m_ComRetVal);
      Hr := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_BlockLength
   (
      this : in out SymmetricKeyAlgorithmProvider
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ISymmetricKeyAlgorithmProvider.all.get_BlockLength (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function CreateSymmetricKey
   (
      this : in out SymmetricKeyAlgorithmProvider;
      keyMaterial : Windows.Storage.Streams.IBuffer
   )
   return WinRt.Windows.Security.Cryptography.Core.CryptographicKey'Class is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Security.Cryptography.Core.ICryptographicKey;
   begin
      return RetVal : WinRt.Windows.Security.Cryptography.Core.CryptographicKey do
         Hr := this.m_ISymmetricKeyAlgorithmProvider.all.CreateSymmetricKey (keyMaterial, m_ComRetVal'Access);
         Retval.m_ICryptographicKey := new Windows.Security.Cryptography.Core.ICryptographicKey;
         Retval.m_ICryptographicKey.all := m_ComRetVal;
      end return;
   end;

end;
