--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.System;
with WinRt.Windows.UI.Composition;
with WinRt.Windows.UI.Input;
with WinRt.Windows.UI.Popups;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.Core is

   package IAsyncOperation_Boolean is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Boolean);
   package AsyncOperationCompletedHandler_Boolean is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Boolean);

   package IAsyncOperation_IUICommand is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.UI.Popups.IUICommand);
   package AsyncOperationCompletedHandler_IUICommand is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.UI.Popups.IUICommand);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AcceleratorKeyEventArgs

   procedure Initialize (this : in out AcceleratorKeyEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AcceleratorKeyEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAcceleratorKeyEventArgs, IAcceleratorKeyEventArgs_Ptr);
   begin
      if this.m_IAcceleratorKeyEventArgs /= null then
         if this.m_IAcceleratorKeyEventArgs.all /= null then
            temp := this.m_IAcceleratorKeyEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IAcceleratorKeyEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AcceleratorKeyEventArgs

   function get_EventType
   (
      this : in out AcceleratorKeyEventArgs
   )
   return WinRt.Windows.UI.Core.CoreAcceleratorKeyEventType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreAcceleratorKeyEventType;
   begin
      Hr := this.m_IAcceleratorKeyEventArgs.all.get_EventType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VirtualKey
   (
      this : in out AcceleratorKeyEventArgs
   )
   return WinRt.Windows.System.VirtualKey is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKey;
   begin
      Hr := this.m_IAcceleratorKeyEventArgs.all.get_VirtualKey (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KeyStatus
   (
      this : in out AcceleratorKeyEventArgs
   )
   return WinRt.Windows.UI.Core.CorePhysicalKeyStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CorePhysicalKeyStatus;
   begin
      Hr := this.m_IAcceleratorKeyEventArgs.all.get_KeyStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out AcceleratorKeyEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IAcceleratorKeyEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAcceleratorKeyEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out AcceleratorKeyEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IAcceleratorKeyEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAcceleratorKeyEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeviceId
   (
      this : in out AcceleratorKeyEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.IAcceleratorKeyEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IAcceleratorKeyEventArgs_Interface, WinRt.Windows.UI.Core.IAcceleratorKeyEventArgs2, WinRt.Windows.UI.Core.IID_IAcceleratorKeyEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAcceleratorKeyEventArgs.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutomationProviderRequestedEventArgs

   procedure Initialize (this : in out AutomationProviderRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutomationProviderRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutomationProviderRequestedEventArgs, IAutomationProviderRequestedEventArgs_Ptr);
   begin
      if this.m_IAutomationProviderRequestedEventArgs /= null then
         if this.m_IAutomationProviderRequestedEventArgs.all /= null then
            temp := this.m_IAutomationProviderRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IAutomationProviderRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutomationProviderRequestedEventArgs

   function get_AutomationProvider
   (
      this : in out AutomationProviderRequestedEventArgs
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := this.m_IAutomationProviderRequestedEventArgs.all.get_AutomationProvider (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutomationProvider
   (
      this : in out AutomationProviderRequestedEventArgs;
      value : WinRt.IInspectable
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAutomationProviderRequestedEventArgs.all.put_AutomationProvider (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Handled
   (
      this : in out AutomationProviderRequestedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IAutomationProviderRequestedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutomationProviderRequestedEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out AutomationProviderRequestedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IAutomationProviderRequestedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutomationProviderRequestedEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BackRequestedEventArgs

   procedure Initialize (this : in out BackRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out BackRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBackRequestedEventArgs, IBackRequestedEventArgs_Ptr);
   begin
      if this.m_IBackRequestedEventArgs /= null then
         if this.m_IBackRequestedEventArgs.all /= null then
            temp := this.m_IBackRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IBackRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BackRequestedEventArgs

   function get_Handled
   (
      this : in out BackRequestedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IBackRequestedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out BackRequestedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBackRequestedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CharacterReceivedEventArgs

   procedure Initialize (this : in out CharacterReceivedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CharacterReceivedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICharacterReceivedEventArgs, ICharacterReceivedEventArgs_Ptr);
   begin
      if this.m_ICharacterReceivedEventArgs /= null then
         if this.m_ICharacterReceivedEventArgs.all /= null then
            temp := this.m_ICharacterReceivedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_ICharacterReceivedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CharacterReceivedEventArgs

   function get_KeyCode
   (
      this : in out CharacterReceivedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICharacterReceivedEventArgs.all.get_KeyCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KeyStatus
   (
      this : in out CharacterReceivedEventArgs
   )
   return WinRt.Windows.UI.Core.CorePhysicalKeyStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CorePhysicalKeyStatus;
   begin
      Hr := this.m_ICharacterReceivedEventArgs.all.get_KeyStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out CharacterReceivedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICharacterReceivedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICharacterReceivedEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out CharacterReceivedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICharacterReceivedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICharacterReceivedEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ClosestInteractiveBoundsRequestedEventArgs

   procedure Initialize (this : in out ClosestInteractiveBoundsRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ClosestInteractiveBoundsRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IClosestInteractiveBoundsRequestedEventArgs, IClosestInteractiveBoundsRequestedEventArgs_Ptr);
   begin
      if this.m_IClosestInteractiveBoundsRequestedEventArgs /= null then
         if this.m_IClosestInteractiveBoundsRequestedEventArgs.all /= null then
            temp := this.m_IClosestInteractiveBoundsRequestedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IClosestInteractiveBoundsRequestedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ClosestInteractiveBoundsRequestedEventArgs

   function get_PointerPosition
   (
      this : in out ClosestInteractiveBoundsRequestedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_IClosestInteractiveBoundsRequestedEventArgs.all.get_PointerPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SearchBounds
   (
      this : in out ClosestInteractiveBoundsRequestedEventArgs
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Rect;
   begin
      Hr := this.m_IClosestInteractiveBoundsRequestedEventArgs.all.get_SearchBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ClosestInteractiveBounds
   (
      this : in out ClosestInteractiveBoundsRequestedEventArgs
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Rect;
   begin
      Hr := this.m_IClosestInteractiveBoundsRequestedEventArgs.all.get_ClosestInteractiveBounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClosestInteractiveBounds
   (
      this : in out ClosestInteractiveBoundsRequestedEventArgs;
      value : WinRt.Windows.Foundation.Rect
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IClosestInteractiveBoundsRequestedEventArgs.all.put_ClosestInteractiveBounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreAcceleratorKeys

   procedure Initialize (this : in out CoreAcceleratorKeys) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreAcceleratorKeys) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreAcceleratorKeys, ICoreAcceleratorKeys_Ptr);
   begin
      if this.m_ICoreAcceleratorKeys /= null then
         if this.m_ICoreAcceleratorKeys.all /= null then
            temp := this.m_ICoreAcceleratorKeys.all.Release;
            if temp < 1 then
               Free (this.m_ICoreAcceleratorKeys);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreAcceleratorKeys

   function add_AcceleratorKeyActivated
   (
      this : in out CoreAcceleratorKeys;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreAcceleratorKeys.all.add_AcceleratorKeyActivated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AcceleratorKeyActivated
   (
      this : in out CoreAcceleratorKeys;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreAcceleratorKeys.all.remove_AcceleratorKeyActivated (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreComponentInputSource

   procedure Initialize (this : in out CoreComponentInputSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreComponentInputSource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreInputSourceBase, ICoreInputSourceBase_Ptr);
   begin
      if this.m_ICoreInputSourceBase /= null then
         if this.m_ICoreInputSourceBase.all /= null then
            temp := this.m_ICoreInputSourceBase.all.Release;
            if temp < 1 then
               Free (this.m_ICoreInputSourceBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreComponentInputSource

   function get_Dispatcher
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.Windows.UI.Core.CoreDispatcher'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreDispatcher;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreDispatcher do
         Hr := this.m_ICoreInputSourceBase.all.get_Dispatcher (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreDispatcher := new WinRt.Windows.UI.Core.ICoreDispatcher;
         Retval.m_ICoreDispatcher.all := m_ComRetVal;
      end return;
   end;

   function get_IsInputEnabled
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreInputSourceBase.all.get_IsInputEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsInputEnabled
   (
      this : in out CoreComponentInputSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreInputSourceBase.all.put_IsInputEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_InputEnabled
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreInputSourceBase.all.add_InputEnabled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_InputEnabled
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreInputSourceBase.all.remove_InputEnabled (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ReleasePointerCapture
   (
      this : in out CoreComponentInputSource
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.ReleasePointerCapture;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPointerCapture
   (
      this : in out CoreComponentInputSource
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.SetPointerCapture;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasCapture
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.get_HasCapture (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerPosition
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.get_PointerPosition (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerCursor
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.Windows.UI.Core.CoreCursor'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreCursor;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreCursor do
         m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
         Hr := m_Interface.get_PointerCursor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreCursor := new WinRt.Windows.UI.Core.ICoreCursor;
         Retval.m_ICoreCursor.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerCursor
   (
      this : in out CoreComponentInputSource;
      value : WinRt.Windows.UI.Core.CoreCursor'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.put_PointerCursor (value.m_ICoreCursor.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerCaptureLost
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerCaptureLost (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerCaptureLost
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerCaptureLost (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerEntered
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerEntered (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerEntered
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerEntered (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerExited
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerExited (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerExited
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerExited (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerMoved
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerMoved (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerMoved
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerMoved (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerPressed
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerPressed (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerPressed
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerPressed (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerReleased
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerReleased (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerReleased
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerReleased (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerWheelChanged
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerWheelChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerWheelChanged
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerWheelChanged (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetCurrentKeyState
   (
      this : in out CoreComponentInputSource;
      virtualKey : WinRt.Windows.System.VirtualKey
   )
   return WinRt.Windows.UI.Core.CoreVirtualKeyStates is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreVirtualKeyStates;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.GetCurrentKeyState (virtualKey, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_CharacterReceived
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_CharacterReceived (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CharacterReceived
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_CharacterReceived (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyDown
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_KeyDown (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyDown
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_KeyDown (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyUp
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_KeyUp (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyUp
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_KeyUp (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasFocus
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreComponentFocusable := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreComponentFocusable, WinRt.Windows.UI.Core.IID_ICoreComponentFocusable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.get_HasFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_GotFocus
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreComponentFocusable := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreComponentFocusable, WinRt.Windows.UI.Core.IID_ICoreComponentFocusable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_GotFocus (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_GotFocus
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreComponentFocusable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreComponentFocusable, WinRt.Windows.UI.Core.IID_ICoreComponentFocusable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_GotFocus (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LostFocus
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreComponentFocusable := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreComponentFocusable, WinRt.Windows.UI.Core.IID_ICoreComponentFocusable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_LostFocus (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LostFocus
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreComponentFocusable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreComponentFocusable, WinRt.Windows.UI.Core.IID_ICoreComponentFocusable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_LostFocus (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TouchHitTesting
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreTouchHitTesting := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreTouchHitTesting, WinRt.Windows.UI.Core.IID_ICoreTouchHitTesting'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_TouchHitTesting (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TouchHitTesting
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreTouchHitTesting := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreTouchHitTesting, WinRt.Windows.UI.Core.IID_ICoreTouchHitTesting'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_TouchHitTesting (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ClosestInteractiveBoundsRequested
   (
      this : in out CoreComponentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreClosestInteractiveBoundsRequested := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreClosestInteractiveBoundsRequested, WinRt.Windows.UI.Core.IID_ICoreClosestInteractiveBoundsRequested'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_ClosestInteractiveBoundsRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ClosestInteractiveBoundsRequested
   (
      this : in out CoreComponentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreClosestInteractiveBoundsRequested := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreClosestInteractiveBoundsRequested, WinRt.Windows.UI.Core.IID_ICoreClosestInteractiveBoundsRequested'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_ClosestInteractiveBoundsRequested (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetCurrentKeyEventDeviceId
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreKeyboardInputSource2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICoreKeyboardInputSource2, WinRt.Windows.UI.Core.IID_ICoreKeyboardInputSource2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.GetCurrentKeyEventDeviceId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_DispatcherQueue
   (
      this : in out CoreComponentInputSource
   )
   return WinRt.Windows.System.DispatcherQueue'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IDispatcherQueue;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource2, WinRt.Windows.UI.Core.IID_ICorePointerInputSource2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.DispatcherQueue do
         m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
         Hr := m_Interface.get_DispatcherQueue (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinRt.Windows.System.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreCursor

   procedure Initialize (this : in out CoreCursor) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreCursor) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreCursor, ICoreCursor_Ptr);
   begin
      if this.m_ICoreCursor /= null then
         if this.m_ICoreCursor.all /= null then
            temp := this.m_ICoreCursor.all.Release;
            if temp < 1 then
               Free (this.m_ICoreCursor);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CoreCursor

   function Constructor
   (
      type_x : WinRt.Windows.UI.Core.CoreCursorType;
      id : WinRt.UInt32
   )
   return CoreCursor is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreCursor");
      m_Factory    : access ICoreCursorFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Core.ICoreCursor;
   begin
      return RetVal : CoreCursor do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreCursorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateCursor (type_x, id, m_ComRetVal'Access);
            Retval.m_ICoreCursor := new WinRt.Windows.UI.Core.ICoreCursor;
            Retval.m_ICoreCursor.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreCursor

   function get_Id
   (
      this : in out CoreCursor
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICoreCursor.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Type
   (
      this : in out CoreCursor
   )
   return WinRt.Windows.UI.Core.CoreCursorType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreCursorType;
   begin
      Hr := this.m_ICoreCursor.all.get_Type (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreDispatcher

   procedure Initialize (this : in out CoreDispatcher) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreDispatcher) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreDispatcher, ICoreDispatcher_Ptr);
   begin
      if this.m_ICoreDispatcher /= null then
         if this.m_ICoreDispatcher.all /= null then
            temp := this.m_ICoreDispatcher.all.Release;
            if temp < 1 then
               Free (this.m_ICoreDispatcher);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreDispatcher

   function get_HasThreadAccess
   (
      this : in out CoreDispatcher
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreDispatcher.all.get_HasThreadAccess (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ProcessEvents
   (
      this : in out CoreDispatcher;
      options : WinRt.Windows.UI.Core.CoreProcessEventsOption
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreDispatcher.all.ProcessEvents (options);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RunAsync
   (
      this : in out CoreDispatcher;
      priority : WinRt.Windows.UI.Core.CoreDispatcherPriority;
      agileCallback : WinRt.Windows.UI.Core.DispatchedHandler
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_ICoreDispatcher.all.RunAsync (priority, agileCallback, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   procedure RunIdleAsync
   (
      this : in out CoreDispatcher;
      agileCallback : WinRt.Windows.UI.Core.IdleDispatchedHandler
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_ICoreDispatcher.all.RunIdleAsync (agileCallback, m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function add_AcceleratorKeyActivated
   (
      this : in out CoreDispatcher;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreAcceleratorKeys := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreAcceleratorKeys, WinRt.Windows.UI.Core.IID_ICoreAcceleratorKeys'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.add_AcceleratorKeyActivated (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AcceleratorKeyActivated
   (
      this : in out CoreDispatcher;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreAcceleratorKeys := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreAcceleratorKeys, WinRt.Windows.UI.Core.IID_ICoreAcceleratorKeys'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.remove_AcceleratorKeyActivated (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CurrentPriority
   (
      this : in out CoreDispatcher
   )
   return WinRt.Windows.UI.Core.CoreDispatcherPriority is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreDispatcherPriority;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority, WinRt.Windows.UI.Core.IID_ICoreDispatcherWithTaskPriority'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.get_CurrentPriority (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CurrentPriority
   (
      this : in out CoreDispatcher;
      value : WinRt.Windows.UI.Core.CoreDispatcherPriority
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority, WinRt.Windows.UI.Core.IID_ICoreDispatcherWithTaskPriority'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.put_CurrentPriority (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShouldYield
   (
      this : in out CoreDispatcher
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority, WinRt.Windows.UI.Core.IID_ICoreDispatcherWithTaskPriority'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.ShouldYield (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ShouldYield
   (
      this : in out CoreDispatcher;
      priority : WinRt.Windows.UI.Core.CoreDispatcherPriority
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority, WinRt.Windows.UI.Core.IID_ICoreDispatcherWithTaskPriority'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.ShouldYield (priority, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure StopProcessEvents
   (
      this : in out CoreDispatcher
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreDispatcherWithTaskPriority, WinRt.Windows.UI.Core.IID_ICoreDispatcherWithTaskPriority'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.StopProcessEvents;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryRunAsync
   (
      this : in out CoreDispatcher;
      priority : WinRt.Windows.UI.Core.CoreDispatcherPriority;
      agileCallback : WinRt.Windows.UI.Core.DispatchedHandler
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreDispatcher2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreDispatcher2, WinRt.Windows.UI.Core.IID_ICoreDispatcher2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.TryRunAsync (priority, agileCallback, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function TryRunIdleAsync
   (
      this : in out CoreDispatcher;
      agileCallback : WinRt.Windows.UI.Core.IdleDispatchedHandler
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreDispatcher2 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreDispatcher_Interface, WinRt.Windows.UI.Core.ICoreDispatcher2, WinRt.Windows.UI.Core.IID_ICoreDispatcher2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreDispatcher.all);
      Hr := m_Interface.TryRunIdleAsync (agileCallback, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreIndependentInputSource

   procedure Initialize (this : in out CoreIndependentInputSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreIndependentInputSource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreInputSourceBase, ICoreInputSourceBase_Ptr);
   begin
      if this.m_ICoreInputSourceBase /= null then
         if this.m_ICoreInputSourceBase.all /= null then
            temp := this.m_ICoreInputSourceBase.all.Release;
            if temp < 1 then
               Free (this.m_ICoreInputSourceBase);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreIndependentInputSource

   function get_Dispatcher
   (
      this : in out CoreIndependentInputSource
   )
   return WinRt.Windows.UI.Core.CoreDispatcher'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreDispatcher;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreDispatcher do
         Hr := this.m_ICoreInputSourceBase.all.get_Dispatcher (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreDispatcher := new WinRt.Windows.UI.Core.ICoreDispatcher;
         Retval.m_ICoreDispatcher.all := m_ComRetVal;
      end return;
   end;

   function get_IsInputEnabled
   (
      this : in out CoreIndependentInputSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreInputSourceBase.all.get_IsInputEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsInputEnabled
   (
      this : in out CoreIndependentInputSource;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreInputSourceBase.all.put_IsInputEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_InputEnabled
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreInputSourceBase.all.add_InputEnabled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_InputEnabled
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreInputSourceBase.all.remove_InputEnabled (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ReleasePointerCapture
   (
      this : in out CoreIndependentInputSource
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.ReleasePointerCapture;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPointerCapture
   (
      this : in out CoreIndependentInputSource
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.SetPointerCapture;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasCapture
   (
      this : in out CoreIndependentInputSource
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.get_HasCapture (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerPosition
   (
      this : in out CoreIndependentInputSource
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.get_PointerPosition (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerCursor
   (
      this : in out CoreIndependentInputSource
   )
   return WinRt.Windows.UI.Core.CoreCursor'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreCursor;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreCursor do
         m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
         Hr := m_Interface.get_PointerCursor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreCursor := new WinRt.Windows.UI.Core.ICoreCursor;
         Retval.m_ICoreCursor.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerCursor
   (
      this : in out CoreIndependentInputSource;
      value : WinRt.Windows.UI.Core.CoreCursor'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.put_PointerCursor (value.m_ICoreCursor.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerCaptureLost
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerCaptureLost (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerCaptureLost
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerCaptureLost (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerEntered
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerEntered (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerEntered
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerEntered (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerExited
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerExited (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerExited
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerExited (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerMoved
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerMoved (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerMoved
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerMoved (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerPressed
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerPressed (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerPressed
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerPressed (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerReleased
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerReleased (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerReleased
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerReleased (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerWheelChanged
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerWheelChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerWheelChanged
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource, WinRt.Windows.UI.Core.IID_ICorePointerInputSource'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerWheelChanged (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DispatcherQueue
   (
      this : in out CoreIndependentInputSource
   )
   return WinRt.Windows.System.DispatcherQueue'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerInputSource2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IDispatcherQueue;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerInputSource2, WinRt.Windows.UI.Core.IID_ICorePointerInputSource2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.DispatcherQueue do
         m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
         Hr := m_Interface.get_DispatcherQueue (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinRt.Windows.System.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   function add_PointerRoutedAway
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerRoutedAway (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedAway
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerRoutedAway (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedTo
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerRoutedTo (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedTo
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerRoutedTo (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedReleased
   (
      this : in out CoreIndependentInputSource;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.add_PointerRoutedReleased (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedReleased
   (
      this : in out CoreIndependentInputSource;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreInputSourceBase_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreInputSourceBase.all);
      Hr := m_Interface.remove_PointerRoutedReleased (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreIndependentInputSourceController

   procedure Initialize (this : in out CoreIndependentInputSourceController) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreIndependentInputSourceController) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreIndependentInputSourceController, ICoreIndependentInputSourceController_Ptr);
   begin
      if this.m_ICoreIndependentInputSourceController /= null then
         if this.m_ICoreIndependentInputSourceController.all /= null then
            temp := this.m_ICoreIndependentInputSourceController.all.Release;
            if temp < 1 then
               Free (this.m_ICoreIndependentInputSourceController);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CoreIndependentInputSourceController

   function CreateForVisual
   (
      visual : WinRt.Windows.UI.Composition.Visual'Class
   )
   return WinRt.Windows.UI.Core.CoreIndependentInputSourceController is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreIndependentInputSourceController");
      m_Factory        : access WinRt.Windows.UI.Core.ICoreIndependentInputSourceControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreIndependentInputSourceController;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreIndependentInputSourceController do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreIndependentInputSourceControllerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForVisual (visual.m_IVisual.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICoreIndependentInputSourceController := new WinRt.Windows.UI.Core.ICoreIndependentInputSourceController;
            Retval.m_ICoreIndependentInputSourceController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateForIVisualElement
   (
      visualElement : WinRt.Windows.UI.Composition.IVisualElement
   )
   return WinRt.Windows.UI.Core.CoreIndependentInputSourceController is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreIndependentInputSourceController");
      m_Factory        : access WinRt.Windows.UI.Core.ICoreIndependentInputSourceControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreIndependentInputSourceController;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreIndependentInputSourceController do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreIndependentInputSourceControllerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForIVisualElement (visualElement, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICoreIndependentInputSourceController := new WinRt.Windows.UI.Core.ICoreIndependentInputSourceController;
            Retval.m_ICoreIndependentInputSourceController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreIndependentInputSourceController

   function get_IsTransparentForUncontrolledInput
   (
      this : in out CoreIndependentInputSourceController
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreIndependentInputSourceController.all.get_IsTransparentForUncontrolledInput (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTransparentForUncontrolledInput
   (
      this : in out CoreIndependentInputSourceController;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreIndependentInputSourceController.all.put_IsTransparentForUncontrolledInput (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPalmRejectionEnabled
   (
      this : in out CoreIndependentInputSourceController
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreIndependentInputSourceController.all.get_IsPalmRejectionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPalmRejectionEnabled
   (
      this : in out CoreIndependentInputSourceController;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreIndependentInputSourceController.all.put_IsPalmRejectionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out CoreIndependentInputSourceController
   )
   return WinRt.Windows.UI.Core.CoreIndependentInputSource'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreInputSourceBase;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreIndependentInputSource do
         Hr := this.m_ICoreIndependentInputSourceController.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreInputSourceBase := new WinRt.Windows.UI.Core.ICoreInputSourceBase;
         Retval.m_ICoreInputSourceBase.all := m_ComRetVal;
      end return;
   end;

   procedure SetControlledInput
   (
      this : in out CoreIndependentInputSourceController;
      inputTypes : WinRt.Windows.UI.Core.CoreInputDeviceTypes
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreIndependentInputSourceController.all.SetControlledInput (inputTypes);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetControlledInput
   (
      this : in out CoreIndependentInputSourceController;
      inputTypes : WinRt.Windows.UI.Core.CoreInputDeviceTypes;
      required : WinRt.Windows.UI.Core.CoreIndependentInputFilters;
      excluded : WinRt.Windows.UI.Core.CoreIndependentInputFilters
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreIndependentInputSourceController.all.SetControlledInput (inputTypes, required, excluded);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out CoreIndependentInputSourceController
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreIndependentInputSourceController_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreIndependentInputSourceController.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreWindow

   procedure Initialize (this : in out CoreWindow) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreWindow) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreWindow, ICoreWindow_Ptr);
   begin
      if this.m_ICoreWindow /= null then
         if this.m_ICoreWindow.all /= null then
            temp := this.m_ICoreWindow.all.Release;
            if temp < 1 then
               Free (this.m_ICoreWindow);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CoreWindow

   function GetForCurrentThread
   return WinRt.Windows.UI.Core.CoreWindow is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreWindow");
      m_Factory        : access WinRt.Windows.UI.Core.ICoreWindowStatic_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreWindow;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreWindow do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreWindowStatic'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentThread (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICoreWindow := new WinRt.Windows.UI.Core.ICoreWindow;
            Retval.m_ICoreWindow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreWindow

   function get_AutomationHostProvider
   (
      this : in out CoreWindow
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := this.m_ICoreWindow.all.get_AutomationHostProvider (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Bounds
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICoreWindow.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CustomProperties
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.Foundation.Collections.IPropertySet is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Collections.IPropertySet;
   begin
      Hr := this.m_ICoreWindow.all.get_CustomProperties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Dispatcher
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.UI.Core.CoreDispatcher'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreDispatcher;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreDispatcher do
         Hr := this.m_ICoreWindow.all.get_Dispatcher (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreDispatcher := new WinRt.Windows.UI.Core.ICoreDispatcher;
         Retval.m_ICoreDispatcher.all := m_ComRetVal;
      end return;
   end;

   function get_FlowDirection
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.UI.Core.CoreWindowFlowDirection is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreWindowFlowDirection;
   begin
      Hr := this.m_ICoreWindow.all.get_FlowDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FlowDirection
   (
      this : in out CoreWindow;
      value : WinRt.Windows.UI.Core.CoreWindowFlowDirection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.put_FlowDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInputEnabled
   (
      this : in out CoreWindow
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreWindow.all.get_IsInputEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsInputEnabled
   (
      this : in out CoreWindow;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.put_IsInputEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerCursor
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.UI.Core.CoreCursor'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreCursor;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreCursor do
         Hr := this.m_ICoreWindow.all.get_PointerCursor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreCursor := new WinRt.Windows.UI.Core.ICoreCursor;
         Retval.m_ICoreCursor.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerCursor
   (
      this : in out CoreWindow;
      value : WinRt.Windows.UI.Core.CoreCursor'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.put_PointerCursor (value.m_ICoreCursor.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerPosition
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_ICoreWindow.all.get_PointerPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Visible
   (
      this : in out CoreWindow
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreWindow.all.get_Visible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Activate
   (
      this : in out CoreWindow
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.Activate;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out CoreWindow
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.Close;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetAsyncKeyState
   (
      this : in out CoreWindow;
      virtualKey : WinRt.Windows.System.VirtualKey
   )
   return WinRt.Windows.UI.Core.CoreVirtualKeyStates is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreVirtualKeyStates;
   begin
      Hr := this.m_ICoreWindow.all.GetAsyncKeyState (virtualKey, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetKeyState
   (
      this : in out CoreWindow;
      virtualKey : WinRt.Windows.System.VirtualKey
   )
   return WinRt.Windows.UI.Core.CoreVirtualKeyStates is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreVirtualKeyStates;
   begin
      Hr := this.m_ICoreWindow.all.GetKeyState (virtualKey, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReleasePointerCapture
   (
      this : in out CoreWindow
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.ReleasePointerCapture;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPointerCapture
   (
      this : in out CoreWindow
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.SetPointerCapture;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Activated
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_Activated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Activated
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_Activated (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AutomationProviderRequested
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_AutomationProviderRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AutomationProviderRequested
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_AutomationProviderRequested (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CharacterReceived
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_CharacterReceived (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CharacterReceived
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_CharacterReceived (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_Closed (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_InputEnabled
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_InputEnabled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_InputEnabled
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_InputEnabled (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyDown
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_KeyDown (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyDown
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_KeyDown (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyUp
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_KeyUp (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyUp
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_KeyUp (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerCaptureLost
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_PointerCaptureLost (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerCaptureLost
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_PointerCaptureLost (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerEntered
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_PointerEntered (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerEntered
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_PointerEntered (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerExited
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_PointerExited (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerExited
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_PointerExited (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerMoved
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_PointerMoved (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerMoved
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_PointerMoved (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerPressed
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_PointerPressed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerPressed
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_PointerPressed (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerReleased
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_PointerReleased (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerReleased
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_PointerReleased (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TouchHitTesting
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_TouchHitTesting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TouchHitTesting
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_TouchHitTesting (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerWheelChanged
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_PointerWheelChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerWheelChanged
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_PointerWheelChanged (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SizeChanged
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_SizeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SizeChanged
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_SizeChanged (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VisibilityChanged
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindow.all.add_VisibilityChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VisibilityChanged
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindow.all.remove_VisibilityChanged (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure put_PointerPosition
   (
      this : in out CoreWindow;
      value : WinRt.Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow2, WinRt.Windows.UI.Core.IID_ICoreWindow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.put_PointerPosition (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedAway
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.add_PointerRoutedAway (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedAway
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.remove_PointerRoutedAway (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedTo
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.add_PointerRoutedTo (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedTo
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.remove_PointerRoutedTo (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PointerRoutedReleased
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.add_PointerRoutedReleased (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PointerRoutedReleased
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICorePointerRedirector := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICorePointerRedirector, WinRt.Windows.UI.Core.IID_ICorePointerRedirector'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.remove_PointerRoutedReleased (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ClosestInteractiveBoundsRequested
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow3, WinRt.Windows.UI.Core.IID_ICoreWindow3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.add_ClosestInteractiveBoundsRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ClosestInteractiveBoundsRequested
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow3, WinRt.Windows.UI.Core.IID_ICoreWindow3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.remove_ClosestInteractiveBoundsRequested (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetCurrentKeyEventDeviceId
   (
      this : in out CoreWindow
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow3, WinRt.Windows.UI.Core.IID_ICoreWindow3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.GetCurrentKeyEventDeviceId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function add_ResizeStarted
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow4, WinRt.Windows.UI.Core.IID_ICoreWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.add_ResizeStarted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ResizeStarted
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow4 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow4, WinRt.Windows.UI.Core.IID_ICoreWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.remove_ResizeStarted (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ResizeCompleted
   (
      this : in out CoreWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow4, WinRt.Windows.UI.Core.IID_ICoreWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.add_ResizeCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ResizeCompleted
   (
      this : in out CoreWindow;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow4 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow4, WinRt.Windows.UI.Core.IID_ICoreWindow4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.remove_ResizeCompleted (cookie);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DispatcherQueue
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.System.DispatcherQueue'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IDispatcherQueue;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow5, WinRt.Windows.UI.Core.IID_ICoreWindow5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.DispatcherQueue do
         m_Interface := QInterface (this.m_ICoreWindow.all);
         Hr := m_Interface.get_DispatcherQueue (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinRt.Windows.System.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   function get_ActivationMode
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.UI.Core.CoreWindowActivationMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindow5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreWindowActivationMode;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindow5, WinRt.Windows.UI.Core.IID_ICoreWindow5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindow.all);
      Hr := m_Interface.get_ActivationMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UIContext
   (
      this : in out CoreWindow
   )
   return WinRt.Windows.UI.UIContext'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowWithContext := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.IUIContext;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindow_Interface, WinRt.Windows.UI.Core.ICoreWindowWithContext, WinRt.Windows.UI.Core.IID_ICoreWindowWithContext'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.UIContext do
         m_Interface := QInterface (this.m_ICoreWindow.all);
         Hr := m_Interface.get_UIContext (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIContext := new WinRt.Windows.UI.IUIContext;
         Retval.m_IUIContext.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreWindowDialog

   procedure Initialize (this : in out CoreWindowDialog) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreWindowDialog) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreWindowDialog, ICoreWindowDialog_Ptr);
   begin
      if this.m_ICoreWindowDialog /= null then
         if this.m_ICoreWindowDialog.all /= null then
            temp := this.m_ICoreWindowDialog.all.Release;
            if temp < 1 then
               Free (this.m_ICoreWindowDialog);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CoreWindowDialog

   function Constructor
   (
      title : WinRt.WString
   )
   return CoreWindowDialog is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreWindowDialog");
      m_Factory    : access ICoreWindowDialogFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Core.ICoreWindowDialog;
      HStr_title : constant WinRt.HString := To_HString (title);
   begin
      return RetVal : CoreWindowDialog do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreWindowDialogFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithTitle (HStr_title, m_ComRetVal'Access);
            Retval.m_ICoreWindowDialog := new WinRt.Windows.UI.Core.ICoreWindowDialog;
            Retval.m_ICoreWindowDialog.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_title);
      end return;
   end;

   function Constructor return CoreWindowDialog is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreWindowDialog");
      m_ComRetVal  : aliased WinRt.Windows.UI.Core.ICoreWindowDialog;
   begin
      return RetVal : CoreWindowDialog do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICoreWindowDialog := new WinRt.Windows.UI.Core.ICoreWindowDialog;
            Retval.m_ICoreWindowDialog.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreWindowDialog

   function add_Showing
   (
      this : in out CoreWindowDialog;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindowDialog.all.add_Showing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Showing
   (
      this : in out CoreWindowDialog;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowDialog.all.remove_Showing (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxSize
   (
      this : in out CoreWindowDialog
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Size;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_MaxSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinSize
   (
      this : in out CoreWindowDialog
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Size;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_MinSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Title
   (
      this : in out CoreWindowDialog
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out CoreWindowDialog;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICoreWindowDialog.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsInteractionDelayed
   (
      this : in out CoreWindowDialog
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_IsInteractionDelayed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsInteractionDelayed
   (
      this : in out CoreWindowDialog;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowDialog.all.put_IsInteractionDelayed (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Commands
   (
      this : in out CoreWindowDialog
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_Commands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DefaultCommandIndex
   (
      this : in out CoreWindowDialog
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_DefaultCommandIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultCommandIndex
   (
      this : in out CoreWindowDialog;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowDialog.all.put_DefaultCommandIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CancelCommandIndex
   (
      this : in out CoreWindowDialog
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_CancelCommandIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CancelCommandIndex
   (
      this : in out CoreWindowDialog;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowDialog.all.put_CancelCommandIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackButtonCommand
   (
      this : in out CoreWindowDialog
   )
   return WinRt.Windows.UI.Popups.UICommandInvokedHandler is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Popups.UICommandInvokedHandler;
   begin
      Hr := this.m_ICoreWindowDialog.all.get_BackButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackButtonCommand
   (
      this : in out CoreWindowDialog;
      value : WinRt.Windows.UI.Popups.UICommandInvokedHandler
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowDialog.all.put_BackButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAsync
   (
      this : in out CoreWindowDialog
   )
   return WinRt.Windows.UI.Popups.IUICommand is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_IUICommand.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_IUICommand.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Popups.IUICommand;
      m_IID            : aliased WinRt.IID := (3094807861, 27211, 21169, (181, 120, 243, 205, 197, 0, 122, 31 )); -- Windows.UI.Popups.IUICommand;
      m_HandlerIID     : aliased WinRt.IID := (3711171931, 41549, 23108, (145, 254, 221, 100, 65, 119, 1, 3 ));
      m_Handler        : AsyncOperationCompletedHandler_IUICommand.Kind := new AsyncOperationCompletedHandler_IUICommand.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IUICommand.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IUICommand.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IUICommand.Kind_Delegate, AsyncOperationCompletedHandler_IUICommand.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ICoreWindowDialog.all.ShowAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreWindowEventArgs

   procedure Initialize (this : in out CoreWindowEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreWindowEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreWindowEventArgs, ICoreWindowEventArgs_Ptr);
   begin
      if this.m_ICoreWindowEventArgs /= null then
         if this.m_ICoreWindowEventArgs.all /= null then
            temp := this.m_ICoreWindowEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_ICoreWindowEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreWindowEventArgs

   function get_Handled
   (
      this : in out CoreWindowEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICoreWindowEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out CoreWindowEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreWindowFlyout

   procedure Initialize (this : in out CoreWindowFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreWindowFlyout) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreWindowFlyout, ICoreWindowFlyout_Ptr);
   begin
      if this.m_ICoreWindowFlyout /= null then
         if this.m_ICoreWindowFlyout.all /= null then
            temp := this.m_ICoreWindowFlyout.all.Release;
            if temp < 1 then
               Free (this.m_ICoreWindowFlyout);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CoreWindowFlyout

   function Constructor
   (
      position : WinRt.Windows.Foundation.Point
   )
   return CoreWindowFlyout is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreWindowFlyout");
      m_Factory    : access ICoreWindowFlyoutFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Core.ICoreWindowFlyout;
   begin
      return RetVal : CoreWindowFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreWindowFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (position, m_ComRetVal'Access);
            Retval.m_ICoreWindowFlyout := new WinRt.Windows.UI.Core.ICoreWindowFlyout;
            Retval.m_ICoreWindowFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor
   (
      position : WinRt.Windows.Foundation.Point;
      title : WinRt.WString
   )
   return CoreWindowFlyout is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreWindowFlyout");
      m_Factory    : access ICoreWindowFlyoutFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Core.ICoreWindowFlyout;
      HStr_title : constant WinRt.HString := To_HString (title);
   begin
      return RetVal : CoreWindowFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreWindowFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithTitle (position, HStr_title, m_ComRetVal'Access);
            Retval.m_ICoreWindowFlyout := new WinRt.Windows.UI.Core.ICoreWindowFlyout;
            Retval.m_ICoreWindowFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_title);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreWindowFlyout

   function add_Showing
   (
      this : in out CoreWindowFlyout;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICoreWindowFlyout.all.add_Showing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Showing
   (
      this : in out CoreWindowFlyout;
      cookie : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowFlyout.all.remove_Showing (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxSize
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Size;
   begin
      Hr := this.m_ICoreWindowFlyout.all.get_MaxSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinSize
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Size;
   begin
      Hr := this.m_ICoreWindowFlyout.all.get_MinSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Title
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICoreWindowFlyout.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out CoreWindowFlyout;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_ICoreWindowFlyout.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsInteractionDelayed
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_ICoreWindowFlyout.all.get_IsInteractionDelayed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsInteractionDelayed
   (
      this : in out CoreWindowFlyout;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowFlyout.all.put_IsInteractionDelayed (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Commands
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := this.m_ICoreWindowFlyout.all.get_Commands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DefaultCommandIndex
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICoreWindowFlyout.all.get_DefaultCommandIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultCommandIndex
   (
      this : in out CoreWindowFlyout;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowFlyout.all.put_DefaultCommandIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackButtonCommand
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.Windows.UI.Popups.UICommandInvokedHandler is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Popups.UICommandInvokedHandler;
   begin
      Hr := this.m_ICoreWindowFlyout.all.get_BackButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackButtonCommand
   (
      this : in out CoreWindowFlyout;
      value : WinRt.Windows.UI.Popups.UICommandInvokedHandler
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowFlyout.all.put_BackButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAsync
   (
      this : in out CoreWindowFlyout
   )
   return WinRt.Windows.UI.Popups.IUICommand is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_IUICommand.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_IUICommand.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Popups.IUICommand;
      m_IID            : aliased WinRt.IID := (3094807861, 27211, 21169, (181, 120, 243, 205, 197, 0, 122, 31 )); -- Windows.UI.Popups.IUICommand;
      m_HandlerIID     : aliased WinRt.IID := (3711171931, 41549, 23108, (145, 254, 221, 100, 65, 119, 1, 3 ));
      m_Handler        : AsyncOperationCompletedHandler_IUICommand.Kind := new AsyncOperationCompletedHandler_IUICommand.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_IUICommand.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_IUICommand.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_IUICommand.Kind_Delegate, AsyncOperationCompletedHandler_IUICommand.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ICoreWindowFlyout.all.ShowAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreWindowPopupShowingEventArgs

   procedure Initialize (this : in out CoreWindowPopupShowingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreWindowPopupShowingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreWindowPopupShowingEventArgs, ICoreWindowPopupShowingEventArgs_Ptr);
   begin
      if this.m_ICoreWindowPopupShowingEventArgs /= null then
         if this.m_ICoreWindowPopupShowingEventArgs.all /= null then
            temp := this.m_ICoreWindowPopupShowingEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_ICoreWindowPopupShowingEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreWindowPopupShowingEventArgs

   procedure SetDesiredSize
   (
      this : in out CoreWindowPopupShowingEventArgs;
      value : WinRt.Windows.Foundation.Size
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowPopupShowingEventArgs.all.SetDesiredSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CoreWindowResizeManager

   procedure Initialize (this : in out CoreWindowResizeManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out CoreWindowResizeManager) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICoreWindowResizeManager, ICoreWindowResizeManager_Ptr);
   begin
      if this.m_ICoreWindowResizeManager /= null then
         if this.m_ICoreWindowResizeManager.all /= null then
            temp := this.m_ICoreWindowResizeManager.all.Release;
            if temp < 1 then
               Free (this.m_ICoreWindowResizeManager);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CoreWindowResizeManager

   function GetForCurrentView
   return WinRt.Windows.UI.Core.CoreWindowResizeManager is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Core.CoreWindowResizeManager");
      m_Factory        : access WinRt.Windows.UI.Core.ICoreWindowResizeManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreWindowResizeManager;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreWindowResizeManager do
         Hr := RoGetActivationFactory (m_hString, IID_ICoreWindowResizeManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICoreWindowResizeManager := new WinRt.Windows.UI.Core.ICoreWindowResizeManager;
            Retval.m_ICoreWindowResizeManager.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CoreWindowResizeManager

   procedure NotifyLayoutCompleted
   (
      this : in out CoreWindowResizeManager
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICoreWindowResizeManager.all.NotifyLayoutCompleted;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure put_ShouldWaitForLayoutCompletion
   (
      this : in out CoreWindowResizeManager;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowResizeManagerLayoutCapability := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindowResizeManager_Interface, WinRt.Windows.UI.Core.ICoreWindowResizeManagerLayoutCapability, WinRt.Windows.UI.Core.IID_ICoreWindowResizeManagerLayoutCapability'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindowResizeManager.all);
      Hr := m_Interface.put_ShouldWaitForLayoutCompletion (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShouldWaitForLayoutCompletion
   (
      this : in out CoreWindowResizeManager
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowResizeManagerLayoutCapability := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ICoreWindowResizeManager_Interface, WinRt.Windows.UI.Core.ICoreWindowResizeManagerLayoutCapability, WinRt.Windows.UI.Core.IID_ICoreWindowResizeManagerLayoutCapability'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICoreWindowResizeManager.all);
      Hr := m_Interface.get_ShouldWaitForLayoutCompletion (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DispatchedHandler

   function Invoke
   (
      this : access DispatchedHandler_Delegate
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback.all;
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- Delegate IdleDispatchedHandler

   function Invoke
   (
      this : access IdleDispatchedHandler_Delegate;
      e : WinRt.Windows.UI.Core.IIdleDispatchedHandlerArgs
   )
   return WinRt.Hresult is
      Hr : constant WinRt.HResult := S_OK;
   begin
      this.Callback (e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IdleDispatchedHandlerArgs

   procedure Initialize (this : in out IdleDispatchedHandlerArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out IdleDispatchedHandlerArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIdleDispatchedHandlerArgs, IIdleDispatchedHandlerArgs_Ptr);
   begin
      if this.m_IIdleDispatchedHandlerArgs /= null then
         if this.m_IIdleDispatchedHandlerArgs.all /= null then
            temp := this.m_IIdleDispatchedHandlerArgs.all.Release;
            if temp < 1 then
               Free (this.m_IIdleDispatchedHandlerArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IdleDispatchedHandlerArgs

   function get_IsDispatcherIdle
   (
      this : in out IdleDispatchedHandlerArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IIdleDispatchedHandlerArgs.all.get_IsDispatcherIdle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputEnabledEventArgs

   procedure Initialize (this : in out InputEnabledEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputEnabledEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputEnabledEventArgs, IInputEnabledEventArgs_Ptr);
   begin
      if this.m_IInputEnabledEventArgs /= null then
         if this.m_IInputEnabledEventArgs.all /= null then
            temp := this.m_IInputEnabledEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IInputEnabledEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputEnabledEventArgs

   function get_InputEnabled
   (
      this : in out InputEnabledEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IInputEnabledEventArgs.all.get_InputEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out InputEnabledEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IInputEnabledEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputEnabledEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out InputEnabledEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IInputEnabledEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInputEnabledEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyEventArgs

   procedure Initialize (this : in out KeyEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyEventArgs, IKeyEventArgs_Ptr);
   begin
      if this.m_IKeyEventArgs /= null then
         if this.m_IKeyEventArgs.all /= null then
            temp := this.m_IKeyEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IKeyEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyEventArgs

   function get_VirtualKey
   (
      this : in out KeyEventArgs
   )
   return WinRt.Windows.System.VirtualKey is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKey;
   begin
      Hr := this.m_IKeyEventArgs.all.get_VirtualKey (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_KeyStatus
   (
      this : in out KeyEventArgs
   )
   return WinRt.Windows.UI.Core.CorePhysicalKeyStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CorePhysicalKeyStatus;
   begin
      Hr := this.m_IKeyEventArgs.all.get_KeyStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out KeyEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IKeyEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out KeyEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IKeyEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeviceId
   (
      this : in out KeyEventArgs
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.IKeyEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IKeyEventArgs_Interface, WinRt.Windows.UI.Core.IKeyEventArgs2, WinRt.Windows.UI.Core.IID_IKeyEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyEventArgs.all);
      Hr := m_Interface.get_DeviceId (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerEventArgs

   procedure Initialize (this : in out PointerEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerEventArgs, IPointerEventArgs_Ptr);
   begin
      if this.m_IPointerEventArgs /= null then
         if this.m_IPointerEventArgs.all /= null then
            temp := this.m_IPointerEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IPointerEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerEventArgs

   function get_CurrentPoint
   (
      this : in out PointerEventArgs
   )
   return WinRt.Windows.UI.Input.PointerPoint'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Input.IPointerPoint;
   begin
      return RetVal : WinRt.Windows.UI.Input.PointerPoint do
         Hr := this.m_IPointerEventArgs.all.get_CurrentPoint (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerPoint := new WinRt.Windows.UI.Input.IPointerPoint;
         Retval.m_IPointerPoint.all := m_ComRetVal;
      end return;
   end;

   function get_KeyModifiers
   (
      this : in out PointerEventArgs
   )
   return WinRt.Windows.System.VirtualKeyModifiers is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.VirtualKeyModifiers;
   begin
      Hr := this.m_IPointerEventArgs.all.get_KeyModifiers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetIntermediatePoints
   (
      this : in out PointerEventArgs
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      Hr := this.m_IPointerEventArgs.all.GetIntermediatePoints (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out PointerEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IPointerEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointerEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out PointerEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IPointerEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointerEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SystemNavigationManager

   procedure Initialize (this : in out SystemNavigationManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out SystemNavigationManager) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISystemNavigationManager, ISystemNavigationManager_Ptr);
   begin
      if this.m_ISystemNavigationManager /= null then
         if this.m_ISystemNavigationManager.all /= null then
            temp := this.m_ISystemNavigationManager.all.Release;
            if temp < 1 then
               Free (this.m_ISystemNavigationManager);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SystemNavigationManager

   function GetForCurrentView
   return WinRt.Windows.UI.Core.SystemNavigationManager is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Core.SystemNavigationManager");
      m_Factory        : access WinRt.Windows.UI.Core.ISystemNavigationManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ISystemNavigationManager;
   begin
      return RetVal : WinRt.Windows.UI.Core.SystemNavigationManager do
         Hr := RoGetActivationFactory (m_hString, IID_ISystemNavigationManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISystemNavigationManager := new WinRt.Windows.UI.Core.ISystemNavigationManager;
            Retval.m_ISystemNavigationManager.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SystemNavigationManager

   function add_BackRequested
   (
      this : in out SystemNavigationManager;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISystemNavigationManager.all.add_BackRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BackRequested
   (
      this : in out SystemNavigationManager;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemNavigationManager.all.remove_BackRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AppViewBackButtonVisibility
   (
      this : in out SystemNavigationManager
   )
   return WinRt.Windows.UI.Core.AppViewBackButtonVisibility is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ISystemNavigationManager2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.AppViewBackButtonVisibility;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ISystemNavigationManager_Interface, WinRt.Windows.UI.Core.ISystemNavigationManager2, WinRt.Windows.UI.Core.IID_ISystemNavigationManager2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISystemNavigationManager.all);
      Hr := m_Interface.get_AppViewBackButtonVisibility (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AppViewBackButtonVisibility
   (
      this : in out SystemNavigationManager;
      value : WinRt.Windows.UI.Core.AppViewBackButtonVisibility
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ISystemNavigationManager2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ISystemNavigationManager_Interface, WinRt.Windows.UI.Core.ISystemNavigationManager2, WinRt.Windows.UI.Core.IID_ISystemNavigationManager2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISystemNavigationManager.all);
      Hr := m_Interface.put_AppViewBackButtonVisibility (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TouchHitTestingEventArgs

   procedure Initialize (this : in out TouchHitTestingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TouchHitTestingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITouchHitTestingEventArgs, ITouchHitTestingEventArgs_Ptr);
   begin
      if this.m_ITouchHitTestingEventArgs /= null then
         if this.m_ITouchHitTestingEventArgs.all /= null then
            temp := this.m_ITouchHitTestingEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_ITouchHitTestingEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TouchHitTestingEventArgs

   function get_ProximityEvaluation
   (
      this : in out TouchHitTestingEventArgs
   )
   return WinRt.Windows.UI.Core.CoreProximityEvaluation is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreProximityEvaluation;
   begin
      Hr := this.m_ITouchHitTestingEventArgs.all.get_ProximityEvaluation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ProximityEvaluation
   (
      this : in out TouchHitTestingEventArgs;
      value : WinRt.Windows.UI.Core.CoreProximityEvaluation
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ITouchHitTestingEventArgs.all.put_ProximityEvaluation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Point
   (
      this : in out TouchHitTestingEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Point;
   begin
      Hr := this.m_ITouchHitTestingEventArgs.all.get_Point (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BoundingBox
   (
      this : in out TouchHitTestingEventArgs
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Rect;
   begin
      Hr := this.m_ITouchHitTestingEventArgs.all.get_BoundingBox (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function EvaluateProximity
   (
      this : in out TouchHitTestingEventArgs;
      controlBoundingBox : WinRt.Windows.Foundation.Rect
   )
   return WinRt.Windows.UI.Core.CoreProximityEvaluation is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreProximityEvaluation;
   begin
      Hr := this.m_ITouchHitTestingEventArgs.all.EvaluateProximity (controlBoundingBox, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function EvaluateProximity
   (
      this : in out TouchHitTestingEventArgs;
      controlVertices : WinRt.Windows.Foundation.Point_Array
   )
   return WinRt.Windows.UI.Core.CoreProximityEvaluation is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreProximityEvaluation;
      function Convert_controlVertices is new Ada.Unchecked_Conversion (Address, WinRt.Windows.Foundation.Point_Ptr);
   begin
      Hr := this.m_ITouchHitTestingEventArgs.all.EvaluateProximity (WinRt.UInt32(controlVertices'Length), Convert_controlVertices (controlVertices (controlVertices'First)'Address), m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out TouchHitTestingEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ITouchHitTestingEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITouchHitTestingEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TouchHitTestingEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.ITouchHitTestingEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITouchHitTestingEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisibilityChangedEventArgs

   procedure Initialize (this : in out VisibilityChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisibilityChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisibilityChangedEventArgs, IVisibilityChangedEventArgs_Ptr);
   begin
      if this.m_IVisibilityChangedEventArgs /= null then
         if this.m_IVisibilityChangedEventArgs.all /= null then
            temp := this.m_IVisibilityChangedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IVisibilityChangedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisibilityChangedEventArgs

   function get_Visible
   (
      this : in out VisibilityChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IVisibilityChangedEventArgs.all.get_Visible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out VisibilityChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IVisibilityChangedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisibilityChangedEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out VisibilityChangedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IVisibilityChangedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisibilityChangedEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowActivatedEventArgs

   procedure Initialize (this : in out WindowActivatedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowActivatedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowActivatedEventArgs, IWindowActivatedEventArgs_Ptr);
   begin
      if this.m_IWindowActivatedEventArgs /= null then
         if this.m_IWindowActivatedEventArgs.all /= null then
            temp := this.m_IWindowActivatedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IWindowActivatedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowActivatedEventArgs

   function get_WindowActivationState
   (
      this : in out WindowActivatedEventArgs
   )
   return WinRt.Windows.UI.Core.CoreWindowActivationState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.CoreWindowActivationState;
   begin
      Hr := this.m_IWindowActivatedEventArgs.all.get_WindowActivationState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out WindowActivatedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IWindowActivatedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWindowActivatedEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out WindowActivatedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IWindowActivatedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWindowActivatedEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowSizeChangedEventArgs

   procedure Initialize (this : in out WindowSizeChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowSizeChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowSizeChangedEventArgs, IWindowSizeChangedEventArgs_Ptr);
   begin
      if this.m_IWindowSizeChangedEventArgs /= null then
         if this.m_IWindowSizeChangedEventArgs.all /= null then
            temp := this.m_IWindowSizeChangedEventArgs.all.Release;
            if temp < 1 then
               Free (this.m_IWindowSizeChangedEventArgs);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowSizeChangedEventArgs

   function get_Size
   (
      this : in out WindowSizeChangedEventArgs
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Size;
   begin
      Hr := this.m_IWindowSizeChangedEventArgs.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out WindowSizeChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IWindowSizeChangedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWindowSizeChangedEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out WindowSizeChangedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Core.ICoreWindowEventArgs := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Core.IWindowSizeChangedEventArgs_Interface, WinRt.Windows.UI.Core.ICoreWindowEventArgs, WinRt.Windows.UI.Core.IID_ICoreWindowEventArgs'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWindowSizeChangedEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinRt.Windows.UI.Core;
