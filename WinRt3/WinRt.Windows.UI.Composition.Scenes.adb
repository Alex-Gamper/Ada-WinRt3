--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Numerics;
with WinRt.Windows.Graphics.DirectX;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.Composition.Scenes is

   package IVector_ISceneComponent is new WinRt.Windows.Foundation.Collections.IVector (ISceneComponent);
   package IIterable_ISceneComponent is new WinRt.Windows.Foundation.Collections.IIterable (ISceneComponent);
   package IMap_HString_SceneAttributeSemantic is new WinRt.Windows.Foundation.Collections.IMap (WinRt.HString, SceneAttributeSemantic);
   package IVector_ISceneNode is new WinRt.Windows.Foundation.Collections.IVector (ISceneNode);
   package IIterable_ISceneNode is new WinRt.Windows.Foundation.Collections.IIterable (ISceneNode);
   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneObject

   procedure Initialize (this : in out SceneObject) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneObject) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneObject, ISceneObject_Ptr);
   begin
      if this.m_ISceneObject /= null then
         if this.m_ISceneObject.all /= null then
            temp := this.m_ISceneObject.all.Release;
            Free (this.m_ISceneObject);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SceneObject

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneObject

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneBoundingBox

   procedure Initialize (this : in out SceneBoundingBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneBoundingBox) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneBoundingBox, ISceneBoundingBox_Ptr);
   begin
      if this.m_ISceneBoundingBox /= null then
         if this.m_ISceneBoundingBox.all /= null then
            temp := this.m_ISceneBoundingBox.all.Release;
            Free (this.m_ISceneBoundingBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneBoundingBox

   function get_Center
   (
      this : in out SceneBoundingBox
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneBoundingBox.all.get_Center (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Extents
   (
      this : in out SceneBoundingBox
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneBoundingBox.all.get_Extents (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Max
   (
      this : in out SceneBoundingBox
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneBoundingBox.all.get_Max (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Min
   (
      this : in out SceneBoundingBox
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneBoundingBox.all.get_Min (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out SceneBoundingBox
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneBoundingBox.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneComponent

   procedure Initialize (this : in out SceneComponent) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneComponent) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneComponent, ISceneComponent_Ptr);
   begin
      if this.m_ISceneComponent /= null then
         if this.m_ISceneComponent.all /= null then
            temp := this.m_ISceneComponent.all.Release;
            Free (this.m_ISceneComponent);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SceneComponent

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneComponent

   function get_ComponentType
   (
      this : in out SceneComponent
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneComponentType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.SceneComponentType;
   begin
      Hr := this.m_ISceneComponent.all.get_ComponentType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneComponentCollection

   procedure Initialize (this : in out SceneComponentCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneComponentCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneComponentCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Composition.Scenes.SceneComponent>
   function GetAt
   (
      this : in out SceneComponentCollection;
      index : WinRt.UInt32
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneComponent'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneComponent;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneComponent do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneComponent := new Windows.UI.Composition.Scenes.ISceneComponent;
         Retval.m_ISceneComponent.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out SceneComponentCollection
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out SceneComponentCollection
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out SceneComponentCollection;
      value : Windows.UI.Composition.Scenes.SceneComponent'Class;
      index : WinRt.UInt32_Ptr
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ISceneComponent.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out SceneComponentCollection;
      index : WinRt.UInt32;
      value : Windows.UI.Composition.Scenes.SceneComponent'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ISceneComponent.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out SceneComponentCollection;
      index : WinRt.UInt32;
      value : Windows.UI.Composition.Scenes.SceneComponent'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ISceneComponent.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out SceneComponentCollection;
      index : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out SceneComponentCollection;
      value : Windows.UI.Composition.Scenes.SceneComponent'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ISceneComponent.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out SceneComponentCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out SceneComponentCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out SceneComponentCollection;
      startIndex : WinRt.UInt32;
      items : Windows.UI.Composition.Scenes.ISceneComponent_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out SceneComponentCollection;
      items : Windows.UI.Composition.Scenes.ISceneComponent_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3668774705, 50256, 20576, (151, 50, 240, 44, 136, 94, 155, 63 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.Scenes.SceneComponent>
   function First
   (
      this : in out SceneComponentCollection
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ISceneComponent.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericIID     : aliased WinRt.IID := (2622572763, 1445, 20570, (187, 20, 160, 229, 223, 187, 44, 212 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IIterable_ISceneComponent.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneMaterial

   procedure Initialize (this : in out SceneMaterial) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneMaterial) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneMaterial, ISceneMaterial_Ptr);
   begin
      if this.m_ISceneMaterial /= null then
         if this.m_ISceneMaterial.all /= null then
            temp := this.m_ISceneMaterial.all.Release;
            Free (this.m_ISceneMaterial);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SceneMaterial

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneMaterial

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneMaterialInput

   procedure Initialize (this : in out SceneMaterialInput) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneMaterialInput) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneMaterialInput, ISceneMaterialInput_Ptr);
   begin
      if this.m_ISceneMaterialInput /= null then
         if this.m_ISceneMaterialInput.all /= null then
            temp := this.m_ISceneMaterialInput.all.Release;
            Free (this.m_ISceneMaterialInput);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SceneMaterialInput

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneMaterialInput

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneMesh

   procedure Initialize (this : in out SceneMesh) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneMesh) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneMesh, ISceneMesh_Ptr);
   begin
      if this.m_ISceneMesh /= null then
         if this.m_ISceneMesh.all /= null then
            temp := this.m_ISceneMesh.all.Release;
            Free (this.m_ISceneMesh);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SceneMesh

   function Create
   (
      compositor : Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMesh is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Scenes.SceneMesh");
      m_Factory        : access WinRt.Windows.UI.Composition.Scenes.ISceneMeshStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMesh;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMesh do
         Hr := RoGetActivationFactory (m_hString, IID_ISceneMeshStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISceneMesh := new Windows.UI.Composition.Scenes.ISceneMesh;
            Retval.m_ISceneMesh.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneMesh

   function get_Bounds
   (
      this : in out SceneMesh
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneBoundingBox'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneBoundingBox;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneBoundingBox do
         Hr := this.m_ISceneMesh.all.get_Bounds (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneBoundingBox := new Windows.UI.Composition.Scenes.ISceneBoundingBox;
         Retval.m_ISceneBoundingBox.all := m_ComRetVal;
      end return;
   end;

   function get_PrimitiveTopology
   (
      this : in out SceneMesh
   )
   return WinRt.Windows.Graphics.DirectX.DirectXPrimitiveTopology is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DirectX.DirectXPrimitiveTopology;
   begin
      Hr := this.m_ISceneMesh.all.get_PrimitiveTopology (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PrimitiveTopology
   (
      this : in out SceneMesh;
      value : Windows.Graphics.DirectX.DirectXPrimitiveTopology
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMesh.all.put_PrimitiveTopology (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure FillMeshAttribute
   (
      this : in out SceneMesh;
      semantic : Windows.UI.Composition.Scenes.SceneAttributeSemantic;
      format : Windows.Graphics.DirectX.DirectXPixelFormat;
      memory : Windows.Foundation.MemoryBuffer'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMesh.all.FillMeshAttribute (semantic, format, memory.m_IMemoryBuffer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneMeshMaterialAttributeMap

   procedure Initialize (this : in out SceneMeshMaterialAttributeMap) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneMeshMaterialAttributeMap) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneMeshMaterialAttributeMap, ISceneMeshMaterialAttributeMap_Ptr);
   begin
      if this.m_ISceneMeshMaterialAttributeMap /= null then
         if this.m_ISceneMeshMaterialAttributeMap.all /= null then
            temp := this.m_ISceneMeshMaterialAttributeMap.all.Release;
            Free (this.m_ISceneMeshMaterialAttributeMap);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneMeshMaterialAttributeMap

   -- Generic Interface Windows.Foundation.Collections.IMap`2<System.String,Windows.UI.Composition.Scenes.SceneAttributeSemantic>
   function Lookup
   (
      this : in out SceneMeshMaterialAttributeMap;
      key : WinRt.WString
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneAttributeSemantic is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_SceneAttributeSemantic.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.SceneAttributeSemantic;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1106579220, 39484, 21056, (176, 66, 27, 255, 2, 229, 112, 40 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap_Interface, IMap_HString_SceneAttributeSemantic.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISceneMeshMaterialAttributeMap.all);
      Hr := m_Interface.Lookup (HStr_key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out SceneMeshMaterialAttributeMap
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_SceneAttributeSemantic.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1106579220, 39484, 21056, (176, 66, 27, 255, 2, 229, 112, 40 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap_Interface, IMap_HString_SceneAttributeSemantic.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISceneMeshMaterialAttributeMap.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function HasKey
   (
      this : in out SceneMeshMaterialAttributeMap;
      key : WinRt.WString
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_SceneAttributeSemantic.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1106579220, 39484, 21056, (176, 66, 27, 255, 2, 229, 112, 40 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap_Interface, IMap_HString_SceneAttributeSemantic.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISceneMeshMaterialAttributeMap.all);
      Hr := m_Interface.HasKey (HStr_key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out SceneMeshMaterialAttributeMap
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_SceneAttributeSemantic.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericIID     : aliased WinRt.IID := (1106579220, 39484, 21056, (176, 66, 27, 255, 2, 229, 112, 40 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap_Interface, IMap_HString_SceneAttributeSemantic.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISceneMeshMaterialAttributeMap.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Insert
   (
      this : in out SceneMeshMaterialAttributeMap;
      key : WinRt.WString;
      value : Windows.UI.Composition.Scenes.SceneAttributeSemantic
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_SceneAttributeSemantic.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1106579220, 39484, 21056, (176, 66, 27, 255, 2, 229, 112, 40 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap_Interface, IMap_HString_SceneAttributeSemantic.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISceneMeshMaterialAttributeMap.all);
      Hr := m_Interface.Insert (HStr_key, value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   procedure Remove
   (
      this : in out SceneMeshMaterialAttributeMap;
      key : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_SceneAttributeSemantic.Kind := null;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1106579220, 39484, 21056, (176, 66, 27, 255, 2, 229, 112, 40 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap_Interface, IMap_HString_SceneAttributeSemantic.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISceneMeshMaterialAttributeMap.all);
      Hr := m_Interface.Remove (HStr_key);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure Clear
   (
      this : in out SceneMeshMaterialAttributeMap
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_SceneAttributeSemantic.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1106579220, 39484, 21056, (176, 66, 27, 255, 2, 229, 112, 40 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap_Interface, IMap_HString_SceneAttributeSemantic.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISceneMeshMaterialAttributeMap.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneRendererComponent

   procedure Initialize (this : in out SceneRendererComponent) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneRendererComponent) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneRendererComponent, ISceneRendererComponent_Ptr);
   begin
      if this.m_ISceneRendererComponent /= null then
         if this.m_ISceneRendererComponent.all /= null then
            temp := this.m_ISceneRendererComponent.all.Release;
            Free (this.m_ISceneRendererComponent);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SceneRendererComponent

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneRendererComponent

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneMeshRendererComponent

   procedure Initialize (this : in out SceneMeshRendererComponent) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneMeshRendererComponent) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneMeshRendererComponent, ISceneMeshRendererComponent_Ptr);
   begin
      if this.m_ISceneMeshRendererComponent /= null then
         if this.m_ISceneMeshRendererComponent.all /= null then
            temp := this.m_ISceneMeshRendererComponent.all.Release;
            Free (this.m_ISceneMeshRendererComponent);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SceneMeshRendererComponent

   function Create
   (
      compositor : Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMeshRendererComponent is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Scenes.SceneMeshRendererComponent");
      m_Factory        : access WinRt.Windows.UI.Composition.Scenes.ISceneMeshRendererComponentStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMeshRendererComponent;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMeshRendererComponent do
         Hr := RoGetActivationFactory (m_hString, IID_ISceneMeshRendererComponentStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISceneMeshRendererComponent := new Windows.UI.Composition.Scenes.ISceneMeshRendererComponent;
            Retval.m_ISceneMeshRendererComponent.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneMeshRendererComponent

   function get_Material
   (
      this : in out SceneMeshRendererComponent
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMaterial'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMaterial;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMaterial do
         Hr := this.m_ISceneMeshRendererComponent.all.get_Material (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMaterial := new Windows.UI.Composition.Scenes.ISceneMaterial;
         Retval.m_ISceneMaterial.all := m_ComRetVal;
      end return;
   end;

   procedure put_Material
   (
      this : in out SceneMeshRendererComponent;
      value : Windows.UI.Composition.Scenes.SceneMaterial'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMeshRendererComponent.all.put_Material (value.m_ISceneMaterial.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Mesh
   (
      this : in out SceneMeshRendererComponent
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMesh'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMesh;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMesh do
         Hr := this.m_ISceneMeshRendererComponent.all.get_Mesh (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMesh := new Windows.UI.Composition.Scenes.ISceneMesh;
         Retval.m_ISceneMesh.all := m_ComRetVal;
      end return;
   end;

   procedure put_Mesh
   (
      this : in out SceneMeshRendererComponent;
      value : Windows.UI.Composition.Scenes.SceneMesh'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMeshRendererComponent.all.put_Mesh (value.m_ISceneMesh.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UVMappings
   (
      this : in out SceneMeshRendererComponent
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMeshMaterialAttributeMap do
         Hr := this.m_ISceneMeshRendererComponent.all.get_UVMappings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMeshMaterialAttributeMap := new Windows.UI.Composition.Scenes.ISceneMeshMaterialAttributeMap;
         Retval.m_ISceneMeshMaterialAttributeMap.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScenePbrMaterial

   procedure Initialize (this : in out ScenePbrMaterial) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScenePbrMaterial) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScenePbrMaterial, IScenePbrMaterial_Ptr);
   begin
      if this.m_IScenePbrMaterial /= null then
         if this.m_IScenePbrMaterial.all /= null then
            temp := this.m_IScenePbrMaterial.all.Release;
            Free (this.m_IScenePbrMaterial);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScenePbrMaterial

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScenePbrMaterial

   function get_AlphaCutoff
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IScenePbrMaterial.all.get_AlphaCutoff (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlphaCutoff
   (
      this : in out ScenePbrMaterial;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_AlphaCutoff (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlphaMode
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneAlphaMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.SceneAlphaMode;
   begin
      Hr := this.m_IScenePbrMaterial.all.get_AlphaMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlphaMode
   (
      this : in out ScenePbrMaterial;
      value : Windows.UI.Composition.Scenes.SceneAlphaMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_AlphaMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EmissiveInput
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMaterialInput;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput do
         Hr := this.m_IScenePbrMaterial.all.get_EmissiveInput (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMaterialInput := new Windows.UI.Composition.Scenes.ISceneMaterialInput;
         Retval.m_ISceneMaterialInput.all := m_ComRetVal;
      end return;
   end;

   procedure put_EmissiveInput
   (
      this : in out ScenePbrMaterial;
      value : Windows.UI.Composition.Scenes.SceneMaterialInput'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_EmissiveInput (value.m_ISceneMaterialInput.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EmissiveFactor
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IScenePbrMaterial.all.get_EmissiveFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EmissiveFactor
   (
      this : in out ScenePbrMaterial;
      value : Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_EmissiveFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDoubleSided
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IScenePbrMaterial.all.get_IsDoubleSided (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDoubleSided
   (
      this : in out ScenePbrMaterial;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_IsDoubleSided (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NormalInput
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMaterialInput;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput do
         Hr := this.m_IScenePbrMaterial.all.get_NormalInput (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMaterialInput := new Windows.UI.Composition.Scenes.ISceneMaterialInput;
         Retval.m_ISceneMaterialInput.all := m_ComRetVal;
      end return;
   end;

   procedure put_NormalInput
   (
      this : in out ScenePbrMaterial;
      value : Windows.UI.Composition.Scenes.SceneMaterialInput'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_NormalInput (value.m_ISceneMaterialInput.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NormalScale
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IScenePbrMaterial.all.get_NormalScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NormalScale
   (
      this : in out ScenePbrMaterial;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_NormalScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OcclusionInput
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMaterialInput;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput do
         Hr := this.m_IScenePbrMaterial.all.get_OcclusionInput (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMaterialInput := new Windows.UI.Composition.Scenes.ISceneMaterialInput;
         Retval.m_ISceneMaterialInput.all := m_ComRetVal;
      end return;
   end;

   procedure put_OcclusionInput
   (
      this : in out ScenePbrMaterial;
      value : Windows.UI.Composition.Scenes.SceneMaterialInput'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_OcclusionInput (value.m_ISceneMaterialInput.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OcclusionStrength
   (
      this : in out ScenePbrMaterial
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IScenePbrMaterial.all.get_OcclusionStrength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OcclusionStrength
   (
      this : in out ScenePbrMaterial;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScenePbrMaterial.all.put_OcclusionStrength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneMetallicRoughnessMaterial

   procedure Initialize (this : in out SceneMetallicRoughnessMaterial) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneMetallicRoughnessMaterial) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneMetallicRoughnessMaterial, ISceneMetallicRoughnessMaterial_Ptr);
   begin
      if this.m_ISceneMetallicRoughnessMaterial /= null then
         if this.m_ISceneMetallicRoughnessMaterial.all /= null then
            temp := this.m_ISceneMetallicRoughnessMaterial.all.Release;
            Free (this.m_ISceneMetallicRoughnessMaterial);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SceneMetallicRoughnessMaterial

   function Create
   (
      compositor : Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial");
      m_Factory        : access WinRt.Windows.UI.Composition.Scenes.ISceneMetallicRoughnessMaterialStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMetallicRoughnessMaterial;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMetallicRoughnessMaterial do
         Hr := RoGetActivationFactory (m_hString, IID_ISceneMetallicRoughnessMaterialStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISceneMetallicRoughnessMaterial := new Windows.UI.Composition.Scenes.ISceneMetallicRoughnessMaterial;
            Retval.m_ISceneMetallicRoughnessMaterial.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneMetallicRoughnessMaterial

   function get_BaseColorInput
   (
      this : in out SceneMetallicRoughnessMaterial
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMaterialInput;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput do
         Hr := this.m_ISceneMetallicRoughnessMaterial.all.get_BaseColorInput (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMaterialInput := new Windows.UI.Composition.Scenes.ISceneMaterialInput;
         Retval.m_ISceneMaterialInput.all := m_ComRetVal;
      end return;
   end;

   procedure put_BaseColorInput
   (
      this : in out SceneMetallicRoughnessMaterial;
      value : Windows.UI.Composition.Scenes.SceneMaterialInput'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.put_BaseColorInput (value.m_ISceneMaterialInput.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BaseColorFactor
   (
      this : in out SceneMetallicRoughnessMaterial
   )
   return WinRt.Windows.Foundation.Numerics.Vector4 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector4;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.get_BaseColorFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BaseColorFactor
   (
      this : in out SceneMetallicRoughnessMaterial;
      value : Windows.Foundation.Numerics.Vector4
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.put_BaseColorFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MetallicFactor
   (
      this : in out SceneMetallicRoughnessMaterial
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.get_MetallicFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MetallicFactor
   (
      this : in out SceneMetallicRoughnessMaterial;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.put_MetallicFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MetallicRoughnessInput
   (
      this : in out SceneMetallicRoughnessMaterial
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneMaterialInput;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneMaterialInput do
         Hr := this.m_ISceneMetallicRoughnessMaterial.all.get_MetallicRoughnessInput (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneMaterialInput := new Windows.UI.Composition.Scenes.ISceneMaterialInput;
         Retval.m_ISceneMaterialInput.all := m_ComRetVal;
      end return;
   end;

   procedure put_MetallicRoughnessInput
   (
      this : in out SceneMetallicRoughnessMaterial;
      value : Windows.UI.Composition.Scenes.SceneMaterialInput'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.put_MetallicRoughnessInput (value.m_ISceneMaterialInput.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RoughnessFactor
   (
      this : in out SceneMetallicRoughnessMaterial
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.get_RoughnessFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RoughnessFactor
   (
      this : in out SceneMetallicRoughnessMaterial;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneMetallicRoughnessMaterial.all.put_RoughnessFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneModelTransform

   procedure Initialize (this : in out SceneModelTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneModelTransform) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneModelTransform, ISceneModelTransform_Ptr);
   begin
      if this.m_ISceneModelTransform /= null then
         if this.m_ISceneModelTransform.all /= null then
            temp := this.m_ISceneModelTransform.all.Release;
            Free (this.m_ISceneModelTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneModelTransform

   function get_Orientation
   (
      this : in out SceneModelTransform
   )
   return WinRt.Windows.Foundation.Numerics.Quaternion is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Quaternion;
   begin
      Hr := this.m_ISceneModelTransform.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out SceneModelTransform;
      value : Windows.Foundation.Numerics.Quaternion
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneModelTransform.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngle
   (
      this : in out SceneModelTransform
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISceneModelTransform.all.get_RotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngle
   (
      this : in out SceneModelTransform;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneModelTransform.all.put_RotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngleInDegrees
   (
      this : in out SceneModelTransform
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISceneModelTransform.all.get_RotationAngleInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngleInDegrees
   (
      this : in out SceneModelTransform;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneModelTransform.all.put_RotationAngleInDegrees (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAxis
   (
      this : in out SceneModelTransform
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneModelTransform.all.get_RotationAxis (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAxis
   (
      this : in out SceneModelTransform;
      value : Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneModelTransform.all.put_RotationAxis (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out SceneModelTransform
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneModelTransform.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out SceneModelTransform;
      value : Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneModelTransform.all.put_Scale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Translation
   (
      this : in out SceneModelTransform
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISceneModelTransform.all.get_Translation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Translation
   (
      this : in out SceneModelTransform;
      value : Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneModelTransform.all.put_Translation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneNode

   procedure Initialize (this : in out SceneNode) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneNode) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneNode, ISceneNode_Ptr);
   begin
      if this.m_ISceneNode /= null then
         if this.m_ISceneNode.all /= null then
            temp := this.m_ISceneNode.all.Release;
            Free (this.m_ISceneNode);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SceneNode

   function Create
   (
      compositor : Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneNode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Scenes.SceneNode");
      m_Factory        : access WinRt.Windows.UI.Composition.Scenes.ISceneNodeStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneNode;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneNode do
         Hr := RoGetActivationFactory (m_hString, IID_ISceneNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISceneNode := new Windows.UI.Composition.Scenes.ISceneNode;
            Retval.m_ISceneNode.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneNode

   function get_Children
   (
      this : in out SceneNode
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneNodeCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneNodeCollection do
         Hr := this.m_ISceneNode.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Components
   (
      this : in out SceneNode
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneComponentCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneComponentCollection do
         Hr := this.m_ISceneNode.all.get_Components (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Parent
   (
      this : in out SceneNode
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneNode'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneNode;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneNode do
         Hr := this.m_ISceneNode.all.get_Parent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneNode := new Windows.UI.Composition.Scenes.ISceneNode;
         Retval.m_ISceneNode.all := m_ComRetVal;
      end return;
   end;

   function get_Transform
   (
      this : in out SceneNode
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneModelTransform'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneModelTransform;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneModelTransform do
         Hr := this.m_ISceneNode.all.get_Transform (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneModelTransform := new Windows.UI.Composition.Scenes.ISceneModelTransform;
         Retval.m_ISceneModelTransform.all := m_ComRetVal;
      end return;
   end;

   function FindFirstComponentOfType
   (
      this : in out SceneNode;
      value : Windows.UI.Composition.Scenes.SceneComponentType
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneComponent'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneComponent;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneComponent do
         Hr := this.m_ISceneNode.all.FindFirstComponentOfType (value, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneComponent := new Windows.UI.Composition.Scenes.ISceneComponent;
         Retval.m_ISceneComponent.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneNodeCollection

   procedure Initialize (this : in out SceneNodeCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneNodeCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneNodeCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Composition.Scenes.SceneNode>
   function GetAt
   (
      this : in out SceneNodeCollection;
      index : WinRt.UInt32
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneNode'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneNode;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneNode do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneNode := new Windows.UI.Composition.Scenes.ISceneNode;
         Retval.m_ISceneNode.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out SceneNodeCollection
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out SceneNodeCollection
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out SceneNodeCollection;
      value : Windows.UI.Composition.Scenes.SceneNode'Class;
      index : WinRt.UInt32_Ptr
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ISceneNode.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out SceneNodeCollection;
      index : WinRt.UInt32;
      value : Windows.UI.Composition.Scenes.SceneNode'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ISceneNode.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out SceneNodeCollection;
      index : WinRt.UInt32;
      value : Windows.UI.Composition.Scenes.SceneNode'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ISceneNode.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out SceneNodeCollection;
      index : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out SceneNodeCollection;
      value : Windows.UI.Composition.Scenes.SceneNode'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ISceneNode.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out SceneNodeCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out SceneNodeCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out SceneNodeCollection;
      startIndex : WinRt.UInt32;
      items : Windows.UI.Composition.Scenes.ISceneNode_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out SceneNodeCollection;
      items : Windows.UI.Composition.Scenes.ISceneNode_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1931843232, 27958, 23129, (138, 11, 143, 241, 97, 66, 184, 147 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.Scenes.SceneNode>
   function First
   (
      this : in out SceneNodeCollection
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ISceneNode.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericIID     : aliased WinRt.IID := (3678875876, 62308, 22379, (135, 142, 89, 167, 196, 89, 167, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IIterable_ISceneNode.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneSurfaceMaterialInput

   procedure Initialize (this : in out SceneSurfaceMaterialInput) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneSurfaceMaterialInput) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneSurfaceMaterialInput, ISceneSurfaceMaterialInput_Ptr);
   begin
      if this.m_ISceneSurfaceMaterialInput /= null then
         if this.m_ISceneSurfaceMaterialInput.all /= null then
            temp := this.m_ISceneSurfaceMaterialInput.all.Release;
            Free (this.m_ISceneSurfaceMaterialInput);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SceneSurfaceMaterialInput

   function Create
   (
      compositor : Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput");
      m_Factory        : access WinRt.Windows.UI.Composition.Scenes.ISceneSurfaceMaterialInputStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneSurfaceMaterialInput;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneSurfaceMaterialInput do
         Hr := RoGetActivationFactory (m_hString, IID_ISceneSurfaceMaterialInputStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISceneSurfaceMaterialInput := new Windows.UI.Composition.Scenes.ISceneSurfaceMaterialInput;
            Retval.m_ISceneSurfaceMaterialInput.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneSurfaceMaterialInput

   function get_BitmapInterpolationMode
   (
      this : in out SceneSurfaceMaterialInput
   )
   return WinRt.Windows.UI.Composition.CompositionBitmapInterpolationMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.CompositionBitmapInterpolationMode;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.get_BitmapInterpolationMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BitmapInterpolationMode
   (
      this : in out SceneSurfaceMaterialInput;
      value : Windows.UI.Composition.CompositionBitmapInterpolationMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.put_BitmapInterpolationMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Surface
   (
      this : in out SceneSurfaceMaterialInput
   )
   return WinRt.Windows.UI.Composition.ICompositionSurface is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.ICompositionSurface;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.get_Surface (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Surface
   (
      this : in out SceneSurfaceMaterialInput;
      value : Windows.UI.Composition.ICompositionSurface
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.put_Surface (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_WrappingUMode
   (
      this : in out SceneSurfaceMaterialInput
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneWrappingMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.SceneWrappingMode;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.get_WrappingUMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_WrappingUMode
   (
      this : in out SceneSurfaceMaterialInput;
      value : Windows.UI.Composition.Scenes.SceneWrappingMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.put_WrappingUMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_WrappingVMode
   (
      this : in out SceneSurfaceMaterialInput
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneWrappingMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.SceneWrappingMode;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.get_WrappingVMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_WrappingVMode
   (
      this : in out SceneSurfaceMaterialInput;
      value : Windows.UI.Composition.Scenes.SceneWrappingMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneSurfaceMaterialInput.all.put_WrappingVMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SceneVisual

   procedure Initialize (this : in out SceneVisual) is
   begin
      null;
   end;

   procedure Finalize (this : in out SceneVisual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISceneVisual, ISceneVisual_Ptr);
   begin
      if this.m_ISceneVisual /= null then
         if this.m_ISceneVisual.all /= null then
            temp := this.m_ISceneVisual.all.Release;
            Free (this.m_ISceneVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SceneVisual

   function Create
   (
      compositor : Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneVisual is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Scenes.SceneVisual");
      m_Factory        : access WinRt.Windows.UI.Composition.Scenes.ISceneVisualStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneVisual do
         Hr := RoGetActivationFactory (m_hString, IID_ISceneVisualStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISceneVisual := new Windows.UI.Composition.Scenes.ISceneVisual;
            Retval.m_ISceneVisual.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SceneVisual

   function get_Root
   (
      this : in out SceneVisual
   )
   return WinRt.Windows.UI.Composition.Scenes.SceneNode'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Composition.Scenes.ISceneNode;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Scenes.SceneNode do
         Hr := this.m_ISceneVisual.all.get_Root (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISceneNode := new Windows.UI.Composition.Scenes.ISceneNode;
         Retval.m_ISceneNode.all := m_ComRetVal;
      end return;
   end;

   procedure put_Root
   (
      this : in out SceneVisual;
      value : Windows.UI.Composition.Scenes.SceneNode'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISceneVisual.all.put_Root (value.m_ISceneNode.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinRt.Windows.UI.Composition.Scenes;
