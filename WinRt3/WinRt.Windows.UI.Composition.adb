--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Graphics;
with WinRt.Windows.Graphics.DirectX;
with WinRt.Windows.Graphics.Effects;
with WinRt.Windows.System;
with WinRt.Windows.UI.Core;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.Composition is

   package IIterable_ICompositionAnimation is new WinRt.Windows.Foundation.Collections.IIterable (ICompositionAnimation);
   package IIterable_ICompositionColorGradientStop is new WinRt.Windows.Foundation.Collections.IIterable (ICompositionColorGradientStop);
   package IVector_ICompositionColorGradientStop is new WinRt.Windows.Foundation.Collections.IVector (ICompositionColorGradientStop);
   package IAsyncOperation_ICompositionSurface is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.UI.Composition.ICompositionSurface);
   package AsyncOperationCompletedHandler_ICompositionSurface is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.UI.Composition.ICompositionSurface);

   package IIterable_ICompositionProjectedShadowCaster is new WinRt.Windows.Foundation.Collections.IIterable (ICompositionProjectedShadowCaster);
   package IIterable_ICompositionProjectedShadowReceiver is new WinRt.Windows.Foundation.Collections.IIterable (ICompositionProjectedShadowReceiver);
   package IVector_ICompositionShape is new WinRt.Windows.Foundation.Collections.IVector (ICompositionShape);
   package IIterable_ICompositionShape is new WinRt.Windows.Foundation.Collections.IIterable (ICompositionShape);
   package IVector_Single is new WinRt.Windows.Foundation.Collections.IVector (WinRt.Single);
   package IIterable_Single is new WinRt.Windows.Foundation.Collections.IIterable (WinRt.Single);
   package IMap_HString_ICompositionAnimationBase is new WinRt.Windows.Foundation.Collections.IMap (WinRt.HString, ICompositionAnimationBase);
   package IMap_HString_HString is new WinRt.Windows.Foundation.Collections.IMap (WinRt.HString, WinRt.HString);
   package IIterable_IVisual is new WinRt.Windows.Foundation.Collections.IIterable (IVisual);
   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionObject

   procedure Initialize (this : in out CompositionObject) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionObject) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionObject, ICompositionObject_Ptr);
   begin
      if this.m_ICompositionObject /= null then
         if this.m_ICompositionObject.all /= null then
            temp := this.m_ICompositionObject.all.Release;
            Free (this.m_ICompositionObject);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionObject

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompositionObject

   procedure StartAnimationWithIAnimationObject
   (
      target : WinRt.Windows.UI.Composition.IAnimationObject;
      propertyName : WinRt.WString;
      animation : WinRt.Windows.UI.Composition.CompositionAnimation'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionObject");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionObjectStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionObjectStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.StartAnimationWithIAnimationObject (target, HStr_propertyName, animation.m_ICompositionAnimation.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure StartAnimationGroupWithIAnimationObject
   (
      target : WinRt.Windows.UI.Composition.IAnimationObject;
      animation : WinRt.Windows.UI.Composition.ICompositionAnimationBase
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionObject");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionObjectStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionObjectStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.StartAnimationGroupWithIAnimationObject (target, animation);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionObject

   function get_Compositor
   (
      this : in out CompositionObject
   )
   return WinRt.Windows.UI.Composition.Compositor'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositor;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Compositor do
         Hr := this.m_ICompositionObject.all.get_Compositor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositor := new WinRt.Windows.UI.Composition.ICompositor;
         Retval.m_ICompositor.all := m_ComRetVal;
      end return;
   end;

   function get_Dispatcher
   (
      this : in out CompositionObject
   )
   return WinRt.Windows.UI.Core.CoreDispatcher'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Core.ICoreDispatcher;
   begin
      return RetVal : WinRt.Windows.UI.Core.CoreDispatcher do
         Hr := this.m_ICompositionObject.all.get_Dispatcher (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreDispatcher := new WinRt.Windows.UI.Core.ICoreDispatcher;
         Retval.m_ICoreDispatcher.all := m_ComRetVal;
      end return;
   end;

   function get_Properties
   (
      this : in out CompositionObject
   )
   return WinRt.Windows.UI.Composition.CompositionPropertySet'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionPropertySet;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionPropertySet do
         Hr := this.m_ICompositionObject.all.get_Properties (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionPropertySet := new WinRt.Windows.UI.Composition.ICompositionPropertySet;
         Retval.m_ICompositionPropertySet.all := m_ComRetVal;
      end return;
   end;

   procedure StartAnimation
   (
      this : in out CompositionObject;
      propertyName : WinRt.WString;
      animation : WinRt.Windows.UI.Composition.CompositionAnimation'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionObject.all.StartAnimation (HStr_propertyName, animation.m_ICompositionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure StopAnimation
   (
      this : in out CompositionObject;
      propertyName : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionObject.all.StopAnimation (HStr_propertyName);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   function get_Comment
   (
      this : in out CompositionObject
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject2, WinRt.Windows.UI.Composition.IID_ICompositionObject2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.get_Comment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Comment
   (
      this : in out CompositionObject;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject2 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject2, WinRt.Windows.UI.Composition.IID_ICompositionObject2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.put_Comment (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ImplicitAnimations
   (
      this : in out CompositionObject
   )
   return WinRt.Windows.UI.Composition.ImplicitAnimationCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IImplicitAnimationCollection;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject2, WinRt.Windows.UI.Composition.IID_ICompositionObject2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.ImplicitAnimationCollection do
         m_Interface := QInterface (this.m_ICompositionObject.all);
         Hr := m_Interface.get_ImplicitAnimations (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImplicitAnimationCollection := new WinRt.Windows.UI.Composition.IImplicitAnimationCollection;
         Retval.m_IImplicitAnimationCollection.all := m_ComRetVal;
      end return;
   end;

   procedure put_ImplicitAnimations
   (
      this : in out CompositionObject;
      value : WinRt.Windows.UI.Composition.ImplicitAnimationCollection'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject2, WinRt.Windows.UI.Composition.IID_ICompositionObject2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.put_ImplicitAnimations (value.m_IImplicitAnimationCollection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartAnimationGroup
   (
      this : in out CompositionObject;
      value : WinRt.Windows.UI.Composition.ICompositionAnimationBase
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject2, WinRt.Windows.UI.Composition.IID_ICompositionObject2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.StartAnimationGroup (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StopAnimationGroup
   (
      this : in out CompositionObject;
      value : WinRt.Windows.UI.Composition.ICompositionAnimationBase
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject2, WinRt.Windows.UI.Composition.IID_ICompositionObject2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.StopAnimationGroup (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DispatcherQueue
   (
      this : in out CompositionObject
   )
   return WinRt.Windows.System.DispatcherQueue'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IDispatcherQueue;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject3, WinRt.Windows.UI.Composition.IID_ICompositionObject3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.DispatcherQueue do
         m_Interface := QInterface (this.m_ICompositionObject.all);
         Hr := m_Interface.get_DispatcherQueue (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinRt.Windows.System.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   function TryGetAnimationController
   (
      this : in out CompositionObject;
      propertyName : WinRt.WString
   )
   return WinRt.Windows.UI.Composition.AnimationController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IAnimationController;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject4, WinRt.Windows.UI.Composition.IID_ICompositionObject4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.AnimationController do
         m_Interface := QInterface (this.m_ICompositionObject.all);
         Hr := m_Interface.TryGetAnimationController (HStr_propertyName, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAnimationController := new WinRt.Windows.UI.Composition.IAnimationController;
         Retval.m_IAnimationController.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_propertyName);
      end return;
   end;

   procedure StartAnimation
   (
      this : in out CompositionObject;
      propertyName : WinRt.WString;
      animation : WinRt.Windows.UI.Composition.CompositionAnimation'Class;
      animationController_p : WinRt.Windows.UI.Composition.AnimationController'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionObject5 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.ICompositionObject5, WinRt.Windows.UI.Composition.IID_ICompositionObject5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.StartAnimation (HStr_propertyName, animation.m_ICompositionAnimation.all, animationController_p.m_IAnimationController.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure Close
   (
      this : in out CompositionObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PopulatePropertyInfo
   (
      this : in out CompositionObject;
      propertyName : WinRt.WString;
      propertyInfo : WinRt.Windows.UI.Composition.AnimationPropertyInfo'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IAnimationObject := null;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionObject_Interface, WinRt.Windows.UI.Composition.IAnimationObject, WinRt.Windows.UI.Composition.IID_IAnimationObject'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionObject.all);
      Hr := m_Interface.PopulatePropertyInfo (HStr_propertyName, propertyInfo.m_IAnimationPropertyInfo.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionLight

   procedure Initialize (this : in out CompositionLight) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionLight) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionLight, ICompositionLight_Ptr);
   begin
      if this.m_ICompositionLight /= null then
         if this.m_ICompositionLight.all /= null then
            temp := this.m_ICompositionLight.all.Release;
            Free (this.m_ICompositionLight);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionLight

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionLight

   function get_Targets
   (
      this : in out CompositionLight
   )
   return WinRt.Windows.UI.Composition.VisualUnorderedCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisualUnorderedCollection;
   begin
      return RetVal : WinRt.Windows.UI.Composition.VisualUnorderedCollection do
         Hr := this.m_ICompositionLight.all.get_Targets (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisualUnorderedCollection := new WinRt.Windows.UI.Composition.IVisualUnorderedCollection;
         Retval.m_IVisualUnorderedCollection.all := m_ComRetVal;
      end return;
   end;

   function get_ExclusionsFromTargets
   (
      this : in out CompositionLight
   )
   return WinRt.Windows.UI.Composition.VisualUnorderedCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionLight2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisualUnorderedCollection;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionLight_Interface, WinRt.Windows.UI.Composition.ICompositionLight2, WinRt.Windows.UI.Composition.IID_ICompositionLight2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.VisualUnorderedCollection do
         m_Interface := QInterface (this.m_ICompositionLight.all);
         Hr := m_Interface.get_ExclusionsFromTargets (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisualUnorderedCollection := new WinRt.Windows.UI.Composition.IVisualUnorderedCollection;
         Retval.m_IVisualUnorderedCollection.all := m_ComRetVal;
      end return;
   end;

   function get_IsEnabled
   (
      this : in out CompositionLight
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionLight3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionLight_Interface, WinRt.Windows.UI.Composition.ICompositionLight3, WinRt.Windows.UI.Composition.IID_ICompositionLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionLight.all);
      Hr := m_Interface.get_IsEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsEnabled
   (
      this : in out CompositionLight;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionLight3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionLight_Interface, WinRt.Windows.UI.Composition.ICompositionLight3, WinRt.Windows.UI.Composition.IID_ICompositionLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionLight.all);
      Hr := m_Interface.put_IsEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AmbientLight

   procedure Initialize (this : in out AmbientLight) is
   begin
      null;
   end;

   procedure Finalize (this : in out AmbientLight) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAmbientLight, IAmbientLight_Ptr);
   begin
      if this.m_IAmbientLight /= null then
         if this.m_IAmbientLight.all /= null then
            temp := this.m_IAmbientLight.all.Release;
            Free (this.m_IAmbientLight);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AmbientLight

   function get_Color
   (
      this : in out AmbientLight
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_IAmbientLight.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out AmbientLight;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAmbientLight.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Intensity
   (
      this : in out AmbientLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IAmbientLight2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IAmbientLight_Interface, WinRt.Windows.UI.Composition.IAmbientLight2, WinRt.Windows.UI.Composition.IID_IAmbientLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAmbientLight.all);
      Hr := m_Interface.get_Intensity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Intensity
   (
      this : in out AmbientLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IAmbientLight2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IAmbientLight_Interface, WinRt.Windows.UI.Composition.IAmbientLight2, WinRt.Windows.UI.Composition.IID_IAmbientLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAmbientLight.all);
      Hr := m_Interface.put_Intensity (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnimationController

   procedure Initialize (this : in out AnimationController) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnimationController) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnimationController, IAnimationController_Ptr);
   begin
      if this.m_IAnimationController /= null then
         if this.m_IAnimationController.all /= null then
            temp := this.m_IAnimationController.all.Release;
            Free (this.m_IAnimationController);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AnimationController

   function get_MaxPlaybackRate
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.AnimationController");
      m_Factory        : access WinRt.Windows.UI.Composition.IAnimationControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAnimationControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_MaxPlaybackRate (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_MinPlaybackRate
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.AnimationController");
      m_Factory        : access WinRt.Windows.UI.Composition.IAnimationControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAnimationControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_MinPlaybackRate (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnimationController

   function get_PlaybackRate
   (
      this : in out AnimationController
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IAnimationController.all.get_PlaybackRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PlaybackRate
   (
      this : in out AnimationController;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAnimationController.all.put_PlaybackRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Progress
   (
      this : in out AnimationController
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IAnimationController.all.get_Progress (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Progress
   (
      this : in out AnimationController;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAnimationController.all.put_Progress (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProgressBehavior
   (
      this : in out AnimationController
   )
   return WinRt.Windows.UI.Composition.AnimationControllerProgressBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationControllerProgressBehavior;
   begin
      Hr := this.m_IAnimationController.all.get_ProgressBehavior (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ProgressBehavior
   (
      this : in out AnimationController;
      value : WinRt.Windows.UI.Composition.AnimationControllerProgressBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAnimationController.all.put_ProgressBehavior (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Pause
   (
      this : in out AnimationController
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAnimationController.all.Pause;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Resume
   (
      this : in out AnimationController
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAnimationController.all.Resume;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnimationPropertyInfo

   procedure Initialize (this : in out AnimationPropertyInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnimationPropertyInfo) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnimationPropertyInfo, IAnimationPropertyInfo_Ptr);
   begin
      if this.m_IAnimationPropertyInfo /= null then
         if this.m_IAnimationPropertyInfo.all /= null then
            temp := this.m_IAnimationPropertyInfo.all.Release;
            Free (this.m_IAnimationPropertyInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnimationPropertyInfo

   function get_AccessMode
   (
      this : in out AnimationPropertyInfo
   )
   return WinRt.Windows.UI.Composition.AnimationPropertyAccessMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationPropertyAccessMode;
   begin
      Hr := this.m_IAnimationPropertyInfo.all.get_AccessMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AccessMode
   (
      this : in out AnimationPropertyInfo;
      value : WinRt.Windows.UI.Composition.AnimationPropertyAccessMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAnimationPropertyInfo.all.put_AccessMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetResolvedCompositionObject
   (
      this : in out AnimationPropertyInfo
   )
   return WinRt.Windows.UI.Composition.CompositionObject'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IAnimationPropertyInfo2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionObject;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IAnimationPropertyInfo_Interface, WinRt.Windows.UI.Composition.IAnimationPropertyInfo2, WinRt.Windows.UI.Composition.IID_IAnimationPropertyInfo2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionObject do
         m_Interface := QInterface (this.m_IAnimationPropertyInfo.all);
         Hr := m_Interface.GetResolvedCompositionObject (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionObject := new WinRt.Windows.UI.Composition.ICompositionObject;
         Retval.m_ICompositionObject.all := m_ComRetVal;
      end return;
   end;

   function GetResolvedCompositionObjectProperty
   (
      this : in out AnimationPropertyInfo
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IAnimationPropertyInfo2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IAnimationPropertyInfo_Interface, WinRt.Windows.UI.Composition.IAnimationPropertyInfo2, WinRt.Windows.UI.Composition.IID_IAnimationPropertyInfo2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAnimationPropertyInfo.all);
      Hr := m_Interface.GetResolvedCompositionObjectProperty (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionEasingFunction

   procedure Initialize (this : in out CompositionEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionEasingFunction, ICompositionEasingFunction_Ptr);
   begin
      if this.m_ICompositionEasingFunction /= null then
         if this.m_ICompositionEasingFunction.all /= null then
            temp := this.m_ICompositionEasingFunction.all.Release;
            Free (this.m_ICompositionEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionEasingFunction

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompositionEasingFunction

   function CreateCubicBezierEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      controlPoint1 : WinRt.Windows.Foundation.Numerics.Vector2;
      controlPoint2 : WinRt.Windows.Foundation.Numerics.Vector2
   )
   return WinRt.Windows.UI.Composition.CubicBezierEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICubicBezierEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CubicBezierEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateCubicBezierEasingFunction (owner.m_ICompositor.all, controlPoint1, controlPoint2, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICubicBezierEasingFunction := new WinRt.Windows.UI.Composition.ICubicBezierEasingFunction;
            Retval.m_ICubicBezierEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateLinearEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.LinearEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ILinearEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.LinearEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateLinearEasingFunction (owner.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ILinearEasingFunction := new WinRt.Windows.UI.Composition.ILinearEasingFunction;
            Retval.m_ILinearEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateStepEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.StepEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IStepEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.StepEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateStepEasingFunction (owner.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IStepEasingFunction := new WinRt.Windows.UI.Composition.IStepEasingFunction;
            Retval.m_IStepEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateStepEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      stepCount : WinRt.Int32
   )
   return WinRt.Windows.UI.Composition.StepEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IStepEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.StepEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateStepEasingFunction (owner.m_ICompositor.all, stepCount, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IStepEasingFunction := new WinRt.Windows.UI.Composition.IStepEasingFunction;
            Retval.m_IStepEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateBackEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      mode : WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
      amplitude : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.BackEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IBackEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.BackEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateBackEasingFunction (owner.m_ICompositor.all, mode, amplitude, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IBackEasingFunction := new WinRt.Windows.UI.Composition.IBackEasingFunction;
            Retval.m_IBackEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateBounceEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      mode : WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
      bounces : WinRt.Int32;
      bounciness : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.BounceEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IBounceEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.BounceEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateBounceEasingFunction (owner.m_ICompositor.all, mode, bounces, bounciness, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IBounceEasingFunction := new WinRt.Windows.UI.Composition.IBounceEasingFunction;
            Retval.m_IBounceEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateCircleEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      mode : WinRt.Windows.UI.Composition.CompositionEasingFunctionMode
   )
   return WinRt.Windows.UI.Composition.CircleEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICircleEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CircleEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateCircleEasingFunction (owner.m_ICompositor.all, mode, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICircleEasingFunction := new WinRt.Windows.UI.Composition.ICircleEasingFunction;
            Retval.m_ICircleEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateElasticEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      mode : WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
      oscillations : WinRt.Int32;
      springiness : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.ElasticEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IElasticEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.ElasticEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateElasticEasingFunction (owner.m_ICompositor.all, mode, oscillations, springiness, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IElasticEasingFunction := new WinRt.Windows.UI.Composition.IElasticEasingFunction;
            Retval.m_IElasticEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateExponentialEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      mode : WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
      exponent : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.ExponentialEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IExponentialEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.ExponentialEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateExponentialEasingFunction (owner.m_ICompositor.all, mode, exponent, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IExponentialEasingFunction := new WinRt.Windows.UI.Composition.IExponentialEasingFunction;
            Retval.m_IExponentialEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreatePowerEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      mode : WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
      power : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.PowerEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IPowerEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.PowerEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreatePowerEasingFunction (owner.m_ICompositor.all, mode, power, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPowerEasingFunction := new WinRt.Windows.UI.Composition.IPowerEasingFunction;
            Retval.m_IPowerEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateSineEasingFunction
   (
      owner : WinRt.Windows.UI.Composition.Compositor'Class;
      mode : WinRt.Windows.UI.Composition.CompositionEasingFunctionMode
   )
   return WinRt.Windows.UI.Composition.SineEasingFunction is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionEasingFunction");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionEasingFunctionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ISineEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.SineEasingFunction do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEasingFunctionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateSineEasingFunction (owner.m_ICompositor.all, mode, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISineEasingFunction := new WinRt.Windows.UI.Composition.ISineEasingFunction;
            Retval.m_ISineEasingFunction.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionEasingFunction

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BackEasingFunction

   procedure Initialize (this : in out BackEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out BackEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBackEasingFunction, IBackEasingFunction_Ptr);
   begin
      if this.m_IBackEasingFunction /= null then
         if this.m_IBackEasingFunction.all /= null then
            temp := this.m_IBackEasingFunction.all.Release;
            Free (this.m_IBackEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BackEasingFunction

   function get_Mode
   (
      this : in out BackEasingFunction
   )
   return WinRt.Windows.UI.Composition.CompositionEasingFunctionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
   begin
      Hr := this.m_IBackEasingFunction.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Amplitude
   (
      this : in out BackEasingFunction
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBackEasingFunction.all.get_Amplitude (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionAnimation

   procedure Initialize (this : in out CompositionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionAnimation, ICompositionAnimation_Ptr);
   begin
      if this.m_ICompositionAnimation /= null then
         if this.m_ICompositionAnimation.all /= null then
            temp := this.m_ICompositionAnimation.all.Release;
            Free (this.m_ICompositionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionAnimation

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionAnimation

   procedure ClearAllParameters
   (
      this : in out CompositionAnimation
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionAnimation.all.ClearAllParameters;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ClearParameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.ClearParameter (HStr_key);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetColorParameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetColorParameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetMatrix3x2Parameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetMatrix3x2Parameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetMatrix4x4Parameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Matrix4x4
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetMatrix4x4Parameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetQuaternionParameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Quaternion
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetQuaternionParameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetReferenceParameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      compositionObject_p : WinRt.Windows.UI.Composition.CompositionObject'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetReferenceParameter (HStr_key, compositionObject_p.m_ICompositionObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetScalarParameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetScalarParameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetVector2Parameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetVector2Parameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetVector3Parameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetVector3Parameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetVector4Parameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector4
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := this.m_ICompositionAnimation.all.SetVector4Parameter (HStr_key, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure SetBooleanParameter
   (
      this : in out CompositionAnimation;
      key : WinRt.WString;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionAnimation2 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionAnimation_Interface, WinRt.Windows.UI.Composition.ICompositionAnimation2, WinRt.Windows.UI.Composition.IID_ICompositionAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionAnimation.all);
      Hr := m_Interface.SetBooleanParameter (HStr_key, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   function get_Target
   (
      this : in out CompositionAnimation
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionAnimation2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionAnimation_Interface, WinRt.Windows.UI.Composition.ICompositionAnimation2, WinRt.Windows.UI.Composition.IID_ICompositionAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionAnimation.all);
      Hr := m_Interface.get_Target (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Target
   (
      this : in out CompositionAnimation;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionAnimation2 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionAnimation_Interface, WinRt.Windows.UI.Composition.ICompositionAnimation2, WinRt.Windows.UI.Composition.IID_ICompositionAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionAnimation.all);
      Hr := m_Interface.put_Target (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_InitialValueExpressions
   (
      this : in out CompositionAnimation
   )
   return WinRt.Windows.UI.Composition.InitialValueExpressionCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionAnimation3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionAnimation_Interface, WinRt.Windows.UI.Composition.ICompositionAnimation3, WinRt.Windows.UI.Composition.IID_ICompositionAnimation3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.InitialValueExpressionCollection do
         m_Interface := QInterface (this.m_ICompositionAnimation.all);
         Hr := m_Interface.get_InitialValueExpressions (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinRt.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure SetExpressionReferenceParameter
   (
      this : in out CompositionAnimation;
      parameterName : WinRt.WString;
      source : WinRt.Windows.UI.Composition.IAnimationObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionAnimation4 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_parameterName : constant WinRt.HString := To_HString (parameterName);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionAnimation_Interface, WinRt.Windows.UI.Composition.ICompositionAnimation4, WinRt.Windows.UI.Composition.IID_ICompositionAnimation4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionAnimation.all);
      Hr := m_Interface.SetExpressionReferenceParameter (HStr_parameterName, source);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_parameterName);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyFrameAnimation

   procedure Initialize (this : in out KeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyFrameAnimation, IKeyFrameAnimation_Ptr);
   begin
      if this.m_IKeyFrameAnimation /= null then
         if this.m_IKeyFrameAnimation.all /= null then
            temp := this.m_IKeyFrameAnimation.all.Release;
            Free (this.m_IKeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for KeyFrameAnimation

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyFrameAnimation

   function get_DelayTime
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IKeyFrameAnimation.all.get_DelayTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DelayTime
   (
      this : in out KeyFrameAnimation;
      value : WinRt.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyFrameAnimation.all.put_DelayTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Duration
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IKeyFrameAnimation.all.get_Duration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out KeyFrameAnimation;
      value : WinRt.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyFrameAnimation.all.put_Duration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IterationBehavior
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Windows.UI.Composition.AnimationIterationBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationIterationBehavior;
   begin
      Hr := this.m_IKeyFrameAnimation.all.get_IterationBehavior (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IterationBehavior
   (
      this : in out KeyFrameAnimation;
      value : WinRt.Windows.UI.Composition.AnimationIterationBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyFrameAnimation.all.put_IterationBehavior (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IterationCount
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IKeyFrameAnimation.all.get_IterationCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IterationCount
   (
      this : in out KeyFrameAnimation;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyFrameAnimation.all.put_IterationCount (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyFrameCount
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IKeyFrameAnimation.all.get_KeyFrameCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_StopBehavior
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Windows.UI.Composition.AnimationStopBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationStopBehavior;
   begin
      Hr := this.m_IKeyFrameAnimation.all.get_StopBehavior (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StopBehavior
   (
      this : in out KeyFrameAnimation;
      value : WinRt.Windows.UI.Composition.AnimationStopBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyFrameAnimation.all.put_StopBehavior (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertExpressionKeyFrame
   (
      this : in out KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IKeyFrameAnimation.all.InsertExpressionKeyFrame (normalizedProgressKey, HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   procedure InsertExpressionKeyFrame
   (
      this : in out KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.WString;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IKeyFrameAnimation.all.InsertExpressionKeyFrame (normalizedProgressKey, HStr_value, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Direction
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Windows.UI.Composition.AnimationDirection is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IKeyFrameAnimation2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationDirection;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IKeyFrameAnimation_Interface, WinRt.Windows.UI.Composition.IKeyFrameAnimation2, WinRt.Windows.UI.Composition.IID_IKeyFrameAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyFrameAnimation.all);
      Hr := m_Interface.get_Direction (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Direction
   (
      this : in out KeyFrameAnimation;
      value : WinRt.Windows.UI.Composition.AnimationDirection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IKeyFrameAnimation2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IKeyFrameAnimation_Interface, WinRt.Windows.UI.Composition.IKeyFrameAnimation2, WinRt.Windows.UI.Composition.IID_IKeyFrameAnimation2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyFrameAnimation.all);
      Hr := m_Interface.put_Direction (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DelayBehavior
   (
      this : in out KeyFrameAnimation
   )
   return WinRt.Windows.UI.Composition.AnimationDelayBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IKeyFrameAnimation3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationDelayBehavior;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IKeyFrameAnimation_Interface, WinRt.Windows.UI.Composition.IKeyFrameAnimation3, WinRt.Windows.UI.Composition.IID_IKeyFrameAnimation3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyFrameAnimation.all);
      Hr := m_Interface.get_DelayBehavior (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DelayBehavior
   (
      this : in out KeyFrameAnimation;
      value : WinRt.Windows.UI.Composition.AnimationDelayBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IKeyFrameAnimation3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IKeyFrameAnimation_Interface, WinRt.Windows.UI.Composition.IKeyFrameAnimation3, WinRt.Windows.UI.Composition.IID_IKeyFrameAnimation3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IKeyFrameAnimation.all);
      Hr := m_Interface.put_DelayBehavior (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BooleanKeyFrameAnimation

   procedure Initialize (this : in out BooleanKeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out BooleanKeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBooleanKeyFrameAnimation, IBooleanKeyFrameAnimation_Ptr);
   begin
      if this.m_IBooleanKeyFrameAnimation /= null then
         if this.m_IBooleanKeyFrameAnimation.all /= null then
            temp := this.m_IBooleanKeyFrameAnimation.all.Release;
            Free (this.m_IBooleanKeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BooleanKeyFrameAnimation

   procedure InsertKeyFrame
   (
      this : in out BooleanKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBooleanKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BounceEasingFunction

   procedure Initialize (this : in out BounceEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out BounceEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBounceEasingFunction, IBounceEasingFunction_Ptr);
   begin
      if this.m_IBounceEasingFunction /= null then
         if this.m_IBounceEasingFunction.all /= null then
            temp := this.m_IBounceEasingFunction.all.Release;
            Free (this.m_IBounceEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BounceEasingFunction

   function get_Mode
   (
      this : in out BounceEasingFunction
   )
   return WinRt.Windows.UI.Composition.CompositionEasingFunctionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
   begin
      Hr := this.m_IBounceEasingFunction.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Bounces
   (
      this : in out BounceEasingFunction
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IBounceEasingFunction.all.get_Bounces (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Bounciness
   (
      this : in out BounceEasingFunction
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBounceEasingFunction.all.get_Bounciness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NaturalMotionAnimation

   procedure Initialize (this : in out NaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out NaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INaturalMotionAnimation, INaturalMotionAnimation_Ptr);
   begin
      if this.m_INaturalMotionAnimation /= null then
         if this.m_INaturalMotionAnimation.all /= null then
            temp := this.m_INaturalMotionAnimation.all.Release;
            Free (this.m_INaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NaturalMotionAnimation

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NaturalMotionAnimation

   function get_DelayBehavior
   (
      this : in out NaturalMotionAnimation
   )
   return WinRt.Windows.UI.Composition.AnimationDelayBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationDelayBehavior;
   begin
      Hr := this.m_INaturalMotionAnimation.all.get_DelayBehavior (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DelayBehavior
   (
      this : in out NaturalMotionAnimation;
      value : WinRt.Windows.UI.Composition.AnimationDelayBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_INaturalMotionAnimation.all.put_DelayBehavior (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DelayTime
   (
      this : in out NaturalMotionAnimation
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_INaturalMotionAnimation.all.get_DelayTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DelayTime
   (
      this : in out NaturalMotionAnimation;
      value : WinRt.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_INaturalMotionAnimation.all.put_DelayTime (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StopBehavior
   (
      this : in out NaturalMotionAnimation
   )
   return WinRt.Windows.UI.Composition.AnimationStopBehavior is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.AnimationStopBehavior;
   begin
      Hr := this.m_INaturalMotionAnimation.all.get_StopBehavior (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StopBehavior
   (
      this : in out NaturalMotionAnimation;
      value : WinRt.Windows.UI.Composition.AnimationStopBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_INaturalMotionAnimation.all.put_StopBehavior (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScalarNaturalMotionAnimation

   procedure Initialize (this : in out ScalarNaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScalarNaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScalarNaturalMotionAnimation, IScalarNaturalMotionAnimation_Ptr);
   begin
      if this.m_IScalarNaturalMotionAnimation /= null then
         if this.m_IScalarNaturalMotionAnimation.all /= null then
            temp := this.m_IScalarNaturalMotionAnimation.all.Release;
            Free (this.m_IScalarNaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScalarNaturalMotionAnimation

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScalarNaturalMotionAnimation

   function get_FinalValue
   (
      this : in out ScalarNaturalMotionAnimation
   )
   return IReference_Single.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IReference_Single.Kind;
   begin
      Hr := this.m_IScalarNaturalMotionAnimation.all.get_FinalValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_FinalValue
   (
      this : in out ScalarNaturalMotionAnimation;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScalarNaturalMotionAnimation.all.put_FinalValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InitialValue
   (
      this : in out ScalarNaturalMotionAnimation
   )
   return IReference_Single.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IReference_Single.Kind;
   begin
      Hr := this.m_IScalarNaturalMotionAnimation.all.get_InitialValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_InitialValue
   (
      this : in out ScalarNaturalMotionAnimation;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScalarNaturalMotionAnimation.all.put_InitialValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InitialVelocity
   (
      this : in out ScalarNaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IScalarNaturalMotionAnimation.all.get_InitialVelocity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialVelocity
   (
      this : in out ScalarNaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScalarNaturalMotionAnimation.all.put_InitialVelocity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BounceScalarNaturalMotionAnimation

   procedure Initialize (this : in out BounceScalarNaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out BounceScalarNaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBounceScalarNaturalMotionAnimation, IBounceScalarNaturalMotionAnimation_Ptr);
   begin
      if this.m_IBounceScalarNaturalMotionAnimation /= null then
         if this.m_IBounceScalarNaturalMotionAnimation.all /= null then
            temp := this.m_IBounceScalarNaturalMotionAnimation.all.Release;
            Free (this.m_IBounceScalarNaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BounceScalarNaturalMotionAnimation

   function get_Acceleration
   (
      this : in out BounceScalarNaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBounceScalarNaturalMotionAnimation.all.get_Acceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Acceleration
   (
      this : in out BounceScalarNaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBounceScalarNaturalMotionAnimation.all.put_Acceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Restitution
   (
      this : in out BounceScalarNaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBounceScalarNaturalMotionAnimation.all.get_Restitution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Restitution
   (
      this : in out BounceScalarNaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBounceScalarNaturalMotionAnimation.all.put_Restitution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Vector2NaturalMotionAnimation

   procedure Initialize (this : in out Vector2NaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out Vector2NaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVector2NaturalMotionAnimation, IVector2NaturalMotionAnimation_Ptr);
   begin
      if this.m_IVector2NaturalMotionAnimation /= null then
         if this.m_IVector2NaturalMotionAnimation.all /= null then
            temp := this.m_IVector2NaturalMotionAnimation.all.Release;
            Free (this.m_IVector2NaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Vector2NaturalMotionAnimation

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Vector2NaturalMotionAnimation

   function get_FinalValue
   (
      this : in out Vector2NaturalMotionAnimation
   )
   return IReference_Vector2.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IReference_Vector2.Kind;
   begin
      Hr := this.m_IVector2NaturalMotionAnimation.all.get_FinalValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Vector2 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_FinalValue
   (
      this : in out Vector2NaturalMotionAnimation;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector2NaturalMotionAnimation.all.put_FinalValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InitialValue
   (
      this : in out Vector2NaturalMotionAnimation
   )
   return IReference_Vector2.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IReference_Vector2.Kind;
   begin
      Hr := this.m_IVector2NaturalMotionAnimation.all.get_InitialValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Vector2 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_InitialValue
   (
      this : in out Vector2NaturalMotionAnimation;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector2NaturalMotionAnimation.all.put_InitialValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InitialVelocity
   (
      this : in out Vector2NaturalMotionAnimation
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IVector2NaturalMotionAnimation.all.get_InitialVelocity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialVelocity
   (
      this : in out Vector2NaturalMotionAnimation;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector2NaturalMotionAnimation.all.put_InitialVelocity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BounceVector2NaturalMotionAnimation

   procedure Initialize (this : in out BounceVector2NaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out BounceVector2NaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBounceVector2NaturalMotionAnimation, IBounceVector2NaturalMotionAnimation_Ptr);
   begin
      if this.m_IBounceVector2NaturalMotionAnimation /= null then
         if this.m_IBounceVector2NaturalMotionAnimation.all /= null then
            temp := this.m_IBounceVector2NaturalMotionAnimation.all.Release;
            Free (this.m_IBounceVector2NaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BounceVector2NaturalMotionAnimation

   function get_Acceleration
   (
      this : in out BounceVector2NaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBounceVector2NaturalMotionAnimation.all.get_Acceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Acceleration
   (
      this : in out BounceVector2NaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBounceVector2NaturalMotionAnimation.all.put_Acceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Restitution
   (
      this : in out BounceVector2NaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBounceVector2NaturalMotionAnimation.all.get_Restitution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Restitution
   (
      this : in out BounceVector2NaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBounceVector2NaturalMotionAnimation.all.put_Restitution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Vector3NaturalMotionAnimation

   procedure Initialize (this : in out Vector3NaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out Vector3NaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVector3NaturalMotionAnimation, IVector3NaturalMotionAnimation_Ptr);
   begin
      if this.m_IVector3NaturalMotionAnimation /= null then
         if this.m_IVector3NaturalMotionAnimation.all /= null then
            temp := this.m_IVector3NaturalMotionAnimation.all.Release;
            Free (this.m_IVector3NaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Vector3NaturalMotionAnimation

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Vector3NaturalMotionAnimation

   function get_FinalValue
   (
      this : in out Vector3NaturalMotionAnimation
   )
   return IReference_Vector3.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IReference_Vector3.Kind;
   begin
      Hr := this.m_IVector3NaturalMotionAnimation.all.get_FinalValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Vector3 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_FinalValue
   (
      this : in out Vector3NaturalMotionAnimation;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector3NaturalMotionAnimation.all.put_FinalValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InitialValue
   (
      this : in out Vector3NaturalMotionAnimation
   )
   return IReference_Vector3.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericRetval  : aliased IReference_Vector3.Kind;
   begin
      Hr := this.m_IVector3NaturalMotionAnimation.all.get_InitialValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Vector3 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_InitialValue
   (
      this : in out Vector3NaturalMotionAnimation;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector3NaturalMotionAnimation.all.put_InitialValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InitialVelocity
   (
      this : in out Vector3NaturalMotionAnimation
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IVector3NaturalMotionAnimation.all.get_InitialVelocity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialVelocity
   (
      this : in out Vector3NaturalMotionAnimation;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector3NaturalMotionAnimation.all.put_InitialVelocity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BounceVector3NaturalMotionAnimation

   procedure Initialize (this : in out BounceVector3NaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out BounceVector3NaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBounceVector3NaturalMotionAnimation, IBounceVector3NaturalMotionAnimation_Ptr);
   begin
      if this.m_IBounceVector3NaturalMotionAnimation /= null then
         if this.m_IBounceVector3NaturalMotionAnimation.all /= null then
            temp := this.m_IBounceVector3NaturalMotionAnimation.all.Release;
            Free (this.m_IBounceVector3NaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BounceVector3NaturalMotionAnimation

   function get_Acceleration
   (
      this : in out BounceVector3NaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBounceVector3NaturalMotionAnimation.all.get_Acceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Acceleration
   (
      this : in out BounceVector3NaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBounceVector3NaturalMotionAnimation.all.put_Acceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Restitution
   (
      this : in out BounceVector3NaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IBounceVector3NaturalMotionAnimation.all.get_Restitution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Restitution
   (
      this : in out BounceVector3NaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IBounceVector3NaturalMotionAnimation.all.put_Restitution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CircleEasingFunction

   procedure Initialize (this : in out CircleEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out CircleEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICircleEasingFunction, ICircleEasingFunction_Ptr);
   begin
      if this.m_ICircleEasingFunction /= null then
         if this.m_ICircleEasingFunction.all /= null then
            temp := this.m_ICircleEasingFunction.all.Release;
            Free (this.m_ICircleEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CircleEasingFunction

   function get_Mode
   (
      this : in out CircleEasingFunction
   )
   return WinRt.Windows.UI.Composition.CompositionEasingFunctionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
   begin
      Hr := this.m_ICircleEasingFunction.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorKeyFrameAnimation

   procedure Initialize (this : in out ColorKeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorKeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorKeyFrameAnimation, IColorKeyFrameAnimation_Ptr);
   begin
      if this.m_IColorKeyFrameAnimation /= null then
         if this.m_IColorKeyFrameAnimation.all /= null then
            temp := this.m_IColorKeyFrameAnimation.all.Release;
            Free (this.m_IColorKeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorKeyFrameAnimation

   function get_InterpolationColorSpace
   (
      this : in out ColorKeyFrameAnimation
   )
   return WinRt.Windows.UI.Composition.CompositionColorSpace is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionColorSpace;
   begin
      Hr := this.m_IColorKeyFrameAnimation.all.get_InterpolationColorSpace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InterpolationColorSpace
   (
      this : in out ColorKeyFrameAnimation;
      value : WinRt.Windows.UI.Composition.CompositionColorSpace
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IColorKeyFrameAnimation.all.put_InterpolationColorSpace (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out ColorKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IColorKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out ColorKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.UI.Color;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IColorKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionAnimationGroup

   procedure Initialize (this : in out CompositionAnimationGroup) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionAnimationGroup) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionAnimationGroup, ICompositionAnimationGroup_Ptr);
   begin
      if this.m_ICompositionAnimationGroup /= null then
         if this.m_ICompositionAnimationGroup.all /= null then
            temp := this.m_ICompositionAnimationGroup.all.Release;
            Free (this.m_ICompositionAnimationGroup);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionAnimationGroup

   function get_Count
   (
      this : in out CompositionAnimationGroup
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_ICompositionAnimationGroup.all.get_Count (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Add
   (
      this : in out CompositionAnimationGroup;
      value : WinRt.Windows.UI.Composition.CompositionAnimation'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionAnimationGroup.all.Add (value.m_ICompositionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Remove
   (
      this : in out CompositionAnimationGroup;
      value : WinRt.Windows.UI.Composition.CompositionAnimation'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionAnimationGroup.all.Remove (value.m_ICompositionAnimation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out CompositionAnimationGroup
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionAnimationGroup.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionAnimation>
   function First
   (
      this : in out CompositionAnimationGroup
   )
   return WinRt.Windows.UI.Composition.CompositionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ICompositionAnimation.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionAnimation;
      m_GenericIID     : aliased WinRt.IID := (213227842, 50931, 22623, (154, 146, 180, 126, 141, 211, 142, 191 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionAnimationGroup_Interface, IIterable_ICompositionAnimation.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionAnimation do
         m_Interface := QInterface (this.m_ICompositionAnimationGroup.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionAnimation := new WinRt.Windows.UI.Composition.ICompositionAnimation;
         Retval.m_ICompositionAnimation.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionBrush

   procedure Initialize (this : in out CompositionBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionBrush, ICompositionBrush_Ptr);
   begin
      if this.m_ICompositionBrush /= null then
         if this.m_ICompositionBrush.all /= null then
            temp := this.m_ICompositionBrush.all.Release;
            Free (this.m_ICompositionBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionBrush

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionBrush

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionBackdropBrush

   procedure Initialize (this : in out CompositionBackdropBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionBackdropBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionBackdropBrush, ICompositionBackdropBrush_Ptr);
   begin
      if this.m_ICompositionBackdropBrush /= null then
         if this.m_ICompositionBackdropBrush.all /= null then
            temp := this.m_ICompositionBackdropBrush.all.Release;
            Free (this.m_ICompositionBackdropBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionBackdropBrush

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionBatchCompletedEventArgs

   procedure Initialize (this : in out CompositionBatchCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionBatchCompletedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionBatchCompletedEventArgs, ICompositionBatchCompletedEventArgs_Ptr);
   begin
      if this.m_ICompositionBatchCompletedEventArgs /= null then
         if this.m_ICompositionBatchCompletedEventArgs.all /= null then
            temp := this.m_ICompositionBatchCompletedEventArgs.all.Release;
            Free (this.m_ICompositionBatchCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionBatchCompletedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionCapabilities

   procedure Initialize (this : in out CompositionCapabilities) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionCapabilities) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionCapabilities, ICompositionCapabilities_Ptr);
   begin
      if this.m_ICompositionCapabilities /= null then
         if this.m_ICompositionCapabilities.all /= null then
            temp := this.m_ICompositionCapabilities.all.Release;
            Free (this.m_ICompositionCapabilities);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompositionCapabilities

   function GetForCurrentView
   return WinRt.Windows.UI.Composition.CompositionCapabilities is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionCapabilities");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionCapabilitiesStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionCapabilities;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionCapabilities do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionCapabilitiesStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ICompositionCapabilities := new WinRt.Windows.UI.Composition.ICompositionCapabilities;
            Retval.m_ICompositionCapabilities.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionCapabilities

   function AreEffectsSupported
   (
      this : in out CompositionCapabilities
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionCapabilities.all.AreEffectsSupported (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function AreEffectsFast
   (
      this : in out CompositionCapabilities
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionCapabilities.all.AreEffectsFast (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_Changed
   (
      this : in out CompositionCapabilities;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICompositionCapabilities.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out CompositionCapabilities;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionCapabilities.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionClip

   procedure Initialize (this : in out CompositionClip) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionClip) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionClip, ICompositionClip_Ptr);
   begin
      if this.m_ICompositionClip /= null then
         if this.m_ICompositionClip.all /= null then
            temp := this.m_ICompositionClip.all.Release;
            Free (this.m_ICompositionClip);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionClip

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionClip

   function get_AnchorPoint
   (
      this : in out CompositionClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.get_AnchorPoint (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnchorPoint
   (
      this : in out CompositionClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.put_AnchorPoint (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterPoint
   (
      this : in out CompositionClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.get_CenterPoint (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterPoint
   (
      this : in out CompositionClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.put_CenterPoint (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out CompositionClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.get_Offset (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.put_Offset (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngle
   (
      this : in out CompositionClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.get_RotationAngle (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngle
   (
      this : in out CompositionClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.put_RotationAngle (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngleInDegrees
   (
      this : in out CompositionClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.get_RotationAngleInDegrees (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngleInDegrees
   (
      this : in out CompositionClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.put_RotationAngleInDegrees (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out CompositionClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.get_Scale (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out CompositionClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.put_Scale (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransformMatrix
   (
      this : in out CompositionClip
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Matrix3x2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.get_TransformMatrix (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransformMatrix
   (
      this : in out CompositionClip;
      value : WinRt.Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionClip2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionClip_Interface, WinRt.Windows.UI.Composition.ICompositionClip2, WinRt.Windows.UI.Composition.IID_ICompositionClip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionClip.all);
      Hr := m_Interface.put_TransformMatrix (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionColorBrush

   procedure Initialize (this : in out CompositionColorBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionColorBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionColorBrush, ICompositionColorBrush_Ptr);
   begin
      if this.m_ICompositionColorBrush /= null then
         if this.m_ICompositionColorBrush.all /= null then
            temp := this.m_ICompositionColorBrush.all.Release;
            Free (this.m_ICompositionColorBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionColorBrush

   function get_Color
   (
      this : in out CompositionColorBrush
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_ICompositionColorBrush.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out CompositionColorBrush;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionColorBrush.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionColorGradientStop

   procedure Initialize (this : in out CompositionColorGradientStop) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionColorGradientStop) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionColorGradientStop, ICompositionColorGradientStop_Ptr);
   begin
      if this.m_ICompositionColorGradientStop /= null then
         if this.m_ICompositionColorGradientStop.all /= null then
            temp := this.m_ICompositionColorGradientStop.all.Release;
            Free (this.m_ICompositionColorGradientStop);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionColorGradientStop

   function get_Color
   (
      this : in out CompositionColorGradientStop
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_ICompositionColorGradientStop.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out CompositionColorGradientStop;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionColorGradientStop.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out CompositionColorGradientStop
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionColorGradientStop.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionColorGradientStop;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionColorGradientStop.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionColorGradientStopCollection

   procedure Initialize (this : in out CompositionColorGradientStopCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionColorGradientStopCollection) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionColorGradientStopCollection, ICompositionColorGradientStopCollection_Ptr);
   begin
      if this.m_ICompositionColorGradientStopCollection /= null then
         if this.m_ICompositionColorGradientStopCollection.all /= null then
            temp := this.m_ICompositionColorGradientStopCollection.all.Release;
            Free (this.m_ICompositionColorGradientStopCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionColorGradientStopCollection

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionColorGradientStop>
   function First
   (
      this : in out CompositionColorGradientStopCollection
   )
   return WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
      m_GenericIID     : aliased WinRt.IID := (254606017, 52668, 23630, (167, 210, 163, 145, 79, 182, 52, 38 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IIterable_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorGradientStop do
         m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorGradientStop := new WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
         Retval.m_ICompositionColorGradientStop.all := m_ComRetVal;
      end return;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Composition.CompositionColorGradientStop>
   function GetAt
   (
      this : in out CompositionColorGradientStopCollection;
      index : WinRt.UInt32
   )
   return WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorGradientStop do
         m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorGradientStop := new WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
         Retval.m_ICompositionColorGradientStop.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out CompositionColorGradientStopCollection
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out CompositionColorGradientStopCollection
   )
   return WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorGradientStop do
         m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorGradientStop := new WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
         Retval.m_ICompositionColorGradientStop.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out CompositionColorGradientStopCollection;
      value : WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class;
      index : WinRt.UInt32_Ptr
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.IndexOf (value.m_ICompositionColorGradientStop.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out CompositionColorGradientStopCollection;
      index : WinRt.UInt32;
      value : WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.SetAt (index, value.m_ICompositionColorGradientStop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out CompositionColorGradientStopCollection;
      index : WinRt.UInt32;
      value : WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.InsertAt (index, value.m_ICompositionColorGradientStop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out CompositionColorGradientStopCollection;
      index : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out CompositionColorGradientStopCollection;
      value : WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.Append (value.m_ICompositionColorGradientStop.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out CompositionColorGradientStopCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out CompositionColorGradientStopCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out CompositionColorGradientStopCollection;
      startIndex : WinRt.UInt32;
      items : WinRt.Windows.UI.Composition.ICompositionColorGradientStop_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.GetMany (startIndex, WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out CompositionColorGradientStopCollection;
      items : WinRt.Windows.UI.Composition.ICompositionColorGradientStop_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionColorGradientStop.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (3207467134, 62427, 22221, (145, 237, 193, 18, 148, 6, 213, 82 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection_Interface, IVector_ICompositionColorGradientStop.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ICompositionColorGradientStopCollection.all);
      Hr := m_Interface.ReplaceAll (WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionCommitBatch

   procedure Initialize (this : in out CompositionCommitBatch) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionCommitBatch) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionCommitBatch, ICompositionCommitBatch_Ptr);
   begin
      if this.m_ICompositionCommitBatch /= null then
         if this.m_ICompositionCommitBatch.all /= null then
            temp := this.m_ICompositionCommitBatch.all.Release;
            Free (this.m_ICompositionCommitBatch);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionCommitBatch

   function get_IsActive
   (
      this : in out CompositionCommitBatch
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionCommitBatch.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsEnded
   (
      this : in out CompositionCommitBatch
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionCommitBatch.all.get_IsEnded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_Completed
   (
      this : in out CompositionCommitBatch;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICompositionCommitBatch.all.add_Completed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Completed
   (
      this : in out CompositionCommitBatch;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionCommitBatch.all.remove_Completed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionShape

   procedure Initialize (this : in out CompositionShape) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionShape) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionShape, ICompositionShape_Ptr);
   begin
      if this.m_ICompositionShape /= null then
         if this.m_ICompositionShape.all /= null then
            temp := this.m_ICompositionShape.all.Release;
            Free (this.m_ICompositionShape);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionShape

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionShape

   function get_CenterPoint
   (
      this : in out CompositionShape
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionShape.all.get_CenterPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterPoint
   (
      this : in out CompositionShape;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionShape.all.put_CenterPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out CompositionShape
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionShape.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionShape;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionShape.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngle
   (
      this : in out CompositionShape
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionShape.all.get_RotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngle
   (
      this : in out CompositionShape;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionShape.all.put_RotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngleInDegrees
   (
      this : in out CompositionShape
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionShape.all.get_RotationAngleInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngleInDegrees
   (
      this : in out CompositionShape;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionShape.all.put_RotationAngleInDegrees (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out CompositionShape
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionShape.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out CompositionShape;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionShape.all.put_Scale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransformMatrix
   (
      this : in out CompositionShape
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Matrix3x2;
   begin
      Hr := this.m_ICompositionShape.all.get_TransformMatrix (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransformMatrix
   (
      this : in out CompositionShape;
      value : WinRt.Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionShape.all.put_TransformMatrix (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionContainerShape

   procedure Initialize (this : in out CompositionContainerShape) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionContainerShape) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionContainerShape, ICompositionContainerShape_Ptr);
   begin
      if this.m_ICompositionContainerShape /= null then
         if this.m_ICompositionContainerShape.all /= null then
            temp := this.m_ICompositionContainerShape.all.Release;
            Free (this.m_ICompositionContainerShape);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionContainerShape

   function get_Shapes
   (
      this : in out CompositionContainerShape
   )
   return WinRt.Windows.UI.Composition.CompositionShapeCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionShapeCollection do
         Hr := this.m_ICompositionContainerShape.all.get_Shapes (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinRt.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionDrawingSurface

   procedure Initialize (this : in out CompositionDrawingSurface) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionDrawingSurface) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionDrawingSurface, ICompositionDrawingSurface_Ptr);
   begin
      if this.m_ICompositionDrawingSurface /= null then
         if this.m_ICompositionDrawingSurface.all /= null then
            temp := this.m_ICompositionDrawingSurface.all.Release;
            Free (this.m_ICompositionDrawingSurface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionDrawingSurface

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionDrawingSurface

   function get_AlphaMode
   (
      this : in out CompositionDrawingSurface
   )
   return WinRt.Windows.Graphics.DirectX.DirectXAlphaMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.DirectX.DirectXAlphaMode;
   begin
      Hr := this.m_ICompositionDrawingSurface.all.get_AlphaMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PixelFormat
   (
      this : in out CompositionDrawingSurface
   )
   return WinRt.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_ICompositionDrawingSurface.all.get_PixelFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out CompositionDrawingSurface
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Size;
   begin
      Hr := this.m_ICompositionDrawingSurface.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SizeInt32
   (
      this : in out CompositionDrawingSurface
   )
   return WinRt.Windows.Graphics.SizeInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionDrawingSurface2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.SizeInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionDrawingSurface_Interface, WinRt.Windows.UI.Composition.ICompositionDrawingSurface2, WinRt.Windows.UI.Composition.IID_ICompositionDrawingSurface2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionDrawingSurface.all);
      Hr := m_Interface.get_SizeInt32 (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Resize
   (
      this : in out CompositionDrawingSurface;
      sizePixels : WinRt.Windows.Graphics.SizeInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionDrawingSurface2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionDrawingSurface_Interface, WinRt.Windows.UI.Composition.ICompositionDrawingSurface2, WinRt.Windows.UI.Composition.IID_ICompositionDrawingSurface2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionDrawingSurface.all);
      Hr := m_Interface.Resize (sizePixels);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Scroll
   (
      this : in out CompositionDrawingSurface;
      offset : WinRt.Windows.Graphics.PointInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionDrawingSurface2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionDrawingSurface_Interface, WinRt.Windows.UI.Composition.ICompositionDrawingSurface2, WinRt.Windows.UI.Composition.IID_ICompositionDrawingSurface2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionDrawingSurface.all);
      Hr := m_Interface.Scroll (offset);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Scroll
   (
      this : in out CompositionDrawingSurface;
      offset : WinRt.Windows.Graphics.PointInt32;
      scrollRect : WinRt.Windows.Graphics.RectInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionDrawingSurface2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionDrawingSurface_Interface, WinRt.Windows.UI.Composition.ICompositionDrawingSurface2, WinRt.Windows.UI.Composition.IID_ICompositionDrawingSurface2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionDrawingSurface.all);
      Hr := m_Interface.Scroll (offset, scrollRect);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollWithClip
   (
      this : in out CompositionDrawingSurface;
      offset : WinRt.Windows.Graphics.PointInt32;
      clipRect : WinRt.Windows.Graphics.RectInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionDrawingSurface2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionDrawingSurface_Interface, WinRt.Windows.UI.Composition.ICompositionDrawingSurface2, WinRt.Windows.UI.Composition.IID_ICompositionDrawingSurface2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionDrawingSurface.all);
      Hr := m_Interface.ScrollWithClip (offset, clipRect);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollWithClip
   (
      this : in out CompositionDrawingSurface;
      offset : WinRt.Windows.Graphics.PointInt32;
      clipRect : WinRt.Windows.Graphics.RectInt32;
      scrollRect : WinRt.Windows.Graphics.RectInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionDrawingSurface2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionDrawingSurface_Interface, WinRt.Windows.UI.Composition.ICompositionDrawingSurface2, WinRt.Windows.UI.Composition.IID_ICompositionDrawingSurface2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionDrawingSurface.all);
      Hr := m_Interface.ScrollWithClip (offset, clipRect, scrollRect);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionEffectBrush

   procedure Initialize (this : in out CompositionEffectBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionEffectBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionEffectBrush, ICompositionEffectBrush_Ptr);
   begin
      if this.m_ICompositionEffectBrush /= null then
         if this.m_ICompositionEffectBrush.all /= null then
            temp := this.m_ICompositionEffectBrush.all.Release;
            Free (this.m_ICompositionEffectBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionEffectBrush

   function GetSourceParameter
   (
      this : in out CompositionEffectBrush;
      name : WinRt.WString
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
      HStr_name : constant WinRt.HString := To_HString (name);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ICompositionEffectBrush.all.GetSourceParameter (HStr_name, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_name);
      end return;
   end;

   procedure SetSourceParameter
   (
      this : in out CompositionEffectBrush;
      name : WinRt.WString;
      source : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_name : constant WinRt.HString := To_HString (name);
   begin
      Hr := this.m_ICompositionEffectBrush.all.SetSourceParameter (HStr_name, source.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_name);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionEffectFactory

   procedure Initialize (this : in out CompositionEffectFactory) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionEffectFactory) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionEffectFactory, ICompositionEffectFactory_Ptr);
   begin
      if this.m_ICompositionEffectFactory /= null then
         if this.m_ICompositionEffectFactory.all /= null then
            temp := this.m_ICompositionEffectFactory.all.Release;
            Free (this.m_ICompositionEffectFactory);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionEffectFactory

   function CreateBrush
   (
      this : in out CompositionEffectFactory
   )
   return WinRt.Windows.UI.Composition.CompositionEffectBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionEffectBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionEffectBrush do
         Hr := this.m_ICompositionEffectFactory.all.CreateBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionEffectBrush := new WinRt.Windows.UI.Composition.ICompositionEffectBrush;
         Retval.m_ICompositionEffectBrush.all := m_ComRetVal;
      end return;
   end;

   function get_ExtendedError
   (
      this : in out CompositionEffectFactory
   )
   return WinRt.Windows.Foundation.HResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.HResult;
   begin
      Hr := this.m_ICompositionEffectFactory.all.get_ExtendedError (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LoadStatus
   (
      this : in out CompositionEffectFactory
   )
   return WinRt.Windows.UI.Composition.CompositionEffectFactoryLoadStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEffectFactoryLoadStatus;
   begin
      Hr := this.m_ICompositionEffectFactory.all.get_LoadStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionEffectSourceParameter

   procedure Initialize (this : in out CompositionEffectSourceParameter) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionEffectSourceParameter) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionEffectSourceParameter, ICompositionEffectSourceParameter_Ptr);
   begin
      if this.m_ICompositionEffectSourceParameter /= null then
         if this.m_ICompositionEffectSourceParameter.all /= null then
            temp := this.m_ICompositionEffectSourceParameter.all.Release;
            Free (this.m_ICompositionEffectSourceParameter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionEffectSourceParameter

   function Constructor
   (
      name : WinRt.WString
   )
   return CompositionEffectSourceParameter is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Composition.ICompositionEffectSourceParameter");
      m_Factory    : access ICompositionEffectSourceParameterFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Composition.ICompositionEffectSourceParameter;
      HStr_name : constant WinRt.HString := To_HString (name);
   begin
      return RetVal : CompositionEffectSourceParameter do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionEffectSourceParameterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (HStr_name, m_ComRetVal'Access);
            Retval.m_ICompositionEffectSourceParameter := new WinRt.Windows.UI.Composition.ICompositionEffectSourceParameter;
            Retval.m_ICompositionEffectSourceParameter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_name);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionEffectSourceParameter

   function get_Name
   (
      this : in out CompositionEffectSourceParameter
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICompositionEffectSourceParameter.all.get_Name (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionGeometry

   procedure Initialize (this : in out CompositionGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionGeometry) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionGeometry, ICompositionGeometry_Ptr);
   begin
      if this.m_ICompositionGeometry /= null then
         if this.m_ICompositionGeometry.all /= null then
            temp := this.m_ICompositionGeometry.all.Release;
            Free (this.m_ICompositionGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionGeometry

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionGeometry

   function get_TrimEnd
   (
      this : in out CompositionGeometry
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionGeometry.all.get_TrimEnd (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TrimEnd
   (
      this : in out CompositionGeometry;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGeometry.all.put_TrimEnd (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TrimOffset
   (
      this : in out CompositionGeometry
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionGeometry.all.get_TrimOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TrimOffset
   (
      this : in out CompositionGeometry;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGeometry.all.put_TrimOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TrimStart
   (
      this : in out CompositionGeometry
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionGeometry.all.get_TrimStart (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TrimStart
   (
      this : in out CompositionGeometry;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGeometry.all.put_TrimStart (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionEllipseGeometry

   procedure Initialize (this : in out CompositionEllipseGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionEllipseGeometry) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionEllipseGeometry, ICompositionEllipseGeometry_Ptr);
   begin
      if this.m_ICompositionEllipseGeometry /= null then
         if this.m_ICompositionEllipseGeometry.all /= null then
            temp := this.m_ICompositionEllipseGeometry.all.Release;
            Free (this.m_ICompositionEllipseGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionEllipseGeometry

   function get_Center
   (
      this : in out CompositionEllipseGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionEllipseGeometry.all.get_Center (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Center
   (
      this : in out CompositionEllipseGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionEllipseGeometry.all.put_Center (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Radius
   (
      this : in out CompositionEllipseGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionEllipseGeometry.all.get_Radius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Radius
   (
      this : in out CompositionEllipseGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionEllipseGeometry.all.put_Radius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionGeometricClip

   procedure Initialize (this : in out CompositionGeometricClip) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionGeometricClip) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionGeometricClip, ICompositionGeometricClip_Ptr);
   begin
      if this.m_ICompositionGeometricClip /= null then
         if this.m_ICompositionGeometricClip.all /= null then
            temp := this.m_ICompositionGeometricClip.all.Release;
            Free (this.m_ICompositionGeometricClip);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionGeometricClip

   function get_Geometry
   (
      this : in out CompositionGeometricClip
   )
   return WinRt.Windows.UI.Composition.CompositionGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionGeometry;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionGeometry do
         Hr := this.m_ICompositionGeometricClip.all.get_Geometry (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionGeometry := new WinRt.Windows.UI.Composition.ICompositionGeometry;
         Retval.m_ICompositionGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_Geometry
   (
      this : in out CompositionGeometricClip;
      value : WinRt.Windows.UI.Composition.CompositionGeometry'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGeometricClip.all.put_Geometry (value.m_ICompositionGeometry.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ViewBox
   (
      this : in out CompositionGeometricClip
   )
   return WinRt.Windows.UI.Composition.CompositionViewBox'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionViewBox;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionViewBox do
         Hr := this.m_ICompositionGeometricClip.all.get_ViewBox (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionViewBox := new WinRt.Windows.UI.Composition.ICompositionViewBox;
         Retval.m_ICompositionViewBox.all := m_ComRetVal;
      end return;
   end;

   procedure put_ViewBox
   (
      this : in out CompositionGeometricClip;
      value : WinRt.Windows.UI.Composition.CompositionViewBox'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGeometricClip.all.put_ViewBox (value.m_ICompositionViewBox.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionGradientBrush

   procedure Initialize (this : in out CompositionGradientBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionGradientBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionGradientBrush, ICompositionGradientBrush_Ptr);
   begin
      if this.m_ICompositionGradientBrush /= null then
         if this.m_ICompositionGradientBrush.all /= null then
            temp := this.m_ICompositionGradientBrush.all.Release;
            Free (this.m_ICompositionGradientBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionGradientBrush

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionGradientBrush

   function get_AnchorPoint
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_AnchorPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnchorPoint
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_AnchorPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterPoint
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_CenterPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterPoint
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_CenterPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColorStops
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.UI.Composition.CompositionColorGradientStopCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorGradientStopCollection do
         Hr := this.m_ICompositionGradientBrush.all.get_ColorStops (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorGradientStopCollection := new WinRt.Windows.UI.Composition.ICompositionColorGradientStopCollection;
         Retval.m_ICompositionColorGradientStopCollection.all := m_ComRetVal;
      end return;
   end;

   function get_ExtendMode
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.UI.Composition.CompositionGradientExtendMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGradientExtendMode;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_ExtendMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExtendMode
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.UI.Composition.CompositionGradientExtendMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_ExtendMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InterpolationSpace
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.UI.Composition.CompositionColorSpace is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionColorSpace;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_InterpolationSpace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InterpolationSpace
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.UI.Composition.CompositionColorSpace
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_InterpolationSpace (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngle
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_RotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngle
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_RotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngleInDegrees
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_RotationAngleInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngleInDegrees
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_RotationAngleInDegrees (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_Scale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransformMatrix
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Matrix3x2;
   begin
      Hr := this.m_ICompositionGradientBrush.all.get_TransformMatrix (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransformMatrix
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGradientBrush.all.put_TransformMatrix (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MappingMode
   (
      this : in out CompositionGradientBrush
   )
   return WinRt.Windows.UI.Composition.CompositionMappingMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionGradientBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionMappingMode;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionGradientBrush_Interface, WinRt.Windows.UI.Composition.ICompositionGradientBrush2, WinRt.Windows.UI.Composition.IID_ICompositionGradientBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionGradientBrush.all);
      Hr := m_Interface.get_MappingMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MappingMode
   (
      this : in out CompositionGradientBrush;
      value : WinRt.Windows.UI.Composition.CompositionMappingMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionGradientBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionGradientBrush_Interface, WinRt.Windows.UI.Composition.ICompositionGradientBrush2, WinRt.Windows.UI.Composition.IID_ICompositionGradientBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionGradientBrush.all);
      Hr := m_Interface.put_MappingMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionGraphicsDevice

   procedure Initialize (this : in out CompositionGraphicsDevice) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionGraphicsDevice) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionGraphicsDevice, ICompositionGraphicsDevice_Ptr);
   begin
      if this.m_ICompositionGraphicsDevice /= null then
         if this.m_ICompositionGraphicsDevice.all /= null then
            temp := this.m_ICompositionGraphicsDevice.all.Release;
            Free (this.m_ICompositionGraphicsDevice);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionGraphicsDevice

   function CreateDrawingSurface
   (
      this : in out CompositionGraphicsDevice;
      sizePixels : WinRt.Windows.Foundation.Size;
      pixelFormat : WinRt.Windows.Graphics.DirectX.DirectXPixelFormat;
      alphaMode : WinRt.Windows.Graphics.DirectX.DirectXAlphaMode
   )
   return WinRt.Windows.UI.Composition.CompositionDrawingSurface'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionDrawingSurface;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionDrawingSurface do
         Hr := this.m_ICompositionGraphicsDevice.all.CreateDrawingSurface (sizePixels, pixelFormat, alphaMode, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionDrawingSurface := new WinRt.Windows.UI.Composition.ICompositionDrawingSurface;
         Retval.m_ICompositionDrawingSurface.all := m_ComRetVal;
      end return;
   end;

   function add_RenderingDeviceReplaced
   (
      this : in out CompositionGraphicsDevice;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICompositionGraphicsDevice.all.add_RenderingDeviceReplaced (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RenderingDeviceReplaced
   (
      this : in out CompositionGraphicsDevice;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionGraphicsDevice.all.remove_RenderingDeviceReplaced (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateDrawingSurface2
   (
      this : in out CompositionGraphicsDevice;
      sizePixels : WinRt.Windows.Graphics.SizeInt32;
      pixelFormat : WinRt.Windows.Graphics.DirectX.DirectXPixelFormat;
      alphaMode : WinRt.Windows.Graphics.DirectX.DirectXAlphaMode
   )
   return WinRt.Windows.UI.Composition.CompositionDrawingSurface'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionGraphicsDevice2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionDrawingSurface;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionGraphicsDevice_Interface, WinRt.Windows.UI.Composition.ICompositionGraphicsDevice2, WinRt.Windows.UI.Composition.IID_ICompositionGraphicsDevice2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionDrawingSurface do
         m_Interface := QInterface (this.m_ICompositionGraphicsDevice.all);
         Hr := m_Interface.CreateDrawingSurface2 (sizePixels, pixelFormat, alphaMode, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionDrawingSurface := new WinRt.Windows.UI.Composition.ICompositionDrawingSurface;
         Retval.m_ICompositionDrawingSurface.all := m_ComRetVal;
      end return;
   end;

   function CreateVirtualDrawingSurface
   (
      this : in out CompositionGraphicsDevice;
      sizePixels : WinRt.Windows.Graphics.SizeInt32;
      pixelFormat : WinRt.Windows.Graphics.DirectX.DirectXPixelFormat;
      alphaMode : WinRt.Windows.Graphics.DirectX.DirectXAlphaMode
   )
   return WinRt.Windows.UI.Composition.CompositionVirtualDrawingSurface'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionGraphicsDevice2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionVirtualDrawingSurface;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionGraphicsDevice_Interface, WinRt.Windows.UI.Composition.ICompositionGraphicsDevice2, WinRt.Windows.UI.Composition.IID_ICompositionGraphicsDevice2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionVirtualDrawingSurface do
         m_Interface := QInterface (this.m_ICompositionGraphicsDevice.all);
         Hr := m_Interface.CreateVirtualDrawingSurface (sizePixels, pixelFormat, alphaMode, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionVirtualDrawingSurface := new WinRt.Windows.UI.Composition.ICompositionVirtualDrawingSurface;
         Retval.m_ICompositionVirtualDrawingSurface.all := m_ComRetVal;
      end return;
   end;

   function CreateMipmapSurface
   (
      this : in out CompositionGraphicsDevice;
      sizePixels : WinRt.Windows.Graphics.SizeInt32;
      pixelFormat : WinRt.Windows.Graphics.DirectX.DirectXPixelFormat;
      alphaMode : WinRt.Windows.Graphics.DirectX.DirectXAlphaMode
   )
   return WinRt.Windows.UI.Composition.CompositionMipmapSurface'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionGraphicsDevice3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionMipmapSurface;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionGraphicsDevice_Interface, WinRt.Windows.UI.Composition.ICompositionGraphicsDevice3, WinRt.Windows.UI.Composition.IID_ICompositionGraphicsDevice3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionMipmapSurface do
         m_Interface := QInterface (this.m_ICompositionGraphicsDevice.all);
         Hr := m_Interface.CreateMipmapSurface (sizePixels, pixelFormat, alphaMode, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionMipmapSurface := new WinRt.Windows.UI.Composition.ICompositionMipmapSurface;
         Retval.m_ICompositionMipmapSurface.all := m_ComRetVal;
      end return;
   end;

   procedure Trim
   (
      this : in out CompositionGraphicsDevice
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionGraphicsDevice3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionGraphicsDevice_Interface, WinRt.Windows.UI.Composition.ICompositionGraphicsDevice3, WinRt.Windows.UI.Composition.IID_ICompositionGraphicsDevice3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionGraphicsDevice.all);
      Hr := m_Interface.Trim;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CaptureAsync
   (
      this : in out CompositionGraphicsDevice;
      captureVisual : WinRt.Windows.UI.Composition.Visual'Class;
      size : WinRt.Windows.Graphics.SizeInt32;
      pixelFormat : WinRt.Windows.Graphics.DirectX.DirectXPixelFormat;
      alphaMode : WinRt.Windows.Graphics.DirectX.DirectXAlphaMode;
      sdrBoost : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.ICompositionSurface is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionGraphicsDevice4 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_ICompositionSurface.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ICompositionSurface.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.Composition.ICompositionSurface;
      m_IID            : aliased WinRt.IID := (1717648605, 20598, 20694, (171, 50, 186, 118, 223, 73, 196, 16 )); -- Windows.UI.Composition.ICompositionSurface;
      m_HandlerIID     : aliased WinRt.IID := (3673518830, 858, 22860, (176, 19, 132, 189, 97, 136, 83, 204 ));
      m_Handler        : AsyncOperationCompletedHandler_ICompositionSurface.Kind := new AsyncOperationCompletedHandler_ICompositionSurface.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ICompositionSurface.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ICompositionSurface.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ICompositionSurface.Kind_Delegate, AsyncOperationCompletedHandler_ICompositionSurface.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionGraphicsDevice_Interface, WinRt.Windows.UI.Composition.ICompositionGraphicsDevice4, WinRt.Windows.UI.Composition.IID_ICompositionGraphicsDevice4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionGraphicsDevice.all);
      Hr := m_Interface.CaptureAsync (captureVisual.m_IVisual.all, size, pixelFormat, alphaMode, sdrBoost, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionLineGeometry

   procedure Initialize (this : in out CompositionLineGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionLineGeometry) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionLineGeometry, ICompositionLineGeometry_Ptr);
   begin
      if this.m_ICompositionLineGeometry /= null then
         if this.m_ICompositionLineGeometry.all /= null then
            temp := this.m_ICompositionLineGeometry.all.Release;
            Free (this.m_ICompositionLineGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionLineGeometry

   function get_Start
   (
      this : in out CompositionLineGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionLineGeometry.all.get_Start (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Start
   (
      this : in out CompositionLineGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionLineGeometry.all.put_Start (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_End
   (
      this : in out CompositionLineGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionLineGeometry.all.get_End (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_End
   (
      this : in out CompositionLineGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionLineGeometry.all.put_End (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionLinearGradientBrush

   procedure Initialize (this : in out CompositionLinearGradientBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionLinearGradientBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionLinearGradientBrush, ICompositionLinearGradientBrush_Ptr);
   begin
      if this.m_ICompositionLinearGradientBrush /= null then
         if this.m_ICompositionLinearGradientBrush.all /= null then
            temp := this.m_ICompositionLinearGradientBrush.all.Release;
            Free (this.m_ICompositionLinearGradientBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionLinearGradientBrush

   function get_EndPoint
   (
      this : in out CompositionLinearGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionLinearGradientBrush.all.get_EndPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EndPoint
   (
      this : in out CompositionLinearGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionLinearGradientBrush.all.put_EndPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StartPoint
   (
      this : in out CompositionLinearGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionLinearGradientBrush.all.get_StartPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StartPoint
   (
      this : in out CompositionLinearGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionLinearGradientBrush.all.put_StartPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionMaskBrush

   procedure Initialize (this : in out CompositionMaskBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionMaskBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionMaskBrush, ICompositionMaskBrush_Ptr);
   begin
      if this.m_ICompositionMaskBrush /= null then
         if this.m_ICompositionMaskBrush.all /= null then
            temp := this.m_ICompositionMaskBrush.all.Release;
            Free (this.m_ICompositionMaskBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionMaskBrush

   function get_Mask
   (
      this : in out CompositionMaskBrush
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ICompositionMaskBrush.all.get_Mask (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Mask
   (
      this : in out CompositionMaskBrush;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionMaskBrush.all.put_Mask (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out CompositionMaskBrush
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ICompositionMaskBrush.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out CompositionMaskBrush;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionMaskBrush.all.put_Source (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionMipmapSurface

   procedure Initialize (this : in out CompositionMipmapSurface) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionMipmapSurface) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionMipmapSurface, ICompositionMipmapSurface_Ptr);
   begin
      if this.m_ICompositionMipmapSurface /= null then
         if this.m_ICompositionMipmapSurface.all /= null then
            temp := this.m_ICompositionMipmapSurface.all.Release;
            Free (this.m_ICompositionMipmapSurface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionMipmapSurface

   function get_LevelCount
   (
      this : in out CompositionMipmapSurface
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ICompositionMipmapSurface.all.get_LevelCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AlphaMode
   (
      this : in out CompositionMipmapSurface
   )
   return WinRt.Windows.Graphics.DirectX.DirectXAlphaMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.DirectX.DirectXAlphaMode;
   begin
      Hr := this.m_ICompositionMipmapSurface.all.get_AlphaMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PixelFormat
   (
      this : in out CompositionMipmapSurface
   )
   return WinRt.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_ICompositionMipmapSurface.all.get_PixelFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SizeInt32
   (
      this : in out CompositionMipmapSurface
   )
   return WinRt.Windows.Graphics.SizeInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.SizeInt32;
   begin
      Hr := this.m_ICompositionMipmapSurface.all.get_SizeInt32 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetDrawingSurfaceForLevel
   (
      this : in out CompositionMipmapSurface;
      level : WinRt.UInt32
   )
   return WinRt.Windows.UI.Composition.CompositionDrawingSurface'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionDrawingSurface;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionDrawingSurface do
         Hr := this.m_ICompositionMipmapSurface.all.GetDrawingSurfaceForLevel (level, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionDrawingSurface := new WinRt.Windows.UI.Composition.ICompositionDrawingSurface;
         Retval.m_ICompositionDrawingSurface.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionNineGridBrush

   procedure Initialize (this : in out CompositionNineGridBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionNineGridBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionNineGridBrush, ICompositionNineGridBrush_Ptr);
   begin
      if this.m_ICompositionNineGridBrush /= null then
         if this.m_ICompositionNineGridBrush.all /= null then
            temp := this.m_ICompositionNineGridBrush.all.Release;
            Free (this.m_ICompositionNineGridBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionNineGridBrush

   function get_BottomInset
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_BottomInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BottomInset
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_BottomInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BottomInsetScale
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_BottomInsetScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BottomInsetScale
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_BottomInsetScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCenterHollow
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_IsCenterHollow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCenterHollow
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_IsCenterHollow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftInset
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_LeftInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LeftInset
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_LeftInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftInsetScale
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_LeftInsetScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LeftInsetScale
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_LeftInsetScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightInset
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_RightInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RightInset
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_RightInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightInsetScale
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_RightInsetScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RightInsetScale
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_RightInsetScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ICompositionNineGridBrush.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_Source (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopInset
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_TopInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TopInset
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_TopInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopInsetScale
   (
      this : in out CompositionNineGridBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.get_TopInsetScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TopInsetScale
   (
      this : in out CompositionNineGridBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.put_TopInsetScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetInsets
   (
      this : in out CompositionNineGridBrush;
      inset : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.SetInsets (inset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetInsets
   (
      this : in out CompositionNineGridBrush;
      left : WinRt.Single;
      top : WinRt.Single;
      right : WinRt.Single;
      bottom : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.SetInsets (left, top, right, bottom);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetInsetScales
   (
      this : in out CompositionNineGridBrush;
      scale : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.SetInsetScales (scale);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetInsetScales
   (
      this : in out CompositionNineGridBrush;
      left : WinRt.Single;
      top : WinRt.Single;
      right : WinRt.Single;
      bottom : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionNineGridBrush.all.SetInsetScales (left, top, right, bottom);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionPath

   procedure Initialize (this : in out CompositionPath) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionPath) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionPath, ICompositionPath_Ptr);
   begin
      if this.m_ICompositionPath /= null then
         if this.m_ICompositionPath.all /= null then
            temp := this.m_ICompositionPath.all.Release;
            Free (this.m_ICompositionPath);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionPath

   function Constructor
   (
      source : WinRt.Windows.Graphics.IGeometrySource2D
   )
   return CompositionPath is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Composition.ICompositionPath");
      m_Factory    : access ICompositionPathFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased WinRt.Windows.UI.Composition.ICompositionPath;
   begin
      return RetVal : CompositionPath do
         Hr := RoGetActivationFactory (m_hString, IID_ICompositionPathFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (source, m_ComRetVal'Access);
            Retval.m_ICompositionPath := new WinRt.Windows.UI.Composition.ICompositionPath;
            Retval.m_ICompositionPath.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionPath

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionPathGeometry

   procedure Initialize (this : in out CompositionPathGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionPathGeometry) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionPathGeometry, ICompositionPathGeometry_Ptr);
   begin
      if this.m_ICompositionPathGeometry /= null then
         if this.m_ICompositionPathGeometry.all /= null then
            temp := this.m_ICompositionPathGeometry.all.Release;
            Free (this.m_ICompositionPathGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionPathGeometry

   function get_Path
   (
      this : in out CompositionPathGeometry
   )
   return WinRt.Windows.UI.Composition.CompositionPath'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionPath;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionPath do
         Hr := this.m_ICompositionPathGeometry.all.get_Path (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionPath := new WinRt.Windows.UI.Composition.ICompositionPath;
         Retval.m_ICompositionPath.all := m_ComRetVal;
      end return;
   end;

   procedure put_Path
   (
      this : in out CompositionPathGeometry;
      value : WinRt.Windows.UI.Composition.CompositionPath'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionPathGeometry.all.put_Path (value.m_ICompositionPath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionProjectedShadow

   procedure Initialize (this : in out CompositionProjectedShadow) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionProjectedShadow) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionProjectedShadow, ICompositionProjectedShadow_Ptr);
   begin
      if this.m_ICompositionProjectedShadow /= null then
         if this.m_ICompositionProjectedShadow.all /= null then
            temp := this.m_ICompositionProjectedShadow.all.Release;
            Free (this.m_ICompositionProjectedShadow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionProjectedShadow

   function get_BlurRadiusMultiplier
   (
      this : in out CompositionProjectedShadow
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionProjectedShadow.all.get_BlurRadiusMultiplier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BlurRadiusMultiplier
   (
      this : in out CompositionProjectedShadow;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadow.all.put_BlurRadiusMultiplier (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Casters
   (
      this : in out CompositionProjectedShadow
   )
   return WinRt.Windows.UI.Composition.CompositionProjectedShadowCasterCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionProjectedShadowCasterCollection;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionProjectedShadowCasterCollection do
         Hr := this.m_ICompositionProjectedShadow.all.get_Casters (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionProjectedShadowCasterCollection := new WinRt.Windows.UI.Composition.ICompositionProjectedShadowCasterCollection;
         Retval.m_ICompositionProjectedShadowCasterCollection.all := m_ComRetVal;
      end return;
   end;

   function get_LightSource
   (
      this : in out CompositionProjectedShadow
   )
   return WinRt.Windows.UI.Composition.CompositionLight'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionLight;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionLight do
         Hr := this.m_ICompositionProjectedShadow.all.get_LightSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionLight := new WinRt.Windows.UI.Composition.ICompositionLight;
         Retval.m_ICompositionLight.all := m_ComRetVal;
      end return;
   end;

   procedure put_LightSource
   (
      this : in out CompositionProjectedShadow;
      value : WinRt.Windows.UI.Composition.CompositionLight'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadow.all.put_LightSource (value.m_ICompositionLight.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxBlurRadius
   (
      this : in out CompositionProjectedShadow
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionProjectedShadow.all.get_MaxBlurRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxBlurRadius
   (
      this : in out CompositionProjectedShadow;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadow.all.put_MaxBlurRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinBlurRadius
   (
      this : in out CompositionProjectedShadow
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionProjectedShadow.all.get_MinBlurRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinBlurRadius
   (
      this : in out CompositionProjectedShadow;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadow.all.put_MinBlurRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Receivers
   (
      this : in out CompositionProjectedShadow
   )
   return WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiverUnorderedCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionProjectedShadowReceiverUnorderedCollection;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiverUnorderedCollection do
         Hr := this.m_ICompositionProjectedShadow.all.get_Receivers (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionProjectedShadowReceiverUnorderedCollection := new WinRt.Windows.UI.Composition.ICompositionProjectedShadowReceiverUnorderedCollection;
         Retval.m_ICompositionProjectedShadowReceiverUnorderedCollection.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionProjectedShadowCaster

   procedure Initialize (this : in out CompositionProjectedShadowCaster) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionProjectedShadowCaster) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionProjectedShadowCaster, ICompositionProjectedShadowCaster_Ptr);
   begin
      if this.m_ICompositionProjectedShadowCaster /= null then
         if this.m_ICompositionProjectedShadowCaster.all /= null then
            temp := this.m_ICompositionProjectedShadowCaster.all.Release;
            Free (this.m_ICompositionProjectedShadowCaster);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionProjectedShadowCaster

   function get_Brush
   (
      this : in out CompositionProjectedShadowCaster
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ICompositionProjectedShadowCaster.all.get_Brush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Brush
   (
      this : in out CompositionProjectedShadowCaster;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCaster.all.put_Brush (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CastingVisual
   (
      this : in out CompositionProjectedShadowCaster
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_ICompositionProjectedShadowCaster.all.get_CastingVisual (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_CastingVisual
   (
      this : in out CompositionProjectedShadowCaster;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCaster.all.put_CastingVisual (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionProjectedShadowCasterCollection

   procedure Initialize (this : in out CompositionProjectedShadowCasterCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionProjectedShadowCasterCollection) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionProjectedShadowCasterCollection, ICompositionProjectedShadowCasterCollection_Ptr);
   begin
      if this.m_ICompositionProjectedShadowCasterCollection /= null then
         if this.m_ICompositionProjectedShadowCasterCollection.all /= null then
            temp := this.m_ICompositionProjectedShadowCasterCollection.all.Release;
            Free (this.m_ICompositionProjectedShadowCasterCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CompositionProjectedShadowCasterCollection

   function get_MaxRespectedCasters
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.CompositionProjectedShadowCasterCollection");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositionProjectedShadowCasterCollectionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositionProjectedShadowCasterCollectionStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_MaxRespectedCasters (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionProjectedShadowCasterCollection

   function get_Count
   (
      this : in out CompositionProjectedShadowCasterCollection
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_ICompositionProjectedShadowCasterCollection.all.get_Count (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure InsertAbove
   (
      this : in out CompositionProjectedShadowCasterCollection;
      newCaster : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class;
      reference : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCasterCollection.all.InsertAbove (newCaster.m_ICompositionProjectedShadowCaster.all, reference.m_ICompositionProjectedShadowCaster.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAtBottom
   (
      this : in out CompositionProjectedShadowCasterCollection;
      newCaster : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCasterCollection.all.InsertAtBottom (newCaster.m_ICompositionProjectedShadowCaster.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAtTop
   (
      this : in out CompositionProjectedShadowCasterCollection;
      newCaster : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCasterCollection.all.InsertAtTop (newCaster.m_ICompositionProjectedShadowCaster.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertBelow
   (
      this : in out CompositionProjectedShadowCasterCollection;
      newCaster : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class;
      reference : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCasterCollection.all.InsertBelow (newCaster.m_ICompositionProjectedShadowCaster.all, reference.m_ICompositionProjectedShadowCaster.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Remove
   (
      this : in out CompositionProjectedShadowCasterCollection;
      caster : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCasterCollection.all.Remove (caster.m_ICompositionProjectedShadowCaster.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out CompositionProjectedShadowCasterCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowCasterCollection.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionProjectedShadowCaster>
   function First
   (
      this : in out CompositionProjectedShadowCasterCollection
   )
   return WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ICompositionProjectedShadowCaster.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionProjectedShadowCaster;
      m_GenericIID     : aliased WinRt.IID := (3090160386, 17051, 23921, (171, 12, 141, 17, 65, 177, 42, 195 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionProjectedShadowCasterCollection_Interface, IIterable_ICompositionProjectedShadowCaster.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster do
         m_Interface := QInterface (this.m_ICompositionProjectedShadowCasterCollection.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionProjectedShadowCaster := new WinRt.Windows.UI.Composition.ICompositionProjectedShadowCaster;
         Retval.m_ICompositionProjectedShadowCaster.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionProjectedShadowReceiver

   procedure Initialize (this : in out CompositionProjectedShadowReceiver) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionProjectedShadowReceiver) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionProjectedShadowReceiver, ICompositionProjectedShadowReceiver_Ptr);
   begin
      if this.m_ICompositionProjectedShadowReceiver /= null then
         if this.m_ICompositionProjectedShadowReceiver.all /= null then
            temp := this.m_ICompositionProjectedShadowReceiver.all.Release;
            Free (this.m_ICompositionProjectedShadowReceiver);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionProjectedShadowReceiver

   function get_ReceivingVisual
   (
      this : in out CompositionProjectedShadowReceiver
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_ICompositionProjectedShadowReceiver.all.get_ReceivingVisual (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_ReceivingVisual
   (
      this : in out CompositionProjectedShadowReceiver;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowReceiver.all.put_ReceivingVisual (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionProjectedShadowReceiverUnorderedCollection

   procedure Initialize (this : in out CompositionProjectedShadowReceiverUnorderedCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionProjectedShadowReceiverUnorderedCollection) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionProjectedShadowReceiverUnorderedCollection, ICompositionProjectedShadowReceiverUnorderedCollection_Ptr);
   begin
      if this.m_ICompositionProjectedShadowReceiverUnorderedCollection /= null then
         if this.m_ICompositionProjectedShadowReceiverUnorderedCollection.all /= null then
            temp := this.m_ICompositionProjectedShadowReceiverUnorderedCollection.all.Release;
            Free (this.m_ICompositionProjectedShadowReceiverUnorderedCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionProjectedShadowReceiverUnorderedCollection

   procedure Add
   (
      this : in out CompositionProjectedShadowReceiverUnorderedCollection;
      value : WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiver'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowReceiverUnorderedCollection.all.Add (value.m_ICompositionProjectedShadowReceiver.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Count
   (
      this : in out CompositionProjectedShadowReceiverUnorderedCollection
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_ICompositionProjectedShadowReceiverUnorderedCollection.all.get_Count (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Remove
   (
      this : in out CompositionProjectedShadowReceiverUnorderedCollection;
      value : WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiver'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowReceiverUnorderedCollection.all.Remove (value.m_ICompositionProjectedShadowReceiver.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out CompositionProjectedShadowReceiverUnorderedCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionProjectedShadowReceiverUnorderedCollection.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionProjectedShadowReceiver>
   function First
   (
      this : in out CompositionProjectedShadowReceiverUnorderedCollection
   )
   return WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiver'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ICompositionProjectedShadowReceiver.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionProjectedShadowReceiver;
      m_GenericIID     : aliased WinRt.IID := (3799472680, 60488, 23736, (179, 82, 118, 247, 249, 129, 215, 164 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionProjectedShadowReceiverUnorderedCollection_Interface, IIterable_ICompositionProjectedShadowReceiver.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiver do
         m_Interface := QInterface (this.m_ICompositionProjectedShadowReceiverUnorderedCollection.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionProjectedShadowReceiver := new WinRt.Windows.UI.Composition.ICompositionProjectedShadowReceiver;
         Retval.m_ICompositionProjectedShadowReceiver.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionPropertySet

   procedure Initialize (this : in out CompositionPropertySet) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionPropertySet) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionPropertySet, ICompositionPropertySet_Ptr);
   begin
      if this.m_ICompositionPropertySet /= null then
         if this.m_ICompositionPropertySet.all /= null then
            temp := this.m_ICompositionPropertySet.all.Release;
            Free (this.m_ICompositionPropertySet);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionPropertySet

   procedure InsertColor
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertColor (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure InsertMatrix3x2
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertMatrix3x2 (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure InsertMatrix4x4
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Matrix4x4
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertMatrix4x4 (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure InsertQuaternion
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Quaternion
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertQuaternion (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure InsertScalar
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertScalar (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure InsertVector2
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertVector2 (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure InsertVector3
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertVector3 (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   procedure InsertVector4
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector4
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.InsertVector4 (HStr_propertyName, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   function TryGetColor
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.UI.Color_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetColor (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   function TryGetMatrix3x2
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Matrix3x2_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetMatrix3x2 (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   function TryGetMatrix4x4
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Matrix4x4_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetMatrix4x4 (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   function TryGetQuaternion
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Quaternion_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetQuaternion (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   function TryGetScalar
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Single_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetScalar (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   function TryGetVector2
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector2_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetVector2 (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   function TryGetVector3
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector3_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetVector3 (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   function TryGetVector4
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Windows.Foundation.Numerics.Vector4_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
   begin
      Hr := this.m_ICompositionPropertySet.all.TryGetVector4 (HStr_propertyName, value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   procedure InsertBoolean
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionPropertySet2 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionPropertySet_Interface, WinRt.Windows.UI.Composition.ICompositionPropertySet2, WinRt.Windows.UI.Composition.IID_ICompositionPropertySet2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionPropertySet.all);
      Hr := m_Interface.InsertBoolean (HStr_propertyName, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
   end;

   function TryGetBoolean
   (
      this : in out CompositionPropertySet;
      propertyName : WinRt.WString;
      value : WinRt.Boolean_Ptr
   )
   return WinRt.Windows.UI.Composition.CompositionGetValueStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionPropertySet2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionGetValueStatus;
      HStr_propertyName : constant WinRt.HString := To_HString (propertyName);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionPropertySet_Interface, WinRt.Windows.UI.Composition.ICompositionPropertySet2, WinRt.Windows.UI.Composition.IID_ICompositionPropertySet2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionPropertySet.all);
      Hr := m_Interface.TryGetBoolean (HStr_propertyName, value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_propertyName);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionRadialGradientBrush

   procedure Initialize (this : in out CompositionRadialGradientBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionRadialGradientBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionRadialGradientBrush, ICompositionRadialGradientBrush_Ptr);
   begin
      if this.m_ICompositionRadialGradientBrush /= null then
         if this.m_ICompositionRadialGradientBrush.all /= null then
            temp := this.m_ICompositionRadialGradientBrush.all.Release;
            Free (this.m_ICompositionRadialGradientBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionRadialGradientBrush

   function get_EllipseCenter
   (
      this : in out CompositionRadialGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRadialGradientBrush.all.get_EllipseCenter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EllipseCenter
   (
      this : in out CompositionRadialGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRadialGradientBrush.all.put_EllipseCenter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EllipseRadius
   (
      this : in out CompositionRadialGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRadialGradientBrush.all.get_EllipseRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EllipseRadius
   (
      this : in out CompositionRadialGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRadialGradientBrush.all.put_EllipseRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GradientOriginOffset
   (
      this : in out CompositionRadialGradientBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRadialGradientBrush.all.get_GradientOriginOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GradientOriginOffset
   (
      this : in out CompositionRadialGradientBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRadialGradientBrush.all.put_GradientOriginOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionRectangleGeometry

   procedure Initialize (this : in out CompositionRectangleGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionRectangleGeometry) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionRectangleGeometry, ICompositionRectangleGeometry_Ptr);
   begin
      if this.m_ICompositionRectangleGeometry /= null then
         if this.m_ICompositionRectangleGeometry.all /= null then
            temp := this.m_ICompositionRectangleGeometry.all.Release;
            Free (this.m_ICompositionRectangleGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionRectangleGeometry

   function get_Offset
   (
      this : in out CompositionRectangleGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRectangleGeometry.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionRectangleGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRectangleGeometry.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Size
   (
      this : in out CompositionRectangleGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRectangleGeometry.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Size
   (
      this : in out CompositionRectangleGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRectangleGeometry.all.put_Size (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionRoundedRectangleGeometry

   procedure Initialize (this : in out CompositionRoundedRectangleGeometry) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionRoundedRectangleGeometry) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionRoundedRectangleGeometry, ICompositionRoundedRectangleGeometry_Ptr);
   begin
      if this.m_ICompositionRoundedRectangleGeometry /= null then
         if this.m_ICompositionRoundedRectangleGeometry.all /= null then
            temp := this.m_ICompositionRoundedRectangleGeometry.all.Release;
            Free (this.m_ICompositionRoundedRectangleGeometry);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionRoundedRectangleGeometry

   function get_CornerRadius
   (
      this : in out CompositionRoundedRectangleGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRoundedRectangleGeometry.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out CompositionRoundedRectangleGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRoundedRectangleGeometry.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out CompositionRoundedRectangleGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRoundedRectangleGeometry.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionRoundedRectangleGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRoundedRectangleGeometry.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Size
   (
      this : in out CompositionRoundedRectangleGeometry
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionRoundedRectangleGeometry.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Size
   (
      this : in out CompositionRoundedRectangleGeometry;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionRoundedRectangleGeometry.all.put_Size (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionScopedBatch

   procedure Initialize (this : in out CompositionScopedBatch) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionScopedBatch) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionScopedBatch, ICompositionScopedBatch_Ptr);
   begin
      if this.m_ICompositionScopedBatch /= null then
         if this.m_ICompositionScopedBatch.all /= null then
            temp := this.m_ICompositionScopedBatch.all.Release;
            Free (this.m_ICompositionScopedBatch);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionScopedBatch

   function get_IsActive
   (
      this : in out CompositionScopedBatch
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionScopedBatch.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsEnded
   (
      this : in out CompositionScopedBatch
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionScopedBatch.all.get_IsEnded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure End_x
   (
      this : in out CompositionScopedBatch
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionScopedBatch.all.End_x;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Resume
   (
      this : in out CompositionScopedBatch
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionScopedBatch.all.Resume;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Suspend
   (
      this : in out CompositionScopedBatch
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionScopedBatch.all.Suspend;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Completed
   (
      this : in out CompositionScopedBatch;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICompositionScopedBatch.all.add_Completed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Completed
   (
      this : in out CompositionScopedBatch;
      token : WinRt.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionScopedBatch.all.remove_Completed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionShadow

   procedure Initialize (this : in out CompositionShadow) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionShadow) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionShadow, ICompositionShadow_Ptr);
   begin
      if this.m_ICompositionShadow /= null then
         if this.m_ICompositionShadow.all /= null then
            temp := this.m_ICompositionShadow.all.Release;
            Free (this.m_ICompositionShadow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionShadow

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionShadow

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionShapeCollection

   procedure Initialize (this : in out CompositionShapeCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionShapeCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionShapeCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Composition.CompositionShape>
   function GetAt
   (
      this : in out CompositionShapeCollection;
      index : WinRt.UInt32
   )
   return WinRt.Windows.UI.Composition.CompositionShape'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionShape;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionShape do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionShape := new WinRt.Windows.UI.Composition.ICompositionShape;
         Retval.m_ICompositionShape.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out CompositionShapeCollection
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out CompositionShapeCollection
   )
   return WinRt.Windows.UI.Composition.CompositionShape'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionShape;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionShape do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionShape := new WinRt.Windows.UI.Composition.ICompositionShape;
         Retval.m_ICompositionShape.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out CompositionShapeCollection;
      value : WinRt.Windows.UI.Composition.CompositionShape'Class;
      index : WinRt.UInt32_Ptr
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_ICompositionShape.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out CompositionShapeCollection;
      index : WinRt.UInt32;
      value : WinRt.Windows.UI.Composition.CompositionShape'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_ICompositionShape.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out CompositionShapeCollection;
      index : WinRt.UInt32;
      value : WinRt.Windows.UI.Composition.CompositionShape'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_ICompositionShape.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out CompositionShapeCollection;
      index : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out CompositionShapeCollection;
      value : WinRt.Windows.UI.Composition.CompositionShape'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_ICompositionShape.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out CompositionShapeCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out CompositionShapeCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out CompositionShapeCollection;
      startIndex : WinRt.UInt32;
      items : WinRt.Windows.UI.Composition.ICompositionShape_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out CompositionShapeCollection;
      items : WinRt.Windows.UI.Composition.ICompositionShape_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1121198490, 48667, 20625, (143, 30, 144, 39, 8, 64, 252, 45 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.CompositionShape>
   function First
   (
      this : in out CompositionShapeCollection
   )
   return WinRt.Windows.UI.Composition.CompositionShape'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ICompositionShape.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionShape;
      m_GenericIID     : aliased WinRt.IID := (288730613, 56082, 21992, (174, 15, 189, 141, 145, 75, 211, 153 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IIterable_ICompositionShape.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionShape do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionShape := new WinRt.Windows.UI.Composition.ICompositionShape;
         Retval.m_ICompositionShape.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionSpriteShape

   procedure Initialize (this : in out CompositionSpriteShape) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionSpriteShape) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionSpriteShape, ICompositionSpriteShape_Ptr);
   begin
      if this.m_ICompositionSpriteShape /= null then
         if this.m_ICompositionSpriteShape.all /= null then
            temp := this.m_ICompositionSpriteShape.all.Release;
            Free (this.m_ICompositionSpriteShape);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionSpriteShape

   function get_FillBrush
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ICompositionSpriteShape.all.get_FillBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FillBrush
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_FillBrush (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Geometry
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionGeometry;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionGeometry do
         Hr := this.m_ICompositionSpriteShape.all.get_Geometry (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionGeometry := new WinRt.Windows.UI.Composition.ICompositionGeometry;
         Retval.m_ICompositionGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_Geometry
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Windows.UI.Composition.CompositionGeometry'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_Geometry (value.m_ICompositionGeometry.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStrokeNonScaling
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_IsStrokeNonScaling (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStrokeNonScaling
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_IsStrokeNonScaling (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeBrush
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ICompositionSpriteShape.all.get_StrokeBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_StrokeBrush
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeBrush (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeDashArray
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionStrokeDashArray'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionStrokeDashArray do
         Hr := this.m_ICompositionSpriteShape.all.get_StrokeDashArray (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinRt.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_StrokeDashCap
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionStrokeCap is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionStrokeCap;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_StrokeDashCap (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeDashCap
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Windows.UI.Composition.CompositionStrokeCap
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeDashCap (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeDashOffset
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_StrokeDashOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeDashOffset
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeDashOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeEndCap
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionStrokeCap is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionStrokeCap;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_StrokeEndCap (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeEndCap
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Windows.UI.Composition.CompositionStrokeCap
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeEndCap (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeLineJoin
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionStrokeLineJoin is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionStrokeLineJoin;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_StrokeLineJoin (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeLineJoin
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Windows.UI.Composition.CompositionStrokeLineJoin
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeLineJoin (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeMiterLimit
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_StrokeMiterLimit (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeMiterLimit
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeMiterLimit (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeStartCap
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Windows.UI.Composition.CompositionStrokeCap is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionStrokeCap;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_StrokeStartCap (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeStartCap
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Windows.UI.Composition.CompositionStrokeCap
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeStartCap (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StrokeThickness
   (
      this : in out CompositionSpriteShape
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionSpriteShape.all.get_StrokeThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StrokeThickness
   (
      this : in out CompositionSpriteShape;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSpriteShape.all.put_StrokeThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionStrokeDashArray

   procedure Initialize (this : in out CompositionStrokeDashArray) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionStrokeDashArray) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionStrokeDashArray

   -- Generic Interface Windows.Foundation.Collections.IVector`1<System.Single>
   function GetAt
   (
      this : in out CompositionStrokeDashArray;
      index : WinRt.UInt32
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out CompositionStrokeDashArray
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out CompositionStrokeDashArray
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out CompositionStrokeDashArray;
      value : WinRt.Single;
      index : WinRt.UInt32_Ptr
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out CompositionStrokeDashArray;
      index : WinRt.UInt32;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out CompositionStrokeDashArray;
      index : WinRt.UInt32;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out CompositionStrokeDashArray;
      index : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out CompositionStrokeDashArray;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out CompositionStrokeDashArray
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out CompositionStrokeDashArray
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out CompositionStrokeDashArray;
      startIndex : WinRt.UInt32;
      items : WinRt.Single_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out CompositionStrokeDashArray;
      items : WinRt.Single_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IVector_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1640982847, 56140, 22431, (185, 5, 93, 211, 210, 60, 253, 77 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IVector_Single.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<System.Single>
   function First
   (
      this : in out CompositionStrokeDashArray
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_Single.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      m_GenericIID     : aliased WinRt.IID := (2954620497, 1594, 24538, (189, 114, 215, 102, 55, 187, 140, 184 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IIterable_Single.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionSurfaceBrush

   procedure Initialize (this : in out CompositionSurfaceBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionSurfaceBrush) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionSurfaceBrush, ICompositionSurfaceBrush_Ptr);
   begin
      if this.m_ICompositionSurfaceBrush /= null then
         if this.m_ICompositionSurfaceBrush.all /= null then
            temp := this.m_ICompositionSurfaceBrush.all.Release;
            Free (this.m_ICompositionSurfaceBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionSurfaceBrush

   function get_BitmapInterpolationMode
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.UI.Composition.CompositionBitmapInterpolationMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionBitmapInterpolationMode;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.get_BitmapInterpolationMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BitmapInterpolationMode
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.UI.Composition.CompositionBitmapInterpolationMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.put_BitmapInterpolationMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAlignmentRatio
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.get_HorizontalAlignmentRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAlignmentRatio
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.put_HorizontalAlignmentRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.UI.Composition.CompositionStretch is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionStretch;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.UI.Composition.CompositionStretch
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Surface
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.UI.Composition.ICompositionSurface is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionSurface;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.get_Surface (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Surface
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.UI.Composition.ICompositionSurface
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.put_Surface (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAlignmentRatio
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.get_VerticalAlignmentRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAlignmentRatio
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionSurfaceBrush.all.put_VerticalAlignmentRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AnchorPoint
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_AnchorPoint (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnchorPoint
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_AnchorPoint (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterPoint
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_CenterPoint (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterPoint
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_CenterPoint (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_Offset (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_Offset (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngle
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_RotationAngle (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngle
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_RotationAngle (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngleInDegrees
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_RotationAngleInDegrees (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngleInDegrees
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_RotationAngleInDegrees (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_Scale (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_Scale (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransformMatrix
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Windows.Foundation.Numerics.Matrix3x2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Matrix3x2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_TransformMatrix (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransformMatrix
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Windows.Foundation.Numerics.Matrix3x2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush2, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_TransformMatrix (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SnapToPixels
   (
      this : in out CompositionSurfaceBrush
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush3, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.get_SnapToPixels (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SnapToPixels
   (
      this : in out CompositionSurfaceBrush;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositionSurfaceBrush3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositionSurfaceBrush_Interface, WinRt.Windows.UI.Composition.ICompositionSurfaceBrush3, WinRt.Windows.UI.Composition.IID_ICompositionSurfaceBrush3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositionSurfaceBrush.all);
      Hr := m_Interface.put_SnapToPixels (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionTarget

   procedure Initialize (this : in out CompositionTarget) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionTarget) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionTarget, ICompositionTarget_Ptr);
   begin
      if this.m_ICompositionTarget /= null then
         if this.m_ICompositionTarget.all /= null then
            temp := this.m_ICompositionTarget.all.Release;
            Free (this.m_ICompositionTarget);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionTarget

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionTarget

   function get_Root
   (
      this : in out CompositionTarget
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_ICompositionTarget.all.get_Root (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_Root
   (
      this : in out CompositionTarget;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionTarget.all.put_Root (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionTexture

   procedure Initialize (this : in out CompositionTexture) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionTexture) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionTexture, ICompositionTexture_Ptr);
   begin
      if this.m_ICompositionTexture /= null then
         if this.m_ICompositionTexture.all /= null then
            temp := this.m_ICompositionTexture.all.Release;
            Free (this.m_ICompositionTexture);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionTexture

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionTexture

   function get_SourceRect
   (
      this : in out CompositionTexture
   )
   return WinRt.Windows.Graphics.RectInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.RectInt32;
   begin
      Hr := this.m_ICompositionTexture.all.get_SourceRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourceRect
   (
      this : in out CompositionTexture;
      value : WinRt.Windows.Graphics.RectInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionTexture.all.put_SourceRect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlphaMode
   (
      this : in out CompositionTexture
   )
   return WinRt.Windows.Graphics.DirectX.DirectXAlphaMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.DirectX.DirectXAlphaMode;
   begin
      Hr := this.m_ICompositionTexture.all.get_AlphaMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlphaMode
   (
      this : in out CompositionTexture;
      value : WinRt.Windows.Graphics.DirectX.DirectXAlphaMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionTexture.all.put_AlphaMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColorSpace
   (
      this : in out CompositionTexture
   )
   return WinRt.Windows.Graphics.DirectX.DirectXColorSpace is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Graphics.DirectX.DirectXColorSpace;
   begin
      Hr := this.m_ICompositionTexture.all.get_ColorSpace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorSpace
   (
      this : in out CompositionTexture;
      value : WinRt.Windows.Graphics.DirectX.DirectXColorSpace
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionTexture.all.put_ColorSpace (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionTransform

   procedure Initialize (this : in out CompositionTransform) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionTransform) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionTransform, ICompositionTransform_Ptr);
   begin
      if this.m_ICompositionTransform /= null then
         if this.m_ICompositionTransform.all /= null then
            temp := this.m_ICompositionTransform.all.Release;
            Free (this.m_ICompositionTransform);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionTransform

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionTransform

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionViewBox

   procedure Initialize (this : in out CompositionViewBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionViewBox) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionViewBox, ICompositionViewBox_Ptr);
   begin
      if this.m_ICompositionViewBox /= null then
         if this.m_ICompositionViewBox.all /= null then
            temp := this.m_ICompositionViewBox.all.Release;
            Free (this.m_ICompositionViewBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionViewBox

   function get_HorizontalAlignmentRatio
   (
      this : in out CompositionViewBox
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionViewBox.all.get_HorizontalAlignmentRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAlignmentRatio
   (
      this : in out CompositionViewBox;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionViewBox.all.put_HorizontalAlignmentRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out CompositionViewBox
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionViewBox.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out CompositionViewBox;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionViewBox.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Size
   (
      this : in out CompositionViewBox
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionViewBox.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Size
   (
      this : in out CompositionViewBox;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionViewBox.all.put_Size (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out CompositionViewBox
   )
   return WinRt.Windows.UI.Composition.CompositionStretch is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionStretch;
   begin
      Hr := this.m_ICompositionViewBox.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out CompositionViewBox;
      value : WinRt.Windows.UI.Composition.CompositionStretch
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionViewBox.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAlignmentRatio
   (
      this : in out CompositionViewBox
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ICompositionViewBox.all.get_VerticalAlignmentRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAlignmentRatio
   (
      this : in out CompositionViewBox;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionViewBox.all.put_VerticalAlignmentRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionVirtualDrawingSurface

   procedure Initialize (this : in out CompositionVirtualDrawingSurface) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionVirtualDrawingSurface) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionVirtualDrawingSurface, ICompositionVirtualDrawingSurface_Ptr);
   begin
      if this.m_ICompositionVirtualDrawingSurface /= null then
         if this.m_ICompositionVirtualDrawingSurface.all /= null then
            temp := this.m_ICompositionVirtualDrawingSurface.all.Release;
            Free (this.m_ICompositionVirtualDrawingSurface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompositionVirtualDrawingSurface

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionVirtualDrawingSurface

   procedure Trim
   (
      this : in out CompositionVirtualDrawingSurface;
      rects : WinRt.Windows.Graphics.RectInt32_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      function Convert_rects is new Ada.Unchecked_Conversion (Address, WinRt.Windows.Graphics.RectInt32_Ptr);
   begin
      Hr := this.m_ICompositionVirtualDrawingSurface.all.Trim (WinRt.UInt32(rects'Length), Convert_rects (rects (rects'First)'Address));
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompositionVisualSurface

   procedure Initialize (this : in out CompositionVisualSurface) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompositionVisualSurface) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositionVisualSurface, ICompositionVisualSurface_Ptr);
   begin
      if this.m_ICompositionVisualSurface /= null then
         if this.m_ICompositionVisualSurface.all /= null then
            temp := this.m_ICompositionVisualSurface.all.Release;
            Free (this.m_ICompositionVisualSurface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompositionVisualSurface

   function get_SourceVisual
   (
      this : in out CompositionVisualSurface
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_ICompositionVisualSurface.all.get_SourceVisual (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_SourceVisual
   (
      this : in out CompositionVisualSurface;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionVisualSurface.all.put_SourceVisual (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SourceOffset
   (
      this : in out CompositionVisualSurface
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionVisualSurface.all.get_SourceOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourceOffset
   (
      this : in out CompositionVisualSurface;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionVisualSurface.all.put_SourceOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SourceSize
   (
      this : in out CompositionVisualSurface
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICompositionVisualSurface.all.get_SourceSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourceSize
   (
      this : in out CompositionVisualSurface;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ICompositionVisualSurface.all.put_SourceSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Compositor

   procedure Initialize (this : in out Compositor) is
   begin
      null;
   end;

   procedure Finalize (this : in out Compositor) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompositor, ICompositor_Ptr);
   begin
      if this.m_ICompositor /= null then
         if this.m_ICompositor.all /= null then
            temp := this.m_ICompositor.all.Release;
            Free (this.m_ICompositor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Compositor

   function Constructor return Compositor is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Composition.ICompositor");
      m_ComRetVal  : aliased WinRt.Windows.UI.Composition.ICompositor;
   begin
      return RetVal : Compositor do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICompositor := new WinRt.Windows.UI.Composition.ICompositor;
            Retval.m_ICompositor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Compositor

   function get_MaxGlobalPlaybackRate
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Compositor");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositorStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_MaxGlobalPlaybackRate (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_MinGlobalPlaybackRate
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.Compositor");
      m_Factory        : access WinRt.Windows.UI.Composition.ICompositorStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICompositorStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_MinGlobalPlaybackRate (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Compositor

   function CreateColorKeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.ColorKeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IColorKeyFrameAnimation;
   begin
      return RetVal : WinRt.Windows.UI.Composition.ColorKeyFrameAnimation do
         Hr := this.m_ICompositor.all.CreateColorKeyFrameAnimation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColorKeyFrameAnimation := new WinRt.Windows.UI.Composition.IColorKeyFrameAnimation;
         Retval.m_IColorKeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateColorBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionColorBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorBrush do
         Hr := this.m_ICompositor.all.CreateColorBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorBrush := new WinRt.Windows.UI.Composition.ICompositionColorBrush;
         Retval.m_ICompositionColorBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateColorBrush
   (
      this : in out Compositor;
      color : WinRt.Windows.UI.Color
   )
   return WinRt.Windows.UI.Composition.CompositionColorBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorBrush do
         Hr := this.m_ICompositor.all.CreateColorBrush (color, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorBrush := new WinRt.Windows.UI.Composition.ICompositionColorBrush;
         Retval.m_ICompositionColorBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateContainerVisual
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.ContainerVisual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IContainerVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.ContainerVisual do
         Hr := this.m_ICompositor.all.CreateContainerVisual (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContainerVisual := new WinRt.Windows.UI.Composition.IContainerVisual;
         Retval.m_IContainerVisual.all := m_ComRetVal;
      end return;
   end;

   function CreateCubicBezierEasingFunction
   (
      this : in out Compositor;
      controlPoint1 : WinRt.Windows.Foundation.Numerics.Vector2;
      controlPoint2 : WinRt.Windows.Foundation.Numerics.Vector2
   )
   return WinRt.Windows.UI.Composition.CubicBezierEasingFunction'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICubicBezierEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CubicBezierEasingFunction do
         Hr := this.m_ICompositor.all.CreateCubicBezierEasingFunction (controlPoint1, controlPoint2, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICubicBezierEasingFunction := new WinRt.Windows.UI.Composition.ICubicBezierEasingFunction;
         Retval.m_ICubicBezierEasingFunction.all := m_ComRetVal;
      end return;
   end;

   function CreateEffectFactory
   (
      this : in out Compositor;
      graphicsEffect : WinRt.Windows.Graphics.Effects.IGraphicsEffect
   )
   return WinRt.Windows.UI.Composition.CompositionEffectFactory'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionEffectFactory;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionEffectFactory do
         Hr := this.m_ICompositor.all.CreateEffectFactory (graphicsEffect, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionEffectFactory := new WinRt.Windows.UI.Composition.ICompositionEffectFactory;
         Retval.m_ICompositionEffectFactory.all := m_ComRetVal;
      end return;
   end;

   function CreateEffectFactory
   (
      this : in out Compositor;
      graphicsEffect : WinRt.Windows.Graphics.Effects.IGraphicsEffect;
      animatableProperties : GenericObject
   )
   return WinRt.Windows.UI.Composition.CompositionEffectFactory'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionEffectFactory;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionEffectFactory do
         Hr := this.m_ICompositor.all.CreateEffectFactory (graphicsEffect, animatableProperties, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionEffectFactory := new WinRt.Windows.UI.Composition.ICompositionEffectFactory;
         Retval.m_ICompositionEffectFactory.all := m_ComRetVal;
      end return;
   end;

   function CreateExpressionAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IExpressionAnimation;
   begin
      return RetVal : WinRt.Windows.UI.Composition.ExpressionAnimation do
         Hr := this.m_ICompositor.all.CreateExpressionAnimation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinRt.Windows.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateExpressionAnimation
   (
      this : in out Compositor;
      expression : WinRt.WString
   )
   return WinRt.Windows.UI.Composition.ExpressionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IExpressionAnimation;
      HStr_expression : constant WinRt.HString := To_HString (expression);
   begin
      return RetVal : WinRt.Windows.UI.Composition.ExpressionAnimation do
         Hr := this.m_ICompositor.all.CreateExpressionAnimation (HStr_expression, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IExpressionAnimation := new WinRt.Windows.UI.Composition.IExpressionAnimation;
         Retval.m_IExpressionAnimation.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_expression);
      end return;
   end;

   function CreateInsetClip
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.InsetClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IInsetClip;
   begin
      return RetVal : WinRt.Windows.UI.Composition.InsetClip do
         Hr := this.m_ICompositor.all.CreateInsetClip (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInsetClip := new WinRt.Windows.UI.Composition.IInsetClip;
         Retval.m_IInsetClip.all := m_ComRetVal;
      end return;
   end;

   function CreateInsetClip
   (
      this : in out Compositor;
      leftInset : WinRt.Single;
      topInset : WinRt.Single;
      rightInset : WinRt.Single;
      bottomInset : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.InsetClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IInsetClip;
   begin
      return RetVal : WinRt.Windows.UI.Composition.InsetClip do
         Hr := this.m_ICompositor.all.CreateInsetClip (leftInset, topInset, rightInset, bottomInset, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInsetClip := new WinRt.Windows.UI.Composition.IInsetClip;
         Retval.m_IInsetClip.all := m_ComRetVal;
      end return;
   end;

   function CreateLinearEasingFunction
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.LinearEasingFunction'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ILinearEasingFunction;
   begin
      return RetVal : WinRt.Windows.UI.Composition.LinearEasingFunction do
         Hr := this.m_ICompositor.all.CreateLinearEasingFunction (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ILinearEasingFunction := new WinRt.Windows.UI.Composition.ILinearEasingFunction;
         Retval.m_ILinearEasingFunction.all := m_ComRetVal;
      end return;
   end;

   function CreatePropertySet
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionPropertySet'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionPropertySet;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionPropertySet do
         Hr := this.m_ICompositor.all.CreatePropertySet (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionPropertySet := new WinRt.Windows.UI.Composition.ICompositionPropertySet;
         Retval.m_ICompositionPropertySet.all := m_ComRetVal;
      end return;
   end;

   function CreateQuaternionKeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.QuaternionKeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IQuaternionKeyFrameAnimation;
   begin
      return RetVal : WinRt.Windows.UI.Composition.QuaternionKeyFrameAnimation do
         Hr := this.m_ICompositor.all.CreateQuaternionKeyFrameAnimation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IQuaternionKeyFrameAnimation := new WinRt.Windows.UI.Composition.IQuaternionKeyFrameAnimation;
         Retval.m_IQuaternionKeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateScalarKeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.ScalarKeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IScalarKeyFrameAnimation;
   begin
      return RetVal : WinRt.Windows.UI.Composition.ScalarKeyFrameAnimation do
         Hr := this.m_ICompositor.all.CreateScalarKeyFrameAnimation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScalarKeyFrameAnimation := new WinRt.Windows.UI.Composition.IScalarKeyFrameAnimation;
         Retval.m_IScalarKeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateScopedBatch
   (
      this : in out Compositor;
      batchType : WinRt.Windows.UI.Composition.CompositionBatchTypes
   )
   return WinRt.Windows.UI.Composition.CompositionScopedBatch'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionScopedBatch;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionScopedBatch do
         Hr := this.m_ICompositor.all.CreateScopedBatch (batchType, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionScopedBatch := new WinRt.Windows.UI.Composition.ICompositionScopedBatch;
         Retval.m_ICompositionScopedBatch.all := m_ComRetVal;
      end return;
   end;

   function CreateSpriteVisual
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.SpriteVisual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ISpriteVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.SpriteVisual do
         Hr := this.m_ICompositor.all.CreateSpriteVisual (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISpriteVisual := new WinRt.Windows.UI.Composition.ISpriteVisual;
         Retval.m_ISpriteVisual.all := m_ComRetVal;
      end return;
   end;

   function CreateSurfaceBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionSurfaceBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionSurfaceBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionSurfaceBrush do
         Hr := this.m_ICompositor.all.CreateSurfaceBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionSurfaceBrush := new WinRt.Windows.UI.Composition.ICompositionSurfaceBrush;
         Retval.m_ICompositionSurfaceBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateSurfaceBrush
   (
      this : in out Compositor;
      surface : WinRt.Windows.UI.Composition.ICompositionSurface
   )
   return WinRt.Windows.UI.Composition.CompositionSurfaceBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionSurfaceBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionSurfaceBrush do
         Hr := this.m_ICompositor.all.CreateSurfaceBrush (surface, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionSurfaceBrush := new WinRt.Windows.UI.Composition.ICompositionSurfaceBrush;
         Retval.m_ICompositionSurfaceBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateTargetForCurrentView
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionTarget'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionTarget;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionTarget do
         Hr := this.m_ICompositor.all.CreateTargetForCurrentView (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionTarget := new WinRt.Windows.UI.Composition.ICompositionTarget;
         Retval.m_ICompositionTarget.all := m_ComRetVal;
      end return;
   end;

   function CreateVector2KeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.Vector2KeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVector2KeyFrameAnimation;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Vector2KeyFrameAnimation do
         Hr := this.m_ICompositor.all.CreateVector2KeyFrameAnimation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVector2KeyFrameAnimation := new WinRt.Windows.UI.Composition.IVector2KeyFrameAnimation;
         Retval.m_IVector2KeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateVector3KeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.Vector3KeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVector3KeyFrameAnimation;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Vector3KeyFrameAnimation do
         Hr := this.m_ICompositor.all.CreateVector3KeyFrameAnimation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVector3KeyFrameAnimation := new WinRt.Windows.UI.Composition.IVector3KeyFrameAnimation;
         Retval.m_IVector3KeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateVector4KeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.Vector4KeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVector4KeyFrameAnimation;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Vector4KeyFrameAnimation do
         Hr := this.m_ICompositor.all.CreateVector4KeyFrameAnimation (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVector4KeyFrameAnimation := new WinRt.Windows.UI.Composition.IVector4KeyFrameAnimation;
         Retval.m_IVector4KeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function GetCommitBatch
   (
      this : in out Compositor;
      batchType : WinRt.Windows.UI.Composition.CompositionBatchTypes
   )
   return WinRt.Windows.UI.Composition.CompositionCommitBatch'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionCommitBatch;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionCommitBatch do
         Hr := this.m_ICompositor.all.GetCommitBatch (batchType, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionCommitBatch := new WinRt.Windows.UI.Composition.ICompositionCommitBatch;
         Retval.m_ICompositionCommitBatch.all := m_ComRetVal;
      end return;
   end;

   function CreateAmbientLight
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.AmbientLight'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IAmbientLight;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.AmbientLight do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateAmbientLight (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAmbientLight := new WinRt.Windows.UI.Composition.IAmbientLight;
         Retval.m_IAmbientLight.all := m_ComRetVal;
      end return;
   end;

   function CreateAnimationGroup
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionAnimationGroup'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionAnimationGroup;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionAnimationGroup do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateAnimationGroup (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionAnimationGroup := new WinRt.Windows.UI.Composition.ICompositionAnimationGroup;
         Retval.m_ICompositionAnimationGroup.all := m_ComRetVal;
      end return;
   end;

   function CreateBackdropBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionBackdropBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBackdropBrush;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBackdropBrush do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateBackdropBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBackdropBrush := new WinRt.Windows.UI.Composition.ICompositionBackdropBrush;
         Retval.m_ICompositionBackdropBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateDistantLight
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.DistantLight'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IDistantLight;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.DistantLight do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateDistantLight (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDistantLight := new WinRt.Windows.UI.Composition.IDistantLight;
         Retval.m_IDistantLight.all := m_ComRetVal;
      end return;
   end;

   function CreateDropShadow
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.DropShadow'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IDropShadow;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.DropShadow do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateDropShadow (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDropShadow := new WinRt.Windows.UI.Composition.IDropShadow;
         Retval.m_IDropShadow.all := m_ComRetVal;
      end return;
   end;

   function CreateImplicitAnimationCollection
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.ImplicitAnimationCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IImplicitAnimationCollection;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.ImplicitAnimationCollection do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateImplicitAnimationCollection (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImplicitAnimationCollection := new WinRt.Windows.UI.Composition.IImplicitAnimationCollection;
         Retval.m_IImplicitAnimationCollection.all := m_ComRetVal;
      end return;
   end;

   function CreateLayerVisual
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.LayerVisual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ILayerVisual;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.LayerVisual do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateLayerVisual (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ILayerVisual := new WinRt.Windows.UI.Composition.ILayerVisual;
         Retval.m_ILayerVisual.all := m_ComRetVal;
      end return;
   end;

   function CreateMaskBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionMaskBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionMaskBrush;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionMaskBrush do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateMaskBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionMaskBrush := new WinRt.Windows.UI.Composition.ICompositionMaskBrush;
         Retval.m_ICompositionMaskBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateNineGridBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionNineGridBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionNineGridBrush;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionNineGridBrush do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateNineGridBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionNineGridBrush := new WinRt.Windows.UI.Composition.ICompositionNineGridBrush;
         Retval.m_ICompositionNineGridBrush.all := m_ComRetVal;
      end return;
   end;

   function CreatePointLight
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.PointLight'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IPointLight;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.PointLight do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreatePointLight (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointLight := new WinRt.Windows.UI.Composition.IPointLight;
         Retval.m_IPointLight.all := m_ComRetVal;
      end return;
   end;

   function CreateSpotLight
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.SpotLight'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ISpotLight;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.SpotLight do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateSpotLight (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISpotLight := new WinRt.Windows.UI.Composition.ISpotLight;
         Retval.m_ISpotLight.all := m_ComRetVal;
      end return;
   end;

   function CreateStepEasingFunction
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.StepEasingFunction'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IStepEasingFunction;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.StepEasingFunction do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateStepEasingFunction (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStepEasingFunction := new WinRt.Windows.UI.Composition.IStepEasingFunction;
         Retval.m_IStepEasingFunction.all := m_ComRetVal;
      end return;
   end;

   function CreateStepEasingFunction
   (
      this : in out Compositor;
      stepCount : WinRt.Int32
   )
   return WinRt.Windows.UI.Composition.StepEasingFunction'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IStepEasingFunction;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor2, WinRt.Windows.UI.Composition.IID_ICompositor2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.StepEasingFunction do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateStepEasingFunction (stepCount, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStepEasingFunction := new WinRt.Windows.UI.Composition.IStepEasingFunction;
         Retval.m_IStepEasingFunction.all := m_ComRetVal;
      end return;
   end;

   function CreateHostBackdropBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionBackdropBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBackdropBrush;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor3, WinRt.Windows.UI.Composition.IID_ICompositor3'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBackdropBrush do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateHostBackdropBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBackdropBrush := new WinRt.Windows.UI.Composition.ICompositionBackdropBrush;
         Retval.m_ICompositionBackdropBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateColorGradientStop
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor4, WinRt.Windows.UI.Composition.IID_ICompositor4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorGradientStop do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateColorGradientStop (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorGradientStop := new WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
         Retval.m_ICompositionColorGradientStop.all := m_ComRetVal;
      end return;
   end;

   function CreateColorGradientStop
   (
      this : in out Compositor;
      offset : WinRt.Single;
      color : WinRt.Windows.UI.Color
   )
   return WinRt.Windows.UI.Composition.CompositionColorGradientStop'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor4, WinRt.Windows.UI.Composition.IID_ICompositor4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionColorGradientStop do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateColorGradientStop (offset, color, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionColorGradientStop := new WinRt.Windows.UI.Composition.ICompositionColorGradientStop;
         Retval.m_ICompositionColorGradientStop.all := m_ComRetVal;
      end return;
   end;

   function CreateLinearGradientBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionLinearGradientBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionLinearGradientBrush;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor4, WinRt.Windows.UI.Composition.IID_ICompositor4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionLinearGradientBrush do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateLinearGradientBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionLinearGradientBrush := new WinRt.Windows.UI.Composition.ICompositionLinearGradientBrush;
         Retval.m_ICompositionLinearGradientBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateSpringScalarAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.SpringScalarNaturalMotionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ISpringScalarNaturalMotionAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor4, WinRt.Windows.UI.Composition.IID_ICompositor4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.SpringScalarNaturalMotionAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateSpringScalarAnimation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISpringScalarNaturalMotionAnimation := new WinRt.Windows.UI.Composition.ISpringScalarNaturalMotionAnimation;
         Retval.m_ISpringScalarNaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateSpringVector2Animation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.SpringVector2NaturalMotionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ISpringVector2NaturalMotionAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor4, WinRt.Windows.UI.Composition.IID_ICompositor4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.SpringVector2NaturalMotionAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateSpringVector2Animation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISpringVector2NaturalMotionAnimation := new WinRt.Windows.UI.Composition.ISpringVector2NaturalMotionAnimation;
         Retval.m_ISpringVector2NaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateSpringVector3Animation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.SpringVector3NaturalMotionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ISpringVector3NaturalMotionAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor4, WinRt.Windows.UI.Composition.IID_ICompositor4'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.SpringVector3NaturalMotionAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateSpringVector3Animation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISpringVector3NaturalMotionAnimation := new WinRt.Windows.UI.Composition.ISpringVector3NaturalMotionAnimation;
         Retval.m_ISpringVector3NaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   function get_Comment
   (
      this : in out Compositor
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositor.all);
      Hr := m_Interface.get_Comment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Comment
   (
      this : in out Compositor;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositor.all);
      Hr := m_Interface.put_Comment (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_GlobalPlaybackRate
   (
      this : in out Compositor
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositor.all);
      Hr := m_Interface.get_GlobalPlaybackRate (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlobalPlaybackRate
   (
      this : in out Compositor;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositor.all);
      Hr := m_Interface.put_GlobalPlaybackRate (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateBounceScalarAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.BounceScalarNaturalMotionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IBounceScalarNaturalMotionAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.BounceScalarNaturalMotionAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateBounceScalarAnimation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBounceScalarNaturalMotionAnimation := new WinRt.Windows.UI.Composition.IBounceScalarNaturalMotionAnimation;
         Retval.m_IBounceScalarNaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateBounceVector2Animation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.BounceVector2NaturalMotionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IBounceVector2NaturalMotionAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.BounceVector2NaturalMotionAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateBounceVector2Animation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBounceVector2NaturalMotionAnimation := new WinRt.Windows.UI.Composition.IBounceVector2NaturalMotionAnimation;
         Retval.m_IBounceVector2NaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateBounceVector3Animation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.BounceVector3NaturalMotionAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IBounceVector3NaturalMotionAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.BounceVector3NaturalMotionAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateBounceVector3Animation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBounceVector3NaturalMotionAnimation := new WinRt.Windows.UI.Composition.IBounceVector3NaturalMotionAnimation;
         Retval.m_IBounceVector3NaturalMotionAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateContainerShape
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionContainerShape'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionContainerShape;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionContainerShape do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateContainerShape (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionContainerShape := new WinRt.Windows.UI.Composition.ICompositionContainerShape;
         Retval.m_ICompositionContainerShape.all := m_ComRetVal;
      end return;
   end;

   function CreateEllipseGeometry
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionEllipseGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionEllipseGeometry;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionEllipseGeometry do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateEllipseGeometry (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionEllipseGeometry := new WinRt.Windows.UI.Composition.ICompositionEllipseGeometry;
         Retval.m_ICompositionEllipseGeometry.all := m_ComRetVal;
      end return;
   end;

   function CreateLineGeometry
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionLineGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionLineGeometry;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionLineGeometry do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateLineGeometry (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionLineGeometry := new WinRt.Windows.UI.Composition.ICompositionLineGeometry;
         Retval.m_ICompositionLineGeometry.all := m_ComRetVal;
      end return;
   end;

   function CreatePathGeometry
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionPathGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionPathGeometry;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionPathGeometry do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreatePathGeometry (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionPathGeometry := new WinRt.Windows.UI.Composition.ICompositionPathGeometry;
         Retval.m_ICompositionPathGeometry.all := m_ComRetVal;
      end return;
   end;

   function CreatePathGeometry
   (
      this : in out Compositor;
      path : WinRt.Windows.UI.Composition.CompositionPath'Class
   )
   return WinRt.Windows.UI.Composition.CompositionPathGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionPathGeometry;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionPathGeometry do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreatePathGeometry (path.m_ICompositionPath.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionPathGeometry := new WinRt.Windows.UI.Composition.ICompositionPathGeometry;
         Retval.m_ICompositionPathGeometry.all := m_ComRetVal;
      end return;
   end;

   function CreatePathKeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.PathKeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IPathKeyFrameAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.PathKeyFrameAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreatePathKeyFrameAnimation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPathKeyFrameAnimation := new WinRt.Windows.UI.Composition.IPathKeyFrameAnimation;
         Retval.m_IPathKeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateRectangleGeometry
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionRectangleGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionRectangleGeometry;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionRectangleGeometry do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRectangleGeometry (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionRectangleGeometry := new WinRt.Windows.UI.Composition.ICompositionRectangleGeometry;
         Retval.m_ICompositionRectangleGeometry.all := m_ComRetVal;
      end return;
   end;

   function CreateRoundedRectangleGeometry
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionRoundedRectangleGeometry'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionRoundedRectangleGeometry;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionRoundedRectangleGeometry do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRoundedRectangleGeometry (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionRoundedRectangleGeometry := new WinRt.Windows.UI.Composition.ICompositionRoundedRectangleGeometry;
         Retval.m_ICompositionRoundedRectangleGeometry.all := m_ComRetVal;
      end return;
   end;

   function CreateShapeVisual
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.ShapeVisual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IShapeVisual;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.ShapeVisual do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateShapeVisual (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IShapeVisual := new WinRt.Windows.UI.Composition.IShapeVisual;
         Retval.m_IShapeVisual.all := m_ComRetVal;
      end return;
   end;

   function CreateSpriteShape
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionSpriteShape'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionSpriteShape;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionSpriteShape do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateSpriteShape (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionSpriteShape := new WinRt.Windows.UI.Composition.ICompositionSpriteShape;
         Retval.m_ICompositionSpriteShape.all := m_ComRetVal;
      end return;
   end;

   function CreateSpriteShape
   (
      this : in out Compositor;
      geometry : WinRt.Windows.UI.Composition.CompositionGeometry'Class
   )
   return WinRt.Windows.UI.Composition.CompositionSpriteShape'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionSpriteShape;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionSpriteShape do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateSpriteShape (geometry.m_ICompositionGeometry.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionSpriteShape := new WinRt.Windows.UI.Composition.ICompositionSpriteShape;
         Retval.m_ICompositionSpriteShape.all := m_ComRetVal;
      end return;
   end;

   function CreateViewBox
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionViewBox'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionViewBox;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionViewBox do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateViewBox (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionViewBox := new WinRt.Windows.UI.Composition.ICompositionViewBox;
         Retval.m_ICompositionViewBox.all := m_ComRetVal;
      end return;
   end;

   procedure RequestCommitAsync
   (
      this : in out Compositor
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor5 := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor5, WinRt.Windows.UI.Composition.IID_ICompositor5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositor.all);
      Hr := m_Interface.RequestCommitAsync (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function CreateGeometricClip
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionGeometricClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionGeometricClip;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor6, WinRt.Windows.UI.Composition.IID_ICompositor6'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionGeometricClip do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateGeometricClip (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionGeometricClip := new WinRt.Windows.UI.Composition.ICompositionGeometricClip;
         Retval.m_ICompositionGeometricClip.all := m_ComRetVal;
      end return;
   end;

   function CreateGeometricClip
   (
      this : in out Compositor;
      geometry : WinRt.Windows.UI.Composition.CompositionGeometry'Class
   )
   return WinRt.Windows.UI.Composition.CompositionGeometricClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionGeometricClip;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor6, WinRt.Windows.UI.Composition.IID_ICompositor6'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionGeometricClip do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateGeometricClip (geometry.m_ICompositionGeometry.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionGeometricClip := new WinRt.Windows.UI.Composition.ICompositionGeometricClip;
         Retval.m_ICompositionGeometricClip.all := m_ComRetVal;
      end return;
   end;

   function CreateRedirectVisual
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.RedirectVisual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IRedirectVisual;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor6, WinRt.Windows.UI.Composition.IID_ICompositor6'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.RedirectVisual do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRedirectVisual (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRedirectVisual := new WinRt.Windows.UI.Composition.IRedirectVisual;
         Retval.m_IRedirectVisual.all := m_ComRetVal;
      end return;
   end;

   function CreateRedirectVisual
   (
      this : in out Compositor;
      source : WinRt.Windows.UI.Composition.Visual'Class
   )
   return WinRt.Windows.UI.Composition.RedirectVisual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IRedirectVisual;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor6, WinRt.Windows.UI.Composition.IID_ICompositor6'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.RedirectVisual do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRedirectVisual (source.m_IVisual.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRedirectVisual := new WinRt.Windows.UI.Composition.IRedirectVisual;
         Retval.m_IRedirectVisual.all := m_ComRetVal;
      end return;
   end;

   function CreateBooleanKeyFrameAnimation
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.BooleanKeyFrameAnimation'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor6 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IBooleanKeyFrameAnimation;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor6, WinRt.Windows.UI.Composition.IID_ICompositor6'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.BooleanKeyFrameAnimation do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateBooleanKeyFrameAnimation (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBooleanKeyFrameAnimation := new WinRt.Windows.UI.Composition.IBooleanKeyFrameAnimation;
         Retval.m_IBooleanKeyFrameAnimation.all := m_ComRetVal;
      end return;
   end;

   function CreateProjectedShadowCaster
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositorWithProjectedShadow := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionProjectedShadowCaster;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositorWithProjectedShadow, WinRt.Windows.UI.Composition.IID_ICompositorWithProjectedShadow'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionProjectedShadowCaster do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateProjectedShadowCaster (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionProjectedShadowCaster := new WinRt.Windows.UI.Composition.ICompositionProjectedShadowCaster;
         Retval.m_ICompositionProjectedShadowCaster.all := m_ComRetVal;
      end return;
   end;

   function CreateProjectedShadow
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionProjectedShadow'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositorWithProjectedShadow := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionProjectedShadow;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositorWithProjectedShadow, WinRt.Windows.UI.Composition.IID_ICompositorWithProjectedShadow'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionProjectedShadow do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateProjectedShadow (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionProjectedShadow := new WinRt.Windows.UI.Composition.ICompositionProjectedShadow;
         Retval.m_ICompositionProjectedShadow.all := m_ComRetVal;
      end return;
   end;

   function CreateProjectedShadowReceiver
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiver'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositorWithProjectedShadow := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionProjectedShadowReceiver;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositorWithProjectedShadow, WinRt.Windows.UI.Composition.IID_ICompositorWithProjectedShadow'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionProjectedShadowReceiver do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateProjectedShadowReceiver (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionProjectedShadowReceiver := new WinRt.Windows.UI.Composition.ICompositionProjectedShadowReceiver;
         Retval.m_ICompositionProjectedShadowReceiver.all := m_ComRetVal;
      end return;
   end;

   function CreateRadialGradientBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionRadialGradientBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositorWithRadialGradient := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionRadialGradientBrush;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositorWithRadialGradient, WinRt.Windows.UI.Composition.IID_ICompositorWithRadialGradient'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionRadialGradientBrush do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRadialGradientBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionRadialGradientBrush := new WinRt.Windows.UI.Composition.ICompositionRadialGradientBrush;
         Retval.m_ICompositionRadialGradientBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateVisualSurface
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionVisualSurface'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositorWithVisualSurface := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionVisualSurface;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositorWithVisualSurface, WinRt.Windows.UI.Composition.IID_ICompositorWithVisualSurface'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionVisualSurface do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateVisualSurface (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionVisualSurface := new WinRt.Windows.UI.Composition.ICompositionVisualSurface;
         Retval.m_ICompositionVisualSurface.all := m_ComRetVal;
      end return;
   end;

   function get_DispatcherQueue
   (
      this : in out Compositor
   )
   return WinRt.Windows.System.DispatcherQueue'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor7 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.System.IDispatcherQueue;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor7, WinRt.Windows.UI.Composition.IID_ICompositor7'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.System.DispatcherQueue do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.get_DispatcherQueue (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new WinRt.Windows.System.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   function CreateAnimationPropertyInfo
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.AnimationPropertyInfo'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor7 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IAnimationPropertyInfo;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor7, WinRt.Windows.UI.Composition.IID_ICompositor7'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.AnimationPropertyInfo do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateAnimationPropertyInfo (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAnimationPropertyInfo := new WinRt.Windows.UI.Composition.IAnimationPropertyInfo;
         Retval.m_IAnimationPropertyInfo.all := m_ComRetVal;
      end return;
   end;

   function CreateRectangleClip
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.RectangleClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor7 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IRectangleClip;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor7, WinRt.Windows.UI.Composition.IID_ICompositor7'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.RectangleClip do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRectangleClip (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRectangleClip := new WinRt.Windows.UI.Composition.IRectangleClip;
         Retval.m_IRectangleClip.all := m_ComRetVal;
      end return;
   end;

   function CreateRectangleClip
   (
      this : in out Compositor;
      left : WinRt.Single;
      top : WinRt.Single;
      right : WinRt.Single;
      bottom : WinRt.Single
   )
   return WinRt.Windows.UI.Composition.RectangleClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor7 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IRectangleClip;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor7, WinRt.Windows.UI.Composition.IID_ICompositor7'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.RectangleClip do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRectangleClip (left, top, right, bottom, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRectangleClip := new WinRt.Windows.UI.Composition.IRectangleClip;
         Retval.m_IRectangleClip.all := m_ComRetVal;
      end return;
   end;

   function CreateRectangleClip
   (
      this : in out Compositor;
      left : WinRt.Single;
      top : WinRt.Single;
      right : WinRt.Single;
      bottom : WinRt.Single;
      topLeftRadius : WinRt.Windows.Foundation.Numerics.Vector2;
      topRightRadius : WinRt.Windows.Foundation.Numerics.Vector2;
      bottomRightRadius : WinRt.Windows.Foundation.Numerics.Vector2;
      bottomLeftRadius : WinRt.Windows.Foundation.Numerics.Vector2
   )
   return WinRt.Windows.UI.Composition.RectangleClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor7 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IRectangleClip;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor7, WinRt.Windows.UI.Composition.IID_ICompositor7'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.RectangleClip do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateRectangleClip (left, top, right, bottom, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRectangleClip := new WinRt.Windows.UI.Composition.IRectangleClip;
         Retval.m_IRectangleClip.all := m_ComRetVal;
      end return;
   end;

   function TryCreateBlurredWallpaperBackdropBrush
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.CompositionBackdropBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositorWithBlurredWallpaperBackdropBrush := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBackdropBrush;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositorWithBlurredWallpaperBackdropBrush, WinRt.Windows.UI.Composition.IID_ICompositorWithBlurredWallpaperBackdropBrush'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBackdropBrush do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.TryCreateBlurredWallpaperBackdropBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBackdropBrush := new WinRt.Windows.UI.Composition.ICompositionBackdropBrush;
         Retval.m_ICompositionBackdropBrush.all := m_ComRetVal;
      end return;
   end;

   function CreateAnimationController
   (
      this : in out Compositor
   )
   return WinRt.Windows.UI.Composition.AnimationController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ICompositor8 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IAnimationController;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.UI.Composition.ICompositor8, WinRt.Windows.UI.Composition.IID_ICompositor8'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.AnimationController do
         m_Interface := QInterface (this.m_ICompositor.all);
         Hr := m_Interface.CreateAnimationController (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAnimationController := new WinRt.Windows.UI.Composition.IAnimationController;
         Retval.m_IAnimationController.all := m_ComRetVal;
      end return;
   end;

   procedure Close
   (
      this : in out Compositor
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ICompositor_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICompositor.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Visual

   procedure Initialize (this : in out Visual) is
   begin
      null;
   end;

   procedure Finalize (this : in out Visual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisual, IVisual_Ptr);
   begin
      if this.m_IVisual /= null then
         if this.m_IVisual.all /= null then
            temp := this.m_IVisual.all.Release;
            Free (this.m_IVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Visual

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Visual

   function get_AnchorPoint
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IVisual.all.get_AnchorPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AnchorPoint
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_AnchorPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackfaceVisibility
   (
      this : in out Visual
   )
   return WinRt.Windows.UI.Composition.CompositionBackfaceVisibility is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionBackfaceVisibility;
   begin
      Hr := this.m_IVisual.all.get_BackfaceVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackfaceVisibility
   (
      this : in out Visual;
      value : WinRt.Windows.UI.Composition.CompositionBackfaceVisibility
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_BackfaceVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderMode
   (
      this : in out Visual
   )
   return WinRt.Windows.UI.Composition.CompositionBorderMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionBorderMode;
   begin
      Hr := this.m_IVisual.all.get_BorderMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderMode
   (
      this : in out Visual;
      value : WinRt.Windows.UI.Composition.CompositionBorderMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_BorderMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CenterPoint
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IVisual.all.get_CenterPoint (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CenterPoint
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_CenterPoint (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Clip
   (
      this : in out Visual
   )
   return WinRt.Windows.UI.Composition.CompositionClip'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionClip;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionClip do
         Hr := this.m_IVisual.all.get_Clip (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionClip := new WinRt.Windows.UI.Composition.ICompositionClip;
         Retval.m_ICompositionClip.all := m_ComRetVal;
      end return;
   end;

   procedure put_Clip
   (
      this : in out Visual;
      value : WinRt.Windows.UI.Composition.CompositionClip'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_Clip (value.m_ICompositionClip.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompositeMode
   (
      this : in out Visual
   )
   return WinRt.Windows.UI.Composition.CompositionCompositeMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionCompositeMode;
   begin
      Hr := this.m_IVisual.all.get_CompositeMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompositeMode
   (
      this : in out Visual;
      value : WinRt.Windows.UI.Composition.CompositionCompositeMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_CompositeMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVisible
   (
      this : in out Visual
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IVisual.all.get_IsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVisible
   (
      this : in out Visual;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_IsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IVisual.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Opacity
   (
      this : in out Visual
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IVisual.all.get_Opacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Opacity
   (
      this : in out Visual;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_Opacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Quaternion is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Quaternion;
   begin
      Hr := this.m_IVisual.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Quaternion
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Parent
   (
      this : in out Visual
   )
   return WinRt.Windows.UI.Composition.ContainerVisual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IContainerVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.ContainerVisual do
         Hr := this.m_IVisual.all.get_Parent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContainerVisual := new WinRt.Windows.UI.Composition.IContainerVisual;
         Retval.m_IContainerVisual.all := m_ComRetVal;
      end return;
   end;

   function get_RotationAngle
   (
      this : in out Visual
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IVisual.all.get_RotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngle
   (
      this : in out Visual;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_RotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAngleInDegrees
   (
      this : in out Visual
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IVisual.all.get_RotationAngleInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAngleInDegrees
   (
      this : in out Visual;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_RotationAngleInDegrees (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RotationAxis
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IVisual.all.get_RotationAxis (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationAxis
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_RotationAxis (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scale
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IVisual.all.get_Scale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scale
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_Scale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Size
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IVisual.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Size
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_Size (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransformMatrix
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Matrix4x4 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Matrix4x4;
   begin
      Hr := this.m_IVisual.all.get_TransformMatrix (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TransformMatrix
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Matrix4x4
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisual.all.put_TransformMatrix (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ParentForTransform
   (
      this : in out Visual
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual2, WinRt.Windows.UI.Composition.IID_IVisual2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         m_Interface := QInterface (this.m_IVisual.all);
         Hr := m_Interface.get_ParentForTransform (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_ParentForTransform
   (
      this : in out Visual;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual2, WinRt.Windows.UI.Composition.IID_IVisual2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.put_ParentForTransform (value.m_IVisual.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RelativeOffsetAdjustment
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual2, WinRt.Windows.UI.Composition.IID_IVisual2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.get_RelativeOffsetAdjustment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RelativeOffsetAdjustment
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual2, WinRt.Windows.UI.Composition.IID_IVisual2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.put_RelativeOffsetAdjustment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RelativeSizeAdjustment
   (
      this : in out Visual
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual2, WinRt.Windows.UI.Composition.IID_IVisual2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.get_RelativeSizeAdjustment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RelativeSizeAdjustment
   (
      this : in out Visual;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual2, WinRt.Windows.UI.Composition.IID_IVisual2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.put_RelativeSizeAdjustment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHitTestVisible
   (
      this : in out Visual
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual3, WinRt.Windows.UI.Composition.IID_IVisual3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.get_IsHitTestVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHitTestVisible
   (
      this : in out Visual;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual3, WinRt.Windows.UI.Composition.IID_IVisual3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.put_IsHitTestVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPixelSnappingEnabled
   (
      this : in out Visual
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual4 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual4, WinRt.Windows.UI.Composition.IID_IVisual4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.get_IsPixelSnappingEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPixelSnappingEnabled
   (
      this : in out Visual;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IVisual4 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisual_Interface, WinRt.Windows.UI.Composition.IVisual4, WinRt.Windows.UI.Composition.IID_IVisual4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVisual.all);
      Hr := m_Interface.put_IsPixelSnappingEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContainerVisual

   procedure Initialize (this : in out ContainerVisual) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContainerVisual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContainerVisual, IContainerVisual_Ptr);
   begin
      if this.m_IContainerVisual /= null then
         if this.m_IContainerVisual.all /= null then
            temp := this.m_IContainerVisual.all.Release;
            Free (this.m_IContainerVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContainerVisual

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContainerVisual

   function get_Children
   (
      this : in out ContainerVisual
   )
   return WinRt.Windows.UI.Composition.VisualCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisualCollection;
   begin
      return RetVal : WinRt.Windows.UI.Composition.VisualCollection do
         Hr := this.m_IContainerVisual.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisualCollection := new WinRt.Windows.UI.Composition.IVisualCollection;
         Retval.m_IVisualCollection.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CubicBezierEasingFunction

   procedure Initialize (this : in out CubicBezierEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out CubicBezierEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICubicBezierEasingFunction, ICubicBezierEasingFunction_Ptr);
   begin
      if this.m_ICubicBezierEasingFunction /= null then
         if this.m_ICubicBezierEasingFunction.all /= null then
            temp := this.m_ICubicBezierEasingFunction.all.Release;
            Free (this.m_ICubicBezierEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CubicBezierEasingFunction

   function get_ControlPoint1
   (
      this : in out CubicBezierEasingFunction
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICubicBezierEasingFunction.all.get_ControlPoint1 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ControlPoint2
   (
      this : in out CubicBezierEasingFunction
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_ICubicBezierEasingFunction.all.get_ControlPoint2 (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DelegatedInkTrailVisual

   procedure Initialize (this : in out DelegatedInkTrailVisual) is
   begin
      null;
   end;

   procedure Finalize (this : in out DelegatedInkTrailVisual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDelegatedInkTrailVisual, IDelegatedInkTrailVisual_Ptr);
   begin
      if this.m_IDelegatedInkTrailVisual /= null then
         if this.m_IDelegatedInkTrailVisual.all /= null then
            temp := this.m_IDelegatedInkTrailVisual.all.Release;
            Free (this.m_IDelegatedInkTrailVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DelegatedInkTrailVisual

   function Create
   (
      compositor_p : WinRt.Windows.UI.Composition.Compositor'Class
   )
   return WinRt.Windows.UI.Composition.DelegatedInkTrailVisual is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.DelegatedInkTrailVisual");
      m_Factory        : access WinRt.Windows.UI.Composition.IDelegatedInkTrailVisualStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IDelegatedInkTrailVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.DelegatedInkTrailVisual do
         Hr := RoGetActivationFactory (m_hString, IID_IDelegatedInkTrailVisualStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (compositor_p.m_ICompositor.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDelegatedInkTrailVisual := new WinRt.Windows.UI.Composition.IDelegatedInkTrailVisual;
            Retval.m_IDelegatedInkTrailVisual.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function CreateForSwapChain
   (
      compositor_p : WinRt.Windows.UI.Composition.Compositor'Class;
      swapChain : WinRt.Windows.UI.Composition.ICompositionSurface
   )
   return WinRt.Windows.UI.Composition.DelegatedInkTrailVisual is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Composition.DelegatedInkTrailVisual");
      m_Factory        : access WinRt.Windows.UI.Composition.IDelegatedInkTrailVisualStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IDelegatedInkTrailVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.DelegatedInkTrailVisual do
         Hr := RoGetActivationFactory (m_hString, IID_IDelegatedInkTrailVisualStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForSwapChain (compositor_p.m_ICompositor.all, swapChain, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDelegatedInkTrailVisual := new WinRt.Windows.UI.Composition.IDelegatedInkTrailVisual;
            Retval.m_IDelegatedInkTrailVisual.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DelegatedInkTrailVisual

   function AddTrailPoints
   (
      this : in out DelegatedInkTrailVisual;
      inkPoints : WinRt.Windows.UI.Composition.InkTrailPoint_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function Convert_inkPoints is new Ada.Unchecked_Conversion (Address, WinRt.Windows.UI.Composition.InkTrailPoint_Ptr);
   begin
      Hr := this.m_IDelegatedInkTrailVisual.all.AddTrailPoints (WinRt.UInt32(inkPoints'Length), Convert_inkPoints (inkPoints (inkPoints'First)'Address), m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function AddTrailPointsWithPrediction
   (
      this : in out DelegatedInkTrailVisual;
      inkPoints : WinRt.Windows.UI.Composition.InkTrailPoint_Array;
      predictedInkPoints : WinRt.Windows.UI.Composition.InkTrailPoint_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function Convert_inkPoints is new Ada.Unchecked_Conversion (Address, WinRt.Windows.UI.Composition.InkTrailPoint_Ptr);
      function Convert_predictedInkPoints is new Ada.Unchecked_Conversion (Address, WinRt.Windows.UI.Composition.InkTrailPoint_Ptr);
   begin
      Hr := this.m_IDelegatedInkTrailVisual.all.AddTrailPointsWithPrediction (WinRt.UInt32(inkPoints'Length), Convert_inkPoints (inkPoints (inkPoints'First)'Address), WinRt.UInt32(predictedInkPoints'Length), Convert_predictedInkPoints (predictedInkPoints (predictedInkPoints'First)'Address), m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure RemoveTrailPoints
   (
      this : in out DelegatedInkTrailVisual;
      generationId : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDelegatedInkTrailVisual.all.RemoveTrailPoints (generationId);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartNewTrail
   (
      this : in out DelegatedInkTrailVisual;
      color : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDelegatedInkTrailVisual.all.StartNewTrail (color);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DistantLight

   procedure Initialize (this : in out DistantLight) is
   begin
      null;
   end;

   procedure Finalize (this : in out DistantLight) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDistantLight, IDistantLight_Ptr);
   begin
      if this.m_IDistantLight /= null then
         if this.m_IDistantLight.all /= null then
            temp := this.m_IDistantLight.all.Release;
            Free (this.m_IDistantLight);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DistantLight

   function get_Color
   (
      this : in out DistantLight
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_IDistantLight.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out DistantLight;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDistantLight.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CoordinateSpace
   (
      this : in out DistantLight
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_IDistantLight.all.get_CoordinateSpace (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_CoordinateSpace
   (
      this : in out DistantLight;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDistantLight.all.put_CoordinateSpace (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Direction
   (
      this : in out DistantLight
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IDistantLight.all.get_Direction (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Direction
   (
      this : in out DistantLight;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDistantLight.all.put_Direction (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Intensity
   (
      this : in out DistantLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IDistantLight2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IDistantLight_Interface, WinRt.Windows.UI.Composition.IDistantLight2, WinRt.Windows.UI.Composition.IID_IDistantLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDistantLight.all);
      Hr := m_Interface.get_Intensity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Intensity
   (
      this : in out DistantLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IDistantLight2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IDistantLight_Interface, WinRt.Windows.UI.Composition.IDistantLight2, WinRt.Windows.UI.Composition.IID_IDistantLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDistantLight.all);
      Hr := m_Interface.put_Intensity (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DropShadow

   procedure Initialize (this : in out DropShadow) is
   begin
      null;
   end;

   procedure Finalize (this : in out DropShadow) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDropShadow, IDropShadow_Ptr);
   begin
      if this.m_IDropShadow /= null then
         if this.m_IDropShadow.all /= null then
            temp := this.m_IDropShadow.all.Release;
            Free (this.m_IDropShadow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DropShadow

   function get_BlurRadius
   (
      this : in out DropShadow
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IDropShadow.all.get_BlurRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BlurRadius
   (
      this : in out DropShadow;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDropShadow.all.put_BlurRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Color
   (
      this : in out DropShadow
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_IDropShadow.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out DropShadow;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDropShadow.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Mask
   (
      this : in out DropShadow
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_IDropShadow.all.get_Mask (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Mask
   (
      this : in out DropShadow;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDropShadow.all.put_Mask (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out DropShadow
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IDropShadow.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out DropShadow;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDropShadow.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Opacity
   (
      this : in out DropShadow
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IDropShadow.all.get_Opacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Opacity
   (
      this : in out DropShadow;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDropShadow.all.put_Opacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SourcePolicy
   (
      this : in out DropShadow
   )
   return WinRt.Windows.UI.Composition.CompositionDropShadowSourcePolicy is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IDropShadow2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionDropShadowSourcePolicy;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IDropShadow_Interface, WinRt.Windows.UI.Composition.IDropShadow2, WinRt.Windows.UI.Composition.IID_IDropShadow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDropShadow.all);
      Hr := m_Interface.get_SourcePolicy (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourcePolicy
   (
      this : in out DropShadow;
      value : WinRt.Windows.UI.Composition.CompositionDropShadowSourcePolicy
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IDropShadow2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IDropShadow_Interface, WinRt.Windows.UI.Composition.IDropShadow2, WinRt.Windows.UI.Composition.IID_IDropShadow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDropShadow.all);
      Hr := m_Interface.put_SourcePolicy (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ElasticEasingFunction

   procedure Initialize (this : in out ElasticEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out ElasticEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IElasticEasingFunction, IElasticEasingFunction_Ptr);
   begin
      if this.m_IElasticEasingFunction /= null then
         if this.m_IElasticEasingFunction.all /= null then
            temp := this.m_IElasticEasingFunction.all.Release;
            Free (this.m_IElasticEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ElasticEasingFunction

   function get_Mode
   (
      this : in out ElasticEasingFunction
   )
   return WinRt.Windows.UI.Composition.CompositionEasingFunctionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
   begin
      Hr := this.m_IElasticEasingFunction.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Oscillations
   (
      this : in out ElasticEasingFunction
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IElasticEasingFunction.all.get_Oscillations (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Springiness
   (
      this : in out ElasticEasingFunction
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IElasticEasingFunction.all.get_Springiness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExponentialEasingFunction

   procedure Initialize (this : in out ExponentialEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExponentialEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExponentialEasingFunction, IExponentialEasingFunction_Ptr);
   begin
      if this.m_IExponentialEasingFunction /= null then
         if this.m_IExponentialEasingFunction.all /= null then
            temp := this.m_IExponentialEasingFunction.all.Release;
            Free (this.m_IExponentialEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExponentialEasingFunction

   function get_Mode
   (
      this : in out ExponentialEasingFunction
   )
   return WinRt.Windows.UI.Composition.CompositionEasingFunctionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
   begin
      Hr := this.m_IExponentialEasingFunction.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Exponent
   (
      this : in out ExponentialEasingFunction
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IExponentialEasingFunction.all.get_Exponent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ExpressionAnimation

   procedure Initialize (this : in out ExpressionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out ExpressionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IExpressionAnimation, IExpressionAnimation_Ptr);
   begin
      if this.m_IExpressionAnimation /= null then
         if this.m_IExpressionAnimation.all /= null then
            temp := this.m_IExpressionAnimation.all.Release;
            Free (this.m_IExpressionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ExpressionAnimation

   function get_Expression
   (
      this : in out ExpressionAnimation
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IExpressionAnimation.all.get_Expression (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Expression
   (
      this : in out ExpressionAnimation;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IExpressionAnimation.all.put_Expression (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ImplicitAnimationCollection

   procedure Initialize (this : in out ImplicitAnimationCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out ImplicitAnimationCollection) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IImplicitAnimationCollection, IImplicitAnimationCollection_Ptr);
   begin
      if this.m_IImplicitAnimationCollection /= null then
         if this.m_IImplicitAnimationCollection.all /= null then
            temp := this.m_IImplicitAnimationCollection.all.Release;
            Free (this.m_IImplicitAnimationCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ImplicitAnimationCollection

   -- Generic Interface Windows.Foundation.Collections.IMap`2<System.String,Windows.UI.Composition.ICompositionAnimationBase>
   function Lookup
   (
      this : in out ImplicitAnimationCollection;
      key : WinRt.WString
   )
   return WinRt.Windows.UI.Composition.ICompositionAnimationBase is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_ICompositionAnimationBase.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionAnimationBase;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1269410333, 22444, 21726, (168, 7, 181, 46, 104, 155, 252, 4 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IImplicitAnimationCollection_Interface, IMap_HString_ICompositionAnimationBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IImplicitAnimationCollection.all);
      Hr := m_Interface.Lookup (HStr_key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out ImplicitAnimationCollection
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_ICompositionAnimationBase.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (1269410333, 22444, 21726, (168, 7, 181, 46, 104, 155, 252, 4 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IImplicitAnimationCollection_Interface, IMap_HString_ICompositionAnimationBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IImplicitAnimationCollection.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function HasKey
   (
      this : in out ImplicitAnimationCollection;
      key : WinRt.WString
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_ICompositionAnimationBase.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1269410333, 22444, 21726, (168, 7, 181, 46, 104, 155, 252, 4 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IImplicitAnimationCollection_Interface, IMap_HString_ICompositionAnimationBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IImplicitAnimationCollection.all);
      Hr := m_Interface.HasKey (HStr_key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ImplicitAnimationCollection
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_ICompositionAnimationBase.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericIID     : aliased WinRt.IID := (1269410333, 22444, 21726, (168, 7, 181, 46, 104, 155, 252, 4 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IImplicitAnimationCollection_Interface, IMap_HString_ICompositionAnimationBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IImplicitAnimationCollection.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Insert
   (
      this : in out ImplicitAnimationCollection;
      key : WinRt.WString;
      value : WinRt.Windows.UI.Composition.ICompositionAnimationBase
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_ICompositionAnimationBase.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1269410333, 22444, 21726, (168, 7, 181, 46, 104, 155, 252, 4 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IImplicitAnimationCollection_Interface, IMap_HString_ICompositionAnimationBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IImplicitAnimationCollection.all);
      Hr := m_Interface.Insert (HStr_key, value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   procedure Remove
   (
      this : in out ImplicitAnimationCollection;
      key : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_ICompositionAnimationBase.Kind := null;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (1269410333, 22444, 21726, (168, 7, 181, 46, 104, 155, 252, 4 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IImplicitAnimationCollection_Interface, IMap_HString_ICompositionAnimationBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IImplicitAnimationCollection.all);
      Hr := m_Interface.Remove (HStr_key);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure Clear
   (
      this : in out ImplicitAnimationCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_ICompositionAnimationBase.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (1269410333, 22444, 21726, (168, 7, 181, 46, 104, 155, 252, 4 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IImplicitAnimationCollection_Interface, IMap_HString_ICompositionAnimationBase.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IImplicitAnimationCollection.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InitialValueExpressionCollection

   procedure Initialize (this : in out InitialValueExpressionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out InitialValueExpressionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InitialValueExpressionCollection

   -- Generic Interface Windows.Foundation.Collections.IMap`2<System.String,System.String>
   function Lookup
   (
      this : in out InitialValueExpressionCollection;
      key : WinRt.WString
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_HString.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (4140955392, 18882, 21166, (129, 84, 130, 111, 153, 8, 119, 60 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IMap_HString_HString.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Lookup (HStr_key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Size
   (
      this : in out InitialValueExpressionCollection
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_HString.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (4140955392, 18882, 21166, (129, 84, 130, 111, 153, 8, 119, 60 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IMap_HString_HString.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function HasKey
   (
      this : in out InitialValueExpressionCollection;
      key : WinRt.WString
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_HString.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (4140955392, 18882, 21166, (129, 84, 130, 111, 153, 8, 119, 60 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IMap_HString_HString.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.HasKey (HStr_key, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out InitialValueExpressionCollection
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_HString.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
      m_GenericIID     : aliased WinRt.IID := (4140955392, 18882, 21166, (129, 84, 130, 111, 153, 8, 119, 60 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IMap_HString_HString.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Insert
   (
      this : in out InitialValueExpressionCollection;
      key : WinRt.WString;
      value : WinRt.WString
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_HString.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      HStr_key : constant WinRt.HString := To_HString (key);
      HStr_value : constant WinRt.HString := To_HString (value);
      m_GenericIID     : aliased WinRt.IID := (4140955392, 18882, 21166, (129, 84, 130, 111, 153, 8, 119, 60 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IMap_HString_HString.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Insert (HStr_key, HStr_value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
      tmp := WindowsDeleteString (HStr_value);
      return m_ComRetVal;
   end;

   procedure Remove
   (
      this : in out InitialValueExpressionCollection;
      key : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_HString.Kind := null;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
      m_GenericIID     : aliased WinRt.IID := (4140955392, 18882, 21166, (129, 84, 130, 111, 153, 8, 119, 60 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IMap_HString_HString.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Remove (HStr_key);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_key);
   end;

   procedure Clear
   (
      this : in out InitialValueExpressionCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IMap_HString_HString.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_GenericIID     : aliased WinRt.IID := (4140955392, 18882, 21166, (129, 84, 130, 111, 153, 8, 119, 60 ));
      function QInterface is new Generic_QueryInterface (WinRt.GenericObject_Interface, IMap_HString_HString.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InsetClip

   procedure Initialize (this : in out InsetClip) is
   begin
      null;
   end;

   procedure Finalize (this : in out InsetClip) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInsetClip, IInsetClip_Ptr);
   begin
      if this.m_IInsetClip /= null then
         if this.m_IInsetClip.all /= null then
            temp := this.m_IInsetClip.all.Release;
            Free (this.m_IInsetClip);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InsetClip

   function get_BottomInset
   (
      this : in out InsetClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInsetClip.all.get_BottomInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BottomInset
   (
      this : in out InsetClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInsetClip.all.put_BottomInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftInset
   (
      this : in out InsetClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInsetClip.all.get_LeftInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LeftInset
   (
      this : in out InsetClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInsetClip.all.put_LeftInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightInset
   (
      this : in out InsetClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInsetClip.all.get_RightInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RightInset
   (
      this : in out InsetClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInsetClip.all.put_RightInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopInset
   (
      this : in out InsetClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IInsetClip.all.get_TopInset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TopInset
   (
      this : in out InsetClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInsetClip.all.put_TopInset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LayerVisual

   procedure Initialize (this : in out LayerVisual) is
   begin
      null;
   end;

   procedure Finalize (this : in out LayerVisual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILayerVisual, ILayerVisual_Ptr);
   begin
      if this.m_ILayerVisual /= null then
         if this.m_ILayerVisual.all /= null then
            temp := this.m_ILayerVisual.all.Release;
            Free (this.m_ILayerVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LayerVisual

   function get_Effect
   (
      this : in out LayerVisual
   )
   return WinRt.Windows.UI.Composition.CompositionEffectBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionEffectBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionEffectBrush do
         Hr := this.m_ILayerVisual.all.get_Effect (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionEffectBrush := new WinRt.Windows.UI.Composition.ICompositionEffectBrush;
         Retval.m_ICompositionEffectBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Effect
   (
      this : in out LayerVisual;
      value : WinRt.Windows.UI.Composition.CompositionEffectBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILayerVisual.all.put_Effect (value.m_ICompositionEffectBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Shadow
   (
      this : in out LayerVisual
   )
   return WinRt.Windows.UI.Composition.CompositionShadow'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ILayerVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionShadow;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ILayerVisual_Interface, WinRt.Windows.UI.Composition.ILayerVisual2, WinRt.Windows.UI.Composition.IID_ILayerVisual2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionShadow do
         m_Interface := QInterface (this.m_ILayerVisual.all);
         Hr := m_Interface.get_Shadow (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionShadow := new WinRt.Windows.UI.Composition.ICompositionShadow;
         Retval.m_ICompositionShadow.all := m_ComRetVal;
      end return;
   end;

   procedure put_Shadow
   (
      this : in out LayerVisual;
      value : WinRt.Windows.UI.Composition.CompositionShadow'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ILayerVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ILayerVisual_Interface, WinRt.Windows.UI.Composition.ILayerVisual2, WinRt.Windows.UI.Composition.IID_ILayerVisual2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILayerVisual.all);
      Hr := m_Interface.put_Shadow (value.m_ICompositionShadow.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LinearEasingFunction

   procedure Initialize (this : in out LinearEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out LinearEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILinearEasingFunction, ILinearEasingFunction_Ptr);
   begin
      if this.m_ILinearEasingFunction /= null then
         if this.m_ILinearEasingFunction.all /= null then
            temp := this.m_ILinearEasingFunction.all.Release;
            Free (this.m_ILinearEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LinearEasingFunction

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathKeyFrameAnimation

   procedure Initialize (this : in out PathKeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathKeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathKeyFrameAnimation, IPathKeyFrameAnimation_Ptr);
   begin
      if this.m_IPathKeyFrameAnimation /= null then
         if this.m_IPathKeyFrameAnimation.all /= null then
            temp := this.m_IPathKeyFrameAnimation.all.Release;
            Free (this.m_IPathKeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathKeyFrameAnimation

   procedure InsertKeyFrame
   (
      this : in out PathKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      path : WinRt.Windows.UI.Composition.CompositionPath'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPathKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, path.m_ICompositionPath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out PathKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      path : WinRt.Windows.UI.Composition.CompositionPath'Class;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPathKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, path.m_ICompositionPath.all, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointLight

   procedure Initialize (this : in out PointLight) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointLight) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointLight, IPointLight_Ptr);
   begin
      if this.m_IPointLight /= null then
         if this.m_IPointLight.all /= null then
            temp := this.m_IPointLight.all.Release;
            Free (this.m_IPointLight);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointLight

   function get_Color
   (
      this : in out PointLight
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_IPointLight.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out PointLight;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointLight.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ConstantAttenuation
   (
      this : in out PointLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointLight.all.get_ConstantAttenuation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ConstantAttenuation
   (
      this : in out PointLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointLight.all.put_ConstantAttenuation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CoordinateSpace
   (
      this : in out PointLight
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_IPointLight.all.get_CoordinateSpace (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_CoordinateSpace
   (
      this : in out PointLight;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointLight.all.put_CoordinateSpace (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LinearAttenuation
   (
      this : in out PointLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointLight.all.get_LinearAttenuation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LinearAttenuation
   (
      this : in out PointLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointLight.all.put_LinearAttenuation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out PointLight
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_IPointLight.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out PointLight;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointLight.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_QuadraticAttenuation
   (
      this : in out PointLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointLight.all.get_QuadraticAttenuation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_QuadraticAttenuation
   (
      this : in out PointLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointLight.all.put_QuadraticAttenuation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Intensity
   (
      this : in out PointLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IPointLight2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IPointLight_Interface, WinRt.Windows.UI.Composition.IPointLight2, WinRt.Windows.UI.Composition.IID_IPointLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointLight.all);
      Hr := m_Interface.get_Intensity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Intensity
   (
      this : in out PointLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IPointLight2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IPointLight_Interface, WinRt.Windows.UI.Composition.IPointLight2, WinRt.Windows.UI.Composition.IID_IPointLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointLight.all);
      Hr := m_Interface.put_Intensity (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinAttenuationCutoff
   (
      this : in out PointLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IPointLight3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IPointLight_Interface, WinRt.Windows.UI.Composition.IPointLight3, WinRt.Windows.UI.Composition.IID_IPointLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointLight.all);
      Hr := m_Interface.get_MinAttenuationCutoff (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinAttenuationCutoff
   (
      this : in out PointLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IPointLight3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IPointLight_Interface, WinRt.Windows.UI.Composition.IPointLight3, WinRt.Windows.UI.Composition.IID_IPointLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointLight.all);
      Hr := m_Interface.put_MinAttenuationCutoff (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxAttenuationCutoff
   (
      this : in out PointLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IPointLight3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IPointLight_Interface, WinRt.Windows.UI.Composition.IPointLight3, WinRt.Windows.UI.Composition.IID_IPointLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointLight.all);
      Hr := m_Interface.get_MaxAttenuationCutoff (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxAttenuationCutoff
   (
      this : in out PointLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.IPointLight3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IPointLight_Interface, WinRt.Windows.UI.Composition.IPointLight3, WinRt.Windows.UI.Composition.IID_IPointLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointLight.all);
      Hr := m_Interface.put_MaxAttenuationCutoff (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PowerEasingFunction

   procedure Initialize (this : in out PowerEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out PowerEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPowerEasingFunction, IPowerEasingFunction_Ptr);
   begin
      if this.m_IPowerEasingFunction /= null then
         if this.m_IPowerEasingFunction.all /= null then
            temp := this.m_IPowerEasingFunction.all.Release;
            Free (this.m_IPowerEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PowerEasingFunction

   function get_Mode
   (
      this : in out PowerEasingFunction
   )
   return WinRt.Windows.UI.Composition.CompositionEasingFunctionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
   begin
      Hr := this.m_IPowerEasingFunction.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Power
   (
      this : in out PowerEasingFunction
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPowerEasingFunction.all.get_Power (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for QuaternionKeyFrameAnimation

   procedure Initialize (this : in out QuaternionKeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out QuaternionKeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IQuaternionKeyFrameAnimation, IQuaternionKeyFrameAnimation_Ptr);
   begin
      if this.m_IQuaternionKeyFrameAnimation /= null then
         if this.m_IQuaternionKeyFrameAnimation.all /= null then
            temp := this.m_IQuaternionKeyFrameAnimation.all.Release;
            Free (this.m_IQuaternionKeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for QuaternionKeyFrameAnimation

   procedure InsertKeyFrame
   (
      this : in out QuaternionKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Quaternion
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IQuaternionKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out QuaternionKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Quaternion;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IQuaternionKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RectangleClip

   procedure Initialize (this : in out RectangleClip) is
   begin
      null;
   end;

   procedure Finalize (this : in out RectangleClip) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRectangleClip, IRectangleClip_Ptr);
   begin
      if this.m_IRectangleClip /= null then
         if this.m_IRectangleClip.all /= null then
            temp := this.m_IRectangleClip.all.Release;
            Free (this.m_IRectangleClip);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RectangleClip

   function get_Bottom
   (
      this : in out RectangleClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IRectangleClip.all.get_Bottom (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Bottom
   (
      this : in out RectangleClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_Bottom (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BottomLeftRadius
   (
      this : in out RectangleClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IRectangleClip.all.get_BottomLeftRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BottomLeftRadius
   (
      this : in out RectangleClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_BottomLeftRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BottomRightRadius
   (
      this : in out RectangleClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IRectangleClip.all.get_BottomRightRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BottomRightRadius
   (
      this : in out RectangleClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_BottomRightRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Left
   (
      this : in out RectangleClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IRectangleClip.all.get_Left (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Left
   (
      this : in out RectangleClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_Left (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Right
   (
      this : in out RectangleClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IRectangleClip.all.get_Right (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Right
   (
      this : in out RectangleClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_Right (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Top
   (
      this : in out RectangleClip
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IRectangleClip.all.get_Top (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Top
   (
      this : in out RectangleClip;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_Top (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopLeftRadius
   (
      this : in out RectangleClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IRectangleClip.all.get_TopLeftRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TopLeftRadius
   (
      this : in out RectangleClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_TopLeftRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopRightRadius
   (
      this : in out RectangleClip
   )
   return WinRt.Windows.Foundation.Numerics.Vector2 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector2;
   begin
      Hr := this.m_IRectangleClip.all.get_TopRightRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TopRightRadius
   (
      this : in out RectangleClip;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRectangleClip.all.put_TopRightRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RedirectVisual

   procedure Initialize (this : in out RedirectVisual) is
   begin
      null;
   end;

   procedure Finalize (this : in out RedirectVisual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRedirectVisual, IRedirectVisual_Ptr);
   begin
      if this.m_IRedirectVisual /= null then
         if this.m_IRedirectVisual.all /= null then
            temp := this.m_IRedirectVisual.all.Release;
            Free (this.m_IRedirectVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RedirectVisual

   function get_Source
   (
      this : in out RedirectVisual
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_IRedirectVisual.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out RedirectVisual;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRedirectVisual.all.put_Source (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RenderingDeviceReplacedEventArgs

   procedure Initialize (this : in out RenderingDeviceReplacedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RenderingDeviceReplacedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRenderingDeviceReplacedEventArgs, IRenderingDeviceReplacedEventArgs_Ptr);
   begin
      if this.m_IRenderingDeviceReplacedEventArgs /= null then
         if this.m_IRenderingDeviceReplacedEventArgs.all /= null then
            temp := this.m_IRenderingDeviceReplacedEventArgs.all.Release;
            Free (this.m_IRenderingDeviceReplacedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RenderingDeviceReplacedEventArgs

   function get_GraphicsDevice
   (
      this : in out RenderingDeviceReplacedEventArgs
   )
   return WinRt.Windows.UI.Composition.CompositionGraphicsDevice'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionGraphicsDevice;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionGraphicsDevice do
         Hr := this.m_IRenderingDeviceReplacedEventArgs.all.get_GraphicsDevice (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionGraphicsDevice := new WinRt.Windows.UI.Composition.ICompositionGraphicsDevice;
         Retval.m_ICompositionGraphicsDevice.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScalarKeyFrameAnimation

   procedure Initialize (this : in out ScalarKeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScalarKeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScalarKeyFrameAnimation, IScalarKeyFrameAnimation_Ptr);
   begin
      if this.m_IScalarKeyFrameAnimation /= null then
         if this.m_IScalarKeyFrameAnimation.all /= null then
            temp := this.m_IScalarKeyFrameAnimation.all.Release;
            Free (this.m_IScalarKeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScalarKeyFrameAnimation

   procedure InsertKeyFrame
   (
      this : in out ScalarKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScalarKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out ScalarKeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Single;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IScalarKeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ShapeVisual

   procedure Initialize (this : in out ShapeVisual) is
   begin
      null;
   end;

   procedure Finalize (this : in out ShapeVisual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IShapeVisual, IShapeVisual_Ptr);
   begin
      if this.m_IShapeVisual /= null then
         if this.m_IShapeVisual.all /= null then
            temp := this.m_IShapeVisual.all.Release;
            Free (this.m_IShapeVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ShapeVisual

   function get_Shapes
   (
      this : in out ShapeVisual
   )
   return WinRt.Windows.UI.Composition.CompositionShapeCollection'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.GenericObject;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionShapeCollection do
         Hr := this.m_IShapeVisual.all.get_Shapes (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinRt.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_ViewBox
   (
      this : in out ShapeVisual
   )
   return WinRt.Windows.UI.Composition.CompositionViewBox'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionViewBox;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionViewBox do
         Hr := this.m_IShapeVisual.all.get_ViewBox (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionViewBox := new WinRt.Windows.UI.Composition.ICompositionViewBox;
         Retval.m_ICompositionViewBox.all := m_ComRetVal;
      end return;
   end;

   procedure put_ViewBox
   (
      this : in out ShapeVisual;
      value : WinRt.Windows.UI.Composition.CompositionViewBox'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IShapeVisual.all.put_ViewBox (value.m_ICompositionViewBox.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SineEasingFunction

   procedure Initialize (this : in out SineEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out SineEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISineEasingFunction, ISineEasingFunction_Ptr);
   begin
      if this.m_ISineEasingFunction /= null then
         if this.m_ISineEasingFunction.all /= null then
            temp := this.m_ISineEasingFunction.all.Release;
            Free (this.m_ISineEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SineEasingFunction

   function get_Mode
   (
      this : in out SineEasingFunction
   )
   return WinRt.Windows.UI.Composition.CompositionEasingFunctionMode is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.CompositionEasingFunctionMode;
   begin
      Hr := this.m_ISineEasingFunction.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SpotLight

   procedure Initialize (this : in out SpotLight) is
   begin
      null;
   end;

   procedure Finalize (this : in out SpotLight) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISpotLight, ISpotLight_Ptr);
   begin
      if this.m_ISpotLight /= null then
         if this.m_ISpotLight.all /= null then
            temp := this.m_ISpotLight.all.Release;
            Free (this.m_ISpotLight);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SpotLight

   function get_ConstantAttenuation
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpotLight.all.get_ConstantAttenuation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ConstantAttenuation
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_ConstantAttenuation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CoordinateSpace
   (
      this : in out SpotLight
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         Hr := this.m_ISpotLight.all.get_CoordinateSpace (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   procedure put_CoordinateSpace
   (
      this : in out SpotLight;
      value : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_CoordinateSpace (value.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Direction
   (
      this : in out SpotLight
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISpotLight.all.get_Direction (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Direction
   (
      this : in out SpotLight;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_Direction (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InnerConeAngle
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpotLight.all.get_InnerConeAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InnerConeAngle
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_InnerConeAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InnerConeAngleInDegrees
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpotLight.all.get_InnerConeAngleInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InnerConeAngleInDegrees
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_InnerConeAngleInDegrees (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InnerConeColor
   (
      this : in out SpotLight
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_ISpotLight.all.get_InnerConeColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InnerConeColor
   (
      this : in out SpotLight;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_InnerConeColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LinearAttenuation
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpotLight.all.get_LinearAttenuation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LinearAttenuation
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_LinearAttenuation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Offset
   (
      this : in out SpotLight
   )
   return WinRt.Windows.Foundation.Numerics.Vector3 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.Numerics.Vector3;
   begin
      Hr := this.m_ISpotLight.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Offset
   (
      this : in out SpotLight;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_Offset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OuterConeAngle
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpotLight.all.get_OuterConeAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OuterConeAngle
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_OuterConeAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OuterConeAngleInDegrees
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpotLight.all.get_OuterConeAngleInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OuterConeAngleInDegrees
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_OuterConeAngleInDegrees (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OuterConeColor
   (
      this : in out SpotLight
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Color;
   begin
      Hr := this.m_ISpotLight.all.get_OuterConeColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OuterConeColor
   (
      this : in out SpotLight;
      value : WinRt.Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_OuterConeColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_QuadraticAttenuation
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpotLight.all.get_QuadraticAttenuation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_QuadraticAttenuation
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpotLight.all.put_QuadraticAttenuation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InnerConeIntensity
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight2, WinRt.Windows.UI.Composition.IID_ISpotLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.get_InnerConeIntensity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InnerConeIntensity
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight2, WinRt.Windows.UI.Composition.IID_ISpotLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.put_InnerConeIntensity (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OuterConeIntensity
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight2, WinRt.Windows.UI.Composition.IID_ISpotLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.get_OuterConeIntensity (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OuterConeIntensity
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight2, WinRt.Windows.UI.Composition.IID_ISpotLight2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.put_OuterConeIntensity (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinAttenuationCutoff
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight3, WinRt.Windows.UI.Composition.IID_ISpotLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.get_MinAttenuationCutoff (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinAttenuationCutoff
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight3, WinRt.Windows.UI.Composition.IID_ISpotLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.put_MinAttenuationCutoff (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxAttenuationCutoff
   (
      this : in out SpotLight
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight3 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight3, WinRt.Windows.UI.Composition.IID_ISpotLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.get_MaxAttenuationCutoff (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxAttenuationCutoff
   (
      this : in out SpotLight;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpotLight3 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpotLight_Interface, WinRt.Windows.UI.Composition.ISpotLight3, WinRt.Windows.UI.Composition.IID_ISpotLight3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpotLight.all);
      Hr := m_Interface.put_MaxAttenuationCutoff (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SpringScalarNaturalMotionAnimation

   procedure Initialize (this : in out SpringScalarNaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SpringScalarNaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISpringScalarNaturalMotionAnimation, ISpringScalarNaturalMotionAnimation_Ptr);
   begin
      if this.m_ISpringScalarNaturalMotionAnimation /= null then
         if this.m_ISpringScalarNaturalMotionAnimation.all /= null then
            temp := this.m_ISpringScalarNaturalMotionAnimation.all.Release;
            Free (this.m_ISpringScalarNaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SpringScalarNaturalMotionAnimation

   function get_DampingRatio
   (
      this : in out SpringScalarNaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpringScalarNaturalMotionAnimation.all.get_DampingRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DampingRatio
   (
      this : in out SpringScalarNaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpringScalarNaturalMotionAnimation.all.put_DampingRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Period
   (
      this : in out SpringScalarNaturalMotionAnimation
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ISpringScalarNaturalMotionAnimation.all.get_Period (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Period
   (
      this : in out SpringScalarNaturalMotionAnimation;
      value : WinRt.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpringScalarNaturalMotionAnimation.all.put_Period (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SpringVector2NaturalMotionAnimation

   procedure Initialize (this : in out SpringVector2NaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SpringVector2NaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISpringVector2NaturalMotionAnimation, ISpringVector2NaturalMotionAnimation_Ptr);
   begin
      if this.m_ISpringVector2NaturalMotionAnimation /= null then
         if this.m_ISpringVector2NaturalMotionAnimation.all /= null then
            temp := this.m_ISpringVector2NaturalMotionAnimation.all.Release;
            Free (this.m_ISpringVector2NaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SpringVector2NaturalMotionAnimation

   function get_DampingRatio
   (
      this : in out SpringVector2NaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpringVector2NaturalMotionAnimation.all.get_DampingRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DampingRatio
   (
      this : in out SpringVector2NaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpringVector2NaturalMotionAnimation.all.put_DampingRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Period
   (
      this : in out SpringVector2NaturalMotionAnimation
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ISpringVector2NaturalMotionAnimation.all.get_Period (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Period
   (
      this : in out SpringVector2NaturalMotionAnimation;
      value : WinRt.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpringVector2NaturalMotionAnimation.all.put_Period (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SpringVector3NaturalMotionAnimation

   procedure Initialize (this : in out SpringVector3NaturalMotionAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SpringVector3NaturalMotionAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISpringVector3NaturalMotionAnimation, ISpringVector3NaturalMotionAnimation_Ptr);
   begin
      if this.m_ISpringVector3NaturalMotionAnimation /= null then
         if this.m_ISpringVector3NaturalMotionAnimation.all /= null then
            temp := this.m_ISpringVector3NaturalMotionAnimation.all.Release;
            Free (this.m_ISpringVector3NaturalMotionAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SpringVector3NaturalMotionAnimation

   function get_DampingRatio
   (
      this : in out SpringVector3NaturalMotionAnimation
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_ISpringVector3NaturalMotionAnimation.all.get_DampingRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DampingRatio
   (
      this : in out SpringVector3NaturalMotionAnimation;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpringVector3NaturalMotionAnimation.all.put_DampingRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Period
   (
      this : in out SpringVector3NaturalMotionAnimation
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ISpringVector3NaturalMotionAnimation.all.get_Period (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Period
   (
      this : in out SpringVector3NaturalMotionAnimation;
      value : WinRt.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpringVector3NaturalMotionAnimation.all.put_Period (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SpriteVisual

   procedure Initialize (this : in out SpriteVisual) is
   begin
      null;
   end;

   procedure Finalize (this : in out SpriteVisual) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISpriteVisual, ISpriteVisual_Ptr);
   begin
      if this.m_ISpriteVisual /= null then
         if this.m_ISpriteVisual.all /= null then
            temp := this.m_ISpriteVisual.all.Release;
            Free (this.m_ISpriteVisual);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SpriteVisual

   function get_Brush
   (
      this : in out SpriteVisual
   )
   return WinRt.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionBrush;
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionBrush do
         Hr := this.m_ISpriteVisual.all.get_Brush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinRt.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Brush
   (
      this : in out SpriteVisual;
      value : WinRt.Windows.UI.Composition.CompositionBrush'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISpriteVisual.all.put_Brush (value.m_ICompositionBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Shadow
   (
      this : in out SpriteVisual
   )
   return WinRt.Windows.UI.Composition.CompositionShadow'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpriteVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.ICompositionShadow;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpriteVisual_Interface, WinRt.Windows.UI.Composition.ISpriteVisual2, WinRt.Windows.UI.Composition.IID_ISpriteVisual2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.CompositionShadow do
         m_Interface := QInterface (this.m_ISpriteVisual.all);
         Hr := m_Interface.get_Shadow (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionShadow := new WinRt.Windows.UI.Composition.ICompositionShadow;
         Retval.m_ICompositionShadow.all := m_ComRetVal;
      end return;
   end;

   procedure put_Shadow
   (
      this : in out SpriteVisual;
      value : WinRt.Windows.UI.Composition.CompositionShadow'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Composition.ISpriteVisual2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.ISpriteVisual_Interface, WinRt.Windows.UI.Composition.ISpriteVisual2, WinRt.Windows.UI.Composition.IID_ISpriteVisual2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISpriteVisual.all);
      Hr := m_Interface.put_Shadow (value.m_ICompositionShadow.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StepEasingFunction

   procedure Initialize (this : in out StepEasingFunction) is
   begin
      null;
   end;

   procedure Finalize (this : in out StepEasingFunction) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStepEasingFunction, IStepEasingFunction_Ptr);
   begin
      if this.m_IStepEasingFunction /= null then
         if this.m_IStepEasingFunction.all /= null then
            temp := this.m_IStepEasingFunction.all.Release;
            Free (this.m_IStepEasingFunction);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StepEasingFunction

   function get_FinalStep
   (
      this : in out StepEasingFunction
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IStepEasingFunction.all.get_FinalStep (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FinalStep
   (
      this : in out StepEasingFunction;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStepEasingFunction.all.put_FinalStep (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InitialStep
   (
      this : in out StepEasingFunction
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IStepEasingFunction.all.get_InitialStep (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialStep
   (
      this : in out StepEasingFunction;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStepEasingFunction.all.put_InitialStep (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFinalStepSingleFrame
   (
      this : in out StepEasingFunction
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStepEasingFunction.all.get_IsFinalStepSingleFrame (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFinalStepSingleFrame
   (
      this : in out StepEasingFunction;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStepEasingFunction.all.put_IsFinalStepSingleFrame (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInitialStepSingleFrame
   (
      this : in out StepEasingFunction
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IStepEasingFunction.all.get_IsInitialStepSingleFrame (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsInitialStepSingleFrame
   (
      this : in out StepEasingFunction;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStepEasingFunction.all.put_IsInitialStepSingleFrame (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StepCount
   (
      this : in out StepEasingFunction
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IStepEasingFunction.all.get_StepCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StepCount
   (
      this : in out StepEasingFunction;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IStepEasingFunction.all.put_StepCount (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Vector2KeyFrameAnimation

   procedure Initialize (this : in out Vector2KeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out Vector2KeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVector2KeyFrameAnimation, IVector2KeyFrameAnimation_Ptr);
   begin
      if this.m_IVector2KeyFrameAnimation /= null then
         if this.m_IVector2KeyFrameAnimation.all /= null then
            temp := this.m_IVector2KeyFrameAnimation.all.Release;
            Free (this.m_IVector2KeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Vector2KeyFrameAnimation

   procedure InsertKeyFrame
   (
      this : in out Vector2KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Vector2
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector2KeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out Vector2KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Vector2;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector2KeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Vector3KeyFrameAnimation

   procedure Initialize (this : in out Vector3KeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out Vector3KeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVector3KeyFrameAnimation, IVector3KeyFrameAnimation_Ptr);
   begin
      if this.m_IVector3KeyFrameAnimation /= null then
         if this.m_IVector3KeyFrameAnimation.all /= null then
            temp := this.m_IVector3KeyFrameAnimation.all.Release;
            Free (this.m_IVector3KeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Vector3KeyFrameAnimation

   procedure InsertKeyFrame
   (
      this : in out Vector3KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Vector3
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector3KeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out Vector3KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Vector3;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector3KeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Vector4KeyFrameAnimation

   procedure Initialize (this : in out Vector4KeyFrameAnimation) is
   begin
      null;
   end;

   procedure Finalize (this : in out Vector4KeyFrameAnimation) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVector4KeyFrameAnimation, IVector4KeyFrameAnimation_Ptr);
   begin
      if this.m_IVector4KeyFrameAnimation /= null then
         if this.m_IVector4KeyFrameAnimation.all /= null then
            temp := this.m_IVector4KeyFrameAnimation.all.Release;
            Free (this.m_IVector4KeyFrameAnimation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Vector4KeyFrameAnimation

   procedure InsertKeyFrame
   (
      this : in out Vector4KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Vector4
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector4KeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertKeyFrame
   (
      this : in out Vector4KeyFrameAnimation;
      normalizedProgressKey : WinRt.Single;
      value : WinRt.Windows.Foundation.Numerics.Vector4;
      easingFunction : WinRt.Windows.UI.Composition.CompositionEasingFunction'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVector4KeyFrameAnimation.all.InsertKeyFrame (normalizedProgressKey, value, easingFunction.m_ICompositionEasingFunction.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualCollection

   procedure Initialize (this : in out VisualCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualCollection) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualCollection, IVisualCollection_Ptr);
   begin
      if this.m_IVisualCollection /= null then
         if this.m_IVisualCollection.all /= null then
            temp := this.m_IVisualCollection.all.Release;
            Free (this.m_IVisualCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualCollection

   function get_Count
   (
      this : in out VisualCollection
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IVisualCollection.all.get_Count (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure InsertAbove
   (
      this : in out VisualCollection;
      newChild : WinRt.Windows.UI.Composition.Visual'Class;
      sibling : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualCollection.all.InsertAbove (newChild.m_IVisual.all, sibling.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAtBottom
   (
      this : in out VisualCollection;
      newChild : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualCollection.all.InsertAtBottom (newChild.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAtTop
   (
      this : in out VisualCollection;
      newChild : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualCollection.all.InsertAtTop (newChild.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertBelow
   (
      this : in out VisualCollection;
      newChild : WinRt.Windows.UI.Composition.Visual'Class;
      sibling : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualCollection.all.InsertBelow (newChild.m_IVisual.all, sibling.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Remove
   (
      this : in out VisualCollection;
      child : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualCollection.all.Remove (child.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out VisualCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualCollection.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.Visual>
   function First
   (
      this : in out VisualCollection
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_IVisual.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
      m_GenericIID     : aliased WinRt.IID := (1324187086, 58540, 22673, (155, 82, 121, 157, 112, 223, 71, 254 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisualCollection_Interface, IIterable_IVisual.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         m_Interface := QInterface (this.m_IVisualCollection.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VisualUnorderedCollection

   procedure Initialize (this : in out VisualUnorderedCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out VisualUnorderedCollection) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVisualUnorderedCollection, IVisualUnorderedCollection_Ptr);
   begin
      if this.m_IVisualUnorderedCollection /= null then
         if this.m_IVisualUnorderedCollection.all /= null then
            temp := this.m_IVisualUnorderedCollection.all.Release;
            Free (this.m_IVisualUnorderedCollection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VisualUnorderedCollection

   function get_Count
   (
      this : in out VisualUnorderedCollection
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IVisualUnorderedCollection.all.get_Count (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Add
   (
      this : in out VisualUnorderedCollection;
      newVisual : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualUnorderedCollection.all.Add (newVisual.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Remove
   (
      this : in out VisualUnorderedCollection;
      visual_p : WinRt.Windows.UI.Composition.Visual'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualUnorderedCollection.all.Remove (visual_p.m_IVisual.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out VisualUnorderedCollection
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IVisualUnorderedCollection.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Composition.Visual>
   function First
   (
      this : in out VisualUnorderedCollection
   )
   return WinRt.Windows.UI.Composition.Visual'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : IIterable_IVisual.Kind := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.UI.Composition.IVisual;
      m_GenericIID     : aliased WinRt.IID := (1324187086, 58540, 22673, (155, 82, 121, 157, 112, 223, 71, 254 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Composition.IVisualUnorderedCollection_Interface, IIterable_IVisual.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Composition.Visual do
         m_Interface := QInterface (this.m_IVisualUnorderedCollection.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IVisual := new WinRt.Windows.UI.Composition.IVisual;
         Retval.m_IVisual.all := m_ComRetVal;
      end return;
   end;

end WinRt.Windows.UI.Composition;
