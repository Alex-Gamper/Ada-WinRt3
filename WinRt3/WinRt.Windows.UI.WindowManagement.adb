--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.System;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.WindowManagement is

   package IAsyncOperation_Boolean is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Boolean);
   package AsyncOperationCompletedHandler_Boolean is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Boolean);

   package IAsyncOperation_AppWindow is new WinRt.Windows.Foundation.IAsyncOperation (WinRt.Windows.UI.WindowManagement.IAppWindow);
   package AsyncOperationCompletedHandler_AppWindow is new WinRt.Windows.Foundation.AsyncOperationCompletedHandler (WinRt.Windows.UI.WindowManagement.IAppWindow);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindow

   procedure Initialize (this : in out AppWindow) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindow) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindow, IAppWindow_Ptr);
   begin
      if this.m_IAppWindow /= null then
         if this.m_IAppWindow.all /= null then
            temp := this.m_IAppWindow.all.Release;
            Free (this.m_IAppWindow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppWindow

   function TryCreateAsync
   return WinRt.Windows.UI.WindowManagement.AppWindow is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.AppWindow");
      m_Factory        : access WinRt.Windows.UI.WindowManagement.IAppWindowStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_AppWindow.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_AppWindow.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Windows.UI.WindowManagement.IAppWindow;
      m_IID            : aliased WinRt.IID := (1097298554, 24048, 24275, (182, 36, 22, 124, 129, 190, 255, 107 )); -- Windows.UI.WindowManagement.AppWindow;
      m_HandlerIID     : aliased WinRt.IID := (1002349542, 13496, 24304, (160, 147, 156, 199, 31, 164, 11, 110 ));
      m_Handler        : AsyncOperationCompletedHandler_AppWindow.Kind := new AsyncOperationCompletedHandler_AppWindow.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_AppWindow.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_AppWindow.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_AppWindow.Kind_Delegate, AsyncOperationCompletedHandler_AppWindow.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.AppWindow do
         Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.TryCreateAsync (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr = S_OK then
               m_AsyncOperation := QI (m_ComRetVal);
               temp := m_ComRetVal.Release;
               if m_AsyncOperation /= null then
                  Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
                  while m_Captured = m_Compare loop
                     m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                     m_Captured := m_Completed;
                  end loop;
                  if m_AsyncStatus = Completed_e then
                     Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                     Retval.m_IAppWindow := new Windows.UI.WindowManagement.IAppWindow;
                     Retval.m_IAppWindow.all := m_RetVal;
                  end if;
                  temp := m_AsyncOperation.Release;
                  temp := m_Handler.Release;
                  if temp = 0 then
                     Free (m_Handler);
                  end if;
               end if;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure ClearAllPersistedState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.AppWindow");
      m_Factory        : access WinRt.Windows.UI.WindowManagement.IAppWindowStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.ClearAllPersistedState;
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   procedure ClearPersistedState
   (
      key : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.AppWindow");
      m_Factory        : access WinRt.Windows.UI.WindowManagement.IAppWindowStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      HStr_key : constant WinRt.HString := To_HString (key);
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IAppWindowStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.ClearPersistedState (HStr_key);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_key);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindow

   function get_Content
   (
      this : in out AppWindow
   )
   return WinRt.Windows.UI.UIContentRoot'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.IUIContentRoot;
   begin
      return RetVal : WinRt.Windows.UI.UIContentRoot do
         Hr := this.m_IAppWindow.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIContentRoot := new Windows.UI.IUIContentRoot;
         Retval.m_IUIContentRoot.all := m_ComRetVal;
      end return;
   end;

   function get_DispatcherQueue
   (
      this : in out AppWindow
   )
   return WinRt.Windows.System.DispatcherQueue'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.System.IDispatcherQueue;
   begin
      return RetVal : WinRt.Windows.System.DispatcherQueue do
         Hr := this.m_IAppWindow.all.get_DispatcherQueue (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDispatcherQueue := new Windows.System.IDispatcherQueue;
         Retval.m_IDispatcherQueue.all := m_ComRetVal;
      end return;
   end;

   function get_Frame
   (
      this : in out AppWindow
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowFrame'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IAppWindowFrame;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.AppWindowFrame do
         Hr := this.m_IAppWindow.all.get_Frame (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppWindowFrame := new Windows.UI.WindowManagement.IAppWindowFrame;
         Retval.m_IAppWindowFrame.all := m_ComRetVal;
      end return;
   end;

   function get_IsVisible
   (
      this : in out AppWindow
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindow.all.get_IsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PersistedStateId
   (
      this : in out AppWindow
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppWindow.all.get_PersistedStateId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PersistedStateId
   (
      this : in out AppWindow;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IAppWindow.all.put_PersistedStateId (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Presenter
   (
      this : in out AppWindow
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowPresenter'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IAppWindowPresenter;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.AppWindowPresenter do
         Hr := this.m_IAppWindow.all.get_Presenter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppWindowPresenter := new Windows.UI.WindowManagement.IAppWindowPresenter;
         Retval.m_IAppWindowPresenter.all := m_ComRetVal;
      end return;
   end;

   function get_Title
   (
      this : in out AppWindow
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppWindow.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out AppWindow;
      value : WinRt.WString
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      HStr_value : constant WinRt.HString := To_HString (value);
   begin
      Hr := this.m_IAppWindow.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TitleBar
   (
      this : in out AppWindow
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowTitleBar'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IAppWindowTitleBar;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.AppWindowTitleBar do
         Hr := this.m_IAppWindow.all.get_TitleBar (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppWindowTitleBar := new Windows.UI.WindowManagement.IAppWindowTitleBar;
         Retval.m_IAppWindowTitleBar.all := m_ComRetVal;
      end return;
   end;

   function get_UIContext
   (
      this : in out AppWindow
   )
   return WinRt.Windows.UI.UIContext'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.IUIContext;
   begin
      return RetVal : WinRt.Windows.UI.UIContext do
         Hr := this.m_IAppWindow.all.get_UIContext (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIContext := new Windows.UI.IUIContext;
         Retval.m_IUIContext.all := m_ComRetVal;
      end return;
   end;

   function get_WindowingEnvironment
   (
      this : in out AppWindow
   )
   return WinRt.Windows.UI.WindowManagement.WindowingEnvironment'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IWindowingEnvironment;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.WindowingEnvironment do
         Hr := this.m_IAppWindow.all.get_WindowingEnvironment (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWindowingEnvironment := new Windows.UI.WindowManagement.IWindowingEnvironment;
         Retval.m_IWindowingEnvironment.all := m_ComRetVal;
      end return;
   end;

   procedure CloseAsync
   (
      this : in out AppWindow
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinRt.Windows.Foundation.IAsyncAction; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinRt.Windows.Foundation.AsyncActionCompletedHandler := new WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinRt.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinRt.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := this.m_IAppWindow.all.CloseAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function GetPlacement
   (
      this : in out AppWindow
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowPlacement'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IAppWindowPlacement;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.AppWindowPlacement do
         Hr := this.m_IAppWindow.all.GetPlacement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppWindowPlacement := new Windows.UI.WindowManagement.IAppWindowPlacement;
         Retval.m_IAppWindowPlacement.all := m_ComRetVal;
      end return;
   end;

   function GetDisplayRegions
   (
      this : in out AppWindow
   )
   return IVectorView_IDisplayRegion.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayRegion.Kind;
   begin
      Hr := this.m_IAppWindow.all.GetDisplayRegions (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayRegion (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure RequestMoveToDisplayRegion
   (
      this : in out AppWindow;
      displayRegion_p : Windows.UI.WindowManagement.DisplayRegion'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.RequestMoveToDisplayRegion (displayRegion_p.m_IDisplayRegion.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestMoveAdjacentToCurrentView
   (
      this : in out AppWindow
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.RequestMoveAdjacentToCurrentView;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestMoveAdjacentToWindow
   (
      this : in out AppWindow;
      anchorWindow : Windows.UI.WindowManagement.AppWindow'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.RequestMoveAdjacentToWindow (anchorWindow.m_IAppWindow.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestMoveRelativeToWindowContent
   (
      this : in out AppWindow;
      anchorWindow : Windows.UI.WindowManagement.AppWindow'Class;
      contentOffset : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.RequestMoveRelativeToWindowContent (anchorWindow.m_IAppWindow.all, contentOffset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestMoveRelativeToCurrentViewContent
   (
      this : in out AppWindow;
      contentOffset : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.RequestMoveRelativeToCurrentViewContent (contentOffset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestMoveRelativeToDisplayRegion
   (
      this : in out AppWindow;
      displayRegion_p : Windows.UI.WindowManagement.DisplayRegion'Class;
      displayRegionOffset : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.RequestMoveRelativeToDisplayRegion (displayRegion_p.m_IDisplayRegion.all, displayRegionOffset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestSize
   (
      this : in out AppWindow;
      frameSize : Windows.Foundation.Size
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.RequestSize (frameSize);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryShowAsync
   (
      this : in out AppWindow
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_Temp           : WinRt.Int32 := 0;
      m_Completed      : WinRt.UInt32 := 0;
      m_Captured       : WinRt.UInt32 := 0;
      m_Compare        : constant WinRt.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinRt.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinRt.GenericObject := null;
      m_RetVal         : aliased WinRt.Boolean;
      m_IID            : aliased WinRt.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinRt.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinRt.GenericObject; asyncStatus: WinRt.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IAppWindow.all.TryShowAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function add_Changed
   (
      this : in out AppWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppWindow.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out AppWindow;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out AppWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppWindow.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out AppWindow;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CloseRequested
   (
      this : in out AppWindow;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppWindow.all.add_CloseRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CloseRequested
   (
      this : in out AppWindow;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindow.all.remove_CloseRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowChangedEventArgs

   procedure Initialize (this : in out AppWindowChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowChangedEventArgs, IAppWindowChangedEventArgs_Ptr);
   begin
      if this.m_IAppWindowChangedEventArgs /= null then
         if this.m_IAppWindowChangedEventArgs.all /= null then
            temp := this.m_IAppWindowChangedEventArgs.all.Release;
            Free (this.m_IAppWindowChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowChangedEventArgs

   function get_DidAvailableWindowPresentationsChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidAvailableWindowPresentationsChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidDisplayRegionsChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidDisplayRegionsChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidFrameChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidFrameChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidSizeChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidSizeChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidTitleBarChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidTitleBarChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidVisibilityChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidVisibilityChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidWindowingEnvironmentChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidWindowingEnvironmentChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DidWindowPresentationChange
   (
      this : in out AppWindowChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowChangedEventArgs.all.get_DidWindowPresentationChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowCloseRequestedEventArgs

   procedure Initialize (this : in out AppWindowCloseRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowCloseRequestedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowCloseRequestedEventArgs, IAppWindowCloseRequestedEventArgs_Ptr);
   begin
      if this.m_IAppWindowCloseRequestedEventArgs /= null then
         if this.m_IAppWindowCloseRequestedEventArgs.all /= null then
            temp := this.m_IAppWindowCloseRequestedEventArgs.all.Release;
            Free (this.m_IAppWindowCloseRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowCloseRequestedEventArgs

   function get_Cancel
   (
      this : in out AppWindowCloseRequestedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowCloseRequestedEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out AppWindowCloseRequestedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowCloseRequestedEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out AppWindowCloseRequestedEventArgs
   )
   return WinRt.Windows.Foundation.Deferral'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.IDeferral;
   begin
      return RetVal : WinRt.Windows.Foundation.Deferral do
         Hr := this.m_IAppWindowCloseRequestedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowClosedEventArgs

   procedure Initialize (this : in out AppWindowClosedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowClosedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowClosedEventArgs, IAppWindowClosedEventArgs_Ptr);
   begin
      if this.m_IAppWindowClosedEventArgs /= null then
         if this.m_IAppWindowClosedEventArgs.all /= null then
            temp := this.m_IAppWindowClosedEventArgs.all.Release;
            Free (this.m_IAppWindowClosedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowClosedEventArgs

   function get_Reason
   (
      this : in out AppWindowClosedEventArgs
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowClosedReason is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.AppWindowClosedReason;
   begin
      Hr := this.m_IAppWindowClosedEventArgs.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowFrame

   procedure Initialize (this : in out AppWindowFrame) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowFrame) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowFrame, IAppWindowFrame_Ptr);
   begin
      if this.m_IAppWindowFrame /= null then
         if this.m_IAppWindowFrame.all /= null then
            temp := this.m_IAppWindowFrame.all.Release;
            Free (this.m_IAppWindowFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowFrame

   function GetFrameStyle
   (
      this : in out AppWindowFrame
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowFrameStyle is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.WindowManagement.IAppWindowFrameStyle := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.AppWindowFrameStyle;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.WindowManagement.IAppWindowFrame_Interface, WinRt.Windows.UI.WindowManagement.IAppWindowFrameStyle, WinRt.Windows.UI.WindowManagement.IID_IAppWindowFrameStyle'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowFrame.all);
      Hr := m_Interface.GetFrameStyle (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetFrameStyle
   (
      this : in out AppWindowFrame;
      frameStyle : Windows.UI.WindowManagement.AppWindowFrameStyle
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.WindowManagement.IAppWindowFrameStyle := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.WindowManagement.IAppWindowFrame_Interface, WinRt.Windows.UI.WindowManagement.IAppWindowFrameStyle, WinRt.Windows.UI.WindowManagement.IID_IAppWindowFrameStyle'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowFrame.all);
      Hr := m_Interface.SetFrameStyle (frameStyle);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DragRegionVisuals
   (
      this : in out AppWindowFrame
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IAppWindowFrame.all.get_DragRegionVisuals (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowPlacement

   procedure Initialize (this : in out AppWindowPlacement) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowPlacement) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowPlacement, IAppWindowPlacement_Ptr);
   begin
      if this.m_IAppWindowPlacement /= null then
         if this.m_IAppWindowPlacement.all /= null then
            temp := this.m_IAppWindowPlacement.all.Release;
            Free (this.m_IAppWindowPlacement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowPlacement

   function get_DisplayRegion
   (
      this : in out AppWindowPlacement
   )
   return WinRt.Windows.UI.WindowManagement.DisplayRegion'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IDisplayRegion;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.DisplayRegion do
         Hr := this.m_IAppWindowPlacement.all.get_DisplayRegion (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayRegion := new Windows.UI.WindowManagement.IDisplayRegion;
         Retval.m_IDisplayRegion.all := m_ComRetVal;
      end return;
   end;

   function get_Offset
   (
      this : in out AppWindowPlacement
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IAppWindowPlacement.all.get_Offset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out AppWindowPlacement
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Size;
   begin
      Hr := this.m_IAppWindowPlacement.all.get_Size (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowPresentationConfiguration

   procedure Initialize (this : in out AppWindowPresentationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowPresentationConfiguration) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowPresentationConfiguration, IAppWindowPresentationConfiguration_Ptr);
   begin
      if this.m_IAppWindowPresentationConfiguration /= null then
         if this.m_IAppWindowPresentationConfiguration.all /= null then
            temp := this.m_IAppWindowPresentationConfiguration.all.Release;
            Free (this.m_IAppWindowPresentationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppWindowPresentationConfiguration

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowPresentationConfiguration

   function get_Kind
   (
      this : in out AppWindowPresentationConfiguration
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowPresentationKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.AppWindowPresentationKind;
   begin
      Hr := this.m_IAppWindowPresentationConfiguration.all.get_Kind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowPresenter

   procedure Initialize (this : in out AppWindowPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowPresenter) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowPresenter, IAppWindowPresenter_Ptr);
   begin
      if this.m_IAppWindowPresenter /= null then
         if this.m_IAppWindowPresenter.all /= null then
            temp := this.m_IAppWindowPresenter.all.Release;
            Free (this.m_IAppWindowPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowPresenter

   function GetConfiguration
   (
      this : in out AppWindowPresenter
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowPresentationConfiguration'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IAppWindowPresentationConfiguration;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.AppWindowPresentationConfiguration do
         Hr := this.m_IAppWindowPresenter.all.GetConfiguration (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppWindowPresentationConfiguration := new Windows.UI.WindowManagement.IAppWindowPresentationConfiguration;
         Retval.m_IAppWindowPresentationConfiguration.all := m_ComRetVal;
      end return;
   end;

   function IsPresentationSupported
   (
      this : in out AppWindowPresenter;
      presentationKind : Windows.UI.WindowManagement.AppWindowPresentationKind
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowPresenter.all.IsPresentationSupported (presentationKind, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function RequestPresentation
   (
      this : in out AppWindowPresenter;
      configuration : Windows.UI.WindowManagement.AppWindowPresentationConfiguration'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowPresenter.all.RequestPresentation (configuration.m_IAppWindowPresentationConfiguration.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function RequestPresentation
   (
      this : in out AppWindowPresenter;
      presentationKind : Windows.UI.WindowManagement.AppWindowPresentationKind
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowPresenter.all.RequestPresentation (presentationKind, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowTitleBar

   procedure Initialize (this : in out AppWindowTitleBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowTitleBar) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowTitleBar, IAppWindowTitleBar_Ptr);
   begin
      if this.m_IAppWindowTitleBar /= null then
         if this.m_IAppWindowTitleBar.all /= null then
            temp := this.m_IAppWindowTitleBar.all.Release;
            Free (this.m_IAppWindowTitleBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowTitleBar

   function GetPreferredVisibility
   (
      this : in out AppWindowTitleBar
   )
   return WinRt.Windows.UI.WindowManagement.AppWindowTitleBarVisibility is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.WindowManagement.IAppWindowTitleBarVisibility := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.AppWindowTitleBarVisibility;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.WindowManagement.IAppWindowTitleBar_Interface, WinRt.Windows.UI.WindowManagement.IAppWindowTitleBarVisibility, WinRt.Windows.UI.WindowManagement.IID_IAppWindowTitleBarVisibility'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowTitleBar.all);
      Hr := m_Interface.GetPreferredVisibility (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetPreferredVisibility
   (
      this : in out AppWindowTitleBar;
      visibilityMode : Windows.UI.WindowManagement.AppWindowTitleBarVisibility
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.WindowManagement.IAppWindowTitleBarVisibility := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.WindowManagement.IAppWindowTitleBar_Interface, WinRt.Windows.UI.WindowManagement.IAppWindowTitleBarVisibility, WinRt.Windows.UI.WindowManagement.IID_IAppWindowTitleBarVisibility'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppWindowTitleBar.all);
      Hr := m_Interface.SetPreferredVisibility (visibilityMode);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_BackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_BackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_BackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonHoverBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonHoverBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonHoverBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonHoverBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonHoverForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonHoverForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonHoverForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonHoverForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonInactiveBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonInactiveBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonInactiveBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonInactiveBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonInactiveForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonInactiveForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonInactiveForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonInactiveForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonPressedBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonPressedBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonPressedBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonPressedBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonPressedForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ButtonPressedForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ButtonPressedForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ButtonPressedForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExtendsContentIntoTitleBar
   (
      this : in out AppWindowTitleBar
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ExtendsContentIntoTitleBar (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExtendsContentIntoTitleBar
   (
      this : in out AppWindowTitleBar;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ExtendsContentIntoTitleBar (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_ForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_ForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_ForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InactiveBackgroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_InactiveBackgroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_InactiveBackgroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_InactiveBackgroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InactiveForegroundColor
   (
      this : in out AppWindowTitleBar
   )
   return IReference_Color.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_InactiveForegroundColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_InactiveForegroundColor
   (
      this : in out AppWindowTitleBar;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IAppWindowTitleBar.all.put_InactiveForegroundColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVisible
   (
      this : in out AppWindowTitleBar
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IAppWindowTitleBar.all.get_IsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetTitleBarOcclusions
   (
      this : in out AppWindowTitleBar
   )
   return IVectorView_IAppWindowTitleBarOcclusion.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IAppWindowTitleBarOcclusion.Kind;
   begin
      Hr := this.m_IAppWindowTitleBar.all.GetTitleBarOcclusions (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IAppWindowTitleBarOcclusion (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppWindowTitleBarOcclusion

   procedure Initialize (this : in out AppWindowTitleBarOcclusion) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppWindowTitleBarOcclusion) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppWindowTitleBarOcclusion, IAppWindowTitleBarOcclusion_Ptr);
   begin
      if this.m_IAppWindowTitleBarOcclusion /= null then
         if this.m_IAppWindowTitleBarOcclusion.all /= null then
            temp := this.m_IAppWindowTitleBarOcclusion.all.Release;
            Free (this.m_IAppWindowTitleBarOcclusion);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppWindowTitleBarOcclusion

   function get_OccludingRect
   (
      this : in out AppWindowTitleBarOcclusion
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IAppWindowTitleBarOcclusion.all.get_OccludingRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CompactOverlayPresentationConfiguration

   procedure Initialize (this : in out CompactOverlayPresentationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out CompactOverlayPresentationConfiguration) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICompactOverlayPresentationConfiguration, ICompactOverlayPresentationConfiguration_Ptr);
   begin
      if this.m_ICompactOverlayPresentationConfiguration /= null then
         if this.m_ICompactOverlayPresentationConfiguration.all /= null then
            temp := this.m_ICompactOverlayPresentationConfiguration.all.Release;
            Free (this.m_ICompactOverlayPresentationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CompactOverlayPresentationConfiguration

   function Constructor return CompactOverlayPresentationConfiguration is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.CompactOverlayPresentationConfiguration");
      m_ComRetVal  : aliased Windows.UI.WindowManagement.ICompactOverlayPresentationConfiguration;
   begin
      return RetVal : CompactOverlayPresentationConfiguration do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICompactOverlayPresentationConfiguration := new Windows.UI.WindowManagement.ICompactOverlayPresentationConfiguration;
            Retval.m_ICompactOverlayPresentationConfiguration.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CompactOverlayPresentationConfiguration

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DefaultPresentationConfiguration

   procedure Initialize (this : in out DefaultPresentationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out DefaultPresentationConfiguration) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDefaultPresentationConfiguration, IDefaultPresentationConfiguration_Ptr);
   begin
      if this.m_IDefaultPresentationConfiguration /= null then
         if this.m_IDefaultPresentationConfiguration.all /= null then
            temp := this.m_IDefaultPresentationConfiguration.all.Release;
            Free (this.m_IDefaultPresentationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DefaultPresentationConfiguration

   function Constructor return DefaultPresentationConfiguration is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.DefaultPresentationConfiguration");
      m_ComRetVal  : aliased Windows.UI.WindowManagement.IDefaultPresentationConfiguration;
   begin
      return RetVal : DefaultPresentationConfiguration do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDefaultPresentationConfiguration := new Windows.UI.WindowManagement.IDefaultPresentationConfiguration;
            Retval.m_IDefaultPresentationConfiguration.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DefaultPresentationConfiguration

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayRegion

   procedure Initialize (this : in out DisplayRegion) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayRegion) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayRegion, IDisplayRegion_Ptr);
   begin
      if this.m_IDisplayRegion /= null then
         if this.m_IDisplayRegion.all /= null then
            temp := this.m_IDisplayRegion.all.Release;
            Free (this.m_IDisplayRegion);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayRegion

   function get_DisplayMonitorDeviceId
   (
      this : in out DisplayRegion
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayRegion.all.get_DisplayMonitorDeviceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_IsVisible
   (
      this : in out DisplayRegion
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayRegion.all.get_IsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WorkAreaOffset
   (
      this : in out DisplayRegion
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IDisplayRegion.all.get_WorkAreaOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WorkAreaSize
   (
      this : in out DisplayRegion
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Size;
   begin
      Hr := this.m_IDisplayRegion.all.get_WorkAreaSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WindowingEnvironment
   (
      this : in out DisplayRegion
   )
   return WinRt.Windows.UI.WindowManagement.WindowingEnvironment'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IWindowingEnvironment;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.WindowingEnvironment do
         Hr := this.m_IDisplayRegion.all.get_WindowingEnvironment (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWindowingEnvironment := new Windows.UI.WindowManagement.IWindowingEnvironment;
         Retval.m_IWindowingEnvironment.all := m_ComRetVal;
      end return;
   end;

   function add_Changed
   (
      this : in out DisplayRegion;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayRegion.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out DisplayRegion;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayRegion.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FullScreenPresentationConfiguration

   procedure Initialize (this : in out FullScreenPresentationConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out FullScreenPresentationConfiguration) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFullScreenPresentationConfiguration, IFullScreenPresentationConfiguration_Ptr);
   begin
      if this.m_IFullScreenPresentationConfiguration /= null then
         if this.m_IFullScreenPresentationConfiguration.all /= null then
            temp := this.m_IFullScreenPresentationConfiguration.all.Release;
            Free (this.m_IFullScreenPresentationConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FullScreenPresentationConfiguration

   function Constructor return FullScreenPresentationConfiguration is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.FullScreenPresentationConfiguration");
      m_ComRetVal  : aliased Windows.UI.WindowManagement.IFullScreenPresentationConfiguration;
   begin
      return RetVal : FullScreenPresentationConfiguration do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IFullScreenPresentationConfiguration := new Windows.UI.WindowManagement.IFullScreenPresentationConfiguration;
            Retval.m_IFullScreenPresentationConfiguration.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FullScreenPresentationConfiguration

   function get_IsExclusive
   (
      this : in out FullScreenPresentationConfiguration
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IFullScreenPresentationConfiguration.all.get_IsExclusive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExclusive
   (
      this : in out FullScreenPresentationConfiguration;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IFullScreenPresentationConfiguration.all.put_IsExclusive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowingEnvironment

   procedure Initialize (this : in out WindowingEnvironment) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowingEnvironment) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowingEnvironment, IWindowingEnvironment_Ptr);
   begin
      if this.m_IWindowingEnvironment /= null then
         if this.m_IWindowingEnvironment.all /= null then
            temp := this.m_IWindowingEnvironment.all.Release;
            Free (this.m_IWindowingEnvironment);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for WindowingEnvironment

   function FindAll
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.WindowingEnvironment");
      m_Factory        : access WinRt.Windows.UI.WindowManagement.IWindowingEnvironmentStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IWindowingEnvironmentStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FindAll (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function FindAll
   (
      kind : Windows.UI.WindowManagement.WindowingEnvironmentKind
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.WindowManagement.WindowingEnvironment");
      m_Factory        : access WinRt.Windows.UI.WindowManagement.IWindowingEnvironmentStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IWindowingEnvironmentStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.FindAll (kind, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowingEnvironment

   function get_IsEnabled
   (
      this : in out WindowingEnvironment
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IWindowingEnvironment.all.get_IsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Kind
   (
      this : in out WindowingEnvironment
   )
   return WinRt.Windows.UI.WindowManagement.WindowingEnvironmentKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.WindowingEnvironmentKind;
   begin
      Hr := this.m_IWindowingEnvironment.all.get_Kind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetDisplayRegions
   (
      this : in out WindowingEnvironment
   )
   return IVectorView_IDisplayRegion.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayRegion.Kind;
   begin
      Hr := this.m_IWindowingEnvironment.all.GetDisplayRegions (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayRegion (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_Changed
   (
      this : in out WindowingEnvironment;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWindowingEnvironment.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out WindowingEnvironment;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IWindowingEnvironment.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowingEnvironmentAddedEventArgs

   procedure Initialize (this : in out WindowingEnvironmentAddedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowingEnvironmentAddedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowingEnvironmentAddedEventArgs, IWindowingEnvironmentAddedEventArgs_Ptr);
   begin
      if this.m_IWindowingEnvironmentAddedEventArgs /= null then
         if this.m_IWindowingEnvironmentAddedEventArgs.all /= null then
            temp := this.m_IWindowingEnvironmentAddedEventArgs.all.Release;
            Free (this.m_IWindowingEnvironmentAddedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowingEnvironmentAddedEventArgs

   function get_WindowingEnvironment
   (
      this : in out WindowingEnvironmentAddedEventArgs
   )
   return WinRt.Windows.UI.WindowManagement.WindowingEnvironment'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IWindowingEnvironment;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.WindowingEnvironment do
         Hr := this.m_IWindowingEnvironmentAddedEventArgs.all.get_WindowingEnvironment (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWindowingEnvironment := new Windows.UI.WindowManagement.IWindowingEnvironment;
         Retval.m_IWindowingEnvironment.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowingEnvironmentChangedEventArgs

   procedure Initialize (this : in out WindowingEnvironmentChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowingEnvironmentChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowingEnvironmentChangedEventArgs, IWindowingEnvironmentChangedEventArgs_Ptr);
   begin
      if this.m_IWindowingEnvironmentChangedEventArgs /= null then
         if this.m_IWindowingEnvironmentChangedEventArgs.all /= null then
            temp := this.m_IWindowingEnvironmentChangedEventArgs.all.Release;
            Free (this.m_IWindowingEnvironmentChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowingEnvironmentChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WindowingEnvironmentRemovedEventArgs

   procedure Initialize (this : in out WindowingEnvironmentRemovedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WindowingEnvironmentRemovedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWindowingEnvironmentRemovedEventArgs, IWindowingEnvironmentRemovedEventArgs_Ptr);
   begin
      if this.m_IWindowingEnvironmentRemovedEventArgs /= null then
         if this.m_IWindowingEnvironmentRemovedEventArgs.all /= null then
            temp := this.m_IWindowingEnvironmentRemovedEventArgs.all.Release;
            Free (this.m_IWindowingEnvironmentRemovedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WindowingEnvironmentRemovedEventArgs

   function get_WindowingEnvironment
   (
      this : in out WindowingEnvironmentRemovedEventArgs
   )
   return WinRt.Windows.UI.WindowManagement.WindowingEnvironment'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.WindowManagement.IWindowingEnvironment;
   begin
      return RetVal : WinRt.Windows.UI.WindowManagement.WindowingEnvironment do
         Hr := this.m_IWindowingEnvironmentRemovedEventArgs.all.get_WindowingEnvironment (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWindowingEnvironment := new Windows.UI.WindowManagement.IWindowingEnvironment;
         Retval.m_IWindowingEnvironment.all := m_ComRetVal;
      end return;
   end;

end WinRt.Windows.UI.WindowManagement;
