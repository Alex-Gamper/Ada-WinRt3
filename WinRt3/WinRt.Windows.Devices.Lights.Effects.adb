--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.Graphics.Imaging;
with WinRt.Windows.UI;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Devices.Lights.Effects is

   package IVectorView_ILampArrayEffect is new WinRt.Windows.Foundation.Collections.IVectorView (WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect);
   package IIterable_ILampArrayEffect is new WinRt.Windows.Foundation.Collections.IIterable (WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect);
   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArrayBitmapEffect

   procedure Initialize (this : in out LampArrayBitmapEffect) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArrayBitmapEffect) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArrayBitmapEffect, ILampArrayBitmapEffect_Ptr);
   begin
      if this.m_ILampArrayBitmapEffect /= null then
         if this.m_ILampArrayBitmapEffect.all /= null then
            RefCount := this.m_ILampArrayBitmapEffect.all.Release;
            Free (this.m_ILampArrayBitmapEffect);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LampArrayBitmapEffect

   function Constructor
   (
      lampArray : Windows.Devices.Lights.LampArray'Class;
      lampIndexes : WinRt.Int32_Array
   )
   return LampArrayBitmapEffect is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayBitmapEffect");
      m_Factory    : access ILampArrayBitmapEffectFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Lights.Effects.ILampArrayBitmapEffect;
      function Convert_lampIndexes is new Ada.Unchecked_Conversion (Address, WinRt.Int32_Ptr);
   begin
      return RetVal : LampArrayBitmapEffect do
         Hr := RoGetActivationFactory (m_hString, IID_ILampArrayBitmapEffectFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (lampArray.m_ILampArray.all, WinRt.UInt32(lampIndexes'Length), Convert_lampIndexes (lampIndexes (lampIndexes'First)'Address), m_ComRetVal'Access);
            Retval.m_ILampArrayBitmapEffect := new Windows.Devices.Lights.Effects.ILampArrayBitmapEffect;
            Retval.m_ILampArrayBitmapEffect.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArrayBitmapEffect

   function get_Duration
   (
      this : in out LampArrayBitmapEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.get_Duration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out LampArrayBitmapEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.put_Duration (value);
   end;

   function get_StartDelay
   (
      this : in out LampArrayBitmapEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.get_StartDelay (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_StartDelay
   (
      this : in out LampArrayBitmapEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.put_StartDelay (value);
   end;

   function get_UpdateInterval
   (
      this : in out LampArrayBitmapEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.get_UpdateInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_UpdateInterval
   (
      this : in out LampArrayBitmapEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.put_UpdateInterval (value);
   end;

   function get_SuggestedBitmapSize
   (
      this : in out LampArrayBitmapEffect
   )
   return WinRt.Windows.Foundation.Size is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Size;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.get_SuggestedBitmapSize (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   function add_BitmapRequested
   (
      this : in out LampArrayBitmapEffect;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.add_BitmapRequested (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_BitmapRequested
   (
      this : in out LampArrayBitmapEffect;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBitmapEffect.all.remove_BitmapRequested (token);
   end;

   function get_ZIndex
   (
      this : in out LampArrayBitmapEffect
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayBitmapEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayBitmapEffect.all);
      Hr := m_Interface.get_ZIndex (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out LampArrayBitmapEffect;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayBitmapEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayBitmapEffect.all);
      Hr := m_Interface.put_ZIndex (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArrayBitmapRequestedEventArgs

   procedure Initialize (this : in out LampArrayBitmapRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArrayBitmapRequestedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArrayBitmapRequestedEventArgs, ILampArrayBitmapRequestedEventArgs_Ptr);
   begin
      if this.m_ILampArrayBitmapRequestedEventArgs /= null then
         if this.m_ILampArrayBitmapRequestedEventArgs.all /= null then
            RefCount := this.m_ILampArrayBitmapRequestedEventArgs.all.Release;
            Free (this.m_ILampArrayBitmapRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArrayBitmapRequestedEventArgs

   function get_SinceStarted
   (
      this : in out LampArrayBitmapRequestedEventArgs
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBitmapRequestedEventArgs.all.get_SinceStarted (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure UpdateBitmap
   (
      this : in out LampArrayBitmapRequestedEventArgs;
      bitmap : Windows.Graphics.Imaging.SoftwareBitmap'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBitmapRequestedEventArgs.all.UpdateBitmap (bitmap.m_ISoftwareBitmap.all);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArrayBlinkEffect

   procedure Initialize (this : in out LampArrayBlinkEffect) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArrayBlinkEffect) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArrayBlinkEffect, ILampArrayBlinkEffect_Ptr);
   begin
      if this.m_ILampArrayBlinkEffect /= null then
         if this.m_ILampArrayBlinkEffect.all /= null then
            RefCount := this.m_ILampArrayBlinkEffect.all.Release;
            Free (this.m_ILampArrayBlinkEffect);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LampArrayBlinkEffect

   function Constructor
   (
      lampArray : Windows.Devices.Lights.LampArray'Class;
      lampIndexes : WinRt.Int32_Array
   )
   return LampArrayBlinkEffect is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayBlinkEffect");
      m_Factory    : access ILampArrayBlinkEffectFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Lights.Effects.ILampArrayBlinkEffect;
      function Convert_lampIndexes is new Ada.Unchecked_Conversion (Address, WinRt.Int32_Ptr);
   begin
      return RetVal : LampArrayBlinkEffect do
         Hr := RoGetActivationFactory (m_hString, IID_ILampArrayBlinkEffectFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (lampArray.m_ILampArray.all, WinRt.UInt32(lampIndexes'Length), Convert_lampIndexes (lampIndexes (lampIndexes'First)'Address), m_ComRetVal'Access);
            Retval.m_ILampArrayBlinkEffect := new Windows.Devices.Lights.Effects.ILampArrayBlinkEffect;
            Retval.m_ILampArrayBlinkEffect.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArrayBlinkEffect

   function get_Color
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_Color (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out LampArrayBlinkEffect;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_Color (value);
   end;

   function get_AttackDuration
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_AttackDuration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_AttackDuration
   (
      this : in out LampArrayBlinkEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_AttackDuration (value);
   end;

   function get_SustainDuration
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_SustainDuration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_SustainDuration
   (
      this : in out LampArrayBlinkEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_SustainDuration (value);
   end;

   function get_DecayDuration
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_DecayDuration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_DecayDuration
   (
      this : in out LampArrayBlinkEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_DecayDuration (value);
   end;

   function get_RepetitionDelay
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_RepetitionDelay (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RepetitionDelay
   (
      this : in out LampArrayBlinkEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_RepetitionDelay (value);
   end;

   function get_StartDelay
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_StartDelay (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_StartDelay
   (
      this : in out LampArrayBlinkEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_StartDelay (value);
   end;

   function get_Occurrences
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_Occurrences (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Occurrences
   (
      this : in out LampArrayBlinkEffect;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_Occurrences (value);
   end;

   function get_RepetitionMode
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Windows.Devices.Lights.Effects.LampArrayRepetitionMode is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Lights.Effects.LampArrayRepetitionMode;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.get_RepetitionMode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RepetitionMode
   (
      this : in out LampArrayBlinkEffect;
      value : Windows.Devices.Lights.Effects.LampArrayRepetitionMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayBlinkEffect.all.put_RepetitionMode (value);
   end;

   function get_ZIndex
   (
      this : in out LampArrayBlinkEffect
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayBlinkEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayBlinkEffect.all);
      Hr := m_Interface.get_ZIndex (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out LampArrayBlinkEffect;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayBlinkEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayBlinkEffect.all);
      Hr := m_Interface.put_ZIndex (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArrayColorRampEffect

   procedure Initialize (this : in out LampArrayColorRampEffect) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArrayColorRampEffect) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArrayColorRampEffect, ILampArrayColorRampEffect_Ptr);
   begin
      if this.m_ILampArrayColorRampEffect /= null then
         if this.m_ILampArrayColorRampEffect.all /= null then
            RefCount := this.m_ILampArrayColorRampEffect.all.Release;
            Free (this.m_ILampArrayColorRampEffect);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LampArrayColorRampEffect

   function Constructor
   (
      lampArray : Windows.Devices.Lights.LampArray'Class;
      lampIndexes : WinRt.Int32_Array
   )
   return LampArrayColorRampEffect is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayColorRampEffect");
      m_Factory    : access ILampArrayColorRampEffectFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Lights.Effects.ILampArrayColorRampEffect;
      function Convert_lampIndexes is new Ada.Unchecked_Conversion (Address, WinRt.Int32_Ptr);
   begin
      return RetVal : LampArrayColorRampEffect do
         Hr := RoGetActivationFactory (m_hString, IID_ILampArrayColorRampEffectFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (lampArray.m_ILampArray.all, WinRt.UInt32(lampIndexes'Length), Convert_lampIndexes (lampIndexes (lampIndexes'First)'Address), m_ComRetVal'Access);
            Retval.m_ILampArrayColorRampEffect := new Windows.Devices.Lights.Effects.ILampArrayColorRampEffect;
            Retval.m_ILampArrayColorRampEffect.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArrayColorRampEffect

   function get_Color
   (
      this : in out LampArrayColorRampEffect
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.get_Color (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out LampArrayColorRampEffect;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.put_Color (value);
   end;

   function get_RampDuration
   (
      this : in out LampArrayColorRampEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.get_RampDuration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RampDuration
   (
      this : in out LampArrayColorRampEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.put_RampDuration (value);
   end;

   function get_StartDelay
   (
      this : in out LampArrayColorRampEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.get_StartDelay (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_StartDelay
   (
      this : in out LampArrayColorRampEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.put_StartDelay (value);
   end;

   function get_CompletionBehavior
   (
      this : in out LampArrayColorRampEffect
   )
   return WinRt.Windows.Devices.Lights.Effects.LampArrayEffectCompletionBehavior is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Lights.Effects.LampArrayEffectCompletionBehavior;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.get_CompletionBehavior (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_CompletionBehavior
   (
      this : in out LampArrayColorRampEffect;
      value : Windows.Devices.Lights.Effects.LampArrayEffectCompletionBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayColorRampEffect.all.put_CompletionBehavior (value);
   end;

   function get_ZIndex
   (
      this : in out LampArrayColorRampEffect
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayColorRampEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayColorRampEffect.all);
      Hr := m_Interface.get_ZIndex (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out LampArrayColorRampEffect;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayColorRampEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayColorRampEffect.all);
      Hr := m_Interface.put_ZIndex (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArrayCustomEffect

   procedure Initialize (this : in out LampArrayCustomEffect) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArrayCustomEffect) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArrayCustomEffect, ILampArrayCustomEffect_Ptr);
   begin
      if this.m_ILampArrayCustomEffect /= null then
         if this.m_ILampArrayCustomEffect.all /= null then
            RefCount := this.m_ILampArrayCustomEffect.all.Release;
            Free (this.m_ILampArrayCustomEffect);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LampArrayCustomEffect

   function Constructor
   (
      lampArray : Windows.Devices.Lights.LampArray'Class;
      lampIndexes : WinRt.Int32_Array
   )
   return LampArrayCustomEffect is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayCustomEffect");
      m_Factory    : access ILampArrayCustomEffectFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Lights.Effects.ILampArrayCustomEffect;
      function Convert_lampIndexes is new Ada.Unchecked_Conversion (Address, WinRt.Int32_Ptr);
   begin
      return RetVal : LampArrayCustomEffect do
         Hr := RoGetActivationFactory (m_hString, IID_ILampArrayCustomEffectFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (lampArray.m_ILampArray.all, WinRt.UInt32(lampIndexes'Length), Convert_lampIndexes (lampIndexes (lampIndexes'First)'Address), m_ComRetVal'Access);
            Retval.m_ILampArrayCustomEffect := new Windows.Devices.Lights.Effects.ILampArrayCustomEffect;
            Retval.m_ILampArrayCustomEffect.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArrayCustomEffect

   function get_Duration
   (
      this : in out LampArrayCustomEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayCustomEffect.all.get_Duration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out LampArrayCustomEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayCustomEffect.all.put_Duration (value);
   end;

   function get_UpdateInterval
   (
      this : in out LampArrayCustomEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayCustomEffect.all.get_UpdateInterval (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_UpdateInterval
   (
      this : in out LampArrayCustomEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayCustomEffect.all.put_UpdateInterval (value);
   end;

   function add_UpdateRequested
   (
      this : in out LampArrayCustomEffect;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ILampArrayCustomEffect.all.add_UpdateRequested (handler, m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure remove_UpdateRequested
   (
      this : in out LampArrayCustomEffect;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayCustomEffect.all.remove_UpdateRequested (token);
   end;

   function get_ZIndex
   (
      this : in out LampArrayCustomEffect
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayCustomEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayCustomEffect.all);
      Hr := m_Interface.get_ZIndex (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out LampArrayCustomEffect;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayCustomEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayCustomEffect.all);
      Hr := m_Interface.put_ZIndex (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArrayEffectPlaylist

   procedure Initialize (this : in out LampArrayEffectPlaylist) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArrayEffectPlaylist) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArrayEffectPlaylist, ILampArrayEffectPlaylist_Ptr);
   begin
      if this.m_ILampArrayEffectPlaylist /= null then
         if this.m_ILampArrayEffectPlaylist.all /= null then
            RefCount := this.m_ILampArrayEffectPlaylist.all.Release;
            Free (this.m_ILampArrayEffectPlaylist);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LampArrayEffectPlaylist

   function Constructor return LampArrayEffectPlaylist is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayEffectPlaylist");
      m_ComRetVal  : aliased Windows.Devices.Lights.Effects.ILampArrayEffectPlaylist;
   begin
      return RetVal : LampArrayEffectPlaylist do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ILampArrayEffectPlaylist := new Windows.Devices.Lights.Effects.ILampArrayEffectPlaylist;
            Retval.m_ILampArrayEffectPlaylist.all := m_ComRetVal;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for LampArrayEffectPlaylist

   procedure StartAll
   (
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayEffectPlaylist");
      m_Factory        : access WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylistStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ILampArrayEffectPlaylistStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.StartAll (value);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
   end;

   procedure StopAll
   (
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayEffectPlaylist");
      m_Factory        : access WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylistStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ILampArrayEffectPlaylistStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.StopAll (value);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
   end;

   procedure PauseAll
   (
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_hString        : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArrayEffectPlaylist");
      m_Factory        : access WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylistStatics_Interface'Class := null;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ILampArrayEffectPlaylistStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.PauseAll (value);
         m_RefCount := m_Factory.Release;
      end if;
      Hr := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArrayEffectPlaylist

   procedure Append
   (
      this : in out LampArrayEffectPlaylist;
      effect : Windows.Devices.Lights.Effects.ILampArrayEffect
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.Append (effect);
   end;

   procedure OverrideZIndex
   (
      this : in out LampArrayEffectPlaylist;
      zIndex : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.OverrideZIndex (zIndex);
   end;

   procedure Start
   (
      this : in out LampArrayEffectPlaylist
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.Start;
   end;

   procedure Stop
   (
      this : in out LampArrayEffectPlaylist
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.Stop;
   end;

   procedure Pause
   (
      this : in out LampArrayEffectPlaylist
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.Pause;
   end;

   function get_EffectStartMode
   (
      this : in out LampArrayEffectPlaylist
   )
   return WinRt.Windows.Devices.Lights.Effects.LampArrayEffectStartMode is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Lights.Effects.LampArrayEffectStartMode;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.get_EffectStartMode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_EffectStartMode
   (
      this : in out LampArrayEffectPlaylist;
      value : Windows.Devices.Lights.Effects.LampArrayEffectStartMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.put_EffectStartMode (value);
   end;

   function get_Occurrences
   (
      this : in out LampArrayEffectPlaylist
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.get_Occurrences (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Occurrences
   (
      this : in out LampArrayEffectPlaylist;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.put_Occurrences (value);
   end;

   function get_RepetitionMode
   (
      this : in out LampArrayEffectPlaylist
   )
   return WinRt.Windows.Devices.Lights.Effects.LampArrayRepetitionMode is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Lights.Effects.LampArrayRepetitionMode;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.get_RepetitionMode (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_RepetitionMode
   (
      this : in out LampArrayEffectPlaylist;
      value : Windows.Devices.Lights.Effects.LampArrayRepetitionMode
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayEffectPlaylist.all.put_RepetitionMode (value);
   end;

   -- Generic Interface Windows.Foundation.Collections.IVectorView`1<Windows.Devices.Lights.Effects.ILampArrayEffect>
   function GetAt
   (
      this : in out LampArrayEffectPlaylist;
      index : WinRt.UInt32
   )
   return WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : IVectorView_ILampArrayEffect.Kind := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Lights.Effects.ILampArrayEffect;
      m_GenericIID     : aliased WinRt.IID := (2534774150, 40880, 22228, (157, 244, 140, 54, 234, 21, 16, 14 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylist_Interface, IVectorView_ILampArrayEffect.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayEffectPlaylist.all);
      Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out LampArrayEffectPlaylist
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : IVectorView_ILampArrayEffect.Kind := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (2534774150, 40880, 22228, (157, 244, 140, 54, 234, 21, 16, 14 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylist_Interface, IVectorView_ILampArrayEffect.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayEffectPlaylist.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out LampArrayEffectPlaylist;
      value : Windows.Devices.Lights.Effects.ILampArrayEffect;
      index : WinRt.UInt32_Ptr
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : IVectorView_ILampArrayEffect.Kind := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      m_GenericIID     : aliased WinRt.IID := (2534774150, 40880, 22228, (157, 244, 140, 54, 234, 21, 16, 14 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylist_Interface, IVectorView_ILampArrayEffect.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayEffectPlaylist.all);
      Hr := m_Interface.IndexOf (value, index, m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   function GetMany
   (
      this : in out LampArrayEffectPlaylist;
      startIndex : WinRt.UInt32;
      items : Windows.Devices.Lights.Effects.ILampArrayEffect_Array
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : IVectorView_ILampArrayEffect.Kind := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      m_GenericIID     : aliased WinRt.IID := (2534774150, 40880, 22228, (157, 244, 140, 54, 234, 21, 16, 14 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylist_Interface, IVectorView_ILampArrayEffect.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinRt.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ILampArrayEffectPlaylist.all);
      Hr := m_Interface.GetMany (startIndex, WinRt.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.Devices.Lights.Effects.ILampArrayEffect>
   function First
   (
      this : in out LampArrayEffectPlaylist
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : IIterable_ILampArrayEffect.Kind := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericIID     : aliased WinRt.IID := (1058049335, 26233, 21904, (174, 210, 3, 51, 98, 251, 244, 19 ));
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArrayEffectPlaylist_Interface, IIterable_ILampArrayEffect.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArrayEffectPlaylist.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArraySolidEffect

   procedure Initialize (this : in out LampArraySolidEffect) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArraySolidEffect) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArraySolidEffect, ILampArraySolidEffect_Ptr);
   begin
      if this.m_ILampArraySolidEffect /= null then
         if this.m_ILampArraySolidEffect.all /= null then
            RefCount := this.m_ILampArraySolidEffect.all.Release;
            Free (this.m_ILampArraySolidEffect);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for LampArraySolidEffect

   function Constructor
   (
      lampArray : Windows.Devices.Lights.LampArray'Class;
      lampIndexes : WinRt.Int32_Array
   )
   return LampArraySolidEffect is
      Hr           : WinRt.HResult := S_OK;
      m_hString    : WinRt.HString := To_HString ("Windows.Devices.Lights.Effects.LampArraySolidEffect");
      m_Factory    : access ILampArraySolidEffectFactory_Interface'Class := null;
      m_RefCount   : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Lights.Effects.ILampArraySolidEffect;
      function Convert_lampIndexes is new Ada.Unchecked_Conversion (Address, WinRt.Int32_Ptr);
   begin
      return RetVal : LampArraySolidEffect do
         Hr := RoGetActivationFactory (m_hString, IID_ILampArraySolidEffectFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (lampArray.m_ILampArray.all, WinRt.UInt32(lampIndexes'Length), Convert_lampIndexes (lampIndexes (lampIndexes'First)'Address), m_ComRetVal'Access);
            Retval.m_ILampArraySolidEffect := new Windows.Devices.Lights.Effects.ILampArraySolidEffect;
            Retval.m_ILampArraySolidEffect.all := m_ComRetVal;
            m_RefCount := m_Factory.Release;
         end if;
         Hr := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArraySolidEffect

   function get_Color
   (
      this : in out LampArraySolidEffect
   )
   return WinRt.Windows.UI.Color is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Color;
   begin
      Hr := this.m_ILampArraySolidEffect.all.get_Color (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out LampArraySolidEffect;
      value : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArraySolidEffect.all.put_Color (value);
   end;

   function get_Duration
   (
      this : in out LampArraySolidEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArraySolidEffect.all.get_Duration (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_Duration
   (
      this : in out LampArraySolidEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArraySolidEffect.all.put_Duration (value);
   end;

   function get_StartDelay
   (
      this : in out LampArraySolidEffect
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArraySolidEffect.all.get_StartDelay (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_StartDelay
   (
      this : in out LampArraySolidEffect;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArraySolidEffect.all.put_StartDelay (value);
   end;

   function get_CompletionBehavior
   (
      this : in out LampArraySolidEffect
   )
   return WinRt.Windows.Devices.Lights.Effects.LampArrayEffectCompletionBehavior is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Lights.Effects.LampArrayEffectCompletionBehavior;
   begin
      Hr := this.m_ILampArraySolidEffect.all.get_CompletionBehavior (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure put_CompletionBehavior
   (
      this : in out LampArraySolidEffect;
      value : Windows.Devices.Lights.Effects.LampArrayEffectCompletionBehavior
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArraySolidEffect.all.put_CompletionBehavior (value);
   end;

   function get_ZIndex
   (
      this : in out LampArraySolidEffect
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArraySolidEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArraySolidEffect.all);
      Hr := m_Interface.get_ZIndex (m_ComRetVal'Access);
      m_RefCount := m_Interface.Release;
      return m_ComRetVal;
   end;

   procedure put_ZIndex
   (
      this : in out LampArraySolidEffect;
      value : WinRt.Int32
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect := null;
      m_RefCount       : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Lights.Effects.ILampArraySolidEffect_Interface, WinRt.Windows.Devices.Lights.Effects.ILampArrayEffect, WinRt.Windows.Devices.Lights.Effects.IID_ILampArrayEffect'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ILampArraySolidEffect.all);
      Hr := m_Interface.put_ZIndex (value);
      m_RefCount := m_Interface.Release;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for LampArrayUpdateRequestedEventArgs

   procedure Initialize (this : in out LampArrayUpdateRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out LampArrayUpdateRequestedEventArgs) is
      RefCount : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ILampArrayUpdateRequestedEventArgs, ILampArrayUpdateRequestedEventArgs_Ptr);
   begin
      if this.m_ILampArrayUpdateRequestedEventArgs /= null then
         if this.m_ILampArrayUpdateRequestedEventArgs.all /= null then
            RefCount := this.m_ILampArrayUpdateRequestedEventArgs.all.Release;
            Free (this.m_ILampArrayUpdateRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for LampArrayUpdateRequestedEventArgs

   function get_SinceStarted
   (
      this : in out LampArrayUpdateRequestedEventArgs
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ILampArrayUpdateRequestedEventArgs.all.get_SinceStarted (m_ComRetVal'Access);
      return m_ComRetVal;
   end;

   procedure SetColor
   (
      this : in out LampArrayUpdateRequestedEventArgs;
      desiredColor : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayUpdateRequestedEventArgs.all.SetColor (desiredColor);
   end;

   procedure SetColorForIndex
   (
      this : in out LampArrayUpdateRequestedEventArgs;
      lampIndex : WinRt.Int32;
      desiredColor : Windows.UI.Color
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ILampArrayUpdateRequestedEventArgs.all.SetColorForIndex (lampIndex, desiredColor);
   end;

   procedure SetSingleColorForIndices
   (
      this : in out LampArrayUpdateRequestedEventArgs;
      desiredColor : Windows.UI.Color;
      lampIndexes : WinRt.Int32_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      function Convert_lampIndexes is new Ada.Unchecked_Conversion (Address, WinRt.Int32_Ptr);
   begin
      Hr := this.m_ILampArrayUpdateRequestedEventArgs.all.SetSingleColorForIndices (desiredColor, WinRt.UInt32(lampIndexes'Length), Convert_lampIndexes (lampIndexes (lampIndexes'First)'Address));
   end;

   procedure SetColorsForIndices
   (
      this : in out LampArrayUpdateRequestedEventArgs;
      desiredColors : Windows.UI.Color_Array;
      lampIndexes : WinRt.Int32_Array
   ) is
      Hr               : WinRt.HResult := S_OK;
      m_RefCount       : WinRt.UInt32 := 0;
      function Convert_desiredColors is new Ada.Unchecked_Conversion (Address, WinRt.Windows.UI.Color_Ptr);
      function Convert_lampIndexes is new Ada.Unchecked_Conversion (Address, WinRt.Int32_Ptr);
   begin
      Hr := this.m_ILampArrayUpdateRequestedEventArgs.all.SetColorsForIndices (WinRt.UInt32(desiredColors'Length), Convert_desiredColors (desiredColors (desiredColors'First)'Address), WinRt.UInt32(lampIndexes'Length), Convert_lampIndexes (lampIndexes (lampIndexes'First)'Address));
   end;

end;
