--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Numerics;
with WinRt.Windows.Graphics;
with WinRt.Windows.Graphics.DirectX;
with WinRt.Windows.Graphics.DirectX.Direct3D11;
with WinRt.Windows.Storage.Streams;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.Devices.Display.Core is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayAdapter

   procedure Initialize (this : in out DisplayAdapter) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayAdapter) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayAdapter, IDisplayAdapter_Ptr);
   begin
      if this.m_IDisplayAdapter /= null then
         if this.m_IDisplayAdapter.all /= null then
            temp := this.m_IDisplayAdapter.all.Release;
            Free (this.m_IDisplayAdapter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayAdapter

   function FromId
   (
      id : Windows.Graphics.DisplayAdapterId
   )
   return WinRt.Windows.Devices.Display.Core.DisplayAdapter is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Devices.Display.Core.DisplayAdapter");
      m_Factory        : access WinRt.Windows.Devices.Display.Core.IDisplayAdapterStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayAdapter;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayAdapter do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayAdapterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.FromId (id, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayAdapter := new Windows.Devices.Display.Core.IDisplayAdapter;
            Retval.m_IDisplayAdapter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayAdapter

   function get_Id
   (
      this : in out DisplayAdapter
   )
   return WinRt.Windows.Graphics.DisplayAdapterId is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DisplayAdapterId;
   begin
      Hr := this.m_IDisplayAdapter.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DeviceInterfacePath
   (
      this : in out DisplayAdapter
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayAdapter.all.get_DeviceInterfacePath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_SourceCount
   (
      this : in out DisplayAdapter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_SourceCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciVendorId
   (
      this : in out DisplayAdapter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciVendorId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciDeviceId
   (
      this : in out DisplayAdapter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciDeviceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciSubSystemId
   (
      this : in out DisplayAdapter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciSubSystemId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PciRevision
   (
      this : in out DisplayAdapter
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayAdapter.all.get_PciRevision (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayAdapter
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayAdapter.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayDevice

   procedure Initialize (this : in out DisplayDevice) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayDevice) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayDevice, IDisplayDevice_Ptr);
   begin
      if this.m_IDisplayDevice /= null then
         if this.m_IDisplayDevice.all /= null then
            temp := this.m_IDisplayDevice.all.Release;
            Free (this.m_IDisplayDevice);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayDevice

   function CreateScanoutSource
   (
      this : in out DisplayDevice;
      target : Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplaySource'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplaySource;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplaySource do
         Hr := this.m_IDisplayDevice.all.CreateScanoutSource (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplaySource := new Windows.Devices.Display.Core.IDisplaySource;
         Retval.m_IDisplaySource.all := m_ComRetVal;
      end return;
   end;

   function CreatePrimary
   (
      this : in out DisplayDevice;
      target : Windows.Devices.Display.Core.DisplayTarget'Class;
      desc : Windows.Devices.Display.Core.DisplayPrimaryDescription'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplaySurface'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplaySurface;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplaySurface do
         Hr := this.m_IDisplayDevice.all.CreatePrimary (target.m_IDisplayTarget.all, desc.m_IDisplayPrimaryDescription.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplaySurface := new Windows.Devices.Display.Core.IDisplaySurface;
         Retval.m_IDisplaySurface.all := m_ComRetVal;
      end return;
   end;

   function CreateTaskPool
   (
      this : in out DisplayDevice
   )
   return WinRt.Windows.Devices.Display.Core.DisplayTaskPool'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayTaskPool;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayTaskPool do
         Hr := this.m_IDisplayDevice.all.CreateTaskPool (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTaskPool := new Windows.Devices.Display.Core.IDisplayTaskPool;
         Retval.m_IDisplayTaskPool.all := m_ComRetVal;
      end return;
   end;

   function CreatePeriodicFence
   (
      this : in out DisplayDevice;
      target : Windows.Devices.Display.Core.DisplayTarget'Class;
      offsetFromVBlank : Windows.Foundation.TimeSpan
   )
   return WinRt.Windows.Devices.Display.Core.DisplayFence'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayFence;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayFence do
         Hr := this.m_IDisplayDevice.all.CreatePeriodicFence (target.m_IDisplayTarget.all, offsetFromVBlank, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayFence := new Windows.Devices.Display.Core.IDisplayFence;
         Retval.m_IDisplayFence.all := m_ComRetVal;
      end return;
   end;

   procedure WaitForVBlank
   (
      this : in out DisplayDevice;
      source : Windows.Devices.Display.Core.DisplaySource'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayDevice.all.WaitForVBlank (source.m_IDisplaySource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateSimpleScanout
   (
      this : in out DisplayDevice;
      pSource : Windows.Devices.Display.Core.DisplaySource'Class;
      pSurface : Windows.Devices.Display.Core.DisplaySurface'Class;
      SubResourceIndex : WinRt.UInt32;
      SyncInterval : WinRt.UInt32
   )
   return WinRt.Windows.Devices.Display.Core.DisplayScanout'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayScanout;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayScanout do
         Hr := this.m_IDisplayDevice.all.CreateSimpleScanout (pSource.m_IDisplaySource.all, pSurface.m_IDisplaySurface.all, SubResourceIndex, SyncInterval, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayScanout := new Windows.Devices.Display.Core.IDisplayScanout;
         Retval.m_IDisplayScanout.all := m_ComRetVal;
      end return;
   end;

   function IsCapabilitySupported
   (
      this : in out DisplayDevice;
      capability : Windows.Devices.Display.Core.DisplayDeviceCapability
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayDevice.all.IsCapabilitySupported (capability, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayFence

   procedure Initialize (this : in out DisplayFence) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayFence) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayFence, IDisplayFence_Ptr);
   begin
      if this.m_IDisplayFence /= null then
         if this.m_IDisplayFence.all /= null then
            temp := this.m_IDisplayFence.all.Release;
            Free (this.m_IDisplayFence);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayFence

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManager

   procedure Initialize (this : in out DisplayManager) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManager) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManager, IDisplayManager_Ptr);
   begin
      if this.m_IDisplayManager /= null then
         if this.m_IDisplayManager.all /= null then
            temp := this.m_IDisplayManager.all.Release;
            Free (this.m_IDisplayManager);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayManager

   function Create
   (
      options : Windows.Devices.Display.Core.DisplayManagerOptions
   )
   return WinRt.Windows.Devices.Display.Core.DisplayManager is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Devices.Display.Core.DisplayManager");
      m_Factory        : access WinRt.Windows.Devices.Display.Core.IDisplayManagerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayManager;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayManager do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayManagerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.Create (options, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayManager := new Windows.Devices.Display.Core.IDisplayManager;
            Retval.m_IDisplayManager.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManager

   function GetCurrentTargets
   (
      this : in out DisplayManager
   )
   return IVectorView_IDisplayTarget.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayTarget.Kind;
   begin
      Hr := this.m_IDisplayManager.all.GetCurrentTargets (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayTarget (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetCurrentAdapters
   (
      this : in out DisplayManager
   )
   return IVectorView_IDisplayAdapter.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayAdapter.Kind;
   begin
      Hr := this.m_IDisplayManager.all.GetCurrentAdapters (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayAdapter (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function TryAcquireTarget
   (
      this : in out DisplayManager;
      target : Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplayManagerResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayManagerResult;
   begin
      Hr := this.m_IDisplayManager.all.TryAcquireTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReleaseTarget
   (
      this : in out DisplayManager;
      target : Windows.Devices.Display.Core.DisplayTarget'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.ReleaseTarget (target.m_IDisplayTarget.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryReadCurrentStateForAllTargets
   (
      this : in out DisplayManager
   )
   return WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryReadCurrentStateForAllTargets (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function TryAcquireTargetsAndReadCurrentState
   (
      this : in out DisplayManager;
      targets : GenericObject
   )
   return WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryAcquireTargetsAndReadCurrentState (targets, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function TryAcquireTargetsAndCreateEmptyState
   (
      this : in out DisplayManager;
      targets : GenericObject
   )
   return WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryAcquireTargetsAndCreateEmptyState (targets, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function TryAcquireTargetsAndCreateSubstate
   (
      this : in out DisplayManager;
      existingState : Windows.Devices.Display.Core.DisplayState'Class;
      targets : GenericObject
   )
   return WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayManagerResultWithState;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayManagerResultWithState do
         Hr := this.m_IDisplayManager.all.TryAcquireTargetsAndCreateSubstate (existingState.m_IDisplayState.all, targets, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayManagerResultWithState := new Windows.Devices.Display.Core.IDisplayManagerResultWithState;
         Retval.m_IDisplayManagerResultWithState.all := m_ComRetVal;
      end return;
   end;

   function CreateDisplayDevice
   (
      this : in out DisplayManager;
      adapter : Windows.Devices.Display.Core.DisplayAdapter'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplayDevice'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayDevice;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayDevice do
         Hr := this.m_IDisplayManager.all.CreateDisplayDevice (adapter.m_IDisplayAdapter.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayDevice := new Windows.Devices.Display.Core.IDisplayDevice;
         Retval.m_IDisplayDevice.all := m_ComRetVal;
      end return;
   end;

   function add_Enabled
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_Enabled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Enabled
   (
      this : in out DisplayManager;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_Enabled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Disabled
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_Disabled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Disabled
   (
      this : in out DisplayManager;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_Disabled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Changed
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_Changed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Changed
   (
      this : in out DisplayManager;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_Changed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PathsFailedOrInvalidated
   (
      this : in out DisplayManager;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDisplayManager.all.add_PathsFailedOrInvalidated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PathsFailedOrInvalidated
   (
      this : in out DisplayManager;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.remove_PathsFailedOrInvalidated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Start
   (
      this : in out DisplayManager
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.Start;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out DisplayManager
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManager.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out DisplayManager
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.Devices.Display.Core.IDisplayManager_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDisplayManager.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerChangedEventArgs

   procedure Initialize (this : in out DisplayManagerChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerChangedEventArgs, IDisplayManagerChangedEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerChangedEventArgs /= null then
         if this.m_IDisplayManagerChangedEventArgs.all /= null then
            temp := this.m_IDisplayManagerChangedEventArgs.all.Release;
            Free (this.m_IDisplayManagerChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerChangedEventArgs

   function get_Handled
   (
      this : in out DisplayManagerChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayManagerChangedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerChangedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerChangedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerChangedEventArgs
   )
   return WinRt.Windows.Foundation.Deferral'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.IDeferral;
   begin
      return RetVal : WinRt.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerChangedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerDisabledEventArgs

   procedure Initialize (this : in out DisplayManagerDisabledEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerDisabledEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerDisabledEventArgs, IDisplayManagerDisabledEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerDisabledEventArgs /= null then
         if this.m_IDisplayManagerDisabledEventArgs.all /= null then
            temp := this.m_IDisplayManagerDisabledEventArgs.all.Release;
            Free (this.m_IDisplayManagerDisabledEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerDisabledEventArgs

   function get_Handled
   (
      this : in out DisplayManagerDisabledEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayManagerDisabledEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerDisabledEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerDisabledEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerDisabledEventArgs
   )
   return WinRt.Windows.Foundation.Deferral'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.IDeferral;
   begin
      return RetVal : WinRt.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerDisabledEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerEnabledEventArgs

   procedure Initialize (this : in out DisplayManagerEnabledEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerEnabledEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerEnabledEventArgs, IDisplayManagerEnabledEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerEnabledEventArgs /= null then
         if this.m_IDisplayManagerEnabledEventArgs.all /= null then
            temp := this.m_IDisplayManagerEnabledEventArgs.all.Release;
            Free (this.m_IDisplayManagerEnabledEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerEnabledEventArgs

   function get_Handled
   (
      this : in out DisplayManagerEnabledEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayManagerEnabledEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerEnabledEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerEnabledEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerEnabledEventArgs
   )
   return WinRt.Windows.Foundation.Deferral'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.IDeferral;
   begin
      return RetVal : WinRt.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerEnabledEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerPathsFailedOrInvalidatedEventArgs

   procedure Initialize (this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerPathsFailedOrInvalidatedEventArgs, IDisplayManagerPathsFailedOrInvalidatedEventArgs_Ptr);
   begin
      if this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs /= null then
         if this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all /= null then
            temp := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.Release;
            Free (this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerPathsFailedOrInvalidatedEventArgs

   function get_Handled
   (
      this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out DisplayManagerPathsFailedOrInvalidatedEventArgs
   )
   return WinRt.Windows.Foundation.Deferral'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.IDeferral;
   begin
      return RetVal : WinRt.Windows.Foundation.Deferral do
         Hr := this.m_IDisplayManagerPathsFailedOrInvalidatedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayManagerResultWithState

   procedure Initialize (this : in out DisplayManagerResultWithState) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayManagerResultWithState) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayManagerResultWithState, IDisplayManagerResultWithState_Ptr);
   begin
      if this.m_IDisplayManagerResultWithState /= null then
         if this.m_IDisplayManagerResultWithState.all /= null then
            temp := this.m_IDisplayManagerResultWithState.all.Release;
            Free (this.m_IDisplayManagerResultWithState);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayManagerResultWithState

   function get_ErrorCode
   (
      this : in out DisplayManagerResultWithState
   )
   return WinRt.Windows.Devices.Display.Core.DisplayManagerResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayManagerResult;
   begin
      Hr := this.m_IDisplayManagerResultWithState.all.get_ErrorCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtendedErrorCode
   (
      this : in out DisplayManagerResultWithState
   )
   return WinRt.Windows.Foundation.HResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.HResult;
   begin
      Hr := this.m_IDisplayManagerResultWithState.all.get_ExtendedErrorCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_State
   (
      this : in out DisplayManagerResultWithState
   )
   return WinRt.Windows.Devices.Display.Core.DisplayState'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayState;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayState do
         Hr := this.m_IDisplayManagerResultWithState.all.get_State (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayState := new Windows.Devices.Display.Core.IDisplayState;
         Retval.m_IDisplayState.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayModeInfo

   procedure Initialize (this : in out DisplayModeInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayModeInfo) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayModeInfo, IDisplayModeInfo_Ptr);
   begin
      if this.m_IDisplayModeInfo /= null then
         if this.m_IDisplayModeInfo.all /= null then
            temp := this.m_IDisplayModeInfo.all.Release;
            Free (this.m_IDisplayModeInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayModeInfo

   function get_SourceResolution
   (
      this : in out DisplayModeInfo
   )
   return WinRt.Windows.Graphics.SizeInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.SizeInt32;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_SourceResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsStereo
   (
      this : in out DisplayModeInfo
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_IsStereo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourcePixelFormat
   (
      this : in out DisplayModeInfo
   )
   return WinRt.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_SourcePixelFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TargetResolution
   (
      this : in out DisplayModeInfo
   )
   return WinRt.Windows.Graphics.SizeInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.SizeInt32;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_TargetResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PresentationRate
   (
      this : in out DisplayModeInfo
   )
   return WinRt.Windows.Devices.Display.Core.DisplayPresentationRate is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayPresentationRate;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_PresentationRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInterlaced
   (
      this : in out DisplayModeInfo
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_IsInterlaced (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetWireFormatSupportedBitsPerChannel
   (
      this : in out DisplayModeInfo;
      encoding : Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding
   )
   return WinRt.Windows.Devices.Display.Core.DisplayBitsPerChannel is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayBitsPerChannel;
   begin
      Hr := this.m_IDisplayModeInfo.all.GetWireFormatSupportedBitsPerChannel (encoding, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IsWireFormatSupported
   (
      this : in out DisplayModeInfo;
      wireFormat : Windows.Devices.Display.Core.DisplayWireFormat'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayModeInfo.all.IsWireFormatSupported (wireFormat.m_IDisplayWireFormat.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayModeInfo
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayModeInfo.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayPath

   procedure Initialize (this : in out DisplayPath) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayPath) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayPath, IDisplayPath_Ptr);
   begin
      if this.m_IDisplayPath /= null then
         if this.m_IDisplayPath.all /= null then
            temp := this.m_IDisplayPath.all.Release;
            Free (this.m_IDisplayPath);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayPath

   function get_View
   (
      this : in out DisplayPath
   )
   return WinRt.Windows.Devices.Display.Core.DisplayView'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayView;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayView do
         Hr := this.m_IDisplayPath.all.get_View (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayView := new Windows.Devices.Display.Core.IDisplayView;
         Retval.m_IDisplayView.all := m_ComRetVal;
      end return;
   end;

   function get_Target
   (
      this : in out DisplayPath
   )
   return WinRt.Windows.Devices.Display.Core.DisplayTarget'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayTarget;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayTarget do
         Hr := this.m_IDisplayPath.all.get_Target (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTarget := new Windows.Devices.Display.Core.IDisplayTarget;
         Retval.m_IDisplayTarget.all := m_ComRetVal;
      end return;
   end;

   function get_Status
   (
      this : in out DisplayPath
   )
   return WinRt.Windows.Devices.Display.Core.DisplayPathStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayPathStatus;
   begin
      Hr := this.m_IDisplayPath.all.get_Status (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourceResolution
   (
      this : in out DisplayPath
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IDisplayPath.all.get_SourceResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourceResolution
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_SourceResolution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SourcePixelFormat
   (
      this : in out DisplayPath
   )
   return WinRt.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_IDisplayPath.all.get_SourcePixelFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourcePixelFormat
   (
      this : in out DisplayPath;
      value : Windows.Graphics.DirectX.DirectXPixelFormat
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_SourcePixelFormat (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStereo
   (
      this : in out DisplayPath
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayPath.all.get_IsStereo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStereo
   (
      this : in out DisplayPath;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_IsStereo (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TargetResolution
   (
      this : in out DisplayPath
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IDisplayPath.all.get_TargetResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetResolution
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_TargetResolution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PresentationRate
   (
      this : in out DisplayPath
   )
   return IReference_DisplayPresentationRate.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_DisplayPresentationRate.Kind;
   begin
      Hr := this.m_IDisplayPath.all.get_PresentationRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DisplayPresentationRate (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PresentationRate
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_PresentationRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInterlaced
   (
      this : in out DisplayPath
   )
   return IReference_Boolean.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Boolean.Kind;
   begin
      Hr := this.m_IDisplayPath.all.get_IsInterlaced (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Boolean (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_IsInterlaced
   (
      this : in out DisplayPath;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_IsInterlaced (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_WireFormat
   (
      this : in out DisplayPath
   )
   return WinRt.Windows.Devices.Display.Core.DisplayWireFormat'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayWireFormat;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayWireFormat do
         Hr := this.m_IDisplayPath.all.get_WireFormat (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayWireFormat := new Windows.Devices.Display.Core.IDisplayWireFormat;
         Retval.m_IDisplayWireFormat.all := m_ComRetVal;
      end return;
   end;

   procedure put_WireFormat
   (
      this : in out DisplayPath;
      value : Windows.Devices.Display.Core.DisplayWireFormat'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_WireFormat (value.m_IDisplayWireFormat.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Rotation
   (
      this : in out DisplayPath
   )
   return WinRt.Windows.Devices.Display.Core.DisplayRotation is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayRotation;
   begin
      Hr := this.m_IDisplayPath.all.get_Rotation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Rotation
   (
      this : in out DisplayPath;
      value : Windows.Devices.Display.Core.DisplayRotation
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_Rotation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Scaling
   (
      this : in out DisplayPath
   )
   return WinRt.Windows.Devices.Display.Core.DisplayPathScaling is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayPathScaling;
   begin
      Hr := this.m_IDisplayPath.all.get_Scaling (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Scaling
   (
      this : in out DisplayPath;
      value : Windows.Devices.Display.Core.DisplayPathScaling
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.put_Scaling (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function FindModes
   (
      this : in out DisplayPath;
      flags : Windows.Devices.Display.Core.DisplayModeQueryOptions
   )
   return IVectorView_IDisplayModeInfo.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayModeInfo.Kind;
   begin
      Hr := this.m_IDisplayPath.all.FindModes (flags, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayModeInfo (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure ApplyPropertiesFromMode
   (
      this : in out DisplayPath;
      modeResult : Windows.Devices.Display.Core.DisplayModeInfo'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayPath.all.ApplyPropertiesFromMode (modeResult.m_IDisplayModeInfo.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Properties
   (
      this : in out DisplayPath
   )
   return IMap_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMap_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayPath.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayPrimaryDescription

   procedure Initialize (this : in out DisplayPrimaryDescription) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayPrimaryDescription) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayPrimaryDescription, IDisplayPrimaryDescription_Ptr);
   begin
      if this.m_IDisplayPrimaryDescription /= null then
         if this.m_IDisplayPrimaryDescription.all /= null then
            temp := this.m_IDisplayPrimaryDescription.all.Release;
            Free (this.m_IDisplayPrimaryDescription);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DisplayPrimaryDescription

   function Constructor
   (
      width : WinRt.UInt32;
      height : WinRt.UInt32;
      pixelFormat : Windows.Graphics.DirectX.DirectXPixelFormat;
      colorSpace : Windows.Graphics.DirectX.DirectXColorSpace;
      isStereo : WinRt.Boolean;
      multisampleDescription : Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription
   )
   return DisplayPrimaryDescription is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.Devices.Display.Core.DisplayPrimaryDescription");
      m_Factory    : access IDisplayPrimaryDescriptionFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Display.Core.IDisplayPrimaryDescription;
   begin
      return RetVal : DisplayPrimaryDescription do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayPrimaryDescriptionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, m_ComRetVal'Access);
            Retval.m_IDisplayPrimaryDescription := new Windows.Devices.Display.Core.IDisplayPrimaryDescription;
            Retval.m_IDisplayPrimaryDescription.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayPrimaryDescription

   function CreateWithProperties
   (
      extraProperties : GenericObject;
      width : WinRt.UInt32;
      height : WinRt.UInt32;
      pixelFormat : Windows.Graphics.DirectX.DirectXPixelFormat;
      colorSpace : Windows.Graphics.DirectX.DirectXColorSpace;
      isStereo : WinRt.Boolean;
      multisampleDescription : Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription
   )
   return WinRt.Windows.Devices.Display.Core.DisplayPrimaryDescription is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Devices.Display.Core.DisplayPrimaryDescription");
      m_Factory        : access WinRt.Windows.Devices.Display.Core.IDisplayPrimaryDescriptionStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayPrimaryDescription;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayPrimaryDescription do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayPrimaryDescriptionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithProperties (extraProperties, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayPrimaryDescription := new Windows.Devices.Display.Core.IDisplayPrimaryDescription;
            Retval.m_IDisplayPrimaryDescription.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayPrimaryDescription

   function get_Width
   (
      this : in out DisplayPrimaryDescription
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Width (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Height
   (
      this : in out DisplayPrimaryDescription
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Height (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Format
   (
      this : in out DisplayPrimaryDescription
   )
   return WinRt.Windows.Graphics.DirectX.DirectXPixelFormat is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DirectX.DirectXPixelFormat;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Format (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ColorSpace
   (
      this : in out DisplayPrimaryDescription
   )
   return WinRt.Windows.Graphics.DirectX.DirectXColorSpace is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DirectX.DirectXColorSpace;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_ColorSpace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsStereo
   (
      this : in out DisplayPrimaryDescription
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_IsStereo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MultisampleDescription
   (
      this : in out DisplayPrimaryDescription
   )
   return WinRt.Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_MultisampleDescription (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayPrimaryDescription
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayPrimaryDescription.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayScanout

   procedure Initialize (this : in out DisplayScanout) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayScanout) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayScanout, IDisplayScanout_Ptr);
   begin
      if this.m_IDisplayScanout /= null then
         if this.m_IDisplayScanout.all /= null then
            temp := this.m_IDisplayScanout.all.Release;
            Free (this.m_IDisplayScanout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayScanout

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplaySource

   procedure Initialize (this : in out DisplaySource) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplaySource) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplaySource, IDisplaySource_Ptr);
   begin
      if this.m_IDisplaySource /= null then
         if this.m_IDisplaySource.all /= null then
            temp := this.m_IDisplaySource.all.Release;
            Free (this.m_IDisplaySource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplaySource

   function get_AdapterId
   (
      this : in out DisplaySource
   )
   return WinRt.Windows.Graphics.DisplayAdapterId is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Graphics.DisplayAdapterId;
   begin
      Hr := this.m_IDisplaySource.all.get_AdapterId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourceId
   (
      this : in out DisplaySource
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplaySource.all.get_SourceId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetMetadata
   (
      this : in out DisplaySource;
      Key : WinRt.Guid
   )
   return WinRt.Windows.Storage.Streams.IBuffer is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Storage.Streams.IBuffer;
   begin
      Hr := this.m_IDisplaySource.all.GetMetadata (Key, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayState

   procedure Initialize (this : in out DisplayState) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayState) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayState, IDisplayState_Ptr);
   begin
      if this.m_IDisplayState /= null then
         if this.m_IDisplayState.all /= null then
            temp := this.m_IDisplayState.all.Release;
            Free (this.m_IDisplayState);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayState

   function get_IsReadOnly
   (
      this : in out DisplayState
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayState.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsStale
   (
      this : in out DisplayState
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayState.all.get_IsStale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Targets
   (
      this : in out DisplayState
   )
   return IVectorView_IDisplayTarget.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayTarget.Kind;
   begin
      Hr := this.m_IDisplayState.all.get_Targets (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayTarget (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Views
   (
      this : in out DisplayState
   )
   return IVectorView_IDisplayView.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayView.Kind;
   begin
      Hr := this.m_IDisplayState.all.get_Views (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayView (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayState
   )
   return IMap_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMap_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayState.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function ConnectTarget
   (
      this : in out DisplayState;
      target : Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplayPath'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayPath;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayPath do
         Hr := this.m_IDisplayState.all.ConnectTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayPath := new Windows.Devices.Display.Core.IDisplayPath;
         Retval.m_IDisplayPath.all := m_ComRetVal;
      end return;
   end;

   function ConnectTarget
   (
      this : in out DisplayState;
      target : Windows.Devices.Display.Core.DisplayTarget'Class;
      view : Windows.Devices.Display.Core.DisplayView'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplayPath'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayPath;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayPath do
         Hr := this.m_IDisplayState.all.ConnectTarget (target.m_IDisplayTarget.all, view.m_IDisplayView.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayPath := new Windows.Devices.Display.Core.IDisplayPath;
         Retval.m_IDisplayPath.all := m_ComRetVal;
      end return;
   end;

   function CanConnectTargetToView
   (
      this : in out DisplayState;
      target : Windows.Devices.Display.Core.DisplayTarget'Class;
      view : Windows.Devices.Display.Core.DisplayView'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayState.all.CanConnectTargetToView (target.m_IDisplayTarget.all, view.m_IDisplayView.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetViewForTarget
   (
      this : in out DisplayState;
      target : Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplayView'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayView;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayView do
         Hr := this.m_IDisplayState.all.GetViewForTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayView := new Windows.Devices.Display.Core.IDisplayView;
         Retval.m_IDisplayView.all := m_ComRetVal;
      end return;
   end;

   function GetPathForTarget
   (
      this : in out DisplayState;
      target : Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinRt.Windows.Devices.Display.Core.DisplayPath'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayPath;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayPath do
         Hr := this.m_IDisplayState.all.GetPathForTarget (target.m_IDisplayTarget.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayPath := new Windows.Devices.Display.Core.IDisplayPath;
         Retval.m_IDisplayPath.all := m_ComRetVal;
      end return;
   end;

   procedure DisconnectTarget
   (
      this : in out DisplayState;
      target : Windows.Devices.Display.Core.DisplayTarget'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayState.all.DisconnectTarget (target.m_IDisplayTarget.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryFunctionalize
   (
      this : in out DisplayState;
      options : Windows.Devices.Display.Core.DisplayStateFunctionalizeOptions
   )
   return WinRt.Windows.Devices.Display.Core.DisplayStateOperationResult'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayStateOperationResult;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayStateOperationResult do
         Hr := this.m_IDisplayState.all.TryFunctionalize (options, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayStateOperationResult := new Windows.Devices.Display.Core.IDisplayStateOperationResult;
         Retval.m_IDisplayStateOperationResult.all := m_ComRetVal;
      end return;
   end;

   function TryApply
   (
      this : in out DisplayState;
      options : Windows.Devices.Display.Core.DisplayStateApplyOptions
   )
   return WinRt.Windows.Devices.Display.Core.DisplayStateOperationResult'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayStateOperationResult;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayStateOperationResult do
         Hr := this.m_IDisplayState.all.TryApply (options, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayStateOperationResult := new Windows.Devices.Display.Core.IDisplayStateOperationResult;
         Retval.m_IDisplayStateOperationResult.all := m_ComRetVal;
      end return;
   end;

   function Clone
   (
      this : in out DisplayState
   )
   return WinRt.Windows.Devices.Display.Core.DisplayState'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayState;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayState do
         Hr := this.m_IDisplayState.all.Clone (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayState := new Windows.Devices.Display.Core.IDisplayState;
         Retval.m_IDisplayState.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayStateOperationResult

   procedure Initialize (this : in out DisplayStateOperationResult) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayStateOperationResult) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayStateOperationResult, IDisplayStateOperationResult_Ptr);
   begin
      if this.m_IDisplayStateOperationResult /= null then
         if this.m_IDisplayStateOperationResult.all /= null then
            temp := this.m_IDisplayStateOperationResult.all.Release;
            Free (this.m_IDisplayStateOperationResult);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayStateOperationResult

   function get_Status
   (
      this : in out DisplayStateOperationResult
   )
   return WinRt.Windows.Devices.Display.Core.DisplayStateOperationStatus is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayStateOperationStatus;
   begin
      Hr := this.m_IDisplayStateOperationResult.all.get_Status (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtendedErrorCode
   (
      this : in out DisplayStateOperationResult
   )
   return WinRt.Windows.Foundation.HResult is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.HResult;
   begin
      Hr := this.m_IDisplayStateOperationResult.all.get_ExtendedErrorCode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplaySurface

   procedure Initialize (this : in out DisplaySurface) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplaySurface) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplaySurface, IDisplaySurface_Ptr);
   begin
      if this.m_IDisplaySurface /= null then
         if this.m_IDisplaySurface.all /= null then
            temp := this.m_IDisplaySurface.all.Release;
            Free (this.m_IDisplaySurface);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplaySurface

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayTarget

   procedure Initialize (this : in out DisplayTarget) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayTarget) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayTarget, IDisplayTarget_Ptr);
   begin
      if this.m_IDisplayTarget /= null then
         if this.m_IDisplayTarget.all /= null then
            temp := this.m_IDisplayTarget.all.Release;
            Free (this.m_IDisplayTarget);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayTarget

   function get_Adapter
   (
      this : in out DisplayTarget
   )
   return WinRt.Windows.Devices.Display.Core.DisplayAdapter'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayAdapter;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayAdapter do
         Hr := this.m_IDisplayTarget.all.get_Adapter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayAdapter := new Windows.Devices.Display.Core.IDisplayAdapter;
         Retval.m_IDisplayAdapter.all := m_ComRetVal;
      end return;
   end;

   function get_DeviceInterfacePath
   (
      this : in out DisplayTarget
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayTarget.all.get_DeviceInterfacePath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_AdapterRelativeId
   (
      this : in out DisplayTarget
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IDisplayTarget.all.get_AdapterRelativeId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsConnected
   (
      this : in out DisplayTarget
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsConnected (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsVirtualModeEnabled
   (
      this : in out DisplayTarget
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsVirtualModeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsVirtualTopologyEnabled
   (
      this : in out DisplayTarget
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsVirtualTopologyEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UsageKind
   (
      this : in out DisplayTarget
   )
   return WinRt.Windows.Devices.Display.DisplayMonitorUsageKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.DisplayMonitorUsageKind;
   begin
      Hr := this.m_IDisplayTarget.all.get_UsageKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MonitorPersistence
   (
      this : in out DisplayTarget
   )
   return WinRt.Windows.Devices.Display.Core.DisplayTargetPersistence is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayTargetPersistence;
   begin
      Hr := this.m_IDisplayTarget.all.get_MonitorPersistence (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_StableMonitorId
   (
      this : in out DisplayTarget
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDisplayTarget.all.get_StableMonitorId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function TryGetMonitor
   (
      this : in out DisplayTarget
   )
   return WinRt.Windows.Devices.Display.DisplayMonitor'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.IDisplayMonitor;
   begin
      return RetVal : WinRt.Windows.Devices.Display.DisplayMonitor do
         Hr := this.m_IDisplayTarget.all.TryGetMonitor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayMonitor := new Windows.Devices.Display.IDisplayMonitor;
         Retval.m_IDisplayMonitor.all := m_ComRetVal;
      end return;
   end;

   function get_Properties
   (
      this : in out DisplayTarget
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayTarget.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IsStale
   (
      this : in out DisplayTarget
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.get_IsStale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IsSame
   (
      this : in out DisplayTarget;
      otherTarget : Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.IsSame (otherTarget.m_IDisplayTarget.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IsEqual
   (
      this : in out DisplayTarget;
      otherTarget : Windows.Devices.Display.Core.DisplayTarget'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IDisplayTarget.all.IsEqual (otherTarget.m_IDisplayTarget.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayTask

   procedure Initialize (this : in out DisplayTask) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayTask) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayTask, IDisplayTask_Ptr);
   begin
      if this.m_IDisplayTask /= null then
         if this.m_IDisplayTask.all /= null then
            temp := this.m_IDisplayTask.all.Release;
            Free (this.m_IDisplayTask);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayTask

   procedure SetScanout
   (
      this : in out DisplayTask;
      scanout : Windows.Devices.Display.Core.DisplayScanout'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayTask.all.SetScanout (scanout.m_IDisplayScanout.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetWait
   (
      this : in out DisplayTask;
      readyFence : Windows.Devices.Display.Core.DisplayFence'Class;
      readyFenceValue : WinRt.UInt64
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayTask.all.SetWait (readyFence.m_IDisplayFence.all, readyFenceValue);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayTaskPool

   procedure Initialize (this : in out DisplayTaskPool) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayTaskPool) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayTaskPool, IDisplayTaskPool_Ptr);
   begin
      if this.m_IDisplayTaskPool /= null then
         if this.m_IDisplayTaskPool.all /= null then
            temp := this.m_IDisplayTaskPool.all.Release;
            Free (this.m_IDisplayTaskPool);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayTaskPool

   function CreateTask
   (
      this : in out DisplayTaskPool
   )
   return WinRt.Windows.Devices.Display.Core.DisplayTask'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayTask;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayTask do
         Hr := this.m_IDisplayTaskPool.all.CreateTask (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDisplayTask := new Windows.Devices.Display.Core.IDisplayTask;
         Retval.m_IDisplayTask.all := m_ComRetVal;
      end return;
   end;

   procedure ExecuteTask
   (
      this : in out DisplayTaskPool;
      task_x : Windows.Devices.Display.Core.DisplayTask'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayTaskPool.all.ExecuteTask (task_x.m_IDisplayTask.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayView

   procedure Initialize (this : in out DisplayView) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayView) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayView, IDisplayView_Ptr);
   begin
      if this.m_IDisplayView /= null then
         if this.m_IDisplayView.all /= null then
            temp := this.m_IDisplayView.all.Release;
            Free (this.m_IDisplayView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayView

   function get_Paths
   (
      this : in out DisplayView
   )
   return IVectorView_IDisplayPath.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVectorView_IDisplayPath.Kind;
   begin
      Hr := this.m_IDisplayView.all.get_Paths (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IDisplayPath (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_ContentResolution
   (
      this : in out DisplayView
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := this.m_IDisplayView.all.get_ContentResolution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ContentResolution
   (
      this : in out DisplayView;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayView.all.put_ContentResolution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPrimaryPath
   (
      this : in out DisplayView;
      path : Windows.Devices.Display.Core.DisplayPath'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IDisplayView.all.SetPrimaryPath (path.m_IDisplayPath.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Properties
   (
      this : in out DisplayView
   )
   return IMap_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMap_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayView.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMap_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DisplayWireFormat

   procedure Initialize (this : in out DisplayWireFormat) is
   begin
      null;
   end;

   procedure Finalize (this : in out DisplayWireFormat) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDisplayWireFormat, IDisplayWireFormat_Ptr);
   begin
      if this.m_IDisplayWireFormat /= null then
         if this.m_IDisplayWireFormat.all /= null then
            temp := this.m_IDisplayWireFormat.all.Release;
            Free (this.m_IDisplayWireFormat);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DisplayWireFormat

   function Constructor
   (
      pixelEncoding : Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding;
      bitsPerChannel : WinRt.Int32;
      colorSpace : Windows.Devices.Display.Core.DisplayWireFormatColorSpace;
      eotf : Windows.Devices.Display.Core.DisplayWireFormatEotf;
      hdrMetadata : Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata
   )
   return DisplayWireFormat is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.Devices.Display.Core.DisplayWireFormat");
      m_Factory    : access IDisplayWireFormatFactory_Interface'Class := null;
      temp         : WinRt.UInt32 := 0;
      m_ComRetVal  : aliased Windows.Devices.Display.Core.IDisplayWireFormat;
   begin
      return RetVal : DisplayWireFormat do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayWireFormatFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, m_ComRetVal'Access);
            Retval.m_IDisplayWireFormat := new Windows.Devices.Display.Core.IDisplayWireFormat;
            Retval.m_IDisplayWireFormat.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DisplayWireFormat

   function CreateWithProperties
   (
      extraProperties : GenericObject;
      pixelEncoding : Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding;
      bitsPerChannel : WinRt.Int32;
      colorSpace : Windows.Devices.Display.Core.DisplayWireFormatColorSpace;
      eotf : Windows.Devices.Display.Core.DisplayWireFormatEotf;
      hdrMetadata : Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata
   )
   return WinRt.Windows.Devices.Display.Core.DisplayWireFormat is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.Devices.Display.Core.DisplayWireFormat");
      m_Factory        : access WinRt.Windows.Devices.Display.Core.IDisplayWireFormatStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.IDisplayWireFormat;
   begin
      return RetVal : WinRt.Windows.Devices.Display.Core.DisplayWireFormat do
         Hr := RoGetActivationFactory (m_hString, IID_IDisplayWireFormatStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateWithProperties (extraProperties, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDisplayWireFormat := new Windows.Devices.Display.Core.IDisplayWireFormat;
            Retval.m_IDisplayWireFormat.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DisplayWireFormat

   function get_PixelEncoding
   (
      this : in out DisplayWireFormat
   )
   return WinRt.Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayWireFormatPixelEncoding;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_PixelEncoding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BitsPerChannel
   (
      this : in out DisplayWireFormat
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_BitsPerChannel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ColorSpace
   (
      this : in out DisplayWireFormat
   )
   return WinRt.Windows.Devices.Display.Core.DisplayWireFormatColorSpace is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayWireFormatColorSpace;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_ColorSpace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Eotf
   (
      this : in out DisplayWireFormat
   )
   return WinRt.Windows.Devices.Display.Core.DisplayWireFormatEotf is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayWireFormatEotf;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_Eotf (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HdrMetadata
   (
      this : in out DisplayWireFormat
   )
   return WinRt.Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Display.Core.DisplayWireFormatHdrMetadata;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_HdrMetadata (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out DisplayWireFormat
   )
   return IMapView_Guid_IInspectable.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IMapView_Guid_IInspectable.Kind;
   begin
      Hr := this.m_IDisplayWireFormat.all.get_Properties (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IMapView_Guid_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

end WinRt.Windows.Devices.Display.Core;
