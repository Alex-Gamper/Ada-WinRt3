--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinRt.Windows.Devices.Haptics;
with WinRt.Windows.Devices.Input;
with WinRt.Windows.Foundation; use WinRt.Windows.Foundation;
with WinRt.Windows.Foundation.Collections;
with WinRt.Windows.Storage.Streams;
with WinRt.Windows.System;
with WinRt.Windows.UI.Core;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinRt.Windows.UI.Input is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AttachableInputObject

   procedure Initialize (this : in out AttachableInputObject) is
   begin
      null;
   end;

   procedure Finalize (this : in out AttachableInputObject) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAttachableInputObject, IAttachableInputObject_Ptr);
   begin
      if this.m_IAttachableInputObject /= null then
         if this.m_IAttachableInputObject.all /= null then
            temp := this.m_IAttachableInputObject.all.Release;
            Free (this.m_IAttachableInputObject);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AttachableInputObject

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AttachableInputObject

   procedure Close
   (
      this : in out AttachableInputObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.Foundation.IClosable := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IAttachableInputObject_Interface, WinRt.Windows.Foundation.IClosable, WinRt.Windows.Foundation.IID_IClosable'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAttachableInputObject.all);
      Hr := m_Interface.Close;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CrossSlidingEventArgs

   procedure Initialize (this : in out CrossSlidingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CrossSlidingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICrossSlidingEventArgs, ICrossSlidingEventArgs_Ptr);
   begin
      if this.m_ICrossSlidingEventArgs /= null then
         if this.m_ICrossSlidingEventArgs.all /= null then
            temp := this.m_ICrossSlidingEventArgs.all.Release;
            Free (this.m_ICrossSlidingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CrossSlidingEventArgs

   function get_PointerDeviceType
   (
      this : in out CrossSlidingEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_ICrossSlidingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out CrossSlidingEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_ICrossSlidingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CrossSlidingState
   (
      this : in out CrossSlidingEventArgs
   )
   return WinRt.Windows.UI.Input.CrossSlidingState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.CrossSlidingState;
   begin
      Hr := this.m_ICrossSlidingEventArgs.all.get_CrossSlidingState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out CrossSlidingEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.ICrossSlidingEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.ICrossSlidingEventArgs_Interface, WinRt.Windows.UI.Input.ICrossSlidingEventArgs2, WinRt.Windows.UI.Input.IID_ICrossSlidingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICrossSlidingEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DraggingEventArgs

   procedure Initialize (this : in out DraggingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DraggingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDraggingEventArgs, IDraggingEventArgs_Ptr);
   begin
      if this.m_IDraggingEventArgs /= null then
         if this.m_IDraggingEventArgs.all /= null then
            temp := this.m_IDraggingEventArgs.all.Release;
            Free (this.m_IDraggingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DraggingEventArgs

   function get_PointerDeviceType
   (
      this : in out DraggingEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IDraggingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out DraggingEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IDraggingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DraggingState
   (
      this : in out DraggingEventArgs
   )
   return WinRt.Windows.UI.Input.DraggingState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.DraggingState;
   begin
      Hr := this.m_IDraggingEventArgs.all.get_DraggingState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out DraggingEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IDraggingEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IDraggingEventArgs_Interface, WinRt.Windows.UI.Input.IDraggingEventArgs2, WinRt.Windows.UI.Input.IID_IDraggingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDraggingEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EdgeGesture

   procedure Initialize (this : in out EdgeGesture) is
   begin
      null;
   end;

   procedure Finalize (this : in out EdgeGesture) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEdgeGesture, IEdgeGesture_Ptr);
   begin
      if this.m_IEdgeGesture /= null then
         if this.m_IEdgeGesture.all /= null then
            temp := this.m_IEdgeGesture.all.Release;
            Free (this.m_IEdgeGesture);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for EdgeGesture

   function GetForCurrentView
   return WinRt.Windows.UI.Input.EdgeGesture is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.EdgeGesture");
      m_Factory        : access WinRt.Windows.UI.Input.IEdgeGestureStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IEdgeGesture;
   begin
      return RetVal : WinRt.Windows.UI.Input.EdgeGesture do
         Hr := RoGetActivationFactory (m_hString, IID_IEdgeGestureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IEdgeGesture := new Windows.UI.Input.IEdgeGesture;
            Retval.m_IEdgeGesture.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EdgeGesture

   function add_Starting
   (
      this : in out EdgeGesture;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IEdgeGesture.all.add_Starting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Starting
   (
      this : in out EdgeGesture;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IEdgeGesture.all.remove_Starting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Completed
   (
      this : in out EdgeGesture;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IEdgeGesture.all.add_Completed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Completed
   (
      this : in out EdgeGesture;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IEdgeGesture.all.remove_Completed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Canceled
   (
      this : in out EdgeGesture;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IEdgeGesture.all.add_Canceled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Canceled
   (
      this : in out EdgeGesture;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IEdgeGesture.all.remove_Canceled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for EdgeGestureEventArgs

   procedure Initialize (this : in out EdgeGestureEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out EdgeGestureEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IEdgeGestureEventArgs, IEdgeGestureEventArgs_Ptr);
   begin
      if this.m_IEdgeGestureEventArgs /= null then
         if this.m_IEdgeGestureEventArgs.all /= null then
            temp := this.m_IEdgeGestureEventArgs.all.Release;
            Free (this.m_IEdgeGestureEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for EdgeGestureEventArgs

   function get_Kind
   (
      this : in out EdgeGestureEventArgs
   )
   return WinRt.Windows.UI.Input.EdgeGestureKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.EdgeGestureKind;
   begin
      Hr := this.m_IEdgeGestureEventArgs.all.get_Kind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GestureRecognizer

   procedure Initialize (this : in out GestureRecognizer) is
   begin
      null;
   end;

   procedure Finalize (this : in out GestureRecognizer) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGestureRecognizer, IGestureRecognizer_Ptr);
   begin
      if this.m_IGestureRecognizer /= null then
         if this.m_IGestureRecognizer.all /= null then
            temp := this.m_IGestureRecognizer.all.Release;
            Free (this.m_IGestureRecognizer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GestureRecognizer

   function Constructor return GestureRecognizer is
      Hr           : WinRt.HResult := S_OK;
      tmp          : WinRt.HResult := S_OK;
      m_hString    : constant WinRt.HString := To_HString ("Windows.UI.Input.GestureRecognizer");
      m_ComRetVal  : aliased Windows.UI.Input.IGestureRecognizer;
   begin
      return RetVal : GestureRecognizer do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IGestureRecognizer := new Windows.UI.Input.IGestureRecognizer;
            Retval.m_IGestureRecognizer.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GestureRecognizer

   function get_GestureSettings
   (
      this : in out GestureRecognizer
   )
   return WinRt.Windows.UI.Input.GestureSettings is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.GestureSettings;
   begin
      Hr := this.m_IGestureRecognizer.all.get_GestureSettings (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GestureSettings
   (
      this : in out GestureRecognizer;
      value : Windows.UI.Input.GestureSettings
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_GestureSettings (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInertial
   (
      this : in out GestureRecognizer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_IsInertial (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsActive
   (
      this : in out GestureRecognizer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ShowGestureFeedback
   (
      this : in out GestureRecognizer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_ShowGestureFeedback (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowGestureFeedback
   (
      this : in out GestureRecognizer;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_ShowGestureFeedback (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PivotCenter
   (
      this : in out GestureRecognizer
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IGestureRecognizer.all.get_PivotCenter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PivotCenter
   (
      this : in out GestureRecognizer;
      value : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_PivotCenter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PivotRadius
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_PivotRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PivotRadius
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_PivotRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaTranslationDeceleration
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaTranslationDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaTranslationDeceleration
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaTranslationDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaRotationDeceleration
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaRotationDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaRotationDeceleration
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaRotationDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaExpansionDeceleration
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaExpansionDeceleration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaExpansionDeceleration
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaExpansionDeceleration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaTranslationDisplacement
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaTranslationDisplacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaTranslationDisplacement
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaTranslationDisplacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaRotationAngle
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaRotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaRotationAngle
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaRotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InertiaExpansion
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IGestureRecognizer.all.get_InertiaExpansion (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InertiaExpansion
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_InertiaExpansion (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ManipulationExact
   (
      this : in out GestureRecognizer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_ManipulationExact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ManipulationExact
   (
      this : in out GestureRecognizer;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_ManipulationExact (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CrossSlideThresholds
   (
      this : in out GestureRecognizer
   )
   return WinRt.Windows.UI.Input.CrossSlideThresholds is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.CrossSlideThresholds;
   begin
      Hr := this.m_IGestureRecognizer.all.get_CrossSlideThresholds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CrossSlideThresholds
   (
      this : in out GestureRecognizer;
      value : Windows.UI.Input.CrossSlideThresholds
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_CrossSlideThresholds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CrossSlideHorizontally
   (
      this : in out GestureRecognizer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_CrossSlideHorizontally (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CrossSlideHorizontally
   (
      this : in out GestureRecognizer;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_CrossSlideHorizontally (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CrossSlideExact
   (
      this : in out GestureRecognizer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_CrossSlideExact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CrossSlideExact
   (
      this : in out GestureRecognizer;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_CrossSlideExact (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AutoProcessInertia
   (
      this : in out GestureRecognizer
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.get_AutoProcessInertia (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoProcessInertia
   (
      this : in out GestureRecognizer;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.put_AutoProcessInertia (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MouseWheelParameters
   (
      this : in out GestureRecognizer
   )
   return WinRt.Windows.UI.Input.MouseWheelParameters'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IMouseWheelParameters;
   begin
      return RetVal : WinRt.Windows.UI.Input.MouseWheelParameters do
         Hr := this.m_IGestureRecognizer.all.get_MouseWheelParameters (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMouseWheelParameters := new Windows.UI.Input.IMouseWheelParameters;
         Retval.m_IMouseWheelParameters.all := m_ComRetVal;
      end return;
   end;

   function CanBeDoubleTap
   (
      this : in out GestureRecognizer;
      value : Windows.UI.Input.PointerPoint'Class
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IGestureRecognizer.all.CanBeDoubleTap (value.m_IPointerPoint.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ProcessDownEvent
   (
      this : in out GestureRecognizer;
      value : Windows.UI.Input.PointerPoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessDownEvent (value.m_IPointerPoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessMoveEvents
   (
      this : in out GestureRecognizer;
      value : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessMoveEvents (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessUpEvent
   (
      this : in out GestureRecognizer;
      value : Windows.UI.Input.PointerPoint'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessUpEvent (value.m_IPointerPoint.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessMouseWheelEvent
   (
      this : in out GestureRecognizer;
      value : Windows.UI.Input.PointerPoint'Class;
      isShiftKeyDown : WinRt.Boolean;
      isControlKeyDown : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessMouseWheelEvent (value.m_IPointerPoint.all, isShiftKeyDown, isControlKeyDown);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ProcessInertia
   (
      this : in out GestureRecognizer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.ProcessInertia;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteGesture
   (
      this : in out GestureRecognizer
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.CompleteGesture;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Tapped
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_Tapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Tapped
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_Tapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RightTapped
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_RightTapped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RightTapped
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_RightTapped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Holding
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_Holding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Holding
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_Holding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Dragging
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_Dragging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Dragging
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_Dragging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationStarted
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationStarted
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationUpdated
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationUpdated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationUpdated
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationUpdated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationInertiaStarting
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationInertiaStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationInertiaStarting
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationInertiaStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ManipulationCompleted
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_ManipulationCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ManipulationCompleted
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_ManipulationCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CrossSliding
   (
      this : in out GestureRecognizer;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IGestureRecognizer.all.add_CrossSliding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CrossSliding
   (
      this : in out GestureRecognizer;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IGestureRecognizer.all.remove_CrossSliding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TapMinContactCount
   (
      this : in out GestureRecognizer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_TapMinContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TapMinContactCount
   (
      this : in out GestureRecognizer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_TapMinContactCount (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TapMaxContactCount
   (
      this : in out GestureRecognizer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_TapMaxContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TapMaxContactCount
   (
      this : in out GestureRecognizer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_TapMaxContactCount (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HoldMinContactCount
   (
      this : in out GestureRecognizer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_HoldMinContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HoldMinContactCount
   (
      this : in out GestureRecognizer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_HoldMinContactCount (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HoldMaxContactCount
   (
      this : in out GestureRecognizer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_HoldMaxContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HoldMaxContactCount
   (
      this : in out GestureRecognizer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_HoldMaxContactCount (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HoldRadius
   (
      this : in out GestureRecognizer
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_HoldRadius (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HoldRadius
   (
      this : in out GestureRecognizer;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_HoldRadius (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HoldStartDelay
   (
      this : in out GestureRecognizer
   )
   return WinRt.Windows.Foundation.TimeSpan is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.TimeSpan;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_HoldStartDelay (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HoldStartDelay
   (
      this : in out GestureRecognizer;
      value : Windows.Foundation.TimeSpan
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_HoldStartDelay (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TranslationMinContactCount
   (
      this : in out GestureRecognizer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_TranslationMinContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TranslationMinContactCount
   (
      this : in out GestureRecognizer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_TranslationMinContactCount (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TranslationMaxContactCount
   (
      this : in out GestureRecognizer
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.get_TranslationMaxContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TranslationMaxContactCount
   (
      this : in out GestureRecognizer;
      value : WinRt.UInt32
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IGestureRecognizer2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IGestureRecognizer_Interface, WinRt.Windows.UI.Input.IGestureRecognizer2, WinRt.Windows.UI.Input.IID_IGestureRecognizer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGestureRecognizer.all);
      Hr := m_Interface.put_TranslationMaxContactCount (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HoldingEventArgs

   procedure Initialize (this : in out HoldingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HoldingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHoldingEventArgs, IHoldingEventArgs_Ptr);
   begin
      if this.m_IHoldingEventArgs /= null then
         if this.m_IHoldingEventArgs.all /= null then
            temp := this.m_IHoldingEventArgs.all.Release;
            Free (this.m_IHoldingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HoldingEventArgs

   function get_PointerDeviceType
   (
      this : in out HoldingEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IHoldingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out HoldingEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IHoldingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HoldingState
   (
      this : in out HoldingEventArgs
   )
   return WinRt.Windows.UI.Input.HoldingState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.HoldingState;
   begin
      Hr := this.m_IHoldingEventArgs.all.get_HoldingState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out HoldingEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IHoldingEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IHoldingEventArgs_Interface, WinRt.Windows.UI.Input.IHoldingEventArgs2, WinRt.Windows.UI.Input.IID_IHoldingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHoldingEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurrentContactCount
   (
      this : in out HoldingEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IHoldingEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IHoldingEventArgs_Interface, WinRt.Windows.UI.Input.IHoldingEventArgs2, WinRt.Windows.UI.Input.IID_IHoldingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHoldingEventArgs.all);
      Hr := m_Interface.get_CurrentContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputActivationListener

   procedure Initialize (this : in out InputActivationListener) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputActivationListener) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputActivationListener, IInputActivationListener_Ptr);
   begin
      if this.m_IInputActivationListener /= null then
         if this.m_IInputActivationListener.all /= null then
            temp := this.m_IInputActivationListener.all.Release;
            Free (this.m_IInputActivationListener);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputActivationListener

   function get_State
   (
      this : in out InputActivationListener
   )
   return WinRt.Windows.UI.Input.InputActivationState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.InputActivationState;
   begin
      Hr := this.m_IInputActivationListener.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_InputActivationChanged
   (
      this : in out InputActivationListener;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInputActivationListener.all.add_InputActivationChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_InputActivationChanged
   (
      this : in out InputActivationListener;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IInputActivationListener.all.remove_InputActivationChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InputActivationListenerActivationChangedEventArgs

   procedure Initialize (this : in out InputActivationListenerActivationChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InputActivationListenerActivationChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInputActivationListenerActivationChangedEventArgs, IInputActivationListenerActivationChangedEventArgs_Ptr);
   begin
      if this.m_IInputActivationListenerActivationChangedEventArgs /= null then
         if this.m_IInputActivationListenerActivationChangedEventArgs.all /= null then
            temp := this.m_IInputActivationListenerActivationChangedEventArgs.all.Release;
            Free (this.m_IInputActivationListenerActivationChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InputActivationListenerActivationChangedEventArgs

   function get_State
   (
      this : in out InputActivationListenerActivationChangedEventArgs
   )
   return WinRt.Windows.UI.Input.InputActivationState is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.InputActivationState;
   begin
      Hr := this.m_IInputActivationListenerActivationChangedEventArgs.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for KeyboardDeliveryInterceptor

   procedure Initialize (this : in out KeyboardDeliveryInterceptor) is
   begin
      null;
   end;

   procedure Finalize (this : in out KeyboardDeliveryInterceptor) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IKeyboardDeliveryInterceptor, IKeyboardDeliveryInterceptor_Ptr);
   begin
      if this.m_IKeyboardDeliveryInterceptor /= null then
         if this.m_IKeyboardDeliveryInterceptor.all /= null then
            temp := this.m_IKeyboardDeliveryInterceptor.all.Release;
            Free (this.m_IKeyboardDeliveryInterceptor);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for KeyboardDeliveryInterceptor

   function GetForCurrentView
   return WinRt.Windows.UI.Input.KeyboardDeliveryInterceptor is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.KeyboardDeliveryInterceptor");
      m_Factory        : access WinRt.Windows.UI.Input.IKeyboardDeliveryInterceptorStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IKeyboardDeliveryInterceptor;
   begin
      return RetVal : WinRt.Windows.UI.Input.KeyboardDeliveryInterceptor do
         Hr := RoGetActivationFactory (m_hString, IID_IKeyboardDeliveryInterceptorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IKeyboardDeliveryInterceptor := new Windows.UI.Input.IKeyboardDeliveryInterceptor;
            Retval.m_IKeyboardDeliveryInterceptor.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for KeyboardDeliveryInterceptor

   function get_IsInterceptionEnabledWhenInForeground
   (
      this : in out KeyboardDeliveryInterceptor
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IKeyboardDeliveryInterceptor.all.get_IsInterceptionEnabledWhenInForeground (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsInterceptionEnabledWhenInForeground
   (
      this : in out KeyboardDeliveryInterceptor;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardDeliveryInterceptor.all.put_IsInterceptionEnabledWhenInForeground (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyDown
   (
      this : in out KeyboardDeliveryInterceptor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IKeyboardDeliveryInterceptor.all.add_KeyDown (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyDown
   (
      this : in out KeyboardDeliveryInterceptor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardDeliveryInterceptor.all.remove_KeyDown (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_KeyUp
   (
      this : in out KeyboardDeliveryInterceptor;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IKeyboardDeliveryInterceptor.all.add_KeyUp (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_KeyUp
   (
      this : in out KeyboardDeliveryInterceptor;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IKeyboardDeliveryInterceptor.all.remove_KeyUp (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationCompletedEventArgs

   procedure Initialize (this : in out ManipulationCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationCompletedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationCompletedEventArgs, IManipulationCompletedEventArgs_Ptr);
   begin
      if this.m_IManipulationCompletedEventArgs /= null then
         if this.m_IManipulationCompletedEventArgs.all /= null then
            temp := this.m_IManipulationCompletedEventArgs.all.Release;
            Free (this.m_IManipulationCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationCompletedEventArgs

   function get_PointerDeviceType
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationVelocities is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationCompletedEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IManipulationCompletedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IManipulationCompletedEventArgs_Interface, WinRt.Windows.UI.Input.IManipulationCompletedEventArgs2, WinRt.Windows.UI.Input.IID_IManipulationCompletedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IManipulationCompletedEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurrentContactCount
   (
      this : in out ManipulationCompletedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IManipulationCompletedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IManipulationCompletedEventArgs_Interface, WinRt.Windows.UI.Input.IManipulationCompletedEventArgs2, WinRt.Windows.UI.Input.IID_IManipulationCompletedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IManipulationCompletedEventArgs.all);
      Hr := m_Interface.get_CurrentContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationInertiaStartingEventArgs

   procedure Initialize (this : in out ManipulationInertiaStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationInertiaStartingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationInertiaStartingEventArgs, IManipulationInertiaStartingEventArgs_Ptr);
   begin
      if this.m_IManipulationInertiaStartingEventArgs /= null then
         if this.m_IManipulationInertiaStartingEventArgs.all /= null then
            temp := this.m_IManipulationInertiaStartingEventArgs.all.Release;
            Free (this.m_IManipulationInertiaStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationInertiaStartingEventArgs

   function get_PointerDeviceType
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Delta
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Delta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationVelocities is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationInertiaStartingEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out ManipulationInertiaStartingEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IManipulationInertiaStartingEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IManipulationInertiaStartingEventArgs_Interface, WinRt.Windows.UI.Input.IManipulationInertiaStartingEventArgs2, WinRt.Windows.UI.Input.IID_IManipulationInertiaStartingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IManipulationInertiaStartingEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationStartedEventArgs

   procedure Initialize (this : in out ManipulationStartedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationStartedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationStartedEventArgs, IManipulationStartedEventArgs_Ptr);
   begin
      if this.m_IManipulationStartedEventArgs /= null then
         if this.m_IManipulationStartedEventArgs.all /= null then
            temp := this.m_IManipulationStartedEventArgs.all.Release;
            Free (this.m_IManipulationStartedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationStartedEventArgs

   function get_PointerDeviceType
   (
      this : in out ManipulationStartedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationStartedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationStartedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationStartedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationStartedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationStartedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out ManipulationStartedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IManipulationStartedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IManipulationStartedEventArgs_Interface, WinRt.Windows.UI.Input.IManipulationStartedEventArgs2, WinRt.Windows.UI.Input.IID_IManipulationStartedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IManipulationStartedEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ManipulationUpdatedEventArgs

   procedure Initialize (this : in out ManipulationUpdatedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ManipulationUpdatedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IManipulationUpdatedEventArgs, IManipulationUpdatedEventArgs_Ptr);
   begin
      if this.m_IManipulationUpdatedEventArgs /= null then
         if this.m_IManipulationUpdatedEventArgs.all /= null then
            temp := this.m_IManipulationUpdatedEventArgs.all.Release;
            Free (this.m_IManipulationUpdatedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ManipulationUpdatedEventArgs

   function get_PointerDeviceType
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Delta
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Delta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cumulative
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationDelta is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationDelta;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Cumulative (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Velocities
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinRt.Windows.UI.Input.ManipulationVelocities is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ManipulationVelocities;
   begin
      Hr := this.m_IManipulationUpdatedEventArgs.all.get_Velocities (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IManipulationUpdatedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IManipulationUpdatedEventArgs_Interface, WinRt.Windows.UI.Input.IManipulationUpdatedEventArgs2, WinRt.Windows.UI.Input.IID_IManipulationUpdatedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IManipulationUpdatedEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurrentContactCount
   (
      this : in out ManipulationUpdatedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IManipulationUpdatedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IManipulationUpdatedEventArgs_Interface, WinRt.Windows.UI.Input.IManipulationUpdatedEventArgs2, WinRt.Windows.UI.Input.IID_IManipulationUpdatedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IManipulationUpdatedEventArgs.all);
      Hr := m_Interface.get_CurrentContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MouseWheelParameters

   procedure Initialize (this : in out MouseWheelParameters) is
   begin
      null;
   end;

   procedure Finalize (this : in out MouseWheelParameters) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMouseWheelParameters, IMouseWheelParameters_Ptr);
   begin
      if this.m_IMouseWheelParameters /= null then
         if this.m_IMouseWheelParameters.all /= null then
            temp := this.m_IMouseWheelParameters.all.Release;
            Free (this.m_IMouseWheelParameters);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MouseWheelParameters

   function get_CharTranslation
   (
      this : in out MouseWheelParameters
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_CharTranslation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharTranslation
   (
      this : in out MouseWheelParameters;
      value : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_CharTranslation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeltaScale
   (
      this : in out MouseWheelParameters
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_DeltaScale (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DeltaScale
   (
      this : in out MouseWheelParameters;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_DeltaScale (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DeltaRotationAngle
   (
      this : in out MouseWheelParameters
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_DeltaRotationAngle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DeltaRotationAngle
   (
      this : in out MouseWheelParameters;
      value : WinRt.Single
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_DeltaRotationAngle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PageTranslation
   (
      this : in out MouseWheelParameters
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IMouseWheelParameters.all.get_PageTranslation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PageTranslation
   (
      this : in out MouseWheelParameters;
      value : Windows.Foundation.Point
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IMouseWheelParameters.all.put_PageTranslation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerPoint

   procedure Initialize (this : in out PointerPoint) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerPoint) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerPoint, IPointerPoint_Ptr);
   begin
      if this.m_IPointerPoint /= null then
         if this.m_IPointerPoint.all /= null then
            temp := this.m_IPointerPoint.all.Release;
            Free (this.m_IPointerPoint);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointerPoint

   function GetCurrentPoint
   (
      pointerId : WinRt.UInt32
   )
   return WinRt.Windows.UI.Input.PointerPoint is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.PointerPoint");
      m_Factory        : access WinRt.Windows.UI.Input.IPointerPointStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IPointerPoint;
   begin
      return RetVal : WinRt.Windows.UI.Input.PointerPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IPointerPointStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetCurrentPoint (pointerId, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPointerPoint := new Windows.UI.Input.IPointerPoint;
            Retval.m_IPointerPoint.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIntermediatePoints
   (
      pointerId : WinRt.UInt32
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.PointerPoint");
      m_Factory        : access WinRt.Windows.UI.Input.IPointerPointStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPointerPointStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIntermediatePoints (pointerId, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetCurrentPoint
   (
      pointerId : WinRt.UInt32;
      transform : Windows.UI.Input.IPointerPointTransform
   )
   return WinRt.Windows.UI.Input.PointerPoint is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.PointerPoint");
      m_Factory        : access WinRt.Windows.UI.Input.IPointerPointStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IPointerPoint;
   begin
      return RetVal : WinRt.Windows.UI.Input.PointerPoint do
         Hr := RoGetActivationFactory (m_hString, IID_IPointerPointStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetCurrentPoint (pointerId, transform, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPointerPoint := new Windows.UI.Input.IPointerPoint;
            Retval.m_IPointerPoint.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIntermediatePoints
   (
      pointerId : WinRt.UInt32;
      transform : Windows.UI.Input.IPointerPointTransform
   )
   return WinRt.GenericObject is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.PointerPoint");
      m_Factory        : access WinRt.Windows.UI.Input.IPointerPointStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPointerPointStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIntermediatePoints (pointerId, transform, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerPoint

   function get_PointerDevice
   (
      this : in out PointerPoint
   )
   return WinRt.Windows.Devices.Input.PointerDevice'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.IPointerDevice;
   begin
      return RetVal : WinRt.Windows.Devices.Input.PointerDevice do
         Hr := this.m_IPointerPoint.all.get_PointerDevice (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerDevice := new Windows.Devices.Input.IPointerDevice;
         Retval.m_IPointerDevice.all := m_ComRetVal;
      end return;
   end;

   function get_Position
   (
      this : in out PointerPoint
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IPointerPoint.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RawPosition
   (
      this : in out PointerPoint
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IPointerPoint.all.get_RawPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerId
   (
      this : in out PointerPoint
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IPointerPoint.all.get_PointerId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_FrameId
   (
      this : in out PointerPoint
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_IPointerPoint.all.get_FrameId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Timestamp
   (
      this : in out PointerPoint
   )
   return WinRt.UInt64 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt64;
   begin
      Hr := this.m_IPointerPoint.all.get_Timestamp (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInContact
   (
      this : in out PointerPoint
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPoint.all.get_IsInContact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Properties
   (
      this : in out PointerPoint
   )
   return WinRt.Windows.UI.Input.PointerPointProperties'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IPointerPointProperties;
   begin
      return RetVal : WinRt.Windows.UI.Input.PointerPointProperties do
         Hr := this.m_IPointerPoint.all.get_Properties (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPointerPointProperties := new Windows.UI.Input.IPointerPointProperties;
         Retval.m_IPointerPointProperties.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerPointProperties

   procedure Initialize (this : in out PointerPointProperties) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerPointProperties) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerPointProperties, IPointerPointProperties_Ptr);
   begin
      if this.m_IPointerPointProperties /= null then
         if this.m_IPointerPointProperties.all /= null then
            temp := this.m_IPointerPointProperties.all.Release;
            Free (this.m_IPointerPointProperties);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerPointProperties

   function get_Pressure
   (
      this : in out PointerPointProperties
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_Pressure (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInverted
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsInverted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsEraser
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsEraser (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Orientation
   (
      this : in out PointerPointProperties
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_XTilt
   (
      this : in out PointerPointProperties
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_XTilt (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_YTilt
   (
      this : in out PointerPointProperties
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_YTilt (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Twist
   (
      this : in out PointerPointProperties
   )
   return WinRt.Single is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Single;
   begin
      Hr := this.m_IPointerPointProperties.all.get_Twist (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactRect
   (
      this : in out PointerPointProperties
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IPointerPointProperties.all.get_ContactRect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactRectRaw
   (
      this : in out PointerPointProperties
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IPointerPointProperties.all.get_ContactRectRaw (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TouchConfidence
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_TouchConfidence (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsLeftButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsLeftButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsRightButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsRightButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsMiddleButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsMiddleButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MouseWheelDelta
   (
      this : in out PointerPointProperties
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IPointerPointProperties.all.get_MouseWheelDelta (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsHorizontalMouseWheel
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsHorizontalMouseWheel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsPrimary
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsPrimary (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsInRange
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsInRange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsCanceled
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsCanceled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsBarrelButtonPressed
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsBarrelButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsXButton1Pressed
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsXButton1Pressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsXButton2Pressed
   (
      this : in out PointerPointProperties
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.get_IsXButton2Pressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PointerUpdateKind
   (
      this : in out PointerPointProperties
   )
   return WinRt.Windows.UI.Input.PointerUpdateKind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.PointerUpdateKind;
   begin
      Hr := this.m_IPointerPointProperties.all.get_PointerUpdateKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function HasUsage
   (
      this : in out PointerPointProperties;
      usagePage : WinRt.UInt32;
      usageId : WinRt.UInt32
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerPointProperties.all.HasUsage (usagePage, usageId, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetUsageValue
   (
      this : in out PointerPointProperties;
      usagePage : WinRt.UInt32;
      usageId : WinRt.UInt32
   )
   return WinRt.Int32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Int32;
   begin
      Hr := this.m_IPointerPointProperties.all.GetUsageValue (usagePage, usageId, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZDistance
   (
      this : in out PointerPointProperties
   )
   return IReference_Single.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IPointerPointProperties2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IReference_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IPointerPointProperties_Interface, WinRt.Windows.UI.Input.IPointerPointProperties2, WinRt.Windows.UI.Input.IID_IPointerPointProperties2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPointerPointProperties.all);
      Hr := m_Interface.get_ZDistance (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PointerVisualizationSettings

   procedure Initialize (this : in out PointerVisualizationSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out PointerVisualizationSettings) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPointerVisualizationSettings, IPointerVisualizationSettings_Ptr);
   begin
      if this.m_IPointerVisualizationSettings /= null then
         if this.m_IPointerVisualizationSettings.all /= null then
            temp := this.m_IPointerVisualizationSettings.all.Release;
            Free (this.m_IPointerVisualizationSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PointerVisualizationSettings

   function GetForCurrentView
   return WinRt.Windows.UI.Input.PointerVisualizationSettings is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.PointerVisualizationSettings");
      m_Factory        : access WinRt.Windows.UI.Input.IPointerVisualizationSettingsStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IPointerVisualizationSettings;
   begin
      return RetVal : WinRt.Windows.UI.Input.PointerVisualizationSettings do
         Hr := RoGetActivationFactory (m_hString, IID_IPointerVisualizationSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IPointerVisualizationSettings := new Windows.UI.Input.IPointerVisualizationSettings;
            Retval.m_IPointerVisualizationSettings.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PointerVisualizationSettings

   procedure put_IsContactFeedbackEnabled
   (
      this : in out PointerVisualizationSettings;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointerVisualizationSettings.all.put_IsContactFeedbackEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsContactFeedbackEnabled
   (
      this : in out PointerVisualizationSettings
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerVisualizationSettings.all.get_IsContactFeedbackEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBarrelButtonFeedbackEnabled
   (
      this : in out PointerVisualizationSettings;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IPointerVisualizationSettings.all.put_IsBarrelButtonFeedbackEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBarrelButtonFeedbackEnabled
   (
      this : in out PointerVisualizationSettings
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IPointerVisualizationSettings.all.get_IsBarrelButtonFeedbackEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialController

   procedure Initialize (this : in out RadialController) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialController) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialController, IRadialController_Ptr);
   begin
      if this.m_IRadialController /= null then
         if this.m_IRadialController.all /= null then
            temp := this.m_IRadialController.all.Release;
            Free (this.m_IRadialController);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RadialController

   function IsSupported
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialController");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.IsSupported (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function CreateForCurrentView
   return WinRt.Windows.UI.Input.RadialController is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialController");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialController;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialController do
         Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRadialController := new Windows.UI.Input.IRadialController;
            Retval.m_IRadialController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialController

   function get_Menu
   (
      this : in out RadialController
   )
   return WinRt.Windows.UI.Input.RadialControllerMenu'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerMenu;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerMenu do
         Hr := this.m_IRadialController.all.get_Menu (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerMenu := new Windows.UI.Input.IRadialControllerMenu;
         Retval.m_IRadialControllerMenu.all := m_ComRetVal;
      end return;
   end;

   function get_RotationResolutionInDegrees
   (
      this : in out RadialController
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IRadialController.all.get_RotationResolutionInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RotationResolutionInDegrees
   (
      this : in out RadialController;
      value : WinRt.Double
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.put_RotationResolutionInDegrees (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UseAutomaticHapticFeedback
   (
      this : in out RadialController
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRadialController.all.get_UseAutomaticHapticFeedback (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UseAutomaticHapticFeedback
   (
      this : in out RadialController;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.put_UseAutomaticHapticFeedback (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScreenContactStarted
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialController.all.add_ScreenContactStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScreenContactStarted
   (
      this : in out RadialController;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.remove_ScreenContactStarted (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScreenContactEnded
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialController.all.add_ScreenContactEnded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScreenContactEnded
   (
      this : in out RadialController;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.remove_ScreenContactEnded (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScreenContactContinued
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialController.all.add_ScreenContactContinued (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScreenContactContinued
   (
      this : in out RadialController;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.remove_ScreenContactContinued (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ControlLost
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialController.all.add_ControlLost (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ControlLost
   (
      this : in out RadialController;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.remove_ControlLost (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RotationChanged
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialController.all.add_RotationChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RotationChanged
   (
      this : in out RadialController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.remove_RotationChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ButtonClicked
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialController.all.add_ButtonClicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ButtonClicked
   (
      this : in out RadialController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.remove_ButtonClicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ControlAcquired
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialController.all.add_ControlAcquired (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ControlAcquired
   (
      this : in out RadialController;
      cookie : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialController.all.remove_ControlAcquired (cookie);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ButtonPressed
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialController2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialController_Interface, WinRt.Windows.UI.Input.IRadialController2, WinRt.Windows.UI.Input.IID_IRadialController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialController.all);
      Hr := m_Interface.add_ButtonPressed (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ButtonPressed
   (
      this : in out RadialController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialController2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialController_Interface, WinRt.Windows.UI.Input.IRadialController2, WinRt.Windows.UI.Input.IID_IRadialController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialController.all);
      Hr := m_Interface.remove_ButtonPressed (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ButtonHolding
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialController2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialController_Interface, WinRt.Windows.UI.Input.IRadialController2, WinRt.Windows.UI.Input.IID_IRadialController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialController.all);
      Hr := m_Interface.add_ButtonHolding (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ButtonHolding
   (
      this : in out RadialController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialController2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialController_Interface, WinRt.Windows.UI.Input.IRadialController2, WinRt.Windows.UI.Input.IID_IRadialController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialController.all);
      Hr := m_Interface.remove_ButtonHolding (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ButtonReleased
   (
      this : in out RadialController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialController2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialController_Interface, WinRt.Windows.UI.Input.IRadialController2, WinRt.Windows.UI.Input.IID_IRadialController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialController.all);
      Hr := m_Interface.add_ButtonReleased (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ButtonReleased
   (
      this : in out RadialController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialController2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialController_Interface, WinRt.Windows.UI.Input.IRadialController2, WinRt.Windows.UI.Input.IID_IRadialController2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialController.all);
      Hr := m_Interface.remove_ButtonReleased (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerButtonClickedEventArgs

   procedure Initialize (this : in out RadialControllerButtonClickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerButtonClickedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerButtonClickedEventArgs, IRadialControllerButtonClickedEventArgs_Ptr);
   begin
      if this.m_IRadialControllerButtonClickedEventArgs /= null then
         if this.m_IRadialControllerButtonClickedEventArgs.all /= null then
            temp := this.m_IRadialControllerButtonClickedEventArgs.all.Release;
            Free (this.m_IRadialControllerButtonClickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerButtonClickedEventArgs

   function get_Contact
   (
      this : in out RadialControllerButtonClickedEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerButtonClickedEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerButtonClickedEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerButtonClickedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerButtonClickedEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerButtonClickedEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerButtonClickedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         m_Interface := QInterface (this.m_IRadialControllerButtonClickedEventArgs.all);
         Hr := m_Interface.get_SimpleHapticsController (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerButtonHoldingEventArgs

   procedure Initialize (this : in out RadialControllerButtonHoldingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerButtonHoldingEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerButtonHoldingEventArgs, IRadialControllerButtonHoldingEventArgs_Ptr);
   begin
      if this.m_IRadialControllerButtonHoldingEventArgs /= null then
         if this.m_IRadialControllerButtonHoldingEventArgs.all /= null then
            temp := this.m_IRadialControllerButtonHoldingEventArgs.all.Release;
            Free (this.m_IRadialControllerButtonHoldingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerButtonHoldingEventArgs

   function get_Contact
   (
      this : in out RadialControllerButtonHoldingEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerButtonHoldingEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerButtonHoldingEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         Hr := this.m_IRadialControllerButtonHoldingEventArgs.all.get_SimpleHapticsController (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerButtonPressedEventArgs

   procedure Initialize (this : in out RadialControllerButtonPressedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerButtonPressedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerButtonPressedEventArgs, IRadialControllerButtonPressedEventArgs_Ptr);
   begin
      if this.m_IRadialControllerButtonPressedEventArgs /= null then
         if this.m_IRadialControllerButtonPressedEventArgs.all /= null then
            temp := this.m_IRadialControllerButtonPressedEventArgs.all.Release;
            Free (this.m_IRadialControllerButtonPressedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerButtonPressedEventArgs

   function get_Contact
   (
      this : in out RadialControllerButtonPressedEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerButtonPressedEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerButtonPressedEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         Hr := this.m_IRadialControllerButtonPressedEventArgs.all.get_SimpleHapticsController (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerButtonReleasedEventArgs

   procedure Initialize (this : in out RadialControllerButtonReleasedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerButtonReleasedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerButtonReleasedEventArgs, IRadialControllerButtonReleasedEventArgs_Ptr);
   begin
      if this.m_IRadialControllerButtonReleasedEventArgs /= null then
         if this.m_IRadialControllerButtonReleasedEventArgs.all /= null then
            temp := this.m_IRadialControllerButtonReleasedEventArgs.all.Release;
            Free (this.m_IRadialControllerButtonReleasedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerButtonReleasedEventArgs

   function get_Contact
   (
      this : in out RadialControllerButtonReleasedEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerButtonReleasedEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerButtonReleasedEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         Hr := this.m_IRadialControllerButtonReleasedEventArgs.all.get_SimpleHapticsController (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerConfiguration

   procedure Initialize (this : in out RadialControllerConfiguration) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerConfiguration) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerConfiguration, IRadialControllerConfiguration_Ptr);
   begin
      if this.m_IRadialControllerConfiguration /= null then
         if this.m_IRadialControllerConfiguration.all /= null then
            temp := this.m_IRadialControllerConfiguration.all.Release;
            Free (this.m_IRadialControllerConfiguration);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RadialControllerConfiguration

   procedure put_AppController
   (
      value : Windows.UI.Input.RadialController'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerConfiguration");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerConfigurationStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerConfigurationStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_AppController (value.m_IRadialController.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AppController
   return WinRt.Windows.UI.Input.RadialController is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerConfiguration");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerConfigurationStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialController;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialController do
         Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerConfigurationStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AppController (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRadialController := new Windows.UI.Input.IRadialController;
            Retval.m_IRadialController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure put_IsAppControllerEnabled
   (
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerConfiguration");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerConfigurationStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerConfigurationStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.put_IsAppControllerEnabled (value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsAppControllerEnabled
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerConfiguration");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerConfigurationStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerConfigurationStatics2'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_IsAppControllerEnabled (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function GetForCurrentView
   return WinRt.Windows.UI.Input.RadialControllerConfiguration is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerConfiguration");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerConfigurationStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerConfiguration;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerConfiguration do
         Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerConfigurationStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetForCurrentView (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRadialControllerConfiguration := new Windows.UI.Input.IRadialControllerConfiguration;
            Retval.m_IRadialControllerConfiguration.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerConfiguration

   procedure SetDefaultMenuItems
   (
      this : in out RadialControllerConfiguration;
      buttons : GenericObject
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialControllerConfiguration.all.SetDefaultMenuItems (buttons);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ResetToDefaultMenuItems
   (
      this : in out RadialControllerConfiguration
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialControllerConfiguration.all.ResetToDefaultMenuItems;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TrySelectDefaultMenuItem
   (
      this : in out RadialControllerConfiguration;
      type_x : Windows.UI.Input.RadialControllerSystemMenuItemKind
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRadialControllerConfiguration.all.TrySelectDefaultMenuItem (type_x, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ActiveControllerWhenMenuIsSuppressed
   (
      this : in out RadialControllerConfiguration;
      value : Windows.UI.Input.RadialController'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerConfiguration2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerConfiguration_Interface, WinRt.Windows.UI.Input.IRadialControllerConfiguration2, WinRt.Windows.UI.Input.IID_IRadialControllerConfiguration2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialControllerConfiguration.all);
      Hr := m_Interface.put_ActiveControllerWhenMenuIsSuppressed (value.m_IRadialController.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActiveControllerWhenMenuIsSuppressed
   (
      this : in out RadialControllerConfiguration
   )
   return WinRt.Windows.UI.Input.RadialController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerConfiguration2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialController;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerConfiguration_Interface, WinRt.Windows.UI.Input.IRadialControllerConfiguration2, WinRt.Windows.UI.Input.IID_IRadialControllerConfiguration2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialController do
         m_Interface := QInterface (this.m_IRadialControllerConfiguration.all);
         Hr := m_Interface.get_ActiveControllerWhenMenuIsSuppressed (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialController := new Windows.UI.Input.IRadialController;
         Retval.m_IRadialController.all := m_ComRetVal;
      end return;
   end;

   procedure put_IsMenuSuppressed
   (
      this : in out RadialControllerConfiguration;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerConfiguration2 := null;
      temp             : WinRt.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerConfiguration_Interface, WinRt.Windows.UI.Input.IRadialControllerConfiguration2, WinRt.Windows.UI.Input.IID_IRadialControllerConfiguration2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialControllerConfiguration.all);
      Hr := m_Interface.put_IsMenuSuppressed (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsMenuSuppressed
   (
      this : in out RadialControllerConfiguration
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerConfiguration2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerConfiguration_Interface, WinRt.Windows.UI.Input.IRadialControllerConfiguration2, WinRt.Windows.UI.Input.IID_IRadialControllerConfiguration2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialControllerConfiguration.all);
      Hr := m_Interface.get_IsMenuSuppressed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerControlAcquiredEventArgs

   procedure Initialize (this : in out RadialControllerControlAcquiredEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerControlAcquiredEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerControlAcquiredEventArgs, IRadialControllerControlAcquiredEventArgs_Ptr);
   begin
      if this.m_IRadialControllerControlAcquiredEventArgs /= null then
         if this.m_IRadialControllerControlAcquiredEventArgs.all /= null then
            temp := this.m_IRadialControllerControlAcquiredEventArgs.all.Release;
            Free (this.m_IRadialControllerControlAcquiredEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerControlAcquiredEventArgs

   function get_Contact
   (
      this : in out RadialControllerControlAcquiredEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerControlAcquiredEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_IsButtonPressed
   (
      this : in out RadialControllerControlAcquiredEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerControlAcquiredEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerControlAcquiredEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerControlAcquiredEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerControlAcquiredEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialControllerControlAcquiredEventArgs.all);
      Hr := m_Interface.get_IsButtonPressed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerControlAcquiredEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerControlAcquiredEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerControlAcquiredEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerControlAcquiredEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerControlAcquiredEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         m_Interface := QInterface (this.m_IRadialControllerControlAcquiredEventArgs.all);
         Hr := m_Interface.get_SimpleHapticsController (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerMenu

   procedure Initialize (this : in out RadialControllerMenu) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerMenu) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerMenu, IRadialControllerMenu_Ptr);
   begin
      if this.m_IRadialControllerMenu /= null then
         if this.m_IRadialControllerMenu.all /= null then
            temp := this.m_IRadialControllerMenu.all.Release;
            Free (this.m_IRadialControllerMenu);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerMenu

   function get_Items
   (
      this : in out RadialControllerMenu
   )
   return IVector_IRadialControllerMenuItem.Kind is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased GenericObject;
      m_GenericRetval  : aliased IVector_IRadialControllerMenuItem.Kind;
   begin
      Hr := this.m_IRadialControllerMenu.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IRadialControllerMenuItem (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_IsEnabled
   (
      this : in out RadialControllerMenu
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRadialControllerMenu.all.get_IsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsEnabled
   (
      this : in out RadialControllerMenu;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialControllerMenu.all.put_IsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetSelectedMenuItem
   (
      this : in out RadialControllerMenu
   )
   return WinRt.Windows.UI.Input.RadialControllerMenuItem'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerMenuItem;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerMenuItem do
         Hr := this.m_IRadialControllerMenu.all.GetSelectedMenuItem (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerMenuItem := new Windows.UI.Input.IRadialControllerMenuItem;
         Retval.m_IRadialControllerMenuItem.all := m_ComRetVal;
      end return;
   end;

   procedure SelectMenuItem
   (
      this : in out RadialControllerMenu;
      menuItem : Windows.UI.Input.RadialControllerMenuItem'Class
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialControllerMenu.all.SelectMenuItem (menuItem.m_IRadialControllerMenuItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TrySelectPreviouslySelectedMenuItem
   (
      this : in out RadialControllerMenu
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRadialControllerMenu.all.TrySelectPreviouslySelectedMenuItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerMenuItem

   procedure Initialize (this : in out RadialControllerMenuItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerMenuItem) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerMenuItem, IRadialControllerMenuItem_Ptr);
   begin
      if this.m_IRadialControllerMenuItem /= null then
         if this.m_IRadialControllerMenuItem.all /= null then
            temp := this.m_IRadialControllerMenuItem.all.Release;
            Free (this.m_IRadialControllerMenuItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RadialControllerMenuItem

   function CreateFromIcon
   (
      displayText : WinRt.WString;
      icon : Windows.Storage.Streams.RandomAccessStreamReference'Class
   )
   return WinRt.Windows.UI.Input.RadialControllerMenuItem is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerMenuItem");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerMenuItemStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerMenuItem;
      HStr_displayText : constant WinRt.HString := To_HString (displayText);
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerMenuItem do
         Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerMenuItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromIcon (HStr_displayText, icon.m_IRandomAccessStreamReference.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRadialControllerMenuItem := new Windows.UI.Input.IRadialControllerMenuItem;
            Retval.m_IRadialControllerMenuItem.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_displayText);
      end return;
   end;

   function CreateFromKnownIcon
   (
      displayText : WinRt.WString;
      value : Windows.UI.Input.RadialControllerMenuKnownIcon
   )
   return WinRt.Windows.UI.Input.RadialControllerMenuItem is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerMenuItem");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerMenuItemStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerMenuItem;
      HStr_displayText : constant WinRt.HString := To_HString (displayText);
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerMenuItem do
         Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerMenuItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromKnownIcon (HStr_displayText, value, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRadialControllerMenuItem := new Windows.UI.Input.IRadialControllerMenuItem;
            Retval.m_IRadialControllerMenuItem.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_displayText);
      end return;
   end;

   function CreateFromFontGlyph
   (
      displayText : WinRt.WString;
      glyph : WinRt.WString;
      fontFamily : WinRt.WString
   )
   return WinRt.Windows.UI.Input.RadialControllerMenuItem is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerMenuItem");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerMenuItemStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerMenuItem;
      HStr_displayText : constant WinRt.HString := To_HString (displayText);
      HStr_glyph : constant WinRt.HString := To_HString (glyph);
      HStr_fontFamily : constant WinRt.HString := To_HString (fontFamily);
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerMenuItem do
         Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerMenuItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromFontGlyph (HStr_displayText, HStr_glyph, HStr_fontFamily, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRadialControllerMenuItem := new Windows.UI.Input.IRadialControllerMenuItem;
            Retval.m_IRadialControllerMenuItem.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_displayText);
         tmp := WindowsDeleteString (HStr_glyph);
         tmp := WindowsDeleteString (HStr_fontFamily);
      end return;
   end;

   function CreateFromFontGlyph
   (
      displayText : WinRt.WString;
      glyph : WinRt.WString;
      fontFamily : WinRt.WString;
      fontUri : Windows.Foundation.Uri'Class
   )
   return WinRt.Windows.UI.Input.RadialControllerMenuItem is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.RadialControllerMenuItem");
      m_Factory        : access WinRt.Windows.UI.Input.IRadialControllerMenuItemStatics2_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerMenuItem;
      HStr_displayText : constant WinRt.HString := To_HString (displayText);
      HStr_glyph : constant WinRt.HString := To_HString (glyph);
      HStr_fontFamily : constant WinRt.HString := To_HString (fontFamily);
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerMenuItem do
         Hr := RoGetActivationFactory (m_hString, IID_IRadialControllerMenuItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateFromFontGlyph (HStr_displayText, HStr_glyph, HStr_fontFamily, fontUri.m_IUriRuntimeClass.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IRadialControllerMenuItem := new Windows.UI.Input.IRadialControllerMenuItem;
            Retval.m_IRadialControllerMenuItem.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
         tmp := WindowsDeleteString (HStr_displayText);
         tmp := WindowsDeleteString (HStr_glyph);
         tmp := WindowsDeleteString (HStr_fontFamily);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerMenuItem

   function get_DisplayText
   (
      this : in out RadialControllerMenuItem
   )
   return WinRt.WString is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRadialControllerMenuItem.all.get_DisplayText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Tag
   (
      this : in out RadialControllerMenuItem
   )
   return WinRt.IInspectable is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.IInspectable;
   begin
      Hr := this.m_IRadialControllerMenuItem.all.get_Tag (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Tag
   (
      this : in out RadialControllerMenuItem;
      value : WinRt.IInspectable
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialControllerMenuItem.all.put_Tag (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Invoked
   (
      this : in out RadialControllerMenuItem;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRadialControllerMenuItem.all.add_Invoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Invoked
   (
      this : in out RadialControllerMenuItem;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_IRadialControllerMenuItem.all.remove_Invoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerRotationChangedEventArgs

   procedure Initialize (this : in out RadialControllerRotationChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerRotationChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerRotationChangedEventArgs, IRadialControllerRotationChangedEventArgs_Ptr);
   begin
      if this.m_IRadialControllerRotationChangedEventArgs /= null then
         if this.m_IRadialControllerRotationChangedEventArgs.all /= null then
            temp := this.m_IRadialControllerRotationChangedEventArgs.all.Release;
            Free (this.m_IRadialControllerRotationChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerRotationChangedEventArgs

   function get_RotationDeltaInDegrees
   (
      this : in out RadialControllerRotationChangedEventArgs
   )
   return WinRt.Double is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Double;
   begin
      Hr := this.m_IRadialControllerRotationChangedEventArgs.all.get_RotationDeltaInDegrees (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Contact
   (
      this : in out RadialControllerRotationChangedEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerRotationChangedEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_IsButtonPressed
   (
      this : in out RadialControllerRotationChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerRotationChangedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerRotationChangedEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerRotationChangedEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerRotationChangedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialControllerRotationChangedEventArgs.all);
      Hr := m_Interface.get_IsButtonPressed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerRotationChangedEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerRotationChangedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerRotationChangedEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerRotationChangedEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerRotationChangedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         m_Interface := QInterface (this.m_IRadialControllerRotationChangedEventArgs.all);
         Hr := m_Interface.get_SimpleHapticsController (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerScreenContact

   procedure Initialize (this : in out RadialControllerScreenContact) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerScreenContact) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerScreenContact, IRadialControllerScreenContact_Ptr);
   begin
      if this.m_IRadialControllerScreenContact /= null then
         if this.m_IRadialControllerScreenContact.all /= null then
            temp := this.m_IRadialControllerScreenContact.all.Release;
            Free (this.m_IRadialControllerScreenContact);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerScreenContact

   function get_Bounds
   (
      this : in out RadialControllerScreenContact
   )
   return WinRt.Windows.Foundation.Rect is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Rect;
   begin
      Hr := this.m_IRadialControllerScreenContact.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out RadialControllerScreenContact
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IRadialControllerScreenContact.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerScreenContactContinuedEventArgs

   procedure Initialize (this : in out RadialControllerScreenContactContinuedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerScreenContactContinuedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerScreenContactContinuedEventArgs, IRadialControllerScreenContactContinuedEventArgs_Ptr);
   begin
      if this.m_IRadialControllerScreenContactContinuedEventArgs /= null then
         if this.m_IRadialControllerScreenContactContinuedEventArgs.all /= null then
            temp := this.m_IRadialControllerScreenContactContinuedEventArgs.all.Release;
            Free (this.m_IRadialControllerScreenContactContinuedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerScreenContactContinuedEventArgs

   function get_Contact
   (
      this : in out RadialControllerScreenContactContinuedEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerScreenContactContinuedEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_IsButtonPressed
   (
      this : in out RadialControllerScreenContactContinuedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerScreenContactContinuedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerScreenContactContinuedEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerScreenContactContinuedEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerScreenContactContinuedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialControllerScreenContactContinuedEventArgs.all);
      Hr := m_Interface.get_IsButtonPressed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerScreenContactContinuedEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerScreenContactContinuedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerScreenContactContinuedEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerScreenContactContinuedEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerScreenContactContinuedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         m_Interface := QInterface (this.m_IRadialControllerScreenContactContinuedEventArgs.all);
         Hr := m_Interface.get_SimpleHapticsController (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerScreenContactEndedEventArgs

   procedure Initialize (this : in out RadialControllerScreenContactEndedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerScreenContactEndedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerScreenContactEndedEventArgs, IRadialControllerScreenContactEndedEventArgs_Ptr);
   begin
      if this.m_IRadialControllerScreenContactEndedEventArgs /= null then
         if this.m_IRadialControllerScreenContactEndedEventArgs.all /= null then
            temp := this.m_IRadialControllerScreenContactEndedEventArgs.all.Release;
            Free (this.m_IRadialControllerScreenContactEndedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerScreenContactEndedEventArgs

   function get_IsButtonPressed
   (
      this : in out RadialControllerScreenContactEndedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_IRadialControllerScreenContactEndedEventArgs.all.get_IsButtonPressed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerScreenContactEndedEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         Hr := this.m_IRadialControllerScreenContactEndedEventArgs.all.get_SimpleHapticsController (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadialControllerScreenContactStartedEventArgs

   procedure Initialize (this : in out RadialControllerScreenContactStartedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadialControllerScreenContactStartedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadialControllerScreenContactStartedEventArgs, IRadialControllerScreenContactStartedEventArgs_Ptr);
   begin
      if this.m_IRadialControllerScreenContactStartedEventArgs /= null then
         if this.m_IRadialControllerScreenContactStartedEventArgs.all /= null then
            temp := this.m_IRadialControllerScreenContactStartedEventArgs.all.Release;
            Free (this.m_IRadialControllerScreenContactStartedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadialControllerScreenContactStartedEventArgs

   function get_Contact
   (
      this : in out RadialControllerScreenContactStartedEventArgs
   )
   return WinRt.Windows.UI.Input.RadialControllerScreenContact'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.IRadialControllerScreenContact;
   begin
      return RetVal : WinRt.Windows.UI.Input.RadialControllerScreenContact do
         Hr := this.m_IRadialControllerScreenContactStartedEventArgs.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRadialControllerScreenContact := new Windows.UI.Input.IRadialControllerScreenContact;
         Retval.m_IRadialControllerScreenContact.all := m_ComRetVal;
      end return;
   end;

   function get_IsButtonPressed
   (
      this : in out RadialControllerScreenContactStartedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerScreenContactStartedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerScreenContactStartedEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerScreenContactStartedEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerScreenContactStartedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRadialControllerScreenContactStartedEventArgs.all);
      Hr := m_Interface.get_IsButtonPressed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SimpleHapticsController
   (
      this : in out RadialControllerScreenContactStartedEventArgs
   )
   return WinRt.Windows.Devices.Haptics.SimpleHapticsController'Class is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRadialControllerScreenContactStartedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Haptics.ISimpleHapticsController;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRadialControllerScreenContactStartedEventArgs_Interface, WinRt.Windows.UI.Input.IRadialControllerScreenContactStartedEventArgs2, WinRt.Windows.UI.Input.IID_IRadialControllerScreenContactStartedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinRt.Windows.Devices.Haptics.SimpleHapticsController do
         m_Interface := QInterface (this.m_IRadialControllerScreenContactStartedEventArgs.all);
         Hr := m_Interface.get_SimpleHapticsController (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISimpleHapticsController := new Windows.Devices.Haptics.ISimpleHapticsController;
         Retval.m_ISimpleHapticsController.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RightTappedEventArgs

   procedure Initialize (this : in out RightTappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RightTappedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRightTappedEventArgs, IRightTappedEventArgs_Ptr);
   begin
      if this.m_IRightTappedEventArgs /= null then
         if this.m_IRightTappedEventArgs.all /= null then
            temp := this.m_IRightTappedEventArgs.all.Release;
            Free (this.m_IRightTappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RightTappedEventArgs

   function get_PointerDeviceType
   (
      this : in out RightTappedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_IRightTappedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out RightTappedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_IRightTappedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out RightTappedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.IRightTappedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.IRightTappedEventArgs_Interface, WinRt.Windows.UI.Input.IRightTappedEventArgs2, WinRt.Windows.UI.Input.IID_IRightTappedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRightTappedEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SystemButtonEventController

   procedure Initialize (this : in out SystemButtonEventController) is
   begin
      null;
   end;

   procedure Finalize (this : in out SystemButtonEventController) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISystemButtonEventController, ISystemButtonEventController_Ptr);
   begin
      if this.m_ISystemButtonEventController /= null then
         if this.m_ISystemButtonEventController.all /= null then
            temp := this.m_ISystemButtonEventController.all.Release;
            Free (this.m_ISystemButtonEventController);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SystemButtonEventController

   function CreateForDispatcherQueue
   (
      queue : Windows.System.DispatcherQueue'Class
   )
   return WinRt.Windows.UI.Input.SystemButtonEventController is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_hString        : constant WinRt.HString := To_HString ("Windows.UI.Input.SystemButtonEventController");
      m_Factory        : access WinRt.Windows.UI.Input.ISystemButtonEventControllerStatics_Interface'Class := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.UI.Input.ISystemButtonEventController;
   begin
      return RetVal : WinRt.Windows.UI.Input.SystemButtonEventController do
         Hr := RoGetActivationFactory (m_hString, IID_ISystemButtonEventControllerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateForDispatcherQueue (queue.m_IDispatcherQueue.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_ISystemButtonEventController := new Windows.UI.Input.ISystemButtonEventController;
            Retval.m_ISystemButtonEventController.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SystemButtonEventController

   function add_SystemFunctionButtonPressed
   (
      this : in out SystemButtonEventController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISystemButtonEventController.all.add_SystemFunctionButtonPressed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SystemFunctionButtonPressed
   (
      this : in out SystemButtonEventController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemButtonEventController.all.remove_SystemFunctionButtonPressed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SystemFunctionButtonReleased
   (
      this : in out SystemButtonEventController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISystemButtonEventController.all.add_SystemFunctionButtonReleased (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SystemFunctionButtonReleased
   (
      this : in out SystemButtonEventController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemButtonEventController.all.remove_SystemFunctionButtonReleased (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SystemFunctionLockChanged
   (
      this : in out SystemButtonEventController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISystemButtonEventController.all.add_SystemFunctionLockChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SystemFunctionLockChanged
   (
      this : in out SystemButtonEventController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemButtonEventController.all.remove_SystemFunctionLockChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SystemFunctionLockIndicatorChanged
   (
      this : in out SystemButtonEventController;
      handler : GenericObject
   )
   return WinRt.Windows.Foundation.EventRegistrationToken is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISystemButtonEventController.all.add_SystemFunctionLockIndicatorChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SystemFunctionLockIndicatorChanged
   (
      this : in out SystemButtonEventController;
      token : Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemButtonEventController.all.remove_SystemFunctionLockIndicatorChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SystemFunctionButtonEventArgs

   procedure Initialize (this : in out SystemFunctionButtonEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SystemFunctionButtonEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISystemFunctionButtonEventArgs, ISystemFunctionButtonEventArgs_Ptr);
   begin
      if this.m_ISystemFunctionButtonEventArgs /= null then
         if this.m_ISystemFunctionButtonEventArgs.all /= null then
            temp := this.m_ISystemFunctionButtonEventArgs.all.Release;
            Free (this.m_ISystemFunctionButtonEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SystemFunctionButtonEventArgs

   function get_Timestamp
   (
      this : in out SystemFunctionButtonEventArgs
   )
   return WinRt.UInt64 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt64;
   begin
      Hr := this.m_ISystemFunctionButtonEventArgs.all.get_Timestamp (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out SystemFunctionButtonEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ISystemFunctionButtonEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out SystemFunctionButtonEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemFunctionButtonEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SystemFunctionLockChangedEventArgs

   procedure Initialize (this : in out SystemFunctionLockChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SystemFunctionLockChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISystemFunctionLockChangedEventArgs, ISystemFunctionLockChangedEventArgs_Ptr);
   begin
      if this.m_ISystemFunctionLockChangedEventArgs /= null then
         if this.m_ISystemFunctionLockChangedEventArgs.all /= null then
            temp := this.m_ISystemFunctionLockChangedEventArgs.all.Release;
            Free (this.m_ISystemFunctionLockChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SystemFunctionLockChangedEventArgs

   function get_Timestamp
   (
      this : in out SystemFunctionLockChangedEventArgs
   )
   return WinRt.UInt64 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt64;
   begin
      Hr := this.m_ISystemFunctionLockChangedEventArgs.all.get_Timestamp (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsLocked
   (
      this : in out SystemFunctionLockChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ISystemFunctionLockChangedEventArgs.all.get_IsLocked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out SystemFunctionLockChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ISystemFunctionLockChangedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out SystemFunctionLockChangedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemFunctionLockChangedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SystemFunctionLockIndicatorChangedEventArgs

   procedure Initialize (this : in out SystemFunctionLockIndicatorChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SystemFunctionLockIndicatorChangedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISystemFunctionLockIndicatorChangedEventArgs, ISystemFunctionLockIndicatorChangedEventArgs_Ptr);
   begin
      if this.m_ISystemFunctionLockIndicatorChangedEventArgs /= null then
         if this.m_ISystemFunctionLockIndicatorChangedEventArgs.all /= null then
            temp := this.m_ISystemFunctionLockIndicatorChangedEventArgs.all.Release;
            Free (this.m_ISystemFunctionLockIndicatorChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SystemFunctionLockIndicatorChangedEventArgs

   function get_Timestamp
   (
      this : in out SystemFunctionLockIndicatorChangedEventArgs
   )
   return WinRt.UInt64 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt64;
   begin
      Hr := this.m_ISystemFunctionLockIndicatorChangedEventArgs.all.get_Timestamp (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsIndicatorOn
   (
      this : in out SystemFunctionLockIndicatorChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ISystemFunctionLockIndicatorChangedEventArgs.all.get_IsIndicatorOn (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out SystemFunctionLockIndicatorChangedEventArgs
   )
   return WinRt.Boolean is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.Boolean;
   begin
      Hr := this.m_ISystemFunctionLockIndicatorChangedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out SystemFunctionLockIndicatorChangedEventArgs;
      value : WinRt.Boolean
   ) is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
   begin
      Hr := this.m_ISystemFunctionLockIndicatorChangedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TappedEventArgs

   procedure Initialize (this : in out TappedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TappedEventArgs) is
      temp : WinRt.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITappedEventArgs, ITappedEventArgs_Ptr);
   begin
      if this.m_ITappedEventArgs /= null then
         if this.m_ITappedEventArgs.all /= null then
            temp := this.m_ITappedEventArgs.all.Release;
            Free (this.m_ITappedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TappedEventArgs

   function get_PointerDeviceType
   (
      this : in out TappedEventArgs
   )
   return WinRt.Windows.Devices.Input.PointerDeviceType is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Devices.Input.PointerDeviceType;
   begin
      Hr := this.m_ITappedEventArgs.all.get_PointerDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out TappedEventArgs
   )
   return WinRt.Windows.Foundation.Point is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased Windows.Foundation.Point;
   begin
      Hr := this.m_ITappedEventArgs.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TapCount
   (
      this : in out TappedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
   begin
      Hr := this.m_ITappedEventArgs.all.get_TapCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContactCount
   (
      this : in out TappedEventArgs
   )
   return WinRt.UInt32 is
      Hr               : WinRt.HResult := S_OK;
      tmp              : WinRt.HResult := S_OK;
      m_Interface      : WinRt.Windows.UI.Input.ITappedEventArgs2 := null;
      temp             : WinRt.UInt32 := 0;
      m_ComRetVal      : aliased WinRt.UInt32;
      function QInterface is new Generic_QueryInterface (WinRt.Windows.UI.Input.ITappedEventArgs_Interface, WinRt.Windows.UI.Input.ITappedEventArgs2, WinRt.Windows.UI.Input.IID_ITappedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITappedEventArgs.all);
      Hr := m_Interface.get_ContactCount (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

end WinRt.Windows.UI.Input;
