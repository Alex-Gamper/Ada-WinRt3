--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.ApplicationModel.Contacts;
with WinUI3.Windows.ApplicationModel.DataTransfer;
with WinUI3.Windows.ApplicationModel.Search;
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Globalization;
with WinUI3.Windows.Media.Capture;
with WinUI3.Windows.Media.Casting;
with WinUI3.Windows.Media.Core;
with WinUI3.Windows.Media.Playback;
with WinUI3.Windows.Media.PlayTo;
with WinUI3.Windows.Media.Protection;
with WinUI3.Windows.Storage.Streams;
with WinUI3.Windows.System;
with WinUI3.Windows.UI.Composition;
with WinUI3.Windows.UI.Core;
with WinUI3.Windows.UI.Input.Inking;
with WinUI3.Windows.UI.Text;
with WinUI3.Windows.UI.Xaml.Automation;
with WinUI3.Windows.UI.Xaml.Automation.Provider;
with WinUI3.Windows.UI.Xaml.Controls.Primitives;
with WinUI3.Windows.UI.Xaml.Data;
with WinUI3.Windows.UI.Xaml.Documents;
with WinUI3.Windows.UI.Xaml.Input;
with WinUI3.Windows.UI.Xaml.Interop;
with WinUI3.Windows.UI.Xaml.Media;
with WinUI3.Windows.UI.Xaml.Media.Animation;
with WinUI3.Windows.UI.Xaml.Navigation;
with WinUI3.Windows.Web;
with WinUI3.Windows.Web.Http;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Windows.UI.Xaml.Controls is

   package IVector_IColumnDefinition is new WinUI3.Windows.Foundation.Collections.IVector (IColumnDefinition);
   package IIterable_IColumnDefinition is new WinUI3.Windows.Foundation.Collections.IIterable (IColumnDefinition);
   package IAsyncOperation_ContentDialogResult is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult);
   package AsyncOperationCompletedHandler_ContentDialogResult is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult);

   package IAsyncOperation_GenericObject is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.GenericObject);
   package AsyncOperationCompletedHandler_GenericObject is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.GenericObject);

   package IAsyncOperation_LoadMoreItemsResult is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Windows.UI.Xaml.Data.LoadMoreItemsResult);
   package AsyncOperationCompletedHandler_LoadMoreItemsResult is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Windows.UI.Xaml.Data.LoadMoreItemsResult);

   package IAsyncOperation_Boolean is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Boolean);
   package AsyncOperationCompletedHandler_Boolean is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Boolean);

   package IIterable_IHubSection is new WinUI3.Windows.Foundation.Collections.IIterable (IHubSection);
   package IIterable_IInspectable is new WinUI3.Windows.Foundation.Collections.IIterable (WinUI3.IInspectable);
   package IVector_IRowDefinition is new WinUI3.Windows.Foundation.Collections.IVector (IRowDefinition);
   package IIterable_IRowDefinition is new WinUI3.Windows.Foundation.Collections.IIterable (IRowDefinition);
   package IVector_ISwipeItem is new WinUI3.Windows.Foundation.Collections.IVector (ISwipeItem);
   package IIterable_ISwipeItem is new WinUI3.Windows.Foundation.Collections.IIterable (ISwipeItem);
   package IIterable_IUIElement is new WinUI3.Windows.Foundation.Collections.IIterable (WinUI3.Windows.UI.Xaml.IUIElement);
   package IAsyncOperation_HString is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.HString);
   package AsyncOperationCompletedHandler_HString is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.HString);

   package IAsyncOperation_DataPackage is new WinUI3.Windows.Foundation.IAsyncOperation (WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage);
   package AsyncOperationCompletedHandler_DataPackage is new WinUI3.Windows.Foundation.AsyncOperationCompletedHandler (WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage);

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AnchorRequestedEventArgs

   procedure Initialize (this : in out AnchorRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AnchorRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAnchorRequestedEventArgs, IAnchorRequestedEventArgs_Ptr);
   begin
      if this.m_IAnchorRequestedEventArgs /= null then
         if this.m_IAnchorRequestedEventArgs.all /= null then
            temp := this.m_IAnchorRequestedEventArgs.all.Release;
            Free (this.m_IAnchorRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AnchorRequestedEventArgs

   function get_Anchor
   (
      this : in out AnchorRequestedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IAnchorRequestedEventArgs.all.get_Anchor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Anchor
   (
      this : in out AnchorRequestedEventArgs;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAnchorRequestedEventArgs.all.put_Anchor (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AnchorCandidates
   (
      this : in out AnchorRequestedEventArgs
   )
   return IVector_IUIElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IUIElement.Kind;
   begin
      Hr := this.m_IAnchorRequestedEventArgs.all.get_AnchorCandidates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IUIElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Control

   procedure Initialize (this : in out Control) is
   begin
      null;
   end;

   procedure Finalize (this : in out Control) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IControl, IControl_Ptr);
   begin
      if this.m_IControl /= null then
         if this.m_IControl.all /= null then
            temp := this.m_IControl.all.Release;
            Free (this.m_IControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Control

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Control is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory    : access IControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IControl;
   begin
      return RetVal : Control do
         Hr := RoGetActivationFactory (m_hString, IID_IControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IControl := new WinUI3.Windows.UI.Xaml.Controls.IControl;
            Retval.m_IControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Control

   function get_UseSystemFocusVisualsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UseSystemFocusVisualsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTemplateFocusTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTemplateFocusTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsTemplateFocusTarget
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics3'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsTemplateFocusTarget (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsTemplateFocusTarget
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics3'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsTemplateFocusTarget (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsFocusEngagementEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFocusEngagementEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFocusEngagedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFocusEngagedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RequiresPointerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RequiresPointerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusLeftProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusRightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusRightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusUpProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusUpProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusDownProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusDownProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ElementSoundModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ElementSoundModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTabStopProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTabStopProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabIndexProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TabNavigationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TabNavigationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalContentAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalContentAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultStyleKeyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultStyleKeyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusStateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusStateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultStyleResourceUriProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultStyleResourceUriProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTemplateKeyTipTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IControlStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTemplateKeyTipTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsTemplateKeyTipTarget
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics5'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsTemplateKeyTipTarget (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsTemplateKeyTipTarget
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Control");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IControlStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IControlStatics5'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsTemplateKeyTipTarget (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Control

   function get_FontSize
   (
      this : in out Control
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IControl.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out Control;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_IControl.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IControl.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IControl.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_IControl.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out Control
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IControl.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out Control;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IControl.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTabStop
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.get_IsTabStop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTabStop
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_IsTabStop (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsEnabled
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.get_IsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsEnabled
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_IsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabIndex
   (
      this : in out Control
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IControl.all.get_TabIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabIndex
   (
      this : in out Control;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_TabIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TabNavigation
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Input.KeyboardNavigationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.KeyboardNavigationMode;
   begin
      Hr := this.m_IControl.all.get_TabNavigation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TabNavigation
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Input.KeyboardNavigationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_TabNavigation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Template
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Controls.ControlTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IControlTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ControlTemplate do
         Hr := this.m_IControl.all.get_Template (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IControlTemplate := new WinUI3.Windows.UI.Xaml.Controls.IControlTemplate;
         Retval.m_IControlTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_Template
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Controls.ControlTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Template (value.m_IControlTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IControl.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalContentAlignment
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IControl.all.get_HorizontalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalContentAlignment
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_HorizontalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalContentAlignment
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IControl.all.get_VerticalContentAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalContentAlignment
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_VerticalContentAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IControl.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IControl.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IControl.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FocusState
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.FocusState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.FocusState;
   begin
      Hr := this.m_IControl.all.get_FocusState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_IsEnabledChanged
   (
      this : in out Control;
      handler : WinUI3.Windows.UI.Xaml.DependencyPropertyChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IControl.all.add_IsEnabledChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsEnabledChanged
   (
      this : in out Control;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControl.all.remove_IsEnabledChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ApplyTemplate
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.ApplyTemplate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Focus
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.FocusState
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IControl.all.Focus (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl2, WinUI3.Windows.UI.Xaml.Controls.IID_IControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl2, WinUI3.Windows.UI.Xaml.Controls.IID_IControl2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_IsTextScaleFactorEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UseSystemFocusVisuals
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl3, WinUI3.Windows.UI.Xaml.Controls.IID_IControl3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_UseSystemFocusVisuals (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UseSystemFocusVisuals
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl3, WinUI3.Windows.UI.Xaml.Controls.IID_IControl3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_UseSystemFocusVisuals (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFocusEngagementEnabled
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_IsFocusEngagementEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFocusEngagementEnabled
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_IsFocusEngagementEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFocusEngaged
   (
      this : in out Control
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_IsFocusEngaged (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFocusEngaged
   (
      this : in out Control;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_IsFocusEngaged (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RequiresPointer
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Controls.RequiresPointer is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.RequiresPointer;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_RequiresPointer (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RequiresPointer
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Controls.RequiresPointer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_RequiresPointer (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusLeft
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IControl.all);
         Hr := m_Interface.get_XYFocusLeft (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusLeft
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_XYFocusLeft (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusRight
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IControl.all);
         Hr := m_Interface.get_XYFocusRight (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusRight
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_XYFocusRight (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusUp
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IControl.all);
         Hr := m_Interface.get_XYFocusUp (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusUp
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_XYFocusUp (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusDown
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IControl.all);
         Hr := m_Interface.get_XYFocusDown (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusDown
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_XYFocusDown (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ElementSoundMode
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.ElementSoundMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.ElementSoundMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_ElementSoundMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ElementSoundMode
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.ElementSoundMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_ElementSoundMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FocusEngaged
   (
      this : in out Control;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.add_FocusEngaged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FocusEngaged
   (
      this : in out Control;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.remove_FocusEngaged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FocusDisengaged
   (
      this : in out Control;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.add_FocusDisengaged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FocusDisengaged
   (
      this : in out Control;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.remove_FocusDisengaged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveFocusEngagement
   (
      this : in out Control
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl4, WinUI3.Windows.UI.Xaml.Controls.IID_IControl4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.RemoveFocusEngagement;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultStyleResourceUri
   (
      this : in out Control
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl5, WinUI3.Windows.UI.Xaml.Controls.IID_IControl5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         m_Interface := QInterface (this.m_IControl.all);
         Hr := m_Interface.get_DefaultStyleResourceUri (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_DefaultStyleResourceUri
   (
      this : in out Control;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl5, WinUI3.Windows.UI.Xaml.Controls.IID_IControl5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_DefaultStyleResourceUri (value.m_IUriRuntimeClass.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl7, WinUI3.Windows.UI.Xaml.Controls.IID_IControl7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_BackgroundSizing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl7, WinUI3.Windows.UI.Xaml.Controls.IID_IControl7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_BackgroundSizing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out Control
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl7, WinUI3.Windows.UI.Xaml.Controls.IID_IControl7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_CornerRadius (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out Control;
      value : WinUI3.Windows.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControl7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControl7, WinUI3.Windows.UI.Xaml.Controls.IID_IControl7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_CornerRadius (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultStyleKey
   (
      this : in out Control
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlProtected := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlProtected, WinUI3.Windows.UI.Xaml.Controls.IID_IControlProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.get_DefaultStyleKey (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultStyleKey
   (
      this : in out Control;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlProtected, WinUI3.Windows.UI.Xaml.Controls.IID_IControlProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.put_DefaultStyleKey (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetTemplateChild
   (
      this : in out Control;
      childName : WinUI3.WString
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlProtected := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      HStr_childName : constant WinUI3.HString := To_HString (childName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlProtected, WinUI3.Windows.UI.Xaml.Controls.IID_IControlProtected'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IControl.all);
         Hr := m_Interface.GetTemplateChild (HStr_childName, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_childName);
      end return;
   end;

   procedure OnPointerEntered
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerEntered (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerPressed
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerPressed (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerMoved
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerMoved (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerReleased
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerReleased (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerExited
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerExited (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerCaptureLost
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerCaptureLost (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerCanceled
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerCanceled (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPointerWheelChanged
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.PointerRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPointerWheelChanged (e.m_IPointerRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnTapped
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.TappedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnTapped (e.m_ITappedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDoubleTapped
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDoubleTapped (e.m_IDoubleTappedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnHolding
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.HoldingRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnHolding (e.m_IHoldingRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnRightTapped
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.RightTappedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnRightTapped (e.m_IRightTappedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationStarting
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationStarting (e.m_IManipulationStartingRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationInertiaStarting
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationInertiaStarting (e.m_IManipulationInertiaStartingRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationStarted
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationStarted (e.m_IManipulationStartedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationDelta
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationDelta (e.m_IManipulationDeltaRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnManipulationCompleted
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnManipulationCompleted (e.m_IManipulationCompletedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnKeyUp
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnKeyUp (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnKeyDown
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnKeyDown (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnGotFocus
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.RoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnGotFocus (e.m_IRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnLostFocus
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.RoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnLostFocus (e.m_IRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDragEnter
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDragEnter (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDragLeave
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDragLeave (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDragOver
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDragOver (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDrop
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.DragEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnDrop (e.m_IDragEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPreviewKeyDown
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides6, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPreviewKeyDown (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnPreviewKeyUp
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.KeyRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides6, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnPreviewKeyUp (e.m_IKeyRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnCharacterReceived
   (
      this : in out Control;
      e : WinUI3.Windows.UI.Xaml.Input.CharacterReceivedRoutedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IControlOverrides6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IControlOverrides6, WinUI3.Windows.UI.Xaml.Controls.IID_IControlOverrides6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IControl.all);
      Hr := m_Interface.OnCharacterReceived (e.m_ICharacterReceivedRoutedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentControl

   procedure Initialize (this : in out ContentControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentControl, IContentControl_Ptr);
   begin
      if this.m_IContentControl /= null then
         if this.m_IContentControl.all /= null then
            temp := this.m_IContentControl.all.Release;
            Free (this.m_IContentControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContentControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ContentControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentControl");
      m_Factory    : access IContentControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IContentControl;
   begin
      return RetVal : ContentControl do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IContentControl := new WinUI3.Windows.UI.Xaml.Controls.IContentControl;
            Retval.m_IContentControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContentControl

   function get_ContentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateSelectorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTransitionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentControl

   function get_Content
   (
      this : in out ContentControl
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentControl.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out ContentControl;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplate
   (
      this : in out ContentControl
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IContentControl.all.get_ContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplate
   (
      this : in out ContentControl;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_ContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplateSelector
   (
      this : in out ContentControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IContentControl.all.get_ContentTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplateSelector
   (
      this : in out ContentControl;
      value : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_ContentTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTransitions
   (
      this : in out ContentControl
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IContentControl.all.get_ContentTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTransitions
   (
      this : in out ContentControl;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentControl.all.put_ContentTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplateRoot
   (
      this : in out ContentControl
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentControl2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentControl2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentControl2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IContentControl.all);
         Hr := m_Interface.get_ContentTemplateRoot (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure OnContentChanged
   (
      this : in out ContentControl;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IContentControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentControl.all);
      Hr := m_Interface.OnContentChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateChanged
   (
      this : in out ContentControl;
      oldContentTemplate : WinUI3.Windows.UI.Xaml.DataTemplate'Class;
      newContentTemplate : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IContentControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentControl.all);
      Hr := m_Interface.OnContentTemplateChanged (oldContentTemplate.m_IDataTemplate.all, newContentTemplate.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateSelectorChanged
   (
      this : in out ContentControl;
      oldContentTemplateSelector : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class;
      newContentTemplateSelector : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IContentControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentControl.all);
      Hr := m_Interface.OnContentTemplateSelectorChanged (oldContentTemplateSelector.m_IDataTemplateSelector.all, newContentTemplateSelector.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBar

   procedure Initialize (this : in out AppBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBar, IAppBar_Ptr);
   begin
      if this.m_IAppBar /= null then
         if this.m_IAppBar.all /= null then
            temp := this.m_IAppBar.all.Release;
            Free (this.m_IAppBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBar");
      m_Factory    : access IAppBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAppBar;
   begin
      return RetVal : AppBar do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBar := new WinUI3.Windows.UI.Xaml.Controls.IAppBar;
            Retval.m_IAppBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBar

   function get_LightDismissOverlayModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClosedDisplayModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClosedDisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOpenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStickyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStickyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBar

   function get_IsOpen
   (
      this : in out AppBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppBar.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOpen
   (
      this : in out AppBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.put_IsOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSticky
   (
      this : in out AppBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAppBar.all.get_IsSticky (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSticky
   (
      this : in out AppBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.put_IsSticky (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppBar.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAppBar.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBar.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClosedDisplayMode
   (
      this : in out AppBar
   )
   return WinUI3.Windows.UI.Xaml.Controls.AppBarClosedDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.AppBarClosedDisplayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar2, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.get_ClosedDisplayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClosedDisplayMode
   (
      this : in out AppBar;
      value : WinUI3.Windows.UI.Xaml.Controls.AppBarClosedDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar2, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.put_ClosedDisplayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out AppBar
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IAppBarTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings do
         m_Interface := QInterface (this.m_IAppBar.all);
         Hr := m_Interface.get_TemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBarTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IAppBarTemplateSettings;
         Retval.m_IAppBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_Opening
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.add_Opening (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opening
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.remove_Opening (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out AppBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.add_Closing (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out AppBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.remove_Closing (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out AppBar
   )
   return WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar4, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.get_LightDismissOverlayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out AppBar;
      value : WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBar4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBar4, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBar4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.put_LightDismissOverlayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnClosed
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnClosed (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOpened
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnOpened (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnClosing
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarOverrides3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnClosing (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOpening
   (
      this : in out AppBar;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBar_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarOverrides3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarOverrides3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBar.all);
      Hr := m_Interface.OnOpening (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Button

   procedure Initialize (this : in out Button) is
   begin
      null;
   end;

   procedure Finalize (this : in out Button) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IButton, IButton_Ptr);
   begin
      if this.m_IButton /= null then
         if this.m_IButton.all /= null then
            temp := this.m_IButton.all.Release;
            Free (this.m_IButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Button

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Button is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Button");
      m_Factory    : access IButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IButton;
   begin
      return RetVal : Button do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IButton := new WinUI3.Windows.UI.Xaml.Controls.IButton;
            Retval.m_IButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Button

   function get_FlyoutProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Button");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IButtonStaticsWithFlyout_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IButtonStaticsWithFlyout'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Button

   function get_Flyout
   (
      this : in out Button
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IButtonWithFlyout := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IButtonWithFlyout, WinUI3.Windows.UI.Xaml.Controls.IID_IButtonWithFlyout'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_IButton.all);
         Hr := m_Interface.get_Flyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_Flyout
   (
      this : in out Button;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IButtonWithFlyout := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IButtonWithFlyout, WinUI3.Windows.UI.Xaml.Controls.IID_IButtonWithFlyout'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IButton.all);
      Hr := m_Interface.put_Flyout (value.m_IFlyoutBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarButton

   procedure Initialize (this : in out AppBarButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarButton, IAppBarButton_Ptr);
   begin
      if this.m_IAppBarButton /= null then
         if this.m_IAppBarButton.all /= null then
            temp := this.m_IAppBarButton.all.Release;
            Free (this.m_IAppBarButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory    : access IAppBarButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAppBarButton;
   begin
      return RetVal : AppBarButton do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarButton := new WinUI3.Windows.UI.Xaml.Controls.IAppBarButton;
            Retval.m_IAppBarButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarButton

   function get_LabelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorTextOverrideProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarButtonStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorTextOverrideProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LabelPositionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarButtonStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelPositionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsInOverflowProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarButtonStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarButtonStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarButtonStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarButton

   function get_Label
   (
      this : in out AppBarButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppBarButton.all.get_Label (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Label
   (
      this : in out AppBarButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAppBarButton.all.put_Label (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Icon
   (
      this : in out AppBarButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconElement do
         Hr := this.m_IAppBarButton.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Windows.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out AppBarButton;
      value : WinUI3.Windows.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBarButton.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LabelPosition
   (
      this : in out AppBarButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.CommandBarLabelPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarButton3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CommandBarLabelPosition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarButton3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarButton3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_LabelPosition (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LabelPosition
   (
      this : in out AppBarButton;
      value : WinUI3.Windows.UI.Xaml.Controls.CommandBarLabelPosition
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarButton3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarButton3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarButton3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.put_LabelPosition (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarButton4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarButton4, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarButton4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_KeyboardAcceleratorTextOverride (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarButton4 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarButton4, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarButton4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.put_KeyboardAcceleratorTextOverride (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TemplateSettings
   (
      this : in out AppBarButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.AppBarButtonTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarButton5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IAppBarButtonTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarButton5, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarButton5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.AppBarButtonTemplateSettings do
         m_Interface := QInterface (this.m_IAppBarButton.all);
         Hr := m_Interface.get_TemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBarButtonTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IAppBarButtonTemplateSettings;
         Retval.m_IAppBarButtonTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_IsCompact
   (
      this : in out AppBarButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarButton
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarButton;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarButton.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarElementContainer

   procedure Initialize (this : in out AppBarElementContainer) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarElementContainer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarElementContainer, IAppBarElementContainer_Ptr);
   begin
      if this.m_IAppBarElementContainer /= null then
         if this.m_IAppBarElementContainer.all /= null then
            temp := this.m_IAppBarElementContainer.all.Release;
            Free (this.m_IAppBarElementContainer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarElementContainer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarElementContainer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarElementContainer");
      m_Factory    : access IAppBarElementContainerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainer;
   begin
      return RetVal : AppBarElementContainer do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarElementContainer := new WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainer;
            Retval.m_IAppBarElementContainer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarElementContainer

   function get_IsCompactProperty_AppBarElementContainer
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarElementContainer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsInOverflowProperty_AppBarElementContainer
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarElementContainer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty_AppBarElementContainer
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarElementContainer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarElementContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarElementContainer

   function get_IsCompact
   (
      this : in out AppBarElementContainer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarElementContainer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarElementContainer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarElementContainer
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarElementContainer;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarElementContainer_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarElementContainer.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarSeparator

   procedure Initialize (this : in out AppBarSeparator) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarSeparator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarSeparator, IAppBarSeparator_Ptr);
   begin
      if this.m_IAppBarSeparator /= null then
         if this.m_IAppBarSeparator.all /= null then
            temp := this.m_IAppBarSeparator.all.Release;
            Free (this.m_IAppBarSeparator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarSeparator

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarSeparator is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarSeparator");
      m_Factory    : access IAppBarSeparatorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparator;
   begin
      return RetVal : AppBarSeparator do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarSeparator := new WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparator;
            Retval.m_IAppBarSeparator.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarSeparator

   function get_IsInOverflowProperty_AppBarSeparator
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarSeparator");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparatorStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty_AppBarSeparator
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarSeparator");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparatorStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactProperty_AppBarSeparator
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarSeparator");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparatorStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarSeparatorStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarSeparator

   function get_IsCompact
   (
      this : in out AppBarSeparator
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarSeparator;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarSeparator
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarSeparator
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarSeparator;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarSeparator_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarSeparator.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AppBarToggleButton

   procedure Initialize (this : in out AppBarToggleButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out AppBarToggleButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAppBarToggleButton, IAppBarToggleButton_Ptr);
   begin
      if this.m_IAppBarToggleButton /= null then
         if this.m_IAppBarToggleButton.all /= null then
            temp := this.m_IAppBarToggleButton.all.Release;
            Free (this.m_IAppBarToggleButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AppBarToggleButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return AppBarToggleButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory    : access IAppBarToggleButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton;
   begin
      return RetVal : AppBarToggleButton do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IAppBarToggleButton := new WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton;
            Retval.m_IAppBarToggleButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AppBarToggleButton

   function get_LabelPositionProperty_AppBarToggleButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelPositionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsInOverflowProperty_AppBarToggleButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsInOverflowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DynamicOverflowOrderProperty_AppBarToggleButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DynamicOverflowOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorTextOverrideProperty_AppBarToggleButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorTextOverrideProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LabelProperty_AppBarToggleButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LabelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_AppBarToggleButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactProperty_AppBarToggleButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AppBarToggleButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAppBarToggleButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AppBarToggleButton

   function get_Label
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAppBarToggleButton.all.get_Label (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Label
   (
      this : in out AppBarToggleButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAppBarToggleButton.all.put_Label (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Icon
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconElement do
         Hr := this.m_IAppBarToggleButton.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Windows.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Windows.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAppBarToggleButton.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LabelPosition
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.CommandBarLabelPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CommandBarLabelPosition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarToggleButton3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_LabelPosition (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LabelPosition
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Windows.UI.Xaml.Controls.CommandBarLabelPosition
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton3, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarToggleButton3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.put_LabelPosition (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton4, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarToggleButton4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_KeyboardAcceleratorTextOverride (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyboardAcceleratorTextOverride
   (
      this : in out AppBarToggleButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton4 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton4, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarToggleButton4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.put_KeyboardAcceleratorTextOverride (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TemplateSettings
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.AppBarToggleButtonTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IAppBarToggleButtonTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton5, WinUI3.Windows.UI.Xaml.Controls.IID_IAppBarToggleButton5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.AppBarToggleButtonTemplateSettings do
         m_Interface := QInterface (this.m_IAppBarToggleButton.all);
         Hr := m_Interface.get_TemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBarToggleButtonTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IAppBarToggleButtonTemplateSettings;
         Retval.m_IAppBarToggleButtonTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_IsCompact
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_IsCompact (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.put_IsCompact (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsInOverflow
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_IsInOverflow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DynamicOverflowOrder
   (
      this : in out AppBarToggleButton
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.get_DynamicOverflowOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DynamicOverflowOrder
   (
      this : in out AppBarToggleButton;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAppBarToggleButton_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBarElement2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBarElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAppBarToggleButton.all);
      Hr := m_Interface.put_DynamicOverflowOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsControl

   procedure Initialize (this : in out ItemsControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsControl, IItemsControl_Ptr);
   begin
      if this.m_IItemsControl /= null then
         if this.m_IItemsControl.all /= null then
            temp := this.m_IItemsControl.all.Release;
            Free (this.m_IItemsControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ItemsControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory    : access IItemsControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsControl;
   begin
      return RetVal : ItemsControl do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IItemsControl := new WinUI3.Windows.UI.Xaml.Controls.IItemsControl;
            Retval.m_IItemsControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsControl

   function get_ItemsSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateSelectorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsPanelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayMemberPathProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayMemberPathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleSelectorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerTransitionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GroupStyleSelectorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetItemsOwner
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemsControl is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsControl;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemsControl do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetItemsOwner (element.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IItemsControl := new WinUI3.Windows.UI.Xaml.Controls.IItemsControl;
            Retval.m_IItemsControl.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function ItemsControlFromItemContainer
   (
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemsControl is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsControl;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemsControl do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.ItemsControlFromItemContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IItemsControl := new WinUI3.Windows.UI.Xaml.Controls.IItemsControl;
            Retval.m_IItemsControl.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsControl

   function get_ItemsSource
   (
      this : in out ItemsControl
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsControl.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out ItemsControl;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Items
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemCollection do
         Hr := this.m_IItemsControl.all.get_Items (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_ItemTemplate
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IItemsControl.all.get_ItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out ItemsControl;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplateSelector
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IItemsControl.all.get_ItemTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplateSelector
   (
      this : in out ItemsControl;
      value : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsPanel
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemsPanelTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsPanelTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemsPanelTemplate do
         Hr := this.m_IItemsControl.all.get_ItemsPanel (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemsPanelTemplate := new WinUI3.Windows.UI.Xaml.Controls.IItemsPanelTemplate;
         Retval.m_IItemsPanelTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemsPanel
   (
      this : in out ItemsControl;
      value : WinUI3.Windows.UI.Xaml.Controls.ItemsPanelTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemsPanel (value.m_IItemsPanelTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMemberPath
   (
      this : in out ItemsControl
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IItemsControl.all.get_DisplayMemberPath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisplayMemberPath
   (
      this : in out ItemsControl;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IItemsControl.all.put_DisplayMemberPath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ItemContainerStyle
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IItemsControl.all.get_ItemContainerStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyle
   (
      this : in out ItemsControl;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemContainerStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerStyleSelector
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.StyleSelector do
         Hr := this.m_IItemsControl.all.get_ItemContainerStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyleSelector
   (
      this : in out ItemsControl;
      value : WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemContainerStyleSelector (value.m_IStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerGenerator
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemContainerGenerator'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IItemContainerGenerator;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemContainerGenerator do
         Hr := this.m_IItemsControl.all.get_ItemContainerGenerator (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemContainerGenerator := new WinUI3.Windows.UI.Xaml.Controls.IItemContainerGenerator;
         Retval.m_IItemContainerGenerator.all := m_ComRetVal;
      end return;
   end;

   function get_ItemContainerTransitions
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IItemsControl.all.get_ItemContainerTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerTransitions
   (
      this : in out ItemsControl;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_ItemContainerTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GroupStyle
   (
      this : in out ItemsControl
   )
   return IObservableVector_IGroupStyle.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_IGroupStyle.Kind;
   begin
      Hr := this.m_IItemsControl.all.get_GroupStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_IGroupStyle (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_GroupStyleSelector
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.GroupStyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IGroupStyleSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.GroupStyleSelector do
         Hr := this.m_IItemsControl.all.get_GroupStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGroupStyleSelector := new WinUI3.Windows.UI.Xaml.Controls.IGroupStyleSelector;
         Retval.m_IGroupStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_GroupStyleSelector
   (
      this : in out ItemsControl;
      value : WinUI3.Windows.UI.Xaml.Controls.GroupStyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsControl.all.put_GroupStyleSelector (value.m_IGroupStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsGrouping
   (
      this : in out ItemsControl
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IItemsControl.all.get_IsGrouping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ItemsPanelRoot
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.Panel'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControl2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IPanel;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControl2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControl2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Panel do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.get_ItemsPanelRoot (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPanel := new WinUI3.Windows.UI.Xaml.Controls.IPanel;
         Retval.m_IPanel.all := m_ComRetVal;
      end return;
   end;

   function GroupHeaderContainerFromItemContainer
   (
      this : in out ItemsControl;
      itemContainer : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControl3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControl3, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControl3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.GroupHeaderContainerFromItemContainer (itemContainer.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function IsItemItsOwnContainerOverride
   (
      this : in out ItemsControl;
      item : WinUI3.IInspectable
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.IsItemItsOwnContainerOverride (item, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetContainerForItemOverride
   (
      this : in out ItemsControl
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.GetContainerForItemOverride (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure ClearContainerForItemOverride
   (
      this : in out ItemsControl;
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.ClearContainerForItemOverride (element.m_IDependencyObject.all, item);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PrepareContainerForItemOverride
   (
      this : in out ItemsControl;
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.PrepareContainerForItemOverride (element.m_IDependencyObject.all, item);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemsChanged
   (
      this : in out ItemsControl;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemsChanged (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemContainerStyleChanged
   (
      this : in out ItemsControl;
      oldItemContainerStyle : WinUI3.Windows.UI.Xaml.Style'Class;
      newItemContainerStyle : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemContainerStyleChanged (oldItemContainerStyle.m_IStyle.all, newItemContainerStyle.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemContainerStyleSelectorChanged
   (
      this : in out ItemsControl;
      oldItemContainerStyleSelector : WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class;
      newItemContainerStyleSelector : WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector.m_IStyleSelector.all, newItemContainerStyleSelector.m_IStyleSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemTemplateChanged
   (
      this : in out ItemsControl;
      oldItemTemplate : WinUI3.Windows.UI.Xaml.DataTemplate'Class;
      newItemTemplate : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemTemplateChanged (oldItemTemplate.m_IDataTemplate.all, newItemTemplate.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemTemplateSelectorChanged
   (
      this : in out ItemsControl;
      oldItemTemplateSelector : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class;
      newItemTemplateSelector : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnItemTemplateSelectorChanged (oldItemTemplateSelector.m_IDataTemplateSelector.all, newItemTemplateSelector.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnGroupStyleSelectorChanged
   (
      this : in out ItemsControl;
      oldGroupStyleSelector : WinUI3.Windows.UI.Xaml.Controls.GroupStyleSelector'Class;
      newGroupStyleSelector : WinUI3.Windows.UI.Xaml.Controls.GroupStyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsControlOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsControlOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.OnGroupStyleSelectorChanged (oldGroupStyleSelector.m_IGroupStyleSelector.all, newGroupStyleSelector.m_IGroupStyleSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ItemFromContainer
   (
      this : in out ItemsControl;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Windows.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.ItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromItem
   (
      this : in out ItemsControl;
      item : WinUI3.IInspectable
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Windows.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.ContainerFromItem (item, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function IndexFromContainer
   (
      this : in out ItemsControl;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Windows.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsControl.all);
      Hr := m_Interface.IndexFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromIndex
   (
      this : in out ItemsControl;
      index : WinUI3.Int32
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsControl_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemContainerMapping, WinUI3.Windows.UI.Xaml.Controls.IID_IItemContainerMapping'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IItemsControl.all);
         Hr := m_Interface.ContainerFromIndex (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBox

   procedure Initialize (this : in out AutoSuggestBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBox, IAutoSuggestBox_Ptr);
   begin
      if this.m_IAutoSuggestBox /= null then
         if this.m_IAutoSuggestBox.all /= null then
            temp := this.m_IAutoSuggestBox.all.Release;
            Free (this.m_IAutoSuggestBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBox

   function Constructor return AutoSuggestBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox;
   begin
      return RetVal : AutoSuggestBox do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBox := new WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox;
            Retval.m_IAutoSuggestBox.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AutoSuggestBox

   function get_DescriptionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxSuggestionListHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxSuggestionListHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSuggestionListOpenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSuggestionListOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextMemberPathProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextMemberPathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UpdateTextOnSelectProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UpdateTextOnSelectProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoMaximizeSuggestionAreaProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoMaximizeSuggestionAreaProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextBoxStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextBoxStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_QueryIconProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_QueryIconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_AutoSuggestBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBox

   function get_MaxSuggestionListHeight
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_MaxSuggestionListHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxSuggestionListHeight
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_MaxSuggestionListHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSuggestionListOpen
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_IsSuggestionListOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSuggestionListOpen
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_IsSuggestionListOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextMemberPath
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_TextMemberPath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_TextMemberPath
   (
      this : in out AutoSuggestBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAutoSuggestBox.all.put_TextMemberPath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Text
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out AutoSuggestBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAutoSuggestBox.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_UpdateTextOnSelect
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_UpdateTextOnSelect (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UpdateTextOnSelect
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_UpdateTextOnSelect (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out AutoSuggestBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IAutoSuggestBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Header
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out AutoSuggestBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AutoMaximizeSuggestionArea
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBox.all.get_AutoMaximizeSuggestionArea (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoMaximizeSuggestionArea
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_AutoMaximizeSuggestionArea (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextBoxStyle
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IAutoSuggestBox.all.get_TextBoxStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_TextBoxStyle
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.put_TextBoxStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SuggestionChosen
   (
      this : in out AutoSuggestBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAutoSuggestBox.all.add_SuggestionChosen (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SuggestionChosen
   (
      this : in out AutoSuggestBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.remove_SuggestionChosen (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanged
   (
      this : in out AutoSuggestBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IAutoSuggestBox.all.add_TextChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanged
   (
      this : in out AutoSuggestBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBox.all.remove_TextChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_QueryIcon
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconElement do
         m_Interface := QInterface (this.m_IAutoSuggestBox.all);
         Hr := m_Interface.get_QueryIcon (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Windows.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_QueryIcon
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Windows.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutoSuggestBox.all);
      Hr := m_Interface.put_QueryIcon (value.m_IIconElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_QuerySubmitted
   (
      this : in out AutoSuggestBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutoSuggestBox.all);
      Hr := m_Interface.add_QuerySubmitted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_QuerySubmitted
   (
      this : in out AutoSuggestBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutoSuggestBox.all);
      Hr := m_Interface.remove_QuerySubmitted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutoSuggestBox.all);
      Hr := m_Interface.get_LightDismissOverlayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out AutoSuggestBox;
      value : WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutoSuggestBox.all);
      Hr := m_Interface.put_LightDismissOverlayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out AutoSuggestBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutoSuggestBox.all);
      Hr := m_Interface.get_Description (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out AutoSuggestBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IAutoSuggestBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IAutoSuggestBox.all);
      Hr := m_Interface.put_Description (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBoxQuerySubmittedEventArgs

   procedure Initialize (this : in out AutoSuggestBoxQuerySubmittedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBoxQuerySubmittedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBoxQuerySubmittedEventArgs, IAutoSuggestBoxQuerySubmittedEventArgs_Ptr);
   begin
      if this.m_IAutoSuggestBoxQuerySubmittedEventArgs /= null then
         if this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all /= null then
            temp := this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all.Release;
            Free (this.m_IAutoSuggestBoxQuerySubmittedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBoxQuerySubmittedEventArgs

   function Constructor return AutoSuggestBoxQuerySubmittedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBoxQuerySubmittedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs;
   begin
      return RetVal : AutoSuggestBoxQuerySubmittedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBoxQuerySubmittedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxQuerySubmittedEventArgs;
            Retval.m_IAutoSuggestBoxQuerySubmittedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBoxQuerySubmittedEventArgs

   function get_QueryText
   (
      this : in out AutoSuggestBoxQuerySubmittedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all.get_QueryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ChosenSuggestion
   (
      this : in out AutoSuggestBoxQuerySubmittedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAutoSuggestBoxQuerySubmittedEventArgs.all.get_ChosenSuggestion (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBoxSuggestionChosenEventArgs

   procedure Initialize (this : in out AutoSuggestBoxSuggestionChosenEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBoxSuggestionChosenEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBoxSuggestionChosenEventArgs, IAutoSuggestBoxSuggestionChosenEventArgs_Ptr);
   begin
      if this.m_IAutoSuggestBoxSuggestionChosenEventArgs /= null then
         if this.m_IAutoSuggestBoxSuggestionChosenEventArgs.all /= null then
            temp := this.m_IAutoSuggestBoxSuggestionChosenEventArgs.all.Release;
            Free (this.m_IAutoSuggestBoxSuggestionChosenEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBoxSuggestionChosenEventArgs

   function Constructor return AutoSuggestBoxSuggestionChosenEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBoxSuggestionChosenEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs;
   begin
      return RetVal : AutoSuggestBoxSuggestionChosenEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBoxSuggestionChosenEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxSuggestionChosenEventArgs;
            Retval.m_IAutoSuggestBoxSuggestionChosenEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBoxSuggestionChosenEventArgs

   function get_SelectedItem
   (
      this : in out AutoSuggestBoxSuggestionChosenEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IAutoSuggestBoxSuggestionChosenEventArgs.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for AutoSuggestBoxTextChangedEventArgs

   procedure Initialize (this : in out AutoSuggestBoxTextChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out AutoSuggestBoxTextChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IAutoSuggestBoxTextChangedEventArgs, IAutoSuggestBoxTextChangedEventArgs_Ptr);
   begin
      if this.m_IAutoSuggestBoxTextChangedEventArgs /= null then
         if this.m_IAutoSuggestBoxTextChangedEventArgs.all /= null then
            temp := this.m_IAutoSuggestBoxTextChangedEventArgs.all.Release;
            Free (this.m_IAutoSuggestBoxTextChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for AutoSuggestBoxTextChangedEventArgs

   function Constructor return AutoSuggestBoxTextChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBoxTextChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs;
   begin
      return RetVal : AutoSuggestBoxTextChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IAutoSuggestBoxTextChangedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgs;
            Retval.m_IAutoSuggestBoxTextChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for AutoSuggestBoxTextChangedEventArgs

   function get_ReasonProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.AutoSuggestBoxTextChangedEventArgs");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBoxTextChangedEventArgsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IAutoSuggestBoxTextChangedEventArgsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReasonProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for AutoSuggestBoxTextChangedEventArgs

   function get_Reason
   (
      this : in out AutoSuggestBoxTextChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.AutoSuggestionBoxTextChangeReason is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.AutoSuggestionBoxTextChangeReason;
   begin
      Hr := this.m_IAutoSuggestBoxTextChangedEventArgs.all.get_Reason (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Reason
   (
      this : in out AutoSuggestBoxTextChangedEventArgs;
      value : WinUI3.Windows.UI.Xaml.Controls.AutoSuggestionBoxTextChangeReason
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IAutoSuggestBoxTextChangedEventArgs.all.put_Reason (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CheckCurrent
   (
      this : in out AutoSuggestBoxTextChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IAutoSuggestBoxTextChangedEventArgs.all.CheckCurrent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BackClickEventArgs

   procedure Initialize (this : in out BackClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out BackClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBackClickEventArgs, IBackClickEventArgs_Ptr);
   begin
      if this.m_IBackClickEventArgs /= null then
         if this.m_IBackClickEventArgs.all /= null then
            temp := this.m_IBackClickEventArgs.all.Release;
            Free (this.m_IBackClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BackClickEventArgs

   function Constructor return BackClickEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.BackClickEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IBackClickEventArgs;
   begin
      return RetVal : BackClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBackClickEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IBackClickEventArgs;
            Retval.m_IBackClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BackClickEventArgs

   function get_Handled
   (
      this : in out BackClickEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBackClickEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out BackClickEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBackClickEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate BackClickEventHandler

   function Invoke
   (
      this : access BackClickEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.IBackClickEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IconElement

   procedure Initialize (this : in out IconElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out IconElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIconElement, IIconElement_Ptr);
   begin
      if this.m_IIconElement /= null then
         if this.m_IIconElement.all /= null then
            temp := this.m_IIconElement.all.Release;
            Free (this.m_IIconElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for IconElement

   -----------------------------------------------------------------------------
   -- Static Interfaces for IconElement

   function get_ForegroundProperty_IconElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.IconElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IIconElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IIconElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IconElement

   function get_Foreground
   (
      this : in out IconElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IIconElement.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out IconElement;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IIconElement.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BitmapIcon

   procedure Initialize (this : in out BitmapIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out BitmapIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBitmapIcon, IBitmapIcon_Ptr);
   begin
      if this.m_IBitmapIcon /= null then
         if this.m_IBitmapIcon.all /= null then
            temp := this.m_IBitmapIcon.all.Release;
            Free (this.m_IBitmapIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BitmapIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BitmapIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.BitmapIcon");
      m_Factory    : access IBitmapIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon;
   begin
      return RetVal : BitmapIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBitmapIcon := new WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon;
            Retval.m_IBitmapIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BitmapIcon

   function get_ShowAsMonochromeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.BitmapIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBitmapIconStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowAsMonochromeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UriSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.BitmapIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBitmapIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UriSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BitmapIcon

   function get_UriSource
   (
      this : in out BitmapIcon
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IBitmapIcon.all.get_UriSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_UriSource
   (
      this : in out BitmapIcon;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapIcon.all.put_UriSource (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowAsMonochrome
   (
      this : in out BitmapIcon
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon_Interface, WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon2, WinUI3.Windows.UI.Xaml.Controls.IID_IBitmapIcon2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBitmapIcon.all);
      Hr := m_Interface.get_ShowAsMonochrome (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowAsMonochrome
   (
      this : in out BitmapIcon;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon_Interface, WinUI3.Windows.UI.Xaml.Controls.IBitmapIcon2, WinUI3.Windows.UI.Xaml.Controls.IID_IBitmapIcon2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBitmapIcon.all);
      Hr := m_Interface.put_ShowAsMonochrome (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IconSource

   procedure Initialize (this : in out IconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out IconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIconSource, IIconSource_Ptr);
   begin
      if this.m_IIconSource /= null then
         if this.m_IIconSource.all /= null then
            temp := this.m_IIconSource.all.Release;
            Free (this.m_IIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for IconSource

   -----------------------------------------------------------------------------
   -- Static Interfaces for IconSource

   function get_ForegroundProperty_IconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.IconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IconSource

   function get_Foreground
   (
      this : in out IconSource
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IIconSource.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out IconSource;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IIconSource.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for BitmapIconSource

   procedure Initialize (this : in out BitmapIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out BitmapIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBitmapIconSource, IBitmapIconSource_Ptr);
   begin
      if this.m_IBitmapIconSource /= null then
         if this.m_IBitmapIconSource.all /= null then
            temp := this.m_IBitmapIconSource.all.Release;
            Free (this.m_IBitmapIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for BitmapIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return BitmapIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.BitmapIconSource");
      m_Factory    : access IBitmapIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IBitmapIconSource;
   begin
      return RetVal : BitmapIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IBitmapIconSource := new WinUI3.Windows.UI.Xaml.Controls.IBitmapIconSource;
            Retval.m_IBitmapIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for BitmapIconSource

   function get_UriSourceProperty_BitmapIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.BitmapIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBitmapIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UriSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowAsMonochromeProperty_BitmapIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.BitmapIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBitmapIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBitmapIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowAsMonochromeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for BitmapIconSource

   function get_UriSource
   (
      this : in out BitmapIconSource
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IBitmapIconSource.all.get_UriSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_UriSource
   (
      this : in out BitmapIconSource;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapIconSource.all.put_UriSource (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowAsMonochrome
   (
      this : in out BitmapIconSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IBitmapIconSource.all.get_ShowAsMonochrome (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowAsMonochrome
   (
      this : in out BitmapIconSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBitmapIconSource.all.put_ShowAsMonochrome (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Border

   procedure Initialize (this : in out Border) is
   begin
      null;
   end;

   procedure Finalize (this : in out Border) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IBorder, IBorder_Ptr);
   begin
      if this.m_IBorder /= null then
         if this.m_IBorder.all /= null then
            temp := this.m_IBorder.all.Release;
            Free (this.m_IBorder);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Border

   function Constructor return Border is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IBorder;
   begin
      return RetVal : Border do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IBorder := new WinUI3.Windows.UI.Xaml.Controls.IBorder;
            Retval.m_IBorder.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Border

   function get_BorderBrushProperty_Border
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_Border
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty_Border
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_Border
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_Border
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildTransitionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBorderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty_Border
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Border");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IBorderStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IBorderStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Border

   function get_BorderBrush
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IBorder.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IBorder.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IBorder.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IBorder.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IBorder.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Child
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IBorder.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChildTransitions
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IBorder.all.get_ChildTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ChildTransitions
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IBorder.all.put_ChildTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IBorder2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IBorder_Interface, WinUI3.Windows.UI.Xaml.Controls.IBorder2, WinUI3.Windows.UI.Xaml.Controls.IID_IBorder2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBorder.all);
      Hr := m_Interface.get_BackgroundSizing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IBorder2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IBorder_Interface, WinUI3.Windows.UI.Xaml.Controls.IBorder2, WinUI3.Windows.UI.Xaml.Controls.IID_IBorder2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBorder.all);
      Hr := m_Interface.put_BackgroundSizing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundTransition
   (
      this : in out Border
   )
   return WinUI3.Windows.UI.Xaml.BrushTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IBorder2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IBrushTransition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IBorder_Interface, WinUI3.Windows.UI.Xaml.Controls.IBorder2, WinUI3.Windows.UI.Xaml.Controls.IID_IBorder2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.BrushTransition do
         m_Interface := QInterface (this.m_IBorder.all);
         Hr := m_Interface.get_BackgroundTransition (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrushTransition := new WinUI3.Windows.UI.Xaml.IBrushTransition;
         Retval.m_IBrushTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_BackgroundTransition
   (
      this : in out Border;
      value : WinUI3.Windows.UI.Xaml.BrushTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IBorder2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IBorder_Interface, WinUI3.Windows.UI.Xaml.Controls.IBorder2, WinUI3.Windows.UI.Xaml.Controls.IID_IBorder2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IBorder.all);
      Hr := m_Interface.put_BackgroundTransition (value.m_IBrushTransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarDatePicker

   procedure Initialize (this : in out CalendarDatePicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarDatePicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarDatePicker, ICalendarDatePicker_Ptr);
   begin
      if this.m_ICalendarDatePicker /= null then
         if this.m_ICalendarDatePicker.all /= null then
            temp := this.m_ICalendarDatePicker.all.Release;
            Free (this.m_ICalendarDatePicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CalendarDatePicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CalendarDatePicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory    : access ICalendarDatePickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker;
   begin
      return RetVal : CalendarDatePicker do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICalendarDatePicker := new WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker;
            Retval.m_ICalendarDatePicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CalendarDatePicker

   function get_LightDismissOverlayModeProperty_CalendarDatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_CalendarDatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCalendarOpenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCalendarOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateFormatProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_CalendarDatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_CalendarDatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarViewStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarViewStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinDateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxDateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTodayHighlightedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTodayHighlightedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstDayOfWeekProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstDayOfWeekProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayOfWeekFormatProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayOfWeekFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarIdentifierProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOutOfScopeEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOutOfScopeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupLabelVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarDatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupLabelVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarDatePicker

   function get_Date
   (
      this : in out CalendarDatePicker
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_Date
   (
      this : in out CalendarDatePicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_Date (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCalendarOpen
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsCalendarOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCalendarOpen
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsCalendarOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DateFormat
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_DateFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DateFormat
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_DateFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PlaceholderText
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Header
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out CalendarDatePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_ICalendarDatePicker.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarViewStyle
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_ICalendarDatePicker.all.get_CalendarViewStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarViewStyle
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_CalendarViewStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinDate
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_MinDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinDate
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_MinDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxDate
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_MaxDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxDate
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_MaxDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTodayHighlighted
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsTodayHighlighted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTodayHighlighted
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsTodayHighlighted (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.UI.Xaml.Controls.CalendarViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CalendarViewDisplayMode;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisplayMode
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.UI.Xaml.Controls.CalendarViewDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_DisplayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstDayOfWeek
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.Globalization.DayOfWeek is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Globalization.DayOfWeek;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_FirstDayOfWeek (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstDayOfWeek
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.Globalization.DayOfWeek
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_FirstDayOfWeek (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayOfWeekFormat
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_DayOfWeekFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayOfWeekFormat
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_DayOfWeekFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_CalendarIdentifier
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out CalendarDatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarDatePicker.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsOutOfScopeEnabled
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsOutOfScopeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOutOfScopeEnabled
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsOutOfScopeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsGroupLabelVisible
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarDatePicker.all.get_IsGroupLabelVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsGroupLabelVisible
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.put_IsGroupLabelVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CalendarViewDayItemChanging
   (
      this : in out CalendarDatePicker;
      handler : WinUI3.Windows.UI.Xaml.Controls.CalendarViewDayItemChangingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_CalendarViewDayItemChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CalendarViewDayItemChanging
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_CalendarViewDayItemChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DateChanged
   (
      this : in out CalendarDatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_DateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DateChanged
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_DateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out CalendarDatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out CalendarDatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarDatePicker.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out CalendarDatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDisplayDate
   (
      this : in out CalendarDatePicker;
      date : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.SetDisplayDate (date);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetYearDecadeDisplayDimensions
   (
      this : in out CalendarDatePicker;
      columns : WinUI3.Int32;
      rows : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarDatePicker.all.SetYearDecadeDisplayDimensions (columns, rows);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarDatePicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarDatePicker.all);
      Hr := m_Interface.get_LightDismissOverlayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out CalendarDatePicker;
      value : WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarDatePicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarDatePicker.all);
      Hr := m_Interface.put_LightDismissOverlayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out CalendarDatePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarDatePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarDatePicker.all);
      Hr := m_Interface.get_Description (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out CalendarDatePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarDatePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarDatePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarDatePicker.all);
      Hr := m_Interface.put_Description (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarDatePickerDateChangedEventArgs

   procedure Initialize (this : in out CalendarDatePickerDateChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarDatePickerDateChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarDatePickerDateChangedEventArgs, ICalendarDatePickerDateChangedEventArgs_Ptr);
   begin
      if this.m_ICalendarDatePickerDateChangedEventArgs /= null then
         if this.m_ICalendarDatePickerDateChangedEventArgs.all /= null then
            temp := this.m_ICalendarDatePickerDateChangedEventArgs.all.Release;
            Free (this.m_ICalendarDatePickerDateChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarDatePickerDateChangedEventArgs

   function get_NewDate
   (
      this : in out CalendarDatePickerDateChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_ICalendarDatePickerDateChangedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_OldDate
   (
      this : in out CalendarDatePickerDateChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_ICalendarDatePickerDateChangedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarView

   procedure Initialize (this : in out CalendarView) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarView, ICalendarView_Ptr);
   begin
      if this.m_ICalendarView /= null then
         if this.m_ICalendarView.all /= null then
            temp := this.m_ICalendarView.all.Release;
            Free (this.m_ICalendarView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CalendarView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CalendarView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory    : access ICalendarViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICalendarView;
   begin
      return RetVal : CalendarView do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICalendarView := new WinUI3.Windows.UI.Xaml.Controls.ICalendarView;
            Retval.m_ICalendarView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CalendarView

   function get_SelectedDisabledBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDisabledBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodaySelectedInnerBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodaySelectedInnerBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BlackoutStrikethroughBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BlackoutStrikethroughBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BlackoutBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BlackoutBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemHoverBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemHoverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemPressedBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemPressedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemDisabledBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemDisabledBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayBlackoutBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayBlackoutBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayHoverBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayHoverBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayPressedBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayPressedBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayDisabledBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayDisabledBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayBlackoutForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayBlackoutForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedHoverForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedHoverForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPressedForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPressedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDisabledForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDisabledForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopeHoverForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopeHoverForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopePressedForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopePressedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemMarginProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemMarginProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelMarginProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelMarginProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelMarginProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemCornerRadiusProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemCornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarIdentifierProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayOfWeekFormatProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayOfWeekFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupLabelVisibleProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupLabelVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstDayOfWeekProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstDayOfWeekProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOutOfScopeEnabledProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOutOfScopeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTodayHighlightedProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTodayHighlightedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxDateProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinDateProperty_CalendarView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NumberOfWeeksInViewProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NumberOfWeeksInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDatesProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDatesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedHoverBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedHoverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedPressedBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedPressedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HoverBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HoverBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PressedBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PressedBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemBorderBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemBorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopeBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopeBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PressedForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PressedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BlackoutForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BlackoutForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OutOfScopeForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OutOfScopeForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontFamilyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayItemFontWeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayItemFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TodayFontWeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TodayFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontFamilyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfMonthLabelFontWeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfMonthLabelFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontFamilyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthYearItemFontWeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthYearItemFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontFamilyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FirstOfYearDecadeLabelFontWeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FirstOfYearDecadeLabelFontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalDayItemAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalDayItemAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalDayItemAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalDayItemAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalFirstOfMonthLabelAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalFirstOfMonthLabelAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalFirstOfMonthLabelAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalFirstOfMonthLabelAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarItemBorderThicknessProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarItemBorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarViewDayItemStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarViewDayItemStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarView

   function get_CalendarIdentifier
   (
      this : in out CalendarView
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarView.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out CalendarView;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarView.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_DayOfWeekFormat
   (
      this : in out CalendarView
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ICalendarView.all.get_DayOfWeekFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayOfWeekFormat
   (
      this : in out CalendarView;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ICalendarView.all.put_DayOfWeekFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsGroupLabelVisible
   (
      this : in out CalendarView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarView.all.get_IsGroupLabelVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsGroupLabelVisible
   (
      this : in out CalendarView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_IsGroupLabelVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Controls.CalendarViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CalendarViewDisplayMode;
   begin
      Hr := this.m_ICalendarView.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisplayMode
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Controls.CalendarViewDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DisplayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstDayOfWeek
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.Globalization.DayOfWeek is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Globalization.DayOfWeek;
   begin
      Hr := this.m_ICalendarView.all.get_FirstDayOfWeek (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstDayOfWeek
   (
      this : in out CalendarView;
      value : WinUI3.Windows.Globalization.DayOfWeek
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstDayOfWeek (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOutOfScopeEnabled
   (
      this : in out CalendarView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarView.all.get_IsOutOfScopeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOutOfScopeEnabled
   (
      this : in out CalendarView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_IsOutOfScopeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTodayHighlighted
   (
      this : in out CalendarView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarView.all.get_IsTodayHighlighted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTodayHighlighted
   (
      this : in out CalendarView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_IsTodayHighlighted (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxDate
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarView.all.get_MaxDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxDate
   (
      this : in out CalendarView;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MaxDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinDate
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarView.all.get_MinDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinDate
   (
      this : in out CalendarView;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MinDate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NumberOfWeeksInView
   (
      this : in out CalendarView
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ICalendarView.all.get_NumberOfWeeksInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NumberOfWeeksInView
   (
      this : in out CalendarView;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_NumberOfWeeksInView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDates
   (
      this : in out CalendarView
   )
   return IVector_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_DateTime.Kind;
   begin
      Hr := this.m_ICalendarView.all.get_SelectedDates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Controls.CalendarViewSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CalendarViewSelectionMode;
   begin
      Hr := this.m_ICalendarView.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Controls.CalendarViewSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.ICalendarViewTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings do
         Hr := this.m_ICalendarView.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICalendarViewTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.ICalendarViewTemplateSettings;
         Retval.m_ICalendarViewTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_FocusBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_FocusBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_FocusBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FocusBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedHoverBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedHoverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedHoverBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedHoverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPressedBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedPressedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPressedBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedPressedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HoverBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_HoverBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_HoverBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_HoverBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PressedBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_PressedBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PressedBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_PressedBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemBorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemBorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopeBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_OutOfScopeBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopeBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_OutOfScopeBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PressedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_PressedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PressedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_PressedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_TodayForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BlackoutForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_BlackoutForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BlackoutForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_BlackoutForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_SelectedForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_SelectedForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopeForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_OutOfScopeForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopeForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_OutOfScopeForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ICalendarView.all.get_CalendarItemForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_DayItemFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_DayItemFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_DayItemFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_DayItemFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_DayItemFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_DayItemFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_TodayFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TodayFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_TodayFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FirstOfMonthLabelFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfMonthLabelFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfMonthLabelFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_MonthYearItemFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_MonthYearItemFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_MonthYearItemFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_MonthYearItemFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_MonthYearItemFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_MonthYearItemFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontFamily
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FirstOfYearDecadeLabelFontFamily
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontSize
   (
      this : in out CalendarView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelFontSize
   (
      this : in out CalendarView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelFontStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelFontWeight
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ICalendarView.all.get_FirstOfYearDecadeLabelFontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelFontWeight
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_FirstOfYearDecadeLabelFontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalDayItemAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_HorizontalDayItemAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalDayItemAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_HorizontalDayItemAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalDayItemAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_VerticalDayItemAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalDayItemAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_VerticalDayItemAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_HorizontalFirstOfMonthLabelAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_HorizontalFirstOfMonthLabelAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_ICalendarView.all.get_VerticalFirstOfMonthLabelAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalFirstOfMonthLabelAlignment
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_VerticalFirstOfMonthLabelAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemBorderThickness
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_ICalendarView.all.get_CalendarItemBorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CalendarItemBorderThickness
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarItemBorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarViewDayItemStyle
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_ICalendarView.all.get_CalendarViewDayItemStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarViewDayItemStyle
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.put_CalendarViewDayItemStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CalendarViewDayItemChanging
   (
      this : in out CalendarView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarView.all.add_CalendarViewDayItemChanging (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CalendarViewDayItemChanging
   (
      this : in out CalendarView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.remove_CalendarViewDayItemChanging (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectedDatesChanged
   (
      this : in out CalendarView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ICalendarView.all.add_SelectedDatesChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectedDatesChanged
   (
      this : in out CalendarView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.remove_SelectedDatesChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDisplayDate
   (
      this : in out CalendarView;
      date : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.SetDisplayDate (date);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetYearDecadeDisplayDimensions
   (
      this : in out CalendarView;
      columns : WinUI3.Int32;
      rows : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarView.all.SetYearDecadeDisplayDimensions (columns, rows);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDisabledBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_SelectedDisabledBorderBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedDisabledBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_SelectedDisabledBorderBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodaySelectedInnerBorderBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_TodaySelectedInnerBorderBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodaySelectedInnerBorderBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_TodaySelectedInnerBorderBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BlackoutStrikethroughBrush
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_BlackoutStrikethroughBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BlackoutStrikethroughBrush
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_BlackoutStrikethroughBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BlackoutBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_BlackoutBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BlackoutBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_BlackoutBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemHoverBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_CalendarItemHoverBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemHoverBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_CalendarItemHoverBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemPressedBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_CalendarItemPressedBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemPressedBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_CalendarItemPressedBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemDisabledBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_CalendarItemDisabledBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_CalendarItemDisabledBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_CalendarItemDisabledBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_TodayBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_TodayBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayBlackoutBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_TodayBlackoutBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayBlackoutBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_TodayBlackoutBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayHoverBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_TodayHoverBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayHoverBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_TodayHoverBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayPressedBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_TodayPressedBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayPressedBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_TodayPressedBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayDisabledBackground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_TodayDisabledBackground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayDisabledBackground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_TodayDisabledBackground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TodayBlackoutForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_TodayBlackoutForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_TodayBlackoutForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_TodayBlackoutForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedHoverForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_SelectedHoverForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedHoverForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_SelectedHoverForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedPressedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_SelectedPressedForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedPressedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_SelectedPressedForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDisabledForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_SelectedDisabledForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectedDisabledForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_SelectedDisabledForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopeHoverForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_OutOfScopeHoverForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopeHoverForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_OutOfScopeHoverForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OutOfScopePressedForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_OutOfScopePressedForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_OutOfScopePressedForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_OutOfScopePressedForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisabledForeground
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ICalendarView.all);
         Hr := m_Interface.get_DisabledForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_DisabledForeground
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_DisabledForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayItemMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.get_DayItemMargin (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayItemMargin
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_DayItemMargin (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthYearItemMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.get_MonthYearItemMargin (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthYearItemMargin
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_MonthYearItemMargin (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfMonthLabelMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.get_FirstOfMonthLabelMargin (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfMonthLabelMargin
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_FirstOfMonthLabelMargin (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstOfYearDecadeLabelMargin
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.get_FirstOfYearDecadeLabelMargin (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FirstOfYearDecadeLabelMargin
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_FirstOfYearDecadeLabelMargin (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarItemCornerRadius
   (
      this : in out CalendarView
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.get_CalendarItemCornerRadius (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CalendarItemCornerRadius
   (
      this : in out CalendarView;
      value : WinUI3.Windows.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICalendarView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICalendarView_Interface, WinUI3.Windows.UI.Xaml.Controls.ICalendarView2, WinUI3.Windows.UI.Xaml.Controls.IID_ICalendarView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICalendarView.all);
      Hr := m_Interface.put_CalendarItemCornerRadius (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarViewDayItem

   procedure Initialize (this : in out CalendarViewDayItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarViewDayItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarViewDayItem, ICalendarViewDayItem_Ptr);
   begin
      if this.m_ICalendarViewDayItem /= null then
         if this.m_ICalendarViewDayItem.all /= null then
            temp := this.m_ICalendarViewDayItem.all.Release;
            Free (this.m_ICalendarViewDayItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CalendarViewDayItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CalendarViewDayItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarViewDayItem");
      m_Factory    : access ICalendarViewDayItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICalendarViewDayItem;
   begin
      return RetVal : CalendarViewDayItem do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewDayItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICalendarViewDayItem := new WinUI3.Windows.UI.Xaml.Controls.ICalendarViewDayItem;
            Retval.m_ICalendarViewDayItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CalendarViewDayItem

   function get_IsBlackoutProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarViewDayItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewDayItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewDayItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBlackoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateProperty_CalendarViewDayItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CalendarViewDayItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICalendarViewDayItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICalendarViewDayItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarViewDayItem

   function get_IsBlackout
   (
      this : in out CalendarViewDayItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarViewDayItem.all.get_IsBlackout (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBlackout
   (
      this : in out CalendarViewDayItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItem.all.put_IsBlackout (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Date
   (
      this : in out CalendarViewDayItem
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_ICalendarViewDayItem.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetDensityColors
   (
      this : in out CalendarViewDayItem;
      colors : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItem.all.SetDensityColors (colors);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarViewDayItemChangingEventArgs

   procedure Initialize (this : in out CalendarViewDayItemChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarViewDayItemChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarViewDayItemChangingEventArgs, ICalendarViewDayItemChangingEventArgs_Ptr);
   begin
      if this.m_ICalendarViewDayItemChangingEventArgs /= null then
         if this.m_ICalendarViewDayItemChangingEventArgs.all /= null then
            temp := this.m_ICalendarViewDayItemChangingEventArgs.all.Release;
            Free (this.m_ICalendarViewDayItemChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarViewDayItemChangingEventArgs

   function get_InRecycleQueue
   (
      this : in out CalendarViewDayItemChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.get_InRecycleQueue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out CalendarViewDayItemChangingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.CalendarViewDayItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ICalendarViewDayItem;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.CalendarViewDayItem do
         Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.get_Item (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICalendarViewDayItem := new WinUI3.Windows.UI.Xaml.Controls.ICalendarViewDayItem;
         Retval.m_ICalendarViewDayItem.all := m_ComRetVal;
      end return;
   end;

   function get_Phase
   (
      this : in out CalendarViewDayItemChangingEventArgs
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.get_Phase (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out CalendarViewDayItemChangingEventArgs;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.RegisterUpdateCallback (callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out CalendarViewDayItemChangingEventArgs;
      callbackPhase : WinUI3.UInt32;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICalendarViewDayItemChangingEventArgs.all.RegisterUpdateCallback (callbackPhase, callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate CalendarViewDayItemChangingEventHandler

   function Invoke
   (
      this : access CalendarViewDayItemChangingEventHandler_Delegate;
      sender : WinUI3.Windows.UI.Xaml.Controls.ICalendarView;
      e : WinUI3.Windows.UI.Xaml.Controls.ICalendarViewDayItemChangingEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CalendarViewSelectedDatesChangedEventArgs

   procedure Initialize (this : in out CalendarViewSelectedDatesChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CalendarViewSelectedDatesChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICalendarViewSelectedDatesChangedEventArgs, ICalendarViewSelectedDatesChangedEventArgs_Ptr);
   begin
      if this.m_ICalendarViewSelectedDatesChangedEventArgs /= null then
         if this.m_ICalendarViewSelectedDatesChangedEventArgs.all /= null then
            temp := this.m_ICalendarViewSelectedDatesChangedEventArgs.all.Release;
            Free (this.m_ICalendarViewSelectedDatesChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CalendarViewSelectedDatesChangedEventArgs

   function get_AddedDates
   (
      this : in out CalendarViewSelectedDatesChangedEventArgs
   )
   return IVectorView_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_DateTime.Kind;
   begin
      Hr := this.m_ICalendarViewSelectedDatesChangedEventArgs.all.get_AddedDates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedDates
   (
      this : in out CalendarViewSelectedDatesChangedEventArgs
   )
   return IVectorView_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_DateTime.Kind;
   begin
      Hr := this.m_ICalendarViewSelectedDatesChangedEventArgs.all.get_RemovedDates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CandidateWindowBoundsChangedEventArgs

   procedure Initialize (this : in out CandidateWindowBoundsChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CandidateWindowBoundsChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICandidateWindowBoundsChangedEventArgs, ICandidateWindowBoundsChangedEventArgs_Ptr);
   begin
      if this.m_ICandidateWindowBoundsChangedEventArgs /= null then
         if this.m_ICandidateWindowBoundsChangedEventArgs.all /= null then
            temp := this.m_ICandidateWindowBoundsChangedEventArgs.all.Release;
            Free (this.m_ICandidateWindowBoundsChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CandidateWindowBoundsChangedEventArgs

   function get_Bounds
   (
      this : in out CandidateWindowBoundsChangedEventArgs
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ICandidateWindowBoundsChangedEventArgs.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Panel

   procedure Initialize (this : in out Panel) is
   begin
      null;
   end;

   procedure Finalize (this : in out Panel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPanel, IPanel_Ptr);
   begin
      if this.m_IPanel /= null then
         if this.m_IPanel.all /= null then
            temp := this.m_IPanel.all.Release;
            Free (this.m_IPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Panel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Panel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Panel");
      m_Factory    : access IPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPanel;
   begin
      return RetVal : Panel do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPanel := new WinUI3.Windows.UI.Xaml.Controls.IPanel;
            Retval.m_IPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Panel

   function get_BackgroundProperty_Panel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Panel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsItemsHostProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Panel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsItemsHostProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildrenTransitionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Panel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildrenTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Panel

   function get_Children
   (
      this : in out Panel
   )
   return WinUI3.Windows.UI.Xaml.Controls.UIElementCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.UIElementCollection do
         Hr := this.m_IPanel.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Background
   (
      this : in out Panel
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IPanel.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out Panel;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPanel.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsItemsHost
   (
      this : in out Panel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPanel.all.get_IsItemsHost (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ChildrenTransitions
   (
      this : in out Panel
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IPanel.all.get_ChildrenTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ChildrenTransitions
   (
      this : in out Panel;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPanel.all.put_ChildrenTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundTransition
   (
      this : in out Panel
   )
   return WinUI3.Windows.UI.Xaml.BrushTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IBrushTransition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IPanel2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.BrushTransition do
         m_Interface := QInterface (this.m_IPanel.all);
         Hr := m_Interface.get_BackgroundTransition (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrushTransition := new WinUI3.Windows.UI.Xaml.IBrushTransition;
         Retval.m_IBrushTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_BackgroundTransition
   (
      this : in out Panel;
      value : WinUI3.Windows.UI.Xaml.BrushTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPanel.all);
      Hr := m_Interface.put_BackgroundTransition (value.m_IBrushTransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Canvas

   procedure Initialize (this : in out Canvas) is
   begin
      null;
   end;

   procedure Finalize (this : in out Canvas) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICanvas, ICanvas_Ptr);
   begin
      if this.m_ICanvas /= null then
         if this.m_ICanvas.all /= null then
            temp := this.m_ICanvas.all.Release;
            Free (this.m_ICanvas);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Canvas

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Canvas is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory    : access ICanvasFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICanvas;
   begin
      return RetVal : Canvas do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICanvas := new WinUI3.Windows.UI.Xaml.Controls.ICanvas;
            Retval.m_ICanvas.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Canvas

   function get_LeftProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetLeft
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetLeft (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetLeft
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      length : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetLeft (element.m_IUIElement.all, length);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_TopProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetTop
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetTop (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetTop
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      length : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetTop (element.m_IUIElement.all, length);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ZIndexProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetZIndex
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetZIndex (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetZIndex
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Canvas");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICanvasStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_ICanvasStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetZIndex (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Canvas

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CaptureElement

   procedure Initialize (this : in out CaptureElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out CaptureElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICaptureElement, ICaptureElement_Ptr);
   begin
      if this.m_ICaptureElement /= null then
         if this.m_ICaptureElement.all /= null then
            temp := this.m_ICaptureElement.all.Release;
            Free (this.m_ICaptureElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CaptureElement

   function Constructor return CaptureElement is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CaptureElement");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICaptureElement;
   begin
      return RetVal : CaptureElement do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ICaptureElement := new WinUI3.Windows.UI.Xaml.Controls.ICaptureElement;
            Retval.m_ICaptureElement.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CaptureElement

   function get_SourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CaptureElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICaptureElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICaptureElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CaptureElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICaptureElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICaptureElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CaptureElement

   function get_Source
   (
      this : in out CaptureElement
   )
   return WinUI3.Windows.Media.Capture.MediaCapture'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Capture.IMediaCapture;
   begin
      return RetVal : WinUI3.Windows.Media.Capture.MediaCapture do
         Hr := this.m_ICaptureElement.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaCapture := new WinUI3.Windows.Media.Capture.IMediaCapture;
         Retval.m_IMediaCapture.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out CaptureElement;
      value : WinUI3.Windows.Media.Capture.MediaCapture'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICaptureElement.all.put_Source (value.m_IMediaCapture.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out CaptureElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_ICaptureElement.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out CaptureElement;
      value : WinUI3.Windows.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICaptureElement.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CheckBox

   procedure Initialize (this : in out CheckBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out CheckBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICheckBox, ICheckBox_Ptr);
   begin
      if this.m_ICheckBox /= null then
         if this.m_ICheckBox.all /= null then
            temp := this.m_ICheckBox.all.Release;
            Free (this.m_ICheckBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CheckBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CheckBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CheckBox");
      m_Factory    : access ICheckBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICheckBox;
   begin
      return RetVal : CheckBox do
         Hr := RoGetActivationFactory (m_hString, IID_ICheckBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICheckBox := new WinUI3.Windows.UI.Xaml.Controls.ICheckBox;
            Retval.m_ICheckBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CheckBox

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ChoosingGroupHeaderContainerEventArgs

   procedure Initialize (this : in out ChoosingGroupHeaderContainerEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ChoosingGroupHeaderContainerEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IChoosingGroupHeaderContainerEventArgs, IChoosingGroupHeaderContainerEventArgs_Ptr);
   begin
      if this.m_IChoosingGroupHeaderContainerEventArgs /= null then
         if this.m_IChoosingGroupHeaderContainerEventArgs.all /= null then
            temp := this.m_IChoosingGroupHeaderContainerEventArgs.all.Release;
            Free (this.m_IChoosingGroupHeaderContainerEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ChoosingGroupHeaderContainerEventArgs

   function Constructor return ChoosingGroupHeaderContainerEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ChoosingGroupHeaderContainerEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs;
   begin
      return RetVal : ChoosingGroupHeaderContainerEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IChoosingGroupHeaderContainerEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IChoosingGroupHeaderContainerEventArgs;
            Retval.m_IChoosingGroupHeaderContainerEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ChoosingGroupHeaderContainerEventArgs

   function get_GroupHeaderContainer
   (
      this : in out ChoosingGroupHeaderContainerEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ListViewBaseHeaderItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IListViewBaseHeaderItem;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ListViewBaseHeaderItem do
         Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.get_GroupHeaderContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IListViewBaseHeaderItem := new WinUI3.Windows.UI.Xaml.Controls.IListViewBaseHeaderItem;
         Retval.m_IListViewBaseHeaderItem.all := m_ComRetVal;
      end return;
   end;

   procedure put_GroupHeaderContainer
   (
      this : in out ChoosingGroupHeaderContainerEventArgs;
      value : WinUI3.Windows.UI.Xaml.Controls.ListViewBaseHeaderItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.put_GroupHeaderContainer (value.m_IListViewBaseHeaderItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GroupIndex
   (
      this : in out ChoosingGroupHeaderContainerEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.get_GroupIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Group
   (
      this : in out ChoosingGroupHeaderContainerEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IChoosingGroupHeaderContainerEventArgs.all.get_Group (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ChoosingItemContainerEventArgs

   procedure Initialize (this : in out ChoosingItemContainerEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ChoosingItemContainerEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IChoosingItemContainerEventArgs, IChoosingItemContainerEventArgs_Ptr);
   begin
      if this.m_IChoosingItemContainerEventArgs /= null then
         if this.m_IChoosingItemContainerEventArgs.all /= null then
            temp := this.m_IChoosingItemContainerEventArgs.all.Release;
            Free (this.m_IChoosingItemContainerEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ChoosingItemContainerEventArgs

   function Constructor return ChoosingItemContainerEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ChoosingItemContainerEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IChoosingItemContainerEventArgs;
   begin
      return RetVal : ChoosingItemContainerEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IChoosingItemContainerEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IChoosingItemContainerEventArgs;
            Retval.m_IChoosingItemContainerEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ChoosingItemContainerEventArgs

   function get_ItemIndex
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.get_ItemIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ItemContainer
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.SelectorItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.ISelectorItem;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.SelectorItem do
         Hr := this.m_IChoosingItemContainerEventArgs.all.get_ItemContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISelectorItem := new WinUI3.Windows.UI.Xaml.Controls.Primitives.ISelectorItem;
         Retval.m_ISelectorItem.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainer
   (
      this : in out ChoosingItemContainerEventArgs;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.SelectorItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.put_ItemContainer (value.m_ISelectorItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsContainerPrepared
   (
      this : in out ChoosingItemContainerEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.get_IsContainerPrepared (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsContainerPrepared
   (
      this : in out ChoosingItemContainerEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IChoosingItemContainerEventArgs.all.put_IsContainerPrepared (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CleanUpVirtualizedItemEventArgs

   procedure Initialize (this : in out CleanUpVirtualizedItemEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out CleanUpVirtualizedItemEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICleanUpVirtualizedItemEventArgs, ICleanUpVirtualizedItemEventArgs_Ptr);
   begin
      if this.m_ICleanUpVirtualizedItemEventArgs /= null then
         if this.m_ICleanUpVirtualizedItemEventArgs.all /= null then
            temp := this.m_ICleanUpVirtualizedItemEventArgs.all.Release;
            Free (this.m_ICleanUpVirtualizedItemEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CleanUpVirtualizedItemEventArgs

   function get_Value
   (
      this : in out CleanUpVirtualizedItemEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UIElement
   (
      this : in out CleanUpVirtualizedItemEventArgs
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.get_UIElement (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Cancel
   (
      this : in out CleanUpVirtualizedItemEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out CleanUpVirtualizedItemEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ICleanUpVirtualizedItemEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate CleanUpVirtualizedItemEventHandler

   function Invoke
   (
      this : access CleanUpVirtualizedItemEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.ICleanUpVirtualizedItemEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorChangedEventArgs

   procedure Initialize (this : in out ColorChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorChangedEventArgs, IColorChangedEventArgs_Ptr);
   begin
      if this.m_IColorChangedEventArgs /= null then
         if this.m_IColorChangedEventArgs.all /= null then
            temp := this.m_IColorChangedEventArgs.all.Release;
            Free (this.m_IColorChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorChangedEventArgs

   function get_OldColor
   (
      this : in out ColorChangedEventArgs
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorChangedEventArgs.all.get_OldColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewColor
   (
      this : in out ColorChangedEventArgs
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorChangedEventArgs.all.get_NewColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColorPicker

   procedure Initialize (this : in out ColorPicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColorPicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColorPicker, IColorPicker_Ptr);
   begin
      if this.m_IColorPicker /= null then
         if this.m_IColorPicker.all /= null then
            temp := this.m_IColorPicker.all.Release;
            Free (this.m_IColorPicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColorPicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ColorPicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory    : access IColorPickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IColorPicker;
   begin
      return RetVal : ColorPicker do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IColorPicker := new WinUI3.Windows.UI.Xaml.Controls.IColorPicker;
            Retval.m_IColorPicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColorPicker

   function get_ColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreviousColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreviousColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAlphaEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAlphaEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorSpectrumVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorSpectrumVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorPreviewVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorPreviewVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorSliderVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorSliderVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAlphaSliderVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAlphaSliderVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsMoreButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsMoreButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorChannelTextInputVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorChannelTextInputVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAlphaTextInputVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAlphaTextInputVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHexInputVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHexInputVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinHueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinHueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinSaturationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinSaturationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxSaturationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxSaturationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColorSpectrumShapeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorSpectrumShapeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColorSpectrumComponentsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColorPicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColorPickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColorPickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColorSpectrumComponentsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColorPicker

   function get_Color
   (
      this : in out ColorPicker
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
   begin
      Hr := this.m_IColorPicker.all.get_Color (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Color
   (
      this : in out ColorPicker;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_Color (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreviousColor
   (
      this : in out ColorPicker
   )
   return IReference_Color.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Color.Kind;
   begin
      Hr := this.m_IColorPicker.all.get_PreviousColor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Color (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PreviousColor
   (
      this : in out ColorPicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_PreviousColor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAlphaEnabled
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsAlphaEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAlphaEnabled
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsAlphaEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorSpectrumVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorSpectrumVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorSpectrumVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorSpectrumVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorPreviewVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorPreviewVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorPreviewVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorPreviewVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorSliderVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorSliderVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorSliderVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorSliderVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAlphaSliderVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsAlphaSliderVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAlphaSliderVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsAlphaSliderVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsMoreButtonVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsMoreButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsMoreButtonVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsMoreButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorChannelTextInputVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsColorChannelTextInputVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorChannelTextInputVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsColorChannelTextInputVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAlphaTextInputVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsAlphaTextInputVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsAlphaTextInputVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsAlphaTextInputVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHexInputVisible
   (
      this : in out ColorPicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IColorPicker.all.get_IsHexInputVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHexInputVisible
   (
      this : in out ColorPicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_IsHexInputVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinHue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MinHue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinHue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MinHue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MaxHue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MaxHue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinSaturation
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MinSaturation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinSaturation
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MinSaturation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxSaturation
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MaxSaturation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxSaturation
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MaxSaturation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinValue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MinValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinValue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MinValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxValue
   (
      this : in out ColorPicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IColorPicker.all.get_MaxValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxValue
   (
      this : in out ColorPicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_MaxValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColorSpectrumShape
   (
      this : in out ColorPicker
   )
   return WinUI3.Windows.UI.Xaml.Controls.ColorSpectrumShape is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ColorSpectrumShape;
   begin
      Hr := this.m_IColorPicker.all.get_ColorSpectrumShape (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorSpectrumShape
   (
      this : in out ColorPicker;
      value : WinUI3.Windows.UI.Xaml.Controls.ColorSpectrumShape
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_ColorSpectrumShape (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColorSpectrumComponents
   (
      this : in out ColorPicker
   )
   return WinUI3.Windows.UI.Xaml.Controls.ColorSpectrumComponents is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ColorSpectrumComponents;
   begin
      Hr := this.m_IColorPicker.all.get_ColorSpectrumComponents (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColorSpectrumComponents
   (
      this : in out ColorPicker;
      value : WinUI3.Windows.UI.Xaml.Controls.ColorSpectrumComponents
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.put_ColorSpectrumComponents (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ColorChanged
   (
      this : in out ColorPicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IColorPicker.all.add_ColorChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ColorChanged
   (
      this : in out ColorPicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColorPicker.all.remove_ColorChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColumnDefinition

   procedure Initialize (this : in out ColumnDefinition) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColumnDefinition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IColumnDefinition, IColumnDefinition_Ptr);
   begin
      if this.m_IColumnDefinition /= null then
         if this.m_IColumnDefinition.all /= null then
            temp := this.m_IColumnDefinition.all.Release;
            Free (this.m_IColumnDefinition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ColumnDefinition

   function Constructor return ColumnDefinition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColumnDefinition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
   begin
      return RetVal : ColumnDefinition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IColumnDefinition := new WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
            Retval.m_IColumnDefinition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ColumnDefinition

   function get_WidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColumnDefinition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColumnDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColumnDefinition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColumnDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ColumnDefinition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IColumnDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IColumnDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColumnDefinition

   function get_Width
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Windows.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.GridLength;
   begin
      Hr := this.m_IColumnDefinition.all.get_Width (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Width
   (
      this : in out ColumnDefinition;
      value : WinUI3.Windows.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnDefinition.all.put_Width (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxWidth
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnDefinition.all.get_MaxWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxWidth
   (
      this : in out ColumnDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnDefinition.all.put_MaxWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinWidth
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnDefinition.all.get_MinWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWidth
   (
      this : in out ColumnDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IColumnDefinition.all.put_MinWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualWidth
   (
      this : in out ColumnDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IColumnDefinition.all.get_ActualWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ColumnDefinitionCollection

   procedure Initialize (this : in out ColumnDefinitionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out ColumnDefinitionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ColumnDefinitionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Controls.ColumnDefinition>
   function GetAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColumnDefinition := new WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
         Retval.m_IColumnDefinition.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out ColumnDefinitionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ColumnDefinitionCollection
   )
   return WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColumnDefinition := new WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
         Retval.m_IColumnDefinition.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out ColumnDefinitionCollection;
      value : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IColumnDefinition.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IColumnDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IColumnDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out ColumnDefinitionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out ColumnDefinitionCollection;
      value : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IColumnDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out ColumnDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out ColumnDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out ColumnDefinitionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out ColumnDefinitionCollection;
      items : WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1846769780, 56633, 23375, (167, 236, 46, 166, 158, 76, 34, 41 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Controls.ColumnDefinition>
   function First
   (
      this : in out ColumnDefinitionCollection
   )
   return WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IColumnDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
      m_GenericIID     : aliased WinUI3.IID := (2844994035, 16688, 21964, (164, 240, 194, 186, 67, 202, 7, 53 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IColumnDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IColumnDefinition := new WinUI3.Windows.UI.Xaml.Controls.IColumnDefinition;
         Retval.m_IColumnDefinition.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBox

   procedure Initialize (this : in out ComboBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBox, IComboBox_Ptr);
   begin
      if this.m_IComboBox /= null then
         if this.m_IComboBox.all /= null then
            temp := this.m_IComboBox.all.Release;
            Free (this.m_IComboBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ComboBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ComboBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory    : access IComboBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IComboBox;
   begin
      return RetVal : ComboBox do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IComboBox := new WinUI3.Windows.UI.Xaml.Controls.IComboBox;
            Retval.m_IComboBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ComboBox

   function get_IsEditableProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsEditableProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_ComboBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextBoxStyleProperty_ComboBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextBoxStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_ComboBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDropDownOpenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDropDownOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxDropDownHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxDropDownHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionChangedTriggerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionChangedTriggerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_ComboBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextSearchEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextSearchEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_ComboBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ComboBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_ComboBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IComboBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBox

   function get_IsDropDownOpen
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBox.all.get_IsDropDownOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDropDownOpen
   (
      this : in out ComboBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_IsDropDownOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsEditable
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBox.all.get_IsEditable (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSelectionBoxHighlighted
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBox.all.get_IsSelectionBoxHighlighted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxDropDownHeight
   (
      this : in out ComboBox
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IComboBox.all.get_MaxDropDownHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxDropDownHeight
   (
      this : in out ComboBox;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.put_MaxDropDownHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionBoxItem
   (
      this : in out ComboBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IComboBox.all.get_SelectionBoxItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionBoxItemTemplate
   (
      this : in out ComboBox
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IComboBox.all.get_SelectionBoxItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function get_TemplateSettings
   (
      this : in out ComboBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IComboBoxTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings do
         Hr := this.m_IComboBox.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IComboBoxTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IComboBoxTemplateSettings;
         Retval.m_IComboBoxTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_DropDownClosed
   (
      this : in out ComboBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IComboBox.all.add_DropDownClosed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DropDownClosed
   (
      this : in out ComboBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.remove_DropDownClosed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DropDownOpened
   (
      this : in out ComboBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IComboBox.all.add_DropDownOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DropDownOpened
   (
      this : in out ComboBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBox.all.remove_DropDownOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out ComboBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.get_Header (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ComboBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_Header (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ComboBox
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IComboBox.all);
         Hr := m_Interface.get_HeaderTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ComboBox;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_HeaderTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out ComboBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.get_PlaceholderText (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out ComboBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_PlaceholderText (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_LightDismissOverlayMode
   (
      this : in out ComboBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.get_LightDismissOverlayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out ComboBox;
      value : WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_LightDismissOverlayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextSearchEnabled
   (
      this : in out ComboBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.get_IsTextSearchEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextSearchEnabled
   (
      this : in out ComboBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_IsTextSearchEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionChangedTrigger
   (
      this : in out ComboBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.ComboBoxSelectionChangedTrigger is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ComboBoxSelectionChangedTrigger;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.get_SelectionChangedTrigger (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionChangedTrigger
   (
      this : in out ComboBox;
      value : WinUI3.Windows.UI.Xaml.Controls.ComboBoxSelectionChangedTrigger
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_SelectionChangedTrigger (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderForeground
   (
      this : in out ComboBox
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_IComboBox.all);
         Hr := m_Interface.get_PlaceholderForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderForeground
   (
      this : in out ComboBox;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_PlaceholderForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure put_IsEditable
   (
      this : in out ComboBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_IsEditable (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Text
   (
      this : in out ComboBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.get_Text (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out ComboBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_Text (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TextBoxStyle
   (
      this : in out ComboBox
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_IComboBox.all);
         Hr := m_Interface.get_TextBoxStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_TextBoxStyle
   (
      this : in out ComboBox;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_TextBoxStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out ComboBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.get_Description (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out ComboBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.put_Description (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextSubmitted
   (
      this : in out ComboBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.add_TextSubmitted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextSubmitted
   (
      this : in out ComboBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.remove_TextSubmitted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDropDownClosed
   (
      this : in out ComboBox;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBoxOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBoxOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBoxOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.OnDropDownClosed (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnDropDownOpened
   (
      this : in out ComboBox;
      e : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IComboBoxOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IComboBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IComboBoxOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IComboBoxOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IComboBox.all);
      Hr := m_Interface.OnDropDownOpened (e);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBoxItem

   procedure Initialize (this : in out ComboBoxItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBoxItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBoxItem, IComboBoxItem_Ptr);
   begin
      if this.m_IComboBoxItem /= null then
         if this.m_IComboBoxItem.all /= null then
            temp := this.m_IComboBoxItem.all.Release;
            Free (this.m_IComboBoxItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ComboBoxItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ComboBoxItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ComboBoxItem");
      m_Factory    : access IComboBoxItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IComboBoxItem;
   begin
      return RetVal : ComboBoxItem do
         Hr := RoGetActivationFactory (m_hString, IID_IComboBoxItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IComboBoxItem := new WinUI3.Windows.UI.Xaml.Controls.IComboBoxItem;
            Retval.m_IComboBoxItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBoxItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ComboBoxTextSubmittedEventArgs

   procedure Initialize (this : in out ComboBoxTextSubmittedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ComboBoxTextSubmittedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IComboBoxTextSubmittedEventArgs, IComboBoxTextSubmittedEventArgs_Ptr);
   begin
      if this.m_IComboBoxTextSubmittedEventArgs /= null then
         if this.m_IComboBoxTextSubmittedEventArgs.all /= null then
            temp := this.m_IComboBoxTextSubmittedEventArgs.all.Release;
            Free (this.m_IComboBoxTextSubmittedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ComboBoxTextSubmittedEventArgs

   function get_Text
   (
      this : in out ComboBoxTextSubmittedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IComboBoxTextSubmittedEventArgs.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Handled
   (
      this : in out ComboBoxTextSubmittedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IComboBoxTextSubmittedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ComboBoxTextSubmittedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IComboBoxTextSubmittedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBar

   procedure Initialize (this : in out CommandBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBar, ICommandBar_Ptr);
   begin
      if this.m_ICommandBar /= null then
         if this.m_ICommandBar.all /= null then
            temp := this.m_ICommandBar.all.Release;
            Free (this.m_ICommandBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommandBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CommandBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBar");
      m_Factory    : access ICommandBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICommandBar;
   begin
      return RetVal : CommandBar do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICommandBar := new WinUI3.Windows.UI.Xaml.Controls.ICommandBar;
            Retval.m_ICommandBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for CommandBar

   function get_DefaultLabelPositionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICommandBarStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultLabelPositionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowButtonVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICommandBarStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDynamicOverflowEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICommandBarStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDynamicOverflowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandBarOverflowPresenterStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICommandBarStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandBarOverflowPresenterStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryCommandsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryCommandsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryCommandsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ICommandBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryCommandsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBar

   function get_PrimaryCommands
   (
      this : in out CommandBar
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBar.all.get_PrimaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SecondaryCommands
   (
      this : in out CommandBar
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBar.all.get_SecondaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_CommandBarOverflowPresenterStyle
   (
      this : in out CommandBar
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_ICommandBar.all);
         Hr := m_Interface.get_CommandBarOverflowPresenterStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CommandBarOverflowPresenterStyle
   (
      this : in out CommandBar;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.put_CommandBarOverflowPresenterStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandBarTemplateSettings
   (
      this : in out CommandBar
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.ICommandBarTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar2, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings do
         m_Interface := QInterface (this.m_ICommandBar.all);
         Hr := m_Interface.get_CommandBarTemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICommandBarTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.ICommandBarTemplateSettings;
         Retval.m_ICommandBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_DefaultLabelPosition
   (
      this : in out CommandBar
   )
   return WinUI3.Windows.UI.Xaml.Controls.CommandBarDefaultLabelPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CommandBarDefaultLabelPosition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.get_DefaultLabelPosition (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultLabelPosition
   (
      this : in out CommandBar;
      value : WinUI3.Windows.UI.Xaml.Controls.CommandBarDefaultLabelPosition
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.put_DefaultLabelPosition (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverflowButtonVisibility
   (
      this : in out CommandBar
   )
   return WinUI3.Windows.UI.Xaml.Controls.CommandBarOverflowButtonVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CommandBarOverflowButtonVisibility;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.get_OverflowButtonVisibility (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OverflowButtonVisibility
   (
      this : in out CommandBar;
      value : WinUI3.Windows.UI.Xaml.Controls.CommandBarOverflowButtonVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.put_OverflowButtonVisibility (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDynamicOverflowEnabled
   (
      this : in out CommandBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.get_IsDynamicOverflowEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDynamicOverflowEnabled
   (
      this : in out CommandBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.put_IsDynamicOverflowEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DynamicOverflowItemsChanging
   (
      this : in out CommandBar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.add_DynamicOverflowItemsChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DynamicOverflowItemsChanging
   (
      this : in out CommandBar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ICommandBar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ICommandBar_Interface, WinUI3.Windows.UI.Xaml.Controls.ICommandBar3, WinUI3.Windows.UI.Xaml.Controls.IID_ICommandBar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ICommandBar.all);
      Hr := m_Interface.remove_DynamicOverflowItemsChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBarFlyout

   procedure Initialize (this : in out CommandBarFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBarFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBarFlyout, ICommandBarFlyout_Ptr);
   begin
      if this.m_ICommandBarFlyout /= null then
         if this.m_ICommandBarFlyout.all /= null then
            temp := this.m_ICommandBarFlyout.all.Release;
            Free (this.m_ICommandBarFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommandBarFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CommandBarFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBarFlyout");
      m_Factory    : access ICommandBarFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICommandBarFlyout;
   begin
      return RetVal : CommandBarFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICommandBarFlyout := new WinUI3.Windows.UI.Xaml.Controls.ICommandBarFlyout;
            Retval.m_ICommandBarFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBarFlyout

   function get_PrimaryCommands
   (
      this : in out CommandBarFlyout
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBarFlyout.all.get_PrimaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SecondaryCommands
   (
      this : in out CommandBarFlyout
   )
   return IObservableVector_ICommandBarElement.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_ICommandBarElement.Kind;
   begin
      Hr := this.m_ICommandBarFlyout.all.get_SecondaryCommands (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_ICommandBarElement (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for CommandBarOverflowPresenter

   procedure Initialize (this : in out CommandBarOverflowPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out CommandBarOverflowPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ICommandBarOverflowPresenter, ICommandBarOverflowPresenter_Ptr);
   begin
      if this.m_ICommandBarOverflowPresenter /= null then
         if this.m_ICommandBarOverflowPresenter.all /= null then
            temp := this.m_ICommandBarOverflowPresenter.all.Release;
            Free (this.m_ICommandBarOverflowPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for CommandBarOverflowPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return CommandBarOverflowPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.CommandBarOverflowPresenter");
      m_Factory    : access ICommandBarOverflowPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ICommandBarOverflowPresenter;
   begin
      return RetVal : CommandBarOverflowPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_ICommandBarOverflowPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ICommandBarOverflowPresenter := new WinUI3.Windows.UI.Xaml.Controls.ICommandBarOverflowPresenter;
            Retval.m_ICommandBarOverflowPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for CommandBarOverflowPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContainerContentChangingEventArgs

   procedure Initialize (this : in out ContainerContentChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContainerContentChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContainerContentChangingEventArgs, IContainerContentChangingEventArgs_Ptr);
   begin
      if this.m_IContainerContentChangingEventArgs /= null then
         if this.m_IContainerContentChangingEventArgs.all /= null then
            temp := this.m_IContainerContentChangingEventArgs.all.Release;
            Free (this.m_IContainerContentChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContainerContentChangingEventArgs

   function Constructor return ContainerContentChangingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContainerContentChangingEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IContainerContentChangingEventArgs;
   begin
      return RetVal : ContainerContentChangingEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IContainerContentChangingEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IContainerContentChangingEventArgs;
            Retval.m_IContainerContentChangingEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContainerContentChangingEventArgs

   function get_ItemContainer
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.SelectorItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.ISelectorItem;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.SelectorItem do
         Hr := this.m_IContainerContentChangingEventArgs.all.get_ItemContainer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISelectorItem := new WinUI3.Windows.UI.Xaml.Controls.Primitives.ISelectorItem;
         Retval.m_ISelectorItem.all := m_ComRetVal;
      end return;
   end;

   function get_InRecycleQueue
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_InRecycleQueue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ItemIndex
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_ItemIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Item
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Phase
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_Phase (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Handled
   (
      this : in out ContainerContentChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ContainerContentChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out ContainerContentChangingEventArgs;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.RegisterUpdateCallback (callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RegisterUpdateCallback
   (
      this : in out ContainerContentChangingEventArgs;
      callbackPhase : WinUI3.UInt32;
      callback : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContainerContentChangingEventArgs.all.RegisterUpdateCallback (callbackPhase, callback);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialog

   procedure Initialize (this : in out ContentDialog) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialog) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialog, IContentDialog_Ptr);
   begin
      if this.m_IContentDialog /= null then
         if this.m_IContentDialog.all /= null then
            temp := this.m_IContentDialog.all.Release;
            Free (this.m_IContentDialog);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContentDialog

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ContentDialog is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory    : access IContentDialogFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IContentDialog;
   begin
      return RetVal : ContentDialog do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IContentDialog := new WinUI3.Windows.UI.Xaml.Controls.IContentDialog;
            Retval.m_IContentDialog.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContentDialog

   function get_TitleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TitleTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FullSizeDesiredProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FullSizeDesiredProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonCommandProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonCommandProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonCommandParameterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonCommandParameterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPrimaryButtonEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPrimaryButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSecondaryButtonEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSecondaryButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonCommandParameterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonCommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PrimaryButtonStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryButtonStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CloseButtonStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CloseButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultButtonProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentDialog");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentDialogStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentDialogStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultButtonProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialog

   function get_Title
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentDialog.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Title
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_Title (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TitleTemplate
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IContentDialog.all.get_TitleTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_TitleTemplate
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_TitleTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FullSizeDesired
   (
      this : in out ContentDialog
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialog.all.get_FullSizeDesired (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FullSizeDesired
   (
      this : in out ContentDialog;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_FullSizeDesired (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PrimaryButtonText
   (
      this : in out ContentDialog
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IContentDialog.all.get_PrimaryButtonText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PrimaryButtonText
   (
      this : in out ContentDialog;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IContentDialog.all.put_PrimaryButtonText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SecondaryButtonText
   (
      this : in out ContentDialog
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IContentDialog.all.get_SecondaryButtonText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SecondaryButtonText
   (
      this : in out ContentDialog;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IContentDialog.all.put_SecondaryButtonText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PrimaryButtonCommand
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IContentDialog.all.get_PrimaryButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PrimaryButtonCommand
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_PrimaryButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SecondaryButtonCommand
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IContentDialog.all.get_SecondaryButtonCommand (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SecondaryButtonCommand
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_SecondaryButtonCommand (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PrimaryButtonCommandParameter
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentDialog.all.get_PrimaryButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PrimaryButtonCommandParameter
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_PrimaryButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SecondaryButtonCommandParameter
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentDialog.all.get_SecondaryButtonCommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SecondaryButtonCommandParameter
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_SecondaryButtonCommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPrimaryButtonEnabled
   (
      this : in out ContentDialog
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialog.all.get_IsPrimaryButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPrimaryButtonEnabled
   (
      this : in out ContentDialog;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_IsPrimaryButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSecondaryButtonEnabled
   (
      this : in out ContentDialog
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialog.all.get_IsSecondaryButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSecondaryButtonEnabled
   (
      this : in out ContentDialog;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.put_IsSecondaryButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closing
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_Closing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closing
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_Closing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PrimaryButtonClick
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_PrimaryButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PrimaryButtonClick
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_PrimaryButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SecondaryButtonClick
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IContentDialog.all.add_SecondaryButtonClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SecondaryButtonClick
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.remove_SecondaryButtonClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Hide
   (
      this : in out ContentDialog
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialog.all.Hide;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAsync
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_ContentDialogResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ContentDialogResult.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult;
      m_IID            : aliased WinUI3.IID := (522436049, 1756, 23529, (154, 96, 11, 77, 148, 212, 215, 44 )); -- Windows.UI.Xaml.Controls.ContentDialogResult;
      m_HandlerIID     : aliased WinUI3.IID := (1170711302, 58160, 21718, (169, 186, 97, 201, 31, 147, 245, 59 ));
      m_Handler        : AsyncOperationCompletedHandler_ContentDialogResult.Kind := new AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ContentDialogResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ContentDialogResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate, AsyncOperationCompletedHandler_ContentDialogResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IContentDialog.all.ShowAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_CloseButtonText
   (
      this : in out ContentDialog
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.get_CloseButtonText (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CloseButtonText
   (
      this : in out ContentDialog;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.put_CloseButtonText (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_CloseButtonCommand
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.ICommand;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.get_CloseButtonCommand (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommand
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.put_CloseButtonCommand (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonCommandParameter
   (
      this : in out ContentDialog
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.get_CloseButtonCommandParameter (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CloseButtonCommandParameter
   (
      this : in out ContentDialog;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.put_CloseButtonCommandParameter (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PrimaryButtonStyle
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_IContentDialog.all);
         Hr := m_Interface.get_PrimaryButtonStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_PrimaryButtonStyle
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.put_PrimaryButtonStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SecondaryButtonStyle
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_IContentDialog.all);
         Hr := m_Interface.get_SecondaryButtonStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_SecondaryButtonStyle
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.put_SecondaryButtonStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CloseButtonStyle
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_IContentDialog.all);
         Hr := m_Interface.get_CloseButtonStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_CloseButtonStyle
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.put_CloseButtonStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultButton
   (
      this : in out ContentDialog
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentDialogButton is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ContentDialogButton;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.get_DefaultButton (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultButton
   (
      this : in out ContentDialog;
      value : WinUI3.Windows.UI.Xaml.Controls.ContentDialogButton
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.put_DefaultButton (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CloseButtonClick
   (
      this : in out ContentDialog;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.add_CloseButtonClick (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CloseButtonClick
   (
      this : in out ContentDialog;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.remove_CloseButtonClick (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAsync
   (
      this : in out ContentDialog;
      placement : WinUI3.Windows.UI.Xaml.Controls.ContentDialogPlacement
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentDialog3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_ContentDialogResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_ContentDialogResult.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult;
      m_IID            : aliased WinUI3.IID := (522436049, 1756, 23529, (154, 96, 11, 77, 148, 212, 215, 44 )); -- Windows.UI.Xaml.Controls.ContentDialogResult;
      m_HandlerIID     : aliased WinUI3.IID := (1170711302, 58160, 21718, (169, 186, 97, 201, 31, 147, 245, 59 ));
      m_Handler        : AsyncOperationCompletedHandler_ContentDialogResult.Kind := new AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_ContentDialogResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_ContentDialogResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_ContentDialogResult.Kind_Delegate, AsyncOperationCompletedHandler_ContentDialogResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentDialog_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentDialog3, WinUI3.Windows.UI.Xaml.Controls.IID_IContentDialog3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentDialog.all);
      Hr := m_Interface.ShowAsync (placement, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogButtonClickDeferral

   procedure Initialize (this : in out ContentDialogButtonClickDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogButtonClickDeferral) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogButtonClickDeferral, IContentDialogButtonClickDeferral_Ptr);
   begin
      if this.m_IContentDialogButtonClickDeferral /= null then
         if this.m_IContentDialogButtonClickDeferral.all /= null then
            temp := this.m_IContentDialogButtonClickDeferral.all.Release;
            Free (this.m_IContentDialogButtonClickDeferral);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogButtonClickDeferral

   procedure Complete
   (
      this : in out ContentDialogButtonClickDeferral
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogButtonClickDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogButtonClickEventArgs

   procedure Initialize (this : in out ContentDialogButtonClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogButtonClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogButtonClickEventArgs, IContentDialogButtonClickEventArgs_Ptr);
   begin
      if this.m_IContentDialogButtonClickEventArgs /= null then
         if this.m_IContentDialogButtonClickEventArgs.all /= null then
            temp := this.m_IContentDialogButtonClickEventArgs.all.Release;
            Free (this.m_IContentDialogButtonClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogButtonClickEventArgs

   function get_Cancel
   (
      this : in out ContentDialogButtonClickEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialogButtonClickEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out ContentDialogButtonClickEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogButtonClickEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out ContentDialogButtonClickEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentDialogButtonClickDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IContentDialogButtonClickDeferral;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ContentDialogButtonClickDeferral do
         Hr := this.m_IContentDialogButtonClickEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContentDialogButtonClickDeferral := new WinUI3.Windows.UI.Xaml.Controls.IContentDialogButtonClickDeferral;
         Retval.m_IContentDialogButtonClickDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogClosedEventArgs

   procedure Initialize (this : in out ContentDialogClosedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogClosedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogClosedEventArgs, IContentDialogClosedEventArgs_Ptr);
   begin
      if this.m_IContentDialogClosedEventArgs /= null then
         if this.m_IContentDialogClosedEventArgs.all /= null then
            temp := this.m_IContentDialogClosedEventArgs.all.Release;
            Free (this.m_IContentDialogClosedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogClosedEventArgs

   function get_Result
   (
      this : in out ContentDialogClosedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult;
   begin
      Hr := this.m_IContentDialogClosedEventArgs.all.get_Result (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogClosingDeferral

   procedure Initialize (this : in out ContentDialogClosingDeferral) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogClosingDeferral) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogClosingDeferral, IContentDialogClosingDeferral_Ptr);
   begin
      if this.m_IContentDialogClosingDeferral /= null then
         if this.m_IContentDialogClosingDeferral.all /= null then
            temp := this.m_IContentDialogClosingDeferral.all.Release;
            Free (this.m_IContentDialogClosingDeferral);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogClosingDeferral

   procedure Complete
   (
      this : in out ContentDialogClosingDeferral
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogClosingDeferral.all.Complete;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogClosingEventArgs

   procedure Initialize (this : in out ContentDialogClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogClosingEventArgs, IContentDialogClosingEventArgs_Ptr);
   begin
      if this.m_IContentDialogClosingEventArgs /= null then
         if this.m_IContentDialogClosingEventArgs.all /= null then
            temp := this.m_IContentDialogClosingEventArgs.all.Release;
            Free (this.m_IContentDialogClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogClosingEventArgs

   function get_Result
   (
      this : in out ContentDialogClosingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ContentDialogResult;
   begin
      Hr := this.m_IContentDialogClosingEventArgs.all.get_Result (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out ContentDialogClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContentDialogClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out ContentDialogClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentDialogClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out ContentDialogClosingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentDialogClosingDeferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IContentDialogClosingDeferral;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ContentDialogClosingDeferral do
         Hr := this.m_IContentDialogClosingEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContentDialogClosingDeferral := new WinUI3.Windows.UI.Xaml.Controls.IContentDialogClosingDeferral;
         Retval.m_IContentDialogClosingDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentDialogOpenedEventArgs

   procedure Initialize (this : in out ContentDialogOpenedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentDialogOpenedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentDialogOpenedEventArgs, IContentDialogOpenedEventArgs_Ptr);
   begin
      if this.m_IContentDialogOpenedEventArgs /= null then
         if this.m_IContentDialogOpenedEventArgs.all /= null then
            temp := this.m_IContentDialogOpenedEventArgs.all.Release;
            Free (this.m_IContentDialogOpenedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentDialogOpenedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentLinkChangedEventArgs

   procedure Initialize (this : in out ContentLinkChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentLinkChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentLinkChangedEventArgs, IContentLinkChangedEventArgs_Ptr);
   begin
      if this.m_IContentLinkChangedEventArgs /= null then
         if this.m_IContentLinkChangedEventArgs.all /= null then
            temp := this.m_IContentLinkChangedEventArgs.all.Release;
            Free (this.m_IContentLinkChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentLinkChangedEventArgs

   function get_ChangeKind
   (
      this : in out ContentLinkChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ContentLinkChangeKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ContentLinkChangeKind;
   begin
      Hr := this.m_IContentLinkChangedEventArgs.all.get_ChangeKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContentLinkInfo
   (
      this : in out ContentLinkChangedEventArgs
   )
   return WinUI3.Windows.UI.Text.ContentLinkInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.IContentLinkInfo;
   begin
      return RetVal : WinUI3.Windows.UI.Text.ContentLinkInfo do
         Hr := this.m_IContentLinkChangedEventArgs.all.get_ContentLinkInfo (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContentLinkInfo := new WinUI3.Windows.UI.Text.IContentLinkInfo;
         Retval.m_IContentLinkInfo.all := m_ComRetVal;
      end return;
   end;

   function get_TextRange
   (
      this : in out ContentLinkChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextRange is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.TextRange;
   begin
      Hr := this.m_IContentLinkChangedEventArgs.all.get_TextRange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContentPresenter

   procedure Initialize (this : in out ContentPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContentPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContentPresenter, IContentPresenter_Ptr);
   begin
      if this.m_IContentPresenter /= null then
         if this.m_IContentPresenter.all /= null then
            temp := this.m_IContentPresenter.all.Release;
            Free (this.m_IContentPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ContentPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ContentPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory    : access IContentPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IContentPresenter;
   begin
      return RetVal : ContentPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IContentPresenter := new WinUI3.Windows.UI.Xaml.Controls.IContentPresenter;
            Retval.m_IContentPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ContentPresenter

   function get_BackgroundSizingProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLinesProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineStackingStrategyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineStackingStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderBrushProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalContentAlignmentProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalContentAlignmentProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalContentAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateSelectorProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTransitionsProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_ContentPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpticalMarginAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpticalMarginAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextLineBoundsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IContentPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IContentPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextLineBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContentPresenter

   function get_Content
   (
      this : in out ContentPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IContentPresenter.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out ContentPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplate
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IContentPresenter.all.get_ContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplate
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_ContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplateSelector
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IContentPresenter.all.get_ContentTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplateSelector
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_ContentTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTransitions
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IContentPresenter.all.get_ContentTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTransitions
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_ContentTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontSize
   (
      this : in out ContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContentPresenter.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out ContentPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_IContentPresenter.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IContentPresenter.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IContentPresenter.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_IContentPresenter.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out ContentPresenter
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IContentPresenter.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out ContentPresenter;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IContentPresenter.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContentPresenter.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpticalMarginAlignment
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.OpticalMarginAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.OpticalMarginAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_OpticalMarginAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpticalMarginAlignment
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.OpticalMarginAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_OpticalMarginAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextLineBounds
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.TextLineBounds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextLineBounds;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_TextLineBounds (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextLineBounds
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.TextLineBounds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_TextLineBounds (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out ContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter3, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out ContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter3, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_IsTextScaleFactorEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextWrapping;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_TextWrapping (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_TextWrapping (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLines
   (
      this : in out ContentPresenter
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_MaxLines (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out ContentPresenter;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_MaxLines (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineStackingStrategy
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.LineStackingStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.LineStackingStrategy;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_LineStackingStrategy (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineStackingStrategy
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.LineStackingStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_LineStackingStrategy (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineHeight
   (
      this : in out ContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_LineHeight (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineHeight
   (
      this : in out ContentPresenter;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_LineHeight (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_IContentPresenter.all);
         Hr := m_Interface.get_BorderBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_BorderBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_BorderThickness (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_BorderThickness (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_CornerRadius (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_CornerRadius (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_Padding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_Padding (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_IContentPresenter.all);
         Hr := m_Interface.get_Background (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_Background (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalContentAlignment
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.HorizontalAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_HorizontalContentAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalContentAlignment
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_HorizontalContentAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalContentAlignment
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.VerticalAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_VerticalContentAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalContentAlignment
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter4, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_VerticalContentAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundTransition
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.BrushTransition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IBrushTransition;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.BrushTransition do
         m_Interface := QInterface (this.m_IContentPresenter.all);
         Hr := m_Interface.get_BackgroundTransition (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrushTransition := new WinUI3.Windows.UI.Xaml.IBrushTransition;
         Retval.m_IBrushTransition.all := m_ComRetVal;
      end return;
   end;

   procedure put_BackgroundTransition
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.BrushTransition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_BackgroundTransition (value.m_IBrushTransition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out ContentPresenter
   )
   return WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.get_BackgroundSizing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out ContentPresenter;
      value : WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenter5, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenter5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.put_BackgroundSizing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateChanged
   (
      this : in out ContentPresenter;
      oldContentTemplate : WinUI3.Windows.UI.Xaml.DataTemplate'Class;
      newContentTemplate : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenterOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenterOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenterOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.OnContentTemplateChanged (oldContentTemplate.m_IDataTemplate.all, newContentTemplate.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnContentTemplateSelectorChanged
   (
      this : in out ContentPresenter;
      oldContentTemplateSelector : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class;
      newContentTemplateSelector : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IContentPresenterOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IContentPresenterOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IContentPresenterOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IContentPresenter.all);
      Hr := m_Interface.OnContentTemplateSelectorChanged (oldContentTemplateSelector.m_IDataTemplateSelector.all, newContentTemplateSelector.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ContextMenuEventArgs

   procedure Initialize (this : in out ContextMenuEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ContextMenuEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IContextMenuEventArgs, IContextMenuEventArgs_Ptr);
   begin
      if this.m_IContextMenuEventArgs /= null then
         if this.m_IContextMenuEventArgs.all /= null then
            temp := this.m_IContextMenuEventArgs.all.Release;
            Free (this.m_IContextMenuEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ContextMenuEventArgs

   function get_Handled
   (
      this : in out ContextMenuEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IContextMenuEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out ContextMenuEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IContextMenuEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CursorLeft
   (
      this : in out ContextMenuEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContextMenuEventArgs.all.get_CursorLeft (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CursorTop
   (
      this : in out ContextMenuEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IContextMenuEventArgs.all.get_CursorTop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ContextMenuOpeningEventHandler

   function Invoke
   (
      this : access ContextMenuOpeningEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.IContextMenuEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ControlTemplate

   procedure Initialize (this : in out ControlTemplate) is
   begin
      null;
   end;

   procedure Finalize (this : in out ControlTemplate) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IControlTemplate, IControlTemplate_Ptr);
   begin
      if this.m_IControlTemplate /= null then
         if this.m_IControlTemplate.all /= null then
            temp := this.m_IControlTemplate.all.Release;
            Free (this.m_IControlTemplate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ControlTemplate

   function Constructor return ControlTemplate is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ControlTemplate");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IControlTemplate;
   begin
      return RetVal : ControlTemplate do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IControlTemplate := new WinUI3.Windows.UI.Xaml.Controls.IControlTemplate;
            Retval.m_IControlTemplate.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ControlTemplate

   function get_TargetType
   (
      this : in out ControlTemplate
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
   begin
      Hr := this.m_IControlTemplate.all.get_TargetType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TargetType
   (
      this : in out ControlTemplate;
      value : WinUI3.Windows.UI.Xaml.Interop.TypeName
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IControlTemplate.all.put_TargetType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DataTemplateSelector

   procedure Initialize (this : in out DataTemplateSelector) is
   begin
      null;
   end;

   procedure Finalize (this : in out DataTemplateSelector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDataTemplateSelector, IDataTemplateSelector_Ptr);
   begin
      if this.m_IDataTemplateSelector /= null then
         if this.m_IDataTemplateSelector.all /= null then
            temp := this.m_IDataTemplateSelector.all.Release;
            Free (this.m_IDataTemplateSelector);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DataTemplateSelector

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DataTemplateSelector is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DataTemplateSelector");
      m_Factory    : access IDataTemplateSelectorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : DataTemplateSelector do
         Hr := RoGetActivationFactory (m_hString, IID_IDataTemplateSelectorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDataTemplateSelector := new WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
            Retval.m_IDataTemplateSelector.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DataTemplateSelector

   function SelectTemplate
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IDataTemplateSelector.all.SelectTemplate (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function SelectTemplate
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector2, WinUI3.Windows.UI.Xaml.Controls.IID_IDataTemplateSelector2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IDataTemplateSelector.all);
         Hr := m_Interface.SelectTemplate (item, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function SelectTemplateCore
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IDataTemplateSelectorOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IDataTemplateSelector.all);
         Hr := m_Interface.SelectTemplateCore (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function SelectTemplateCore
   (
      this : in out DataTemplateSelector;
      item : WinUI3.IInspectable
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides2, WinUI3.Windows.UI.Xaml.Controls.IID_IDataTemplateSelectorOverrides2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IDataTemplateSelector.all);
         Hr := m_Interface.SelectTemplateCore (item, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   function GetElement
   (
      this : in out DataTemplateSelector;
      args : WinUI3.Windows.UI.Xaml.ElementFactoryGetArgs'Class
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IElementFactory := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Windows.UI.Xaml.IElementFactory, WinUI3.Windows.UI.Xaml.IID_IElementFactory'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IDataTemplateSelector.all);
         Hr := m_Interface.GetElement (args.m_IElementFactoryGetArgs.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RecycleElement
   (
      this : in out DataTemplateSelector;
      args : WinUI3.Windows.UI.Xaml.ElementFactoryRecycleArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.IElementFactory := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector_Interface, WinUI3.Windows.UI.Xaml.IElementFactory, WinUI3.Windows.UI.Xaml.IID_IElementFactory'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDataTemplateSelector.all);
      Hr := m_Interface.RecycleElement (args.m_IElementFactoryRecycleArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickedEventArgs

   procedure Initialize (this : in out DatePickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickedEventArgs, IDatePickedEventArgs_Ptr);
   begin
      if this.m_IDatePickedEventArgs /= null then
         if this.m_IDatePickedEventArgs.all /= null then
            temp := this.m_IDatePickedEventArgs.all.Release;
            Free (this.m_IDatePickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DatePickedEventArgs

   function Constructor return DatePickedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDatePickedEventArgs;
   begin
      return RetVal : DatePickedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDatePickedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IDatePickedEventArgs;
            Retval.m_IDatePickedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickedEventArgs

   function get_OldDate
   (
      this : in out DatePickedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewDate
   (
      this : in out DatePickedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePicker

   procedure Initialize (this : in out DatePicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePicker, IDatePicker_Ptr);
   begin
      if this.m_IDatePicker /= null then
         if this.m_IDatePicker.all /= null then
            temp := this.m_IDatePicker.all.Release;
            Free (this.m_IDatePicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DatePicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DatePicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory    : access IDatePickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDatePicker;
   begin
      return RetVal : DatePicker do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDatePicker := new WinUI3.Windows.UI.Xaml.Controls.IDatePicker;
            Retval.m_IDatePicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePicker

   function get_LightDismissOverlayModeProperty_DatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_DatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_DatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CalendarIdentifierProperty_DatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateProperty_DatePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayFormatProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthFormatProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearFormatProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinYearProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxYearProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedDateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedDateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePicker

   function get_Header
   (
      this : in out DatePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IDatePicker.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out DatePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IDatePicker.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out DatePicker;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CalendarIdentifier
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Date
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePicker.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Date
   (
      this : in out DatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_Date (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayVisible
   (
      this : in out DatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePicker.all.get_DayVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayVisible
   (
      this : in out DatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_DayVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthVisible
   (
      this : in out DatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePicker.all.get_MonthVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthVisible
   (
      this : in out DatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_MonthVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_YearVisible
   (
      this : in out DatePicker
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePicker.all.get_YearVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_YearVisible
   (
      this : in out DatePicker;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_YearVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayFormat
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_DayFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayFormat
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_DayFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MonthFormat
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_MonthFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MonthFormat
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_MonthFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_YearFormat
   (
      this : in out DatePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePicker.all.get_YearFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_YearFormat
   (
      this : in out DatePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePicker.all.put_YearFormat (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MinYear
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePicker.all.get_MinYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinYear
   (
      this : in out DatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_MinYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxYear
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePicker.all.get_MaxYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxYear
   (
      this : in out DatePicker;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_MaxYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IDatePicker.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out DatePicker;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DateChanged
   (
      this : in out DatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDatePicker.all.add_DateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DateChanged
   (
      this : in out DatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePicker.all.remove_DateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out DatePicker
   )
   return WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePicker2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePicker.all);
      Hr := m_Interface.get_LightDismissOverlayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out DatePicker;
      value : WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePicker2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePicker.all);
      Hr := m_Interface.put_LightDismissOverlayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedDate
   (
      this : in out DatePicker
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePicker.all);
      Hr := m_Interface.get_SelectedDate (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_SelectedDate
   (
      this : in out DatePicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePicker.all);
      Hr := m_Interface.put_SelectedDate (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectedDateChanged
   (
      this : in out DatePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePicker.all);
      Hr := m_Interface.add_SelectedDateChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectedDateChanged
   (
      this : in out DatePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePicker.all);
      Hr := m_Interface.remove_SelectedDateChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerFlyout

   procedure Initialize (this : in out DatePickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerFlyout, IDatePickerFlyout_Ptr);
   begin
      if this.m_IDatePickerFlyout /= null then
         if this.m_IDatePickerFlyout.all /= null then
            temp := this.m_IDatePickerFlyout.all.Release;
            Free (this.m_IDatePickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DatePickerFlyout

   function Constructor return DatePickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout;
   begin
      return RetVal : DatePickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDatePickerFlyout := new WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout;
            Retval.m_IDatePickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePickerFlyout

   function get_CalendarIdentifierProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CalendarIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DateProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayVisibleProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthVisibleProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearVisibleProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinYearProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxYearProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxYearProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DayFormatProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DayFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MonthFormatProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MonthFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_YearFormatProperty_DatePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_YearFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerFlyout

   function get_CalendarIdentifier
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_CalendarIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CalendarIdentifier
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyout.all.put_CalendarIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Date
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_Date (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Date
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_Date (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DayVisible
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_DayVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DayVisible
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_DayVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MonthVisible
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_MonthVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MonthVisible
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_MonthVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_YearVisible
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_YearVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_YearVisible
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_YearVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinYear
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_MinYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinYear
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_MinYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxYear
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerFlyout.all.get_MaxYear (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxYear
   (
      this : in out DatePickerFlyout;
      value : WinUI3.Windows.Foundation.DateTime
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.put_MaxYear (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DatePicked
   (
      this : in out DatePickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IDatePickerFlyout.all.add_DatePicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DatePicked
   (
      this : in out DatePickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDatePickerFlyout.all.remove_DatePicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out DatePickerFlyout;
      target : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (539341647, 16916, 22187, (171, 254, 47, 190, 101, 149, 218, 157 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (3290586462, 7036, 22302, (155, 136, 42, 178, 238, 250, 140, 143 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IDatePickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_DayFormat
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyout.all);
      Hr := m_Interface.get_DayFormat (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DayFormat
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyout.all);
      Hr := m_Interface.put_DayFormat (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MonthFormat
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyout.all);
      Hr := m_Interface.get_MonthFormat (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_MonthFormat
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyout.all);
      Hr := m_Interface.put_MonthFormat (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_YearFormat
   (
      this : in out DatePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyout.all);
      Hr := m_Interface.get_YearFormat (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_YearFormat
   (
      this : in out DatePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyout2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyout.all);
      Hr := m_Interface.put_YearFormat (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerFlyoutItem

   procedure Initialize (this : in out DatePickerFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerFlyoutItem, IDatePickerFlyoutItem_Ptr);
   begin
      if this.m_IDatePickerFlyoutItem /= null then
         if this.m_IDatePickerFlyoutItem.all /= null then
            temp := this.m_IDatePickerFlyoutItem.all.Release;
            Free (this.m_IDatePickerFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePickerFlyoutItem

   function get_PrimaryTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PrimaryTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SecondaryTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SecondaryTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerFlyoutItem

   function get_PrimaryText
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.get_PrimaryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PrimaryText
   (
      this : in out DatePickerFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.put_PrimaryText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SecondaryText
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.get_SecondaryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SecondaryText
   (
      this : in out DatePickerFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IDatePickerFlyoutItem.all.put_SecondaryText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function GetCustomProperty
   (
      this : in out DatePickerFlyoutItem;
      name : WinUI3.WString
   )
   return WinUI3.Windows.UI.Xaml.Data.ICustomProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.ICustomProperty;
      HStr_name : constant WinUI3.HString := To_HString (name);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Windows.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.GetCustomProperty (HStr_name, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_name);
      return m_ComRetVal;
   end;

   function GetIndexedProperty
   (
      this : in out DatePickerFlyoutItem;
      name : WinUI3.WString;
      type_x : WinUI3.Windows.UI.Xaml.Interop.TypeName
   )
   return WinUI3.Windows.UI.Xaml.Data.ICustomProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.ICustomProperty;
      HStr_name : constant WinUI3.HString := To_HString (name);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Windows.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.GetIndexedProperty (HStr_name, type_x, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_name);
      return m_ComRetVal;
   end;

   function GetStringRepresentation
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Windows.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.GetStringRepresentation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Type
   (
      this : in out DatePickerFlyoutItem
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Data.ICustomPropertyProvider, WinUI3.Windows.UI.Xaml.Data.IID_ICustomPropertyProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutItem.all);
      Hr := m_Interface.get_Type (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerFlyoutPresenter

   procedure Initialize (this : in out DatePickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerFlyoutPresenter, IDatePickerFlyoutPresenter_Ptr);
   begin
      if this.m_IDatePickerFlyoutPresenter /= null then
         if this.m_IDatePickerFlyoutPresenter.all /= null then
            temp := this.m_IDatePickerFlyoutPresenter.all.Release;
            Free (this.m_IDatePickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for DatePickerFlyoutPresenter

   function get_IsDefaultShadowEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DatePickerFlyoutPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IDatePickerFlyoutPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerFlyoutPresenter

   function get_IsDefaultShadowEnabled
   (
      this : in out DatePickerFlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyoutPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutPresenter.all);
      Hr := m_Interface.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out DatePickerFlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IDatePickerFlyoutPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IDatePickerFlyoutPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDatePickerFlyoutPresenter.all);
      Hr := m_Interface.put_IsDefaultShadowEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerSelectedValueChangedEventArgs

   procedure Initialize (this : in out DatePickerSelectedValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerSelectedValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerSelectedValueChangedEventArgs, IDatePickerSelectedValueChangedEventArgs_Ptr);
   begin
      if this.m_IDatePickerSelectedValueChangedEventArgs /= null then
         if this.m_IDatePickerSelectedValueChangedEventArgs.all /= null then
            temp := this.m_IDatePickerSelectedValueChangedEventArgs.all.Release;
            Free (this.m_IDatePickerSelectedValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerSelectedValueChangedEventArgs

   function get_OldDate
   (
      this : in out DatePickerSelectedValueChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_IDatePickerSelectedValueChangedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_NewDate
   (
      this : in out DatePickerSelectedValueChangedEventArgs
   )
   return IReference_DateTime.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_DateTime.Kind;
   begin
      Hr := this.m_IDatePickerSelectedValueChangedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_DateTime (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DatePickerValueChangedEventArgs

   procedure Initialize (this : in out DatePickerValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DatePickerValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDatePickerValueChangedEventArgs, IDatePickerValueChangedEventArgs_Ptr);
   begin
      if this.m_IDatePickerValueChangedEventArgs /= null then
         if this.m_IDatePickerValueChangedEventArgs.all /= null then
            temp := this.m_IDatePickerValueChangedEventArgs.all.Release;
            Free (this.m_IDatePickerValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DatePickerValueChangedEventArgs

   function get_OldDate
   (
      this : in out DatePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerValueChangedEventArgs.all.get_OldDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewDate
   (
      this : in out DatePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.DateTime is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.DateTime;
   begin
      Hr := this.m_IDatePickerValueChangedEventArgs.all.get_NewDate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragItemsCompletedEventArgs

   procedure Initialize (this : in out DragItemsCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragItemsCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragItemsCompletedEventArgs, IDragItemsCompletedEventArgs_Ptr);
   begin
      if this.m_IDragItemsCompletedEventArgs /= null then
         if this.m_IDragItemsCompletedEventArgs.all /= null then
            temp := this.m_IDragItemsCompletedEventArgs.all.Release;
            Free (this.m_IDragItemsCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragItemsCompletedEventArgs

   function get_Items
   (
      this : in out DragItemsCompletedEventArgs
   )
   return IVectorView_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IInspectable.Kind;
   begin
      Hr := this.m_IDragItemsCompletedEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_DropResult
   (
      this : in out DragItemsCompletedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
   begin
      Hr := this.m_IDragItemsCompletedEventArgs.all.get_DropResult (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DragItemsStartingEventArgs

   procedure Initialize (this : in out DragItemsStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DragItemsStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDragItemsStartingEventArgs, IDragItemsStartingEventArgs_Ptr);
   begin
      if this.m_IDragItemsStartingEventArgs /= null then
         if this.m_IDragItemsStartingEventArgs.all /= null then
            temp := this.m_IDragItemsStartingEventArgs.all.Release;
            Free (this.m_IDragItemsStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DragItemsStartingEventArgs

   function Constructor return DragItemsStartingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DragItemsStartingEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs;
   begin
      return RetVal : DragItemsStartingEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDragItemsStartingEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs;
            Retval.m_IDragItemsStartingEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DragItemsStartingEventArgs

   function get_Cancel
   (
      this : in out DragItemsStartingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IDragItemsStartingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out DragItemsStartingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IDragItemsStartingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Items
   (
      this : in out DragItemsStartingEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IDragItemsStartingEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Data
   (
      this : in out DragItemsStartingEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_IDragItemsStartingEventArgs.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate DragItemsStartingEventHandler

   function Invoke
   (
      this : access DragItemsStartingEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DropDownButton

   procedure Initialize (this : in out DropDownButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out DropDownButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDropDownButton, IDropDownButton_Ptr);
   begin
      if this.m_IDropDownButton /= null then
         if this.m_IDropDownButton.all /= null then
            temp := this.m_IDropDownButton.all.Release;
            Free (this.m_IDropDownButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DropDownButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DropDownButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DropDownButton");
      m_Factory    : access IDropDownButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDropDownButton;
   begin
      return RetVal : DropDownButton do
         Hr := RoGetActivationFactory (m_hString, IID_IDropDownButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDropDownButton := new WinUI3.Windows.UI.Xaml.Controls.IDropDownButton;
            Retval.m_IDropDownButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DropDownButton

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DropDownButtonAutomationPeer

   procedure Initialize (this : in out DropDownButtonAutomationPeer) is
   begin
      null;
   end;

   procedure Finalize (this : in out DropDownButtonAutomationPeer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDropDownButtonAutomationPeer, IDropDownButtonAutomationPeer_Ptr);
   begin
      if this.m_IDropDownButtonAutomationPeer /= null then
         if this.m_IDropDownButtonAutomationPeer.all /= null then
            temp := this.m_IDropDownButtonAutomationPeer.all.Release;
            Free (this.m_IDropDownButtonAutomationPeer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DropDownButtonAutomationPeer

   function Constructor
   (
      owner : WinUI3.Windows.UI.Xaml.Controls.DropDownButton'Class;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return DropDownButtonAutomationPeer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DropDownButtonAutomationPeer");
      m_Factory    : access IDropDownButtonAutomationPeerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer;
   begin
      return RetVal : DropDownButtonAutomationPeer do
         Hr := RoGetActivationFactory (m_hString, IID_IDropDownButtonAutomationPeerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (owner.m_IDropDownButton.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IDropDownButtonAutomationPeer := new WinUI3.Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer;
            Retval.m_IDropDownButtonAutomationPeer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DropDownButtonAutomationPeer

   function get_ExpandCollapseState
   (
      this : in out DropDownButtonAutomationPeer
   )
   return WinUI3.Windows.UI.Xaml.Automation.ExpandCollapseState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Automation.ExpandCollapseState;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDropDownButtonAutomationPeer.all);
      Hr := m_Interface.get_ExpandCollapseState (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Collapse
   (
      this : in out DropDownButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDropDownButtonAutomationPeer.all);
      Hr := m_Interface.Collapse;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Expand
   (
      this : in out DropDownButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IDropDownButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IDropDownButtonAutomationPeer.all);
      Hr := m_Interface.Expand;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for DynamicOverflowItemsChangingEventArgs

   procedure Initialize (this : in out DynamicOverflowItemsChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out DynamicOverflowItemsChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IDynamicOverflowItemsChangingEventArgs, IDynamicOverflowItemsChangingEventArgs_Ptr);
   begin
      if this.m_IDynamicOverflowItemsChangingEventArgs /= null then
         if this.m_IDynamicOverflowItemsChangingEventArgs.all /= null then
            temp := this.m_IDynamicOverflowItemsChangingEventArgs.all.Release;
            Free (this.m_IDynamicOverflowItemsChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for DynamicOverflowItemsChangingEventArgs

   function Constructor return DynamicOverflowItemsChangingEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.DynamicOverflowItemsChangingEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs;
   begin
      return RetVal : DynamicOverflowItemsChangingEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IDynamicOverflowItemsChangingEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IDynamicOverflowItemsChangingEventArgs;
            Retval.m_IDynamicOverflowItemsChangingEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for DynamicOverflowItemsChangingEventArgs

   function get_Action
   (
      this : in out DynamicOverflowItemsChangingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.CommandBarDynamicOverflowAction is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CommandBarDynamicOverflowAction;
   begin
      Hr := this.m_IDynamicOverflowItemsChangingEventArgs.all.get_Action (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlipView

   procedure Initialize (this : in out FlipView) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlipView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlipView, IFlipView_Ptr);
   begin
      if this.m_IFlipView /= null then
         if this.m_IFlipView.all /= null then
            temp := this.m_IFlipView.all.Release;
            Free (this.m_IFlipView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlipView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlipView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FlipView");
      m_Factory    : access IFlipViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IFlipView;
   begin
      return RetVal : FlipView do
         Hr := RoGetActivationFactory (m_hString, IID_IFlipViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlipView := new WinUI3.Windows.UI.Xaml.Controls.IFlipView;
            Retval.m_IFlipView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FlipView

   function get_UseTouchAnimationsForAllNavigationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FlipView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFlipViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlipViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UseTouchAnimationsForAllNavigationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlipView

   function get_UseTouchAnimationsForAllNavigation
   (
      this : in out FlipView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFlipView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFlipView_Interface, WinUI3.Windows.UI.Xaml.Controls.IFlipView2, WinUI3.Windows.UI.Xaml.Controls.IID_IFlipView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlipView.all);
      Hr := m_Interface.get_UseTouchAnimationsForAllNavigation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UseTouchAnimationsForAllNavigation
   (
      this : in out FlipView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFlipView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFlipView_Interface, WinUI3.Windows.UI.Xaml.Controls.IFlipView2, WinUI3.Windows.UI.Xaml.Controls.IID_IFlipView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlipView.all);
      Hr := m_Interface.put_UseTouchAnimationsForAllNavigation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlipViewItem

   procedure Initialize (this : in out FlipViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlipViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlipViewItem, IFlipViewItem_Ptr);
   begin
      if this.m_IFlipViewItem /= null then
         if this.m_IFlipViewItem.all /= null then
            temp := this.m_IFlipViewItem.all.Release;
            Free (this.m_IFlipViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlipViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlipViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FlipViewItem");
      m_Factory    : access IFlipViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IFlipViewItem;
   begin
      return RetVal : FlipViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_IFlipViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlipViewItem := new WinUI3.Windows.UI.Xaml.Controls.IFlipViewItem;
            Retval.m_IFlipViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlipViewItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Flyout

   procedure Initialize (this : in out Flyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out Flyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlyout, IFlyout_Ptr);
   begin
      if this.m_IFlyout /= null then
         if this.m_IFlyout.all /= null then
            temp := this.m_IFlyout.all.Release;
            Free (this.m_IFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Flyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Flyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Flyout");
      m_Factory    : access IFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IFlyout;
   begin
      return RetVal : Flyout do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlyout := new WinUI3.Windows.UI.Xaml.Controls.IFlyout;
            Retval.m_IFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Flyout

   function get_ContentProperty_Flyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Flyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FlyoutPresenterStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Flyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FlyoutPresenterStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Flyout

   function get_Content
   (
      this : in out Flyout
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IFlyout.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out Flyout;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyout.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FlyoutPresenterStyle
   (
      this : in out Flyout
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IFlyout.all.get_FlyoutPresenterStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_FlyoutPresenterStyle
   (
      this : in out Flyout;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFlyout.all.put_FlyoutPresenterStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FlyoutPresenter

   procedure Initialize (this : in out FlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out FlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFlyoutPresenter, IFlyoutPresenter_Ptr);
   begin
      if this.m_IFlyoutPresenter /= null then
         if this.m_IFlyoutPresenter.all /= null then
            temp := this.m_IFlyoutPresenter.all.Release;
            Free (this.m_IFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FlyoutPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FlyoutPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FlyoutPresenter");
      m_Factory    : access IFlyoutPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter;
   begin
      return RetVal : FlyoutPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFlyoutPresenter := new WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter;
            Retval.m_IFlyoutPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FlyoutPresenter

   function get_IsDefaultShadowEnabledProperty_FlyoutPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FlyoutPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFlyoutPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FlyoutPresenter

   function get_IsDefaultShadowEnabled
   (
      this : in out FlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IFlyoutPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlyoutPresenter.all);
      Hr := m_Interface.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out FlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IFlyoutPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IFlyoutPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFlyoutPresenter.all);
      Hr := m_Interface.put_IsDefaultShadowEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusDisengagedEventArgs

   procedure Initialize (this : in out FocusDisengagedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusDisengagedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusDisengagedEventArgs, IFocusDisengagedEventArgs_Ptr);
   begin
      if this.m_IFocusDisengagedEventArgs /= null then
         if this.m_IFocusDisengagedEventArgs.all /= null then
            temp := this.m_IFocusDisengagedEventArgs.all.Release;
            Free (this.m_IFocusDisengagedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusDisengagedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FocusEngagedEventArgs

   procedure Initialize (this : in out FocusEngagedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out FocusEngagedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFocusEngagedEventArgs, IFocusEngagedEventArgs_Ptr);
   begin
      if this.m_IFocusEngagedEventArgs /= null then
         if this.m_IFocusEngagedEventArgs.all /= null then
            temp := this.m_IFocusEngagedEventArgs.all.Release;
            Free (this.m_IFocusEngagedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FocusEngagedEventArgs

   function get_Handled
   (
      this : in out FocusEngagedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFocusEngagedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_IFocusEngagedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFocusEngagedEventArgs.all);
      Hr := m_Interface.get_Handled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out FocusEngagedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFocusEngagedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.IFocusEngagedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_IFocusEngagedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFocusEngagedEventArgs.all);
      Hr := m_Interface.put_Handled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FontIcon

   procedure Initialize (this : in out FontIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out FontIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFontIcon, IFontIcon_Ptr);
   begin
      if this.m_IFontIcon /= null then
         if this.m_IFontIcon.all /= null then
            temp := this.m_IFontIcon.all.Release;
            Free (this.m_IFontIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FontIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FontIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory    : access IFontIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IFontIcon;
   begin
      return RetVal : FontIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFontIcon := new WinUI3.Windows.UI.Xaml.Controls.IFontIcon;
            Retval.m_IFontIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FontIcon

   function get_IsTextScaleFactorEnabledProperty_FontIcon
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MirroredWhenRightToLeftProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MirroredWhenRightToLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_FontIcon
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_FontIcon
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_FontIcon
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_FontIcon
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FontIcon

   function get_Glyph
   (
      this : in out FontIcon
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFontIcon.all.get_Glyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Glyph
   (
      this : in out FontIcon;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFontIcon.all.put_Glyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FontSize
   (
      this : in out FontIcon
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFontIcon.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out FontIcon;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out FontIcon
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_IFontIcon.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out FontIcon;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out FontIcon
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IFontIcon.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out FontIcon;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out FontIcon
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IFontIcon.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out FontIcon;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIcon.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out FontIcon
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFontIcon2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFontIcon_Interface, WinUI3.Windows.UI.Xaml.Controls.IFontIcon2, WinUI3.Windows.UI.Xaml.Controls.IID_IFontIcon2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFontIcon.all);
      Hr := m_Interface.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out FontIcon;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFontIcon2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFontIcon_Interface, WinUI3.Windows.UI.Xaml.Controls.IFontIcon2, WinUI3.Windows.UI.Xaml.Controls.IID_IFontIcon2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFontIcon.all);
      Hr := m_Interface.put_IsTextScaleFactorEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MirroredWhenRightToLeft
   (
      this : in out FontIcon
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFontIcon3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFontIcon_Interface, WinUI3.Windows.UI.Xaml.Controls.IFontIcon3, WinUI3.Windows.UI.Xaml.Controls.IID_IFontIcon3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFontIcon.all);
      Hr := m_Interface.get_MirroredWhenRightToLeft (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MirroredWhenRightToLeft
   (
      this : in out FontIcon;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFontIcon3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFontIcon_Interface, WinUI3.Windows.UI.Xaml.Controls.IFontIcon3, WinUI3.Windows.UI.Xaml.Controls.IID_IFontIcon3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFontIcon.all);
      Hr := m_Interface.put_MirroredWhenRightToLeft (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FontIconSource

   procedure Initialize (this : in out FontIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out FontIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFontIconSource, IFontIconSource_Ptr);
   begin
      if this.m_IFontIconSource /= null then
         if this.m_IFontIconSource.all /= null then
            temp := this.m_IFontIconSource.all.Release;
            Free (this.m_IFontIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for FontIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return FontIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory    : access IFontIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IFontIconSource;
   begin
      return RetVal : FontIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFontIconSource := new WinUI3.Windows.UI.Xaml.Controls.IFontIconSource;
            Retval.m_IFontIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FontIconSource

   function get_GlyphProperty_FontIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_FontIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_FontIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_FontIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_FontIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_FontIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MirroredWhenRightToLeftProperty_FontIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.FontIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFontIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFontIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MirroredWhenRightToLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FontIconSource

   function get_Glyph
   (
      this : in out FontIconSource
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFontIconSource.all.get_Glyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Glyph
   (
      this : in out FontIconSource;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IFontIconSource.all.put_Glyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FontSize
   (
      this : in out FontIconSource
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IFontIconSource.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out FontIconSource;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out FontIconSource
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_IFontIconSource.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out FontIconSource;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out FontIconSource
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IFontIconSource.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out FontIconSource;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out FontIconSource
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IFontIconSource.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out FontIconSource;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out FontIconSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFontIconSource.all.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out FontIconSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_IsTextScaleFactorEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MirroredWhenRightToLeft
   (
      this : in out FontIconSource
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFontIconSource.all.get_MirroredWhenRightToLeft (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MirroredWhenRightToLeft
   (
      this : in out FontIconSource;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFontIconSource.all.put_MirroredWhenRightToLeft (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Frame

   procedure Initialize (this : in out Frame) is
   begin
      null;
   end;

   procedure Finalize (this : in out Frame) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFrame, IFrame_Ptr);
   begin
      if this.m_IFrame /= null then
         if this.m_IFrame.all /= null then
            temp := this.m_IFrame.all.Release;
            Free (this.m_IFrame);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Frame

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Frame is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory    : access IFrameFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IFrame;
   begin
      return RetVal : Frame do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IFrame := new WinUI3.Windows.UI.Xaml.Controls.IFrame;
            Retval.m_IFrame.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Frame

   function get_IsNavigationStackEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsNavigationStackEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackStackProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackStackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForwardStackProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForwardStackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CacheSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CacheSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoBackProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoBackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoForwardProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoForwardProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CurrentSourcePageTypeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CurrentSourcePageTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SourcePageTypeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourcePageTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackStackDepthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Frame");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IFrameStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IFrameStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackStackDepthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Frame

   function get_CacheSize
   (
      this : in out Frame
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IFrame.all.get_CacheSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CacheSize
   (
      this : in out Frame;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.put_CacheSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanGoBack
   (
      this : in out Frame
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.get_CanGoBack (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanGoForward
   (
      this : in out Frame
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.get_CanGoForward (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurrentSourcePageType
   (
      this : in out Frame
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
   begin
      Hr := this.m_IFrame.all.get_CurrentSourcePageType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SourcePageType
   (
      this : in out Frame
   )
   return WinUI3.Windows.UI.Xaml.Interop.TypeName is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Interop.TypeName;
   begin
      Hr := this.m_IFrame.all.get_SourcePageType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SourcePageType
   (
      this : in out Frame;
      value : WinUI3.Windows.UI.Xaml.Interop.TypeName
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.put_SourcePageType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackStackDepth
   (
      this : in out Frame
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IFrame.all.get_BackStackDepth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_Navigated
   (
      this : in out Frame;
      handler : WinUI3.Windows.UI.Xaml.Navigation.NavigatedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_Navigated (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Navigated
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_Navigated (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Navigating
   (
      this : in out Frame;
      handler : WinUI3.Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_Navigating (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Navigating
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_Navigating (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationFailed
   (
      this : in out Frame;
      handler : WinUI3.Windows.UI.Xaml.Navigation.NavigationFailedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_NavigationFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationFailed
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_NavigationFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationStopped
   (
      this : in out Frame;
      handler : WinUI3.Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IFrame.all.add_NavigationStopped (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationStopped
   (
      this : in out Frame;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.remove_NavigationStopped (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoBack
   (
      this : in out Frame
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.GoBack;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoForward
   (
      this : in out Frame
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IFrame.all.GoForward;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Navigate
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IFrame.all.Navigate (sourcePageType, parameter, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetNavigationState
   (
      this : in out Frame
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IFrame.all.GetNavigationState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetNavigationState
   (
      this : in out Frame;
      navigationState : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_navigationState : constant WinUI3.HString := To_HString (navigationState);
   begin
      Hr := this.m_IFrame.all.SetNavigationState (HStr_navigationState);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_navigationState);
   end;

   function get_BackStack
   (
      this : in out Frame
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame2, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.get_BackStack (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ForwardStack
   (
      this : in out Frame
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame2, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.get_ForwardStack (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Navigate
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      infoOverride : WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame2, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.Navigate (sourcePageType, parameter, infoOverride.m_INavigationTransitionInfo.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure GoBack
   (
      this : in out Frame;
      transitionInfoOverride : WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame3, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.GoBack (transitionInfoOverride.m_INavigationTransitionInfo.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetNavigationState
   (
      this : in out Frame;
      navigationState : WinUI3.WString;
      suppressNavigate : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame4 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_navigationState : constant WinUI3.HString := To_HString (navigationState);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame4, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.SetNavigationState (HStr_navigationState, suppressNavigate);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_navigationState);
   end;

   function get_IsNavigationStackEnabled
   (
      this : in out Frame
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame5, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.get_IsNavigationStackEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsNavigationStackEnabled
   (
      this : in out Frame;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame5, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.put_IsNavigationStackEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function NavigateToType
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName;
      parameter : WinUI3.IInspectable;
      navigationOptions : WinUI3.Windows.UI.Xaml.Navigation.FrameNavigationOptions'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IFrame5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.IFrame5, WinUI3.Windows.UI.Xaml.Controls.IID_IFrame5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.NavigateToType (sourcePageType, parameter, navigationOptions.m_IFrameNavigationOptions.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Navigate
   (
      this : in out Frame;
      sourcePageType : WinUI3.Windows.UI.Xaml.Interop.TypeName
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigate := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IFrame_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigate, WinUI3.Windows.UI.Xaml.Controls.IID_INavigate'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IFrame.all);
      Hr := m_Interface.Navigate (sourcePageType, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Grid

   procedure Initialize (this : in out Grid) is
   begin
      null;
   end;

   procedure Finalize (this : in out Grid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGrid, IGrid_Ptr);
   begin
      if this.m_IGrid /= null then
         if this.m_IGrid.all /= null then
            temp := this.m_IGrid.all.Release;
            Free (this.m_IGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Grid

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Grid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory    : access IGridFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IGrid;
   begin
      return RetVal : Grid do
         Hr := RoGetActivationFactory (m_hString, IID_IGridFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGrid := new WinUI3.Windows.UI.Xaml.Controls.IGrid;
            Retval.m_IGrid.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Grid

   function get_RowSpacingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ColumnSpacingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RowProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRow
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRow (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRow
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRow (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ColumnProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetColumn
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetColumn (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetColumn
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetColumn (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RowSpanProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRowSpan
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRowSpan (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRowSpan
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRowSpan (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ColumnSpanProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetColumnSpan
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetColumnSpan (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetColumnSpan
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetColumnSpan (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_BorderBrushProperty_Grid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_Grid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_Grid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_Grid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty_Grid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Grid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IGridStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IGridStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Grid

   function get_RowDefinitions
   (
      this : in out Grid
   )
   return WinUI3.Windows.UI.Xaml.Controls.RowDefinitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RowDefinitionCollection do
         Hr := this.m_IGrid.all.get_RowDefinitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_ColumnDefinitions
   (
      this : in out Grid
   )
   return WinUI3.Windows.UI.Xaml.Controls.ColumnDefinitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ColumnDefinitionCollection do
         Hr := this.m_IGrid.all.get_ColumnDefinitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_BorderBrush
   (
      this : in out Grid
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_IGrid.all);
         Hr := m_Interface.get_BorderBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out Grid;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.put_BorderBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out Grid
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.get_BorderThickness (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out Grid;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.put_BorderThickness (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out Grid
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.get_CornerRadius (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out Grid;
      value : WinUI3.Windows.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.put_CornerRadius (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out Grid
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.get_Padding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out Grid;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.put_Padding (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RowSpacing
   (
      this : in out Grid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid3, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.get_RowSpacing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RowSpacing
   (
      this : in out Grid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid3, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.put_RowSpacing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ColumnSpacing
   (
      this : in out Grid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid3, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.get_ColumnSpacing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ColumnSpacing
   (
      this : in out Grid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid3, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.put_ColumnSpacing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out Grid
   )
   return WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid4, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.get_BackgroundSizing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out Grid;
      value : WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGrid4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IGrid4, WinUI3.Windows.UI.Xaml.Controls.IID_IGrid4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGrid.all);
      Hr := m_Interface.put_BackgroundSizing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewBase

   procedure Initialize (this : in out ListViewBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewBase, IListViewBase_Ptr);
   begin
      if this.m_IListViewBase /= null then
         if this.m_IListViewBase.all /= null then
            temp := this.m_IListViewBase.all.Release;
            Free (this.m_IListViewBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewBase

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListViewBase is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory    : access IListViewBaseFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IListViewBase;
   begin
      return RetVal : ListViewBase do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListViewBase := new WinUI3.Windows.UI.Xaml.Controls.IListViewBase;
            Retval.m_IListViewBase.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListViewBase

   function get_ShowsScrollingPlaceholdersProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowsScrollingPlaceholdersProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTransitionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SingleSelectionFollowsFocusProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SingleSelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsMultiSelectCheckBoxEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsMultiSelectCheckBoxEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionModeProperty_ListViewBase
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSwipeEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSwipeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanDragItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanDragItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanReorderItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanReorderItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsItemClickEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsItemClickEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DataFetchSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataFetchSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IncrementalLoadingThresholdProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IncrementalLoadingThresholdProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IncrementalLoadingTriggerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IncrementalLoadingTriggerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SemanticZoomOwnerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SemanticZoomOwnerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsActiveViewProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsActiveViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomedInViewProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomedInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_ListViewBase
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ListViewBase
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTransitionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ReorderModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewBase");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewBaseStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewBaseStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReorderModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewBase

   function get_SelectedItems
   (
      this : in out ListViewBase
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IListViewBase.all.get_SelectedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.Controls.ListViewSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ListViewSelectionMode;
   begin
      Hr := this.m_IListViewBase.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.Controls.ListViewSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSwipeEnabled
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_IsSwipeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSwipeEnabled
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IsSwipeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanDragItems
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_CanDragItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanDragItems
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_CanDragItems (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanReorderItems
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_CanReorderItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanReorderItems
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_CanReorderItems (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsItemClickEnabled
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IListViewBase.all.get_IsItemClickEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsItemClickEnabled
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IsItemClickEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DataFetchSize
   (
      this : in out ListViewBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IListViewBase.all.get_DataFetchSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DataFetchSize
   (
      this : in out ListViewBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_DataFetchSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IncrementalLoadingThreshold
   (
      this : in out ListViewBase
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IListViewBase.all.get_IncrementalLoadingThreshold (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IncrementalLoadingThreshold
   (
      this : in out ListViewBase;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IncrementalLoadingThreshold (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IncrementalLoadingTrigger
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.Controls.IncrementalLoadingTrigger is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IncrementalLoadingTrigger;
   begin
      Hr := this.m_IListViewBase.all.get_IncrementalLoadingTrigger (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IncrementalLoadingTrigger
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.Controls.IncrementalLoadingTrigger
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_IncrementalLoadingTrigger (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemClick
   (
      this : in out ListViewBase;
      handler : WinUI3.Windows.UI.Xaml.Controls.ItemClickEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_ItemClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemClick
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_ItemClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsStarting
   (
      this : in out ListViewBase;
      handler : WinUI3.Windows.UI.Xaml.Controls.DragItemsStartingEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListViewBase.all.add_DragItemsStarting (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsStarting
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.remove_DragItemsStarting (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollIntoView
   (
      this : in out ListViewBase;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.ScrollIntoView (item);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out ListViewBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function LoadMoreItemsAsync
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.Data.LoadMoreItemsResult is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_LoadMoreItemsResult.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_LoadMoreItemsResult.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Windows.UI.Xaml.Data.LoadMoreItemsResult;
      m_IID            : aliased WinUI3.IID := (3347581085, 14251, 23458, (184, 101, 90, 48, 154, 205, 252, 77 )); -- Windows.UI.Xaml.Data.LoadMoreItemsResult;
      m_HandlerIID     : aliased WinUI3.IID := (284914571, 42555, 20590, (158, 215, 46, 171, 55, 145, 82, 33 ));
      m_Handler        : AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind := new AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_LoadMoreItemsResult.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind_Delegate, AsyncOperationCompletedHandler_LoadMoreItemsResult.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IListViewBase.all.LoadMoreItemsAsync (m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   procedure ScrollIntoView
   (
      this : in out ListViewBase;
      item : WinUI3.IInspectable;
      alignment : WinUI3.Windows.UI.Xaml.Controls.ScrollIntoViewAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.ScrollIntoView (item, alignment);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out ListViewBase
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListViewBase.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ListViewBase;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IListViewBase.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTransitions
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IListViewBase.all.get_HeaderTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTransitions
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListViewBase.all.put_HeaderTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowsScrollingPlaceholders
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_ShowsScrollingPlaceholders (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowsScrollingPlaceholders
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_ShowsScrollingPlaceholders (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContainerContentChanging
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.add_ContainerContentChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContainerContentChanging
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.remove_ContainerContentChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDesiredContainerUpdateDuration
   (
      this : in out ListViewBase;
      duration : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.SetDesiredContainerUpdateDuration (duration);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Footer
   (
      this : in out ListViewBase
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_Footer (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Footer
   (
      this : in out ListViewBase;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_Footer (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTemplate
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IListViewBase.all);
         Hr := m_Interface.get_FooterTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTemplate
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_FooterTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTransitions
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         m_Interface := QInterface (this.m_IListViewBase.all);
         Hr := m_Interface.get_FooterTransitions (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTransitions
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase2, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_FooterTransitions (value.m_GenericObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReorderMode
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.Controls.ListViewReorderMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ListViewReorderMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase3, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_ReorderMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ReorderMode
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.Controls.ListViewReorderMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase3, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_ReorderMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedRanges
   (
      this : in out ListViewBase
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_SelectedRanges (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsMultiSelectCheckBoxEnabled
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_IsMultiSelectCheckBoxEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsMultiSelectCheckBoxEnabled
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_IsMultiSelectCheckBoxEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsCompleted
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.add_DragItemsCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsCompleted
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.remove_DragItemsCompleted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ChoosingItemContainer
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.add_ChoosingItemContainer (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ChoosingItemContainer
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.remove_ChoosingItemContainer (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ChoosingGroupHeaderContainer
   (
      this : in out ListViewBase;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.add_ChoosingGroupHeaderContainer (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ChoosingGroupHeaderContainer
   (
      this : in out ListViewBase;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.remove_ChoosingGroupHeaderContainer (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectRange
   (
      this : in out ListViewBase;
      itemIndexRange : WinUI3.Windows.UI.Xaml.Data.ItemIndexRange'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.SelectRange (itemIndexRange.m_IItemIndexRange.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure DeselectRange
   (
      this : in out ListViewBase;
      itemIndexRange : WinUI3.Windows.UI.Xaml.Data.ItemIndexRange'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase4, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.DeselectRange (itemIndexRange.m_IItemIndexRange.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SingleSelectionFollowsFocus
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase5, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_SingleSelectionFollowsFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SingleSelectionFollowsFocus
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase5, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_SingleSelectionFollowsFocus (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function IsDragSource
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase5, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.IsDragSource (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryStartConnectedAnimationAsync
   (
      this : in out ListViewBase;
      animation : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimation'Class;
      item : WinUI3.IInspectable;
      elementName : WinUI3.WString
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase6 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_elementName : constant WinUI3.HString := To_HString (elementName);
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Boolean;
      m_IID            : aliased WinUI3.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinUI3.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase6, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.TryStartConnectedAnimationAsync (animation.m_IConnectedAnimation.all, item, HStr_elementName, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      tmp := WindowsDeleteString (HStr_elementName);
      return m_RetVal;
   end;

   function PrepareConnectedAnimation
   (
      this : in out ListViewBase;
      key : WinUI3.WString;
      item : WinUI3.IInspectable;
      elementName : WinUI3.WString
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListViewBase6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation;
      HStr_key : constant WinUI3.HString := To_HString (key);
      HStr_elementName : constant WinUI3.HString := To_HString (elementName);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.IListViewBase6, WinUI3.Windows.UI.Xaml.Controls.IID_IListViewBase6'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.ConnectedAnimation do
         m_Interface := QInterface (this.m_IListViewBase.all);
         Hr := m_Interface.PrepareConnectedAnimation (HStr_key, item, HStr_elementName, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IConnectedAnimation := new WinUI3.Windows.UI.Xaml.Media.Animation.IConnectedAnimation;
         Retval.m_IConnectedAnimation.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_key);
         tmp := WindowsDeleteString (HStr_elementName);
      end return;
   end;

   function get_SemanticZoomOwner
   (
      this : in out ListViewBase
   )
   return WinUI3.Windows.UI.Xaml.Controls.SemanticZoom'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoom;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SemanticZoom do
         m_Interface := QInterface (this.m_IListViewBase.all);
         Hr := m_Interface.get_SemanticZoomOwner (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoom := new WinUI3.Windows.UI.Xaml.Controls.ISemanticZoom;
         Retval.m_ISemanticZoom.all := m_ComRetVal;
      end return;
   end;

   procedure put_SemanticZoomOwner
   (
      this : in out ListViewBase;
      value : WinUI3.Windows.UI.Xaml.Controls.SemanticZoom'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_SemanticZoomOwner (value.m_ISemanticZoom.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsActiveView
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_IsActiveView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsActiveView
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_IsActiveView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomedInView
   (
      this : in out ListViewBase
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.get_IsZoomedInView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomedInView
   (
      this : in out ListViewBase;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.put_IsZoomedInView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InitializeViewChange
   (
      this : in out ListViewBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.InitializeViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChange
   (
      this : in out ListViewBase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.CompleteViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MakeVisible
   (
      this : in out ListViewBase;
      item : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.MakeVisible (item.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeFrom
   (
      this : in out ListViewBase;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.StartViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeTo
   (
      this : in out ListViewBase;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.StartViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeFrom
   (
      this : in out ListViewBase;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.CompleteViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeTo
   (
      this : in out ListViewBase;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListViewBase_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListViewBase.all);
      Hr := m_Interface.CompleteViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridView

   procedure Initialize (this : in out GridView) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridView, IGridView_Ptr);
   begin
      if this.m_IGridView /= null then
         if this.m_IGridView.all /= null then
            temp := this.m_IGridView.all.Release;
            Free (this.m_IGridView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GridView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GridView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.GridView");
      m_Factory    : access IGridViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IGridView;
   begin
      return RetVal : GridView do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGridView := new WinUI3.Windows.UI.Xaml.Controls.IGridView;
            Retval.m_IGridView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridView

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewBaseHeaderItem

   procedure Initialize (this : in out ListViewBaseHeaderItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewBaseHeaderItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewBaseHeaderItem, IListViewBaseHeaderItem_Ptr);
   begin
      if this.m_IListViewBaseHeaderItem /= null then
         if this.m_IListViewBaseHeaderItem.all /= null then
            temp := this.m_IListViewBaseHeaderItem.all.Release;
            Free (this.m_IListViewBaseHeaderItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewBaseHeaderItem

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewBaseHeaderItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridViewHeaderItem

   procedure Initialize (this : in out GridViewHeaderItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridViewHeaderItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridViewHeaderItem, IGridViewHeaderItem_Ptr);
   begin
      if this.m_IGridViewHeaderItem /= null then
         if this.m_IGridViewHeaderItem.all /= null then
            temp := this.m_IGridViewHeaderItem.all.Release;
            Free (this.m_IGridViewHeaderItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GridViewHeaderItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GridViewHeaderItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.GridViewHeaderItem");
      m_Factory    : access IGridViewHeaderItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IGridViewHeaderItem;
   begin
      return RetVal : GridViewHeaderItem do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewHeaderItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGridViewHeaderItem := new WinUI3.Windows.UI.Xaml.Controls.IGridViewHeaderItem;
            Retval.m_IGridViewHeaderItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridViewHeaderItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GridViewItem

   procedure Initialize (this : in out GridViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out GridViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGridViewItem, IGridViewItem_Ptr);
   begin
      if this.m_IGridViewItem /= null then
         if this.m_IGridViewItem.all /= null then
            temp := this.m_IGridViewItem.all.Release;
            Free (this.m_IGridViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GridViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GridViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.GridViewItem");
      m_Factory    : access IGridViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IGridViewItem;
   begin
      return RetVal : GridViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_IGridViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGridViewItem := new WinUI3.Windows.UI.Xaml.Controls.IGridViewItem;
            Retval.m_IGridViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GridViewItem

   function get_TemplateSettings
   (
      this : in out GridViewItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IGridViewItemTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings do
         Hr := this.m_IGridViewItem.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGridViewItemTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IGridViewItemTemplateSettings;
         Retval.m_IGridViewItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GroupItem

   procedure Initialize (this : in out GroupItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out GroupItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGroupItem, IGroupItem_Ptr);
   begin
      if this.m_IGroupItem /= null then
         if this.m_IGroupItem.all /= null then
            temp := this.m_IGroupItem.all.Release;
            Free (this.m_IGroupItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GroupItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GroupItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.GroupItem");
      m_Factory    : access IGroupItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IGroupItem;
   begin
      return RetVal : GroupItem do
         Hr := RoGetActivationFactory (m_hString, IID_IGroupItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGroupItem := new WinUI3.Windows.UI.Xaml.Controls.IGroupItem;
            Retval.m_IGroupItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GroupItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GroupStyle

   procedure Initialize (this : in out GroupStyle) is
   begin
      null;
   end;

   procedure Finalize (this : in out GroupStyle) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGroupStyle, IGroupStyle_Ptr);
   begin
      if this.m_IGroupStyle /= null then
         if this.m_IGroupStyle.all /= null then
            temp := this.m_IGroupStyle.all.Release;
            Free (this.m_IGroupStyle);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GroupStyle

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GroupStyle is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.GroupStyle");
      m_Factory    : access IGroupStyleFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IGroupStyle;
   begin
      return RetVal : GroupStyle do
         Hr := RoGetActivationFactory (m_hString, IID_IGroupStyleFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGroupStyle := new WinUI3.Windows.UI.Xaml.Controls.IGroupStyle;
            Retval.m_IGroupStyle.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GroupStyle

   function get_Panel
   (
      this : in out GroupStyle
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemsPanelTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsPanelTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemsPanelTemplate do
         Hr := this.m_IGroupStyle.all.get_Panel (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemsPanelTemplate := new WinUI3.Windows.UI.Xaml.Controls.IItemsPanelTemplate;
         Retval.m_IItemsPanelTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_Panel
   (
      this : in out GroupStyle;
      value : WinUI3.Windows.UI.Xaml.Controls.ItemsPanelTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_Panel (value.m_IItemsPanelTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContainerStyle
   (
      this : in out GroupStyle
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IGroupStyle.all.get_ContainerStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContainerStyle
   (
      this : in out GroupStyle;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_ContainerStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContainerStyleSelector
   (
      this : in out GroupStyle
   )
   return WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.StyleSelector do
         Hr := this.m_IGroupStyle.all.get_ContainerStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContainerStyleSelector
   (
      this : in out GroupStyle;
      value : WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_ContainerStyleSelector (value.m_IStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out GroupStyle
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IGroupStyle.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out GroupStyle;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplateSelector
   (
      this : in out GroupStyle
   )
   return WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_IGroupStyle.all.get_HeaderTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplateSelector
   (
      this : in out GroupStyle;
      value : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_HeaderTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HidesIfEmpty
   (
      this : in out GroupStyle
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IGroupStyle.all.get_HidesIfEmpty (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HidesIfEmpty
   (
      this : in out GroupStyle;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IGroupStyle.all.put_HidesIfEmpty (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderContainerStyle
   (
      this : in out GroupStyle
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGroupStyle2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGroupStyle_Interface, WinUI3.Windows.UI.Xaml.Controls.IGroupStyle2, WinUI3.Windows.UI.Xaml.Controls.IID_IGroupStyle2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_IGroupStyle.all);
         Hr := m_Interface.get_HeaderContainerStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderContainerStyle
   (
      this : in out GroupStyle;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGroupStyle2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGroupStyle_Interface, WinUI3.Windows.UI.Xaml.Controls.IGroupStyle2, WinUI3.Windows.UI.Xaml.Controls.IID_IGroupStyle2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGroupStyle.all);
      Hr := m_Interface.put_HeaderContainerStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PropertyChanged
   (
      this : in out GroupStyle;
      handler : WinUI3.Windows.UI.Xaml.Data.PropertyChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.INotifyPropertyChanged := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGroupStyle_Interface, WinUI3.Windows.UI.Xaml.Data.INotifyPropertyChanged, WinUI3.Windows.UI.Xaml.Data.IID_INotifyPropertyChanged'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGroupStyle.all);
      Hr := m_Interface.add_PropertyChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PropertyChanged
   (
      this : in out GroupStyle;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Data.INotifyPropertyChanged := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGroupStyle_Interface, WinUI3.Windows.UI.Xaml.Data.INotifyPropertyChanged, WinUI3.Windows.UI.Xaml.Data.IID_INotifyPropertyChanged'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IGroupStyle.all);
      Hr := m_Interface.remove_PropertyChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for GroupStyleSelector

   procedure Initialize (this : in out GroupStyleSelector) is
   begin
      null;
   end;

   procedure Finalize (this : in out GroupStyleSelector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IGroupStyleSelector, IGroupStyleSelector_Ptr);
   begin
      if this.m_IGroupStyleSelector /= null then
         if this.m_IGroupStyleSelector.all /= null then
            temp := this.m_IGroupStyleSelector.all.Release;
            Free (this.m_IGroupStyleSelector);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for GroupStyleSelector

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return GroupStyleSelector is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.GroupStyleSelector");
      m_Factory    : access IGroupStyleSelectorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IGroupStyleSelector;
   begin
      return RetVal : GroupStyleSelector do
         Hr := RoGetActivationFactory (m_hString, IID_IGroupStyleSelectorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IGroupStyleSelector := new WinUI3.Windows.UI.Xaml.Controls.IGroupStyleSelector;
            Retval.m_IGroupStyleSelector.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for GroupStyleSelector

   function SelectGroupStyle
   (
      this : in out GroupStyleSelector;
      group : WinUI3.IInspectable;
      level : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Controls.GroupStyle'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IGroupStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.GroupStyle do
         Hr := this.m_IGroupStyleSelector.all.SelectGroupStyle (group, level, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGroupStyle := new WinUI3.Windows.UI.Xaml.Controls.IGroupStyle;
         Retval.m_IGroupStyle.all := m_ComRetVal;
      end return;
   end;

   function SelectGroupStyleCore
   (
      this : in out GroupStyleSelector;
      group : WinUI3.IInspectable;
      level : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Controls.GroupStyle'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IGroupStyleSelectorOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IGroupStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IGroupStyleSelector_Interface, WinUI3.Windows.UI.Xaml.Controls.IGroupStyleSelectorOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IGroupStyleSelectorOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.GroupStyle do
         m_Interface := QInterface (this.m_IGroupStyleSelector.all);
         Hr := m_Interface.SelectGroupStyleCore (group, level, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGroupStyle := new WinUI3.Windows.UI.Xaml.Controls.IGroupStyle;
         Retval.m_IGroupStyle.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HandwritingPanelClosedEventArgs

   procedure Initialize (this : in out HandwritingPanelClosedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HandwritingPanelClosedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHandwritingPanelClosedEventArgs, IHandwritingPanelClosedEventArgs_Ptr);
   begin
      if this.m_IHandwritingPanelClosedEventArgs /= null then
         if this.m_IHandwritingPanelClosedEventArgs.all /= null then
            temp := this.m_IHandwritingPanelClosedEventArgs.all.Release;
            Free (this.m_IHandwritingPanelClosedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HandwritingPanelClosedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HandwritingPanelOpenedEventArgs

   procedure Initialize (this : in out HandwritingPanelOpenedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HandwritingPanelOpenedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHandwritingPanelOpenedEventArgs, IHandwritingPanelOpenedEventArgs_Ptr);
   begin
      if this.m_IHandwritingPanelOpenedEventArgs /= null then
         if this.m_IHandwritingPanelOpenedEventArgs.all /= null then
            temp := this.m_IHandwritingPanelOpenedEventArgs.all.Release;
            Free (this.m_IHandwritingPanelOpenedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HandwritingPanelOpenedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HandwritingView

   procedure Initialize (this : in out HandwritingView) is
   begin
      null;
   end;

   procedure Finalize (this : in out HandwritingView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHandwritingView, IHandwritingView_Ptr);
   begin
      if this.m_IHandwritingView /= null then
         if this.m_IHandwritingView.all /= null then
            temp := this.m_IHandwritingView.all.Release;
            Free (this.m_IHandwritingView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HandwritingView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return HandwritingView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HandwritingView");
      m_Factory    : access IHandwritingViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IHandwritingView;
   begin
      return RetVal : HandwritingView do
         Hr := RoGetActivationFactory (m_hString, IID_IHandwritingViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHandwritingView := new WinUI3.Windows.UI.Xaml.Controls.IHandwritingView;
            Retval.m_IHandwritingView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for HandwritingView

   function get_IsSwitchToKeyboardEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HandwritingView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHandwritingViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHandwritingViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSwitchToKeyboardEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCommandBarOpenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HandwritingView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHandwritingViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHandwritingViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCommandBarOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HandwritingView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHandwritingViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHandwritingViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HandwritingView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHandwritingViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHandwritingViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOpenProperty_HandwritingView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HandwritingView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHandwritingViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHandwritingViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreCandidatesEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HandwritingView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHandwritingViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHandwritingViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreCandidatesEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HandwritingView

   function get_PlacementTarget
   (
      this : in out HandwritingView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IHandwritingView.all.get_PlacementTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlacementTarget
   (
      this : in out HandwritingView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHandwritingView.all.put_PlacementTarget (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlacementAlignment
   (
      this : in out HandwritingView
   )
   return WinUI3.Windows.UI.Xaml.Controls.HandwritingPanelPlacementAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.HandwritingPanelPlacementAlignment;
   begin
      Hr := this.m_IHandwritingView.all.get_PlacementAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PlacementAlignment
   (
      this : in out HandwritingView;
      value : WinUI3.Windows.UI.Xaml.Controls.HandwritingPanelPlacementAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHandwritingView.all.put_PlacementAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOpen
   (
      this : in out HandwritingView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IHandwritingView.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreCandidatesEnabled
   (
      this : in out HandwritingView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IHandwritingView.all.get_AreCandidatesEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreCandidatesEnabled
   (
      this : in out HandwritingView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHandwritingView.all.put_AreCandidatesEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out HandwritingView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHandwritingView.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out HandwritingView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHandwritingView.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Closed
   (
      this : in out HandwritingView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHandwritingView.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out HandwritingView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHandwritingView.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function TryClose
   (
      this : in out HandwritingView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IHandwritingView.all.TryClose (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function TryOpen
   (
      this : in out HandwritingView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IHandwritingView.all.TryOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSwitchToKeyboardEnabled
   (
      this : in out HandwritingView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.get_IsSwitchToKeyboardEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSwitchToKeyboardEnabled
   (
      this : in out HandwritingView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.put_IsSwitchToKeyboardEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCommandBarOpen
   (
      this : in out HandwritingView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.get_IsCommandBarOpen (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCommandBarOpen
   (
      this : in out HandwritingView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.put_IsCommandBarOpen (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputDeviceTypes
   (
      this : in out HandwritingView
   )
   return WinUI3.Windows.UI.Core.CoreInputDeviceTypes is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Core.CoreInputDeviceTypes;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.get_InputDeviceTypes (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InputDeviceTypes
   (
      this : in out HandwritingView;
      value : WinUI3.Windows.UI.Core.CoreInputDeviceTypes
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.put_InputDeviceTypes (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CandidatesChanged
   (
      this : in out HandwritingView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.add_CandidatesChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CandidatesChanged
   (
      this : in out HandwritingView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.remove_CandidatesChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextSubmitted
   (
      this : in out HandwritingView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.add_TextSubmitted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextSubmitted
   (
      this : in out HandwritingView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.remove_TextSubmitted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetCandidates
   (
      this : in out HandwritingView;
      candidatesSessionId : WinUI3.UInt32
   )
   return IVectorView_HString.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_HString.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.GetCandidates (candidatesSessionId, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_HString (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure SelectCandidate
   (
      this : in out HandwritingView;
      candidatesSessionId : WinUI3.UInt32;
      selectedCandidateIndex : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHandwritingView_Interface, WinUI3.Windows.UI.Xaml.Controls.IHandwritingView2, WinUI3.Windows.UI.Xaml.Controls.IID_IHandwritingView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHandwritingView.all);
      Hr := m_Interface.SelectCandidate (candidatesSessionId, selectedCandidateIndex);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HandwritingViewCandidatesChangedEventArgs

   procedure Initialize (this : in out HandwritingViewCandidatesChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HandwritingViewCandidatesChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHandwritingViewCandidatesChangedEventArgs, IHandwritingViewCandidatesChangedEventArgs_Ptr);
   begin
      if this.m_IHandwritingViewCandidatesChangedEventArgs /= null then
         if this.m_IHandwritingViewCandidatesChangedEventArgs.all /= null then
            temp := this.m_IHandwritingViewCandidatesChangedEventArgs.all.Release;
            Free (this.m_IHandwritingViewCandidatesChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HandwritingViewCandidatesChangedEventArgs

   function get_CandidatesSessionId
   (
      this : in out HandwritingViewCandidatesChangedEventArgs
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IHandwritingViewCandidatesChangedEventArgs.all.get_CandidatesSessionId (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HandwritingViewTextSubmittedEventArgs

   procedure Initialize (this : in out HandwritingViewTextSubmittedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HandwritingViewTextSubmittedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHandwritingViewTextSubmittedEventArgs, IHandwritingViewTextSubmittedEventArgs_Ptr);
   begin
      if this.m_IHandwritingViewTextSubmittedEventArgs /= null then
         if this.m_IHandwritingViewTextSubmittedEventArgs.all /= null then
            temp := this.m_IHandwritingViewTextSubmittedEventArgs.all.Release;
            Free (this.m_IHandwritingViewTextSubmittedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HandwritingViewTextSubmittedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Hub

   procedure Initialize (this : in out Hub) is
   begin
      null;
   end;

   procedure Finalize (this : in out Hub) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHub, IHub_Ptr);
   begin
      if this.m_IHub /= null then
         if this.m_IHub.all /= null then
            temp := this.m_IHub.all.Release;
            Free (this.m_IHub);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Hub

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Hub is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory    : access IHubFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IHub;
   begin
      return RetVal : Hub do
         Hr := RoGetActivationFactory (m_hString, IID_IHubFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHub := new WinUI3.Windows.UI.Xaml.Controls.IHub;
            Retval.m_IHub.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Hub

   function get_HeaderProperty_Hub
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_Hub
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_Hub
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultSectionIndexProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultSectionIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SemanticZoomOwnerProperty_Hub
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SemanticZoomOwnerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsActiveViewProperty_Hub
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsActiveViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomedInViewProperty_Hub
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Hub");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomedInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Hub

   function get_Header
   (
      this : in out Hub
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IHub.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out Hub;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out Hub
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IHub.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out Hub;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out Hub
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IHub.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out Hub;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultSectionIndex
   (
      this : in out Hub
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IHub.all.get_DefaultSectionIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultSectionIndex
   (
      this : in out Hub;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.put_DefaultSectionIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Sections
   (
      this : in out Hub
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_IHub.all.get_Sections (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SectionsInView
   (
      this : in out Hub
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_IHub.all.get_SectionsInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SectionHeaders
   (
      this : in out Hub
   )
   return IObservableVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IObservableVector_IInspectable.Kind;
   begin
      Hr := this.m_IHub.all.get_SectionHeaders (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IObservableVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_SectionHeaderClick
   (
      this : in out Hub;
      handler : WinUI3.Windows.UI.Xaml.Controls.HubSectionHeaderClickEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHub.all.add_SectionHeaderClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SectionHeaderClick
   (
      this : in out Hub;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.remove_SectionHeaderClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SectionsInViewChanged
   (
      this : in out Hub;
      handler : WinUI3.Windows.UI.Xaml.Controls.SectionsInViewChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IHub.all.add_SectionsInViewChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SectionsInViewChanged
   (
      this : in out Hub;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.remove_SectionsInViewChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollToSection
   (
      this : in out Hub;
      section : WinUI3.Windows.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHub.all.ScrollToSection (section.m_IHubSection.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SemanticZoomOwner
   (
      this : in out Hub
   )
   return WinUI3.Windows.UI.Xaml.Controls.SemanticZoom'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoom;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SemanticZoom do
         m_Interface := QInterface (this.m_IHub.all);
         Hr := m_Interface.get_SemanticZoomOwner (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoom := new WinUI3.Windows.UI.Xaml.Controls.ISemanticZoom;
         Retval.m_ISemanticZoom.all := m_ComRetVal;
      end return;
   end;

   procedure put_SemanticZoomOwner
   (
      this : in out Hub;
      value : WinUI3.Windows.UI.Xaml.Controls.SemanticZoom'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.put_SemanticZoomOwner (value.m_ISemanticZoom.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsActiveView
   (
      this : in out Hub
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.get_IsActiveView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsActiveView
   (
      this : in out Hub;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.put_IsActiveView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomedInView
   (
      this : in out Hub
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.get_IsZoomedInView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomedInView
   (
      this : in out Hub;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.put_IsZoomedInView (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InitializeViewChange
   (
      this : in out Hub
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.InitializeViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChange
   (
      this : in out Hub
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.CompleteViewChange;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MakeVisible
   (
      this : in out Hub;
      item : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.MakeVisible (item.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeFrom
   (
      this : in out Hub;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.StartViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure StartViewChangeTo
   (
      this : in out Hub;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.StartViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeFrom
   (
      this : in out Hub;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.CompleteViewChangeFrom (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CompleteViewChangeTo
   (
      this : in out Hub;
      source : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class;
      destination : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IHub_Interface, WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation, WinUI3.Windows.UI.Xaml.Controls.IID_ISemanticZoomInformation'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IHub.all);
      Hr := m_Interface.CompleteViewChangeTo (source.m_ISemanticZoomLocation.all, destination.m_ISemanticZoomLocation.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HubSection

   procedure Initialize (this : in out HubSection) is
   begin
      null;
   end;

   procedure Finalize (this : in out HubSection) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHubSection, IHubSection_Ptr);
   begin
      if this.m_IHubSection /= null then
         if this.m_IHubSection.all /= null then
            temp := this.m_IHubSection.all.Release;
            Free (this.m_IHubSection);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HubSection

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return HubSection is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HubSection");
      m_Factory    : access IHubSectionFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IHubSection;
   begin
      return RetVal : HubSection do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHubSection := new WinUI3.Windows.UI.Xaml.Controls.IHubSection;
            Retval.m_IHubSection.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for HubSection

   function get_HeaderProperty_HubSection
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_HubSection
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentTemplateProperty_HubSection
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHeaderInteractiveProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HubSection");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHubSectionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHubSectionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHeaderInteractiveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HubSection

   function get_Header
   (
      this : in out HubSection
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IHubSection.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out HubSection;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out HubSection
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IHubSection.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out HubSection;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentTemplate
   (
      this : in out HubSection
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IHubSection.all.get_ContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentTemplate
   (
      this : in out HubSection;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_ContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHeaderInteractive
   (
      this : in out HubSection
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IHubSection.all.get_IsHeaderInteractive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHeaderInteractive
   (
      this : in out HubSection;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHubSection.all.put_IsHeaderInteractive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HubSectionCollection

   procedure Initialize (this : in out HubSectionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out HubSectionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HubSectionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Controls.HubSection>
   function GetAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IHubSection;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.HubSection do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Windows.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out HubSectionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out HubSectionCollection
   )
   return WinUI3.Windows.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IHubSection;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.HubSection do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Windows.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out HubSectionCollection;
      value : WinUI3.Windows.UI.Xaml.Controls.HubSection'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IHubSection.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IHubSection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IHubSection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out HubSectionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out HubSectionCollection;
      value : WinUI3.Windows.UI.Xaml.Controls.HubSection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IHubSection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out HubSectionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out HubSectionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out HubSectionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Controls.IHubSection_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out HubSectionCollection;
      items : WinUI3.Windows.UI.Xaml.Controls.IHubSection_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2387019898, 15587, 22492, (165, 131, 125, 185, 191, 24, 143, 196 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IHubSection.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Controls.HubSection>
   function First
   (
      this : in out HubSectionCollection
   )
   return WinUI3.Windows.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IHubSection.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IHubSection;
      m_GenericIID     : aliased WinUI3.IID := (1435254914, 17978, 23613, (181, 30, 16, 146, 27, 74, 77, 108 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IHubSection.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.HubSection do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Windows.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HubSectionHeaderClickEventArgs

   procedure Initialize (this : in out HubSectionHeaderClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out HubSectionHeaderClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHubSectionHeaderClickEventArgs, IHubSectionHeaderClickEventArgs_Ptr);
   begin
      if this.m_IHubSectionHeaderClickEventArgs /= null then
         if this.m_IHubSectionHeaderClickEventArgs.all /= null then
            temp := this.m_IHubSectionHeaderClickEventArgs.all.Release;
            Free (this.m_IHubSectionHeaderClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HubSectionHeaderClickEventArgs

   function Constructor return HubSectionHeaderClickEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HubSectionHeaderClickEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs;
   begin
      return RetVal : HubSectionHeaderClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IHubSectionHeaderClickEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs;
            Retval.m_IHubSectionHeaderClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HubSectionHeaderClickEventArgs

   function get_Section
   (
      this : in out HubSectionHeaderClickEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.HubSection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IHubSection;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.HubSection do
         Hr := this.m_IHubSectionHeaderClickEventArgs.all.get_Section (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHubSection := new WinUI3.Windows.UI.Xaml.Controls.IHubSection;
         Retval.m_IHubSection.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate HubSectionHeaderClickEventHandler

   function Invoke
   (
      this : access HubSectionHeaderClickEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.IHubSectionHeaderClickEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for HyperlinkButton

   procedure Initialize (this : in out HyperlinkButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out HyperlinkButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IHyperlinkButton, IHyperlinkButton_Ptr);
   begin
      if this.m_IHyperlinkButton /= null then
         if this.m_IHyperlinkButton.all /= null then
            temp := this.m_IHyperlinkButton.all.Release;
            Free (this.m_IHyperlinkButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for HyperlinkButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return HyperlinkButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HyperlinkButton");
      m_Factory    : access IHyperlinkButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IHyperlinkButton;
   begin
      return RetVal : HyperlinkButton do
         Hr := RoGetActivationFactory (m_hString, IID_IHyperlinkButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IHyperlinkButton := new WinUI3.Windows.UI.Xaml.Controls.IHyperlinkButton;
            Retval.m_IHyperlinkButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for HyperlinkButton

   function get_NavigateUriProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.HyperlinkButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IHyperlinkButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IHyperlinkButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NavigateUriProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for HyperlinkButton

   function get_NavigateUri
   (
      this : in out HyperlinkButton
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IHyperlinkButton.all.get_NavigateUri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_NavigateUri
   (
      this : in out HyperlinkButton;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IHyperlinkButton.all.put_NavigateUri (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IconSourceElement

   procedure Initialize (this : in out IconSourceElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out IconSourceElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIconSourceElement, IIconSourceElement_Ptr);
   begin
      if this.m_IIconSourceElement /= null then
         if this.m_IIconSourceElement.all /= null then
            temp := this.m_IIconSourceElement.all.Release;
            Free (this.m_IIconSourceElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for IconSourceElement

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return IconSourceElement is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.IconSourceElement");
      m_Factory    : access IIconSourceElementFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IIconSourceElement;
   begin
      return RetVal : IconSourceElement do
         Hr := RoGetActivationFactory (m_hString, IID_IIconSourceElementFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IIconSourceElement := new WinUI3.Windows.UI.Xaml.Controls.IIconSourceElement;
            Retval.m_IIconSourceElement.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for IconSourceElement

   function get_IconSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.IconSourceElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IIconSourceElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IIconSourceElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IconSourceElement

   function get_IconSource
   (
      this : in out IconSourceElement
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconSource do
         Hr := this.m_IIconSourceElement.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Windows.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out IconSourceElement;
      value : WinUI3.Windows.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IIconSourceElement.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Image

   procedure Initialize (this : in out Image) is
   begin
      null;
   end;

   procedure Finalize (this : in out Image) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IImage, IImage_Ptr);
   begin
      if this.m_IImage /= null then
         if this.m_IImage.all /= null then
            temp := this.m_IImage.all.Release;
            Free (this.m_IImage);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Image

   function Constructor return Image is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Image");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IImage;
   begin
      return RetVal : Image do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IImage := new WinUI3.Windows.UI.Xaml.Controls.IImage;
            Retval.m_IImage.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Image

   function get_SourceProperty_Image
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Image");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty_Image
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Image");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NineGridProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Image");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NineGridProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlayToSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Image");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IImageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IImageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlayToSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Image

   function get_Source
   (
      this : in out Image
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IImage.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out Image;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.put_Source (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out Image
   )
   return WinUI3.Windows.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IImage.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out Image;
      value : WinUI3.Windows.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NineGrid
   (
      this : in out Image
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IImage.all.get_NineGrid (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NineGrid
   (
      this : in out Image;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.put_NineGrid (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlayToSource
   (
      this : in out Image
   )
   return WinUI3.Windows.Media.PlayTo.PlayToSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.PlayTo.IPlayToSource;
   begin
      return RetVal : WinUI3.Windows.Media.PlayTo.PlayToSource do
         Hr := this.m_IImage.all.get_PlayToSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPlayToSource := new WinUI3.Windows.Media.PlayTo.IPlayToSource;
         Retval.m_IPlayToSource.all := m_ComRetVal;
      end return;
   end;

   function add_ImageFailed
   (
      this : in out Image;
      handler : WinUI3.Windows.UI.Xaml.ExceptionRoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IImage.all.add_ImageFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageFailed
   (
      this : in out Image;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.remove_ImageFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ImageOpened
   (
      this : in out Image;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IImage.all.add_ImageOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ImageOpened
   (
      this : in out Image;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IImage.all.remove_ImageOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetAsCastingSource
   (
      this : in out Image
   )
   return WinUI3.Windows.Media.Casting.CastingSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IImage2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Casting.ICastingSource;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IImage_Interface, WinUI3.Windows.UI.Xaml.Controls.IImage2, WinUI3.Windows.UI.Xaml.Controls.IID_IImage2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Media.Casting.CastingSource do
         m_Interface := QInterface (this.m_IImage.all);
         Hr := m_Interface.GetAsCastingSource (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICastingSource := new WinUI3.Windows.Media.Casting.ICastingSource;
         Retval.m_ICastingSource.all := m_ComRetVal;
      end return;
   end;

   function GetAlphaMask
   (
      this : in out Image
   )
   return WinUI3.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IImage3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Composition.ICompositionBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IImage_Interface, WinUI3.Windows.UI.Xaml.Controls.IImage3, WinUI3.Windows.UI.Xaml.Controls.IID_IImage3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Composition.CompositionBrush do
         m_Interface := QInterface (this.m_IImage.all);
         Hr := m_Interface.GetAlphaMask (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinUI3.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkCanvas

   procedure Initialize (this : in out InkCanvas) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkCanvas) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkCanvas, IInkCanvas_Ptr);
   begin
      if this.m_IInkCanvas /= null then
         if this.m_IInkCanvas.all /= null then
            temp := this.m_IInkCanvas.all.Release;
            Free (this.m_IInkCanvas);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkCanvas

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkCanvas is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkCanvas");
      m_Factory    : access IInkCanvasFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkCanvas;
   begin
      return RetVal : InkCanvas do
         Hr := RoGetActivationFactory (m_hString, IID_IInkCanvasFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkCanvas := new WinUI3.Windows.UI.Xaml.Controls.IInkCanvas;
            Retval.m_IInkCanvas.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkCanvas

   function get_InkPresenter
   (
      this : in out InkCanvas
   )
   return WinUI3.Windows.UI.Input.Inking.InkPresenter'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkPresenter;
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkPresenter do
         Hr := this.m_IInkCanvas.all.get_InkPresenter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkPresenter := new WinUI3.Windows.UI.Input.Inking.IInkPresenter;
         Retval.m_IInkPresenter.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbar

   procedure Initialize (this : in out InkToolbar) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbar, IInkToolbar_Ptr);
   begin
      if this.m_IInkToolbar /= null then
         if this.m_IInkToolbar.all /= null then
            temp := this.m_IInkToolbar.all.Release;
            Free (this.m_IInkToolbar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory    : access IInkToolbarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbar;
   begin
      return RetVal : InkToolbar do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbar := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbar;
            Retval.m_IInkToolbar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbar

   function get_IsStencilButtonCheckedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStencilButtonCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ButtonFlyoutPlacementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ButtonFlyoutPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_InkToolbar
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TargetInkPresenterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetInkPresenterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InitialControlsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InitialControlsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChildrenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActiveToolProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActiveToolProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InkDrawingAttributesProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InkDrawingAttributesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRulerButtonCheckedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRulerButtonCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TargetInkCanvasProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TargetInkCanvasProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbar

   function get_InitialControls
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarInitialControls is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarInitialControls;
   begin
      Hr := this.m_IInkToolbar.all.get_InitialControls (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialControls
   (
      this : in out InkToolbar;
      value : WinUI3.Windows.UI.Xaml.Controls.InkToolbarInitialControls
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.put_InitialControls (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Children
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Xaml.DependencyObjectCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObjectCollection do
         Hr := this.m_IInkToolbar.all.get_Children (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_ActiveTool
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarToolButton'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarToolButton;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkToolbarToolButton do
         Hr := this.m_IInkToolbar.all.get_ActiveTool (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkToolbarToolButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarToolButton;
         Retval.m_IInkToolbarToolButton.all := m_ComRetVal;
      end return;
   end;

   procedure put_ActiveTool
   (
      this : in out InkToolbar;
      value : WinUI3.Windows.UI.Xaml.Controls.InkToolbarToolButton'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.put_ActiveTool (value.m_IInkToolbarToolButton.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InkDrawingAttributes
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Input.Inking.InkDrawingAttributes'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkDrawingAttributes;
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkDrawingAttributes do
         Hr := this.m_IInkToolbar.all.get_InkDrawingAttributes (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkDrawingAttributes := new WinUI3.Windows.UI.Input.Inking.IInkDrawingAttributes;
         Retval.m_IInkDrawingAttributes.all := m_ComRetVal;
      end return;
   end;

   function get_IsRulerButtonChecked
   (
      this : in out InkToolbar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInkToolbar.all.get_IsRulerButtonChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRulerButtonChecked
   (
      this : in out InkToolbar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.put_IsRulerButtonChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TargetInkCanvas
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkCanvas'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkCanvas;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkCanvas do
         Hr := this.m_IInkToolbar.all.get_TargetInkCanvas (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkCanvas := new WinUI3.Windows.UI.Xaml.Controls.IInkCanvas;
         Retval.m_IInkCanvas.all := m_ComRetVal;
      end return;
   end;

   procedure put_TargetInkCanvas
   (
      this : in out InkToolbar;
      value : WinUI3.Windows.UI.Xaml.Controls.InkCanvas'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.put_TargetInkCanvas (value.m_IInkCanvas.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ActiveToolChanged
   (
      this : in out InkToolbar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkToolbar.all.add_ActiveToolChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ActiveToolChanged
   (
      this : in out InkToolbar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.remove_ActiveToolChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_InkDrawingAttributesChanged
   (
      this : in out InkToolbar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkToolbar.all.add_InkDrawingAttributesChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_InkDrawingAttributesChanged
   (
      this : in out InkToolbar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.remove_InkDrawingAttributesChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_EraseAllClicked
   (
      this : in out InkToolbar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkToolbar.all.add_EraseAllClicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_EraseAllClicked
   (
      this : in out InkToolbar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.remove_EraseAllClicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_IsRulerButtonCheckedChanged
   (
      this : in out InkToolbar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkToolbar.all.add_IsRulerButtonCheckedChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsRulerButtonCheckedChanged
   (
      this : in out InkToolbar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbar.all.remove_IsRulerButtonCheckedChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetToolButton
   (
      this : in out InkToolbar;
      tool : WinUI3.Windows.UI.Xaml.Controls.InkToolbarTool
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarToolButton'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarToolButton;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkToolbarToolButton do
         Hr := this.m_IInkToolbar.all.GetToolButton (tool, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkToolbarToolButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarToolButton;
         Retval.m_IInkToolbarToolButton.all := m_ComRetVal;
      end return;
   end;

   function GetToggleButton
   (
      this : in out InkToolbar;
      tool : WinUI3.Windows.UI.Xaml.Controls.InkToolbarToggle
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarToggleButton'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarToggleButton;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkToolbarToggleButton do
         Hr := this.m_IInkToolbar.all.GetToggleButton (tool, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkToolbarToggleButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarToggleButton;
         Retval.m_IInkToolbarToggleButton.all := m_ComRetVal;
      end return;
   end;

   function get_IsStencilButtonChecked
   (
      this : in out InkToolbar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.get_IsStencilButtonChecked (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStencilButtonChecked
   (
      this : in out InkToolbar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.put_IsStencilButtonChecked (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ButtonFlyoutPlacement
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarButtonFlyoutPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarButtonFlyoutPlacement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.get_ButtonFlyoutPlacement (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ButtonFlyoutPlacement
   (
      this : in out InkToolbar;
      value : WinUI3.Windows.UI.Xaml.Controls.InkToolbarButtonFlyoutPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.put_ButtonFlyoutPlacement (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.get_Orientation (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out InkToolbar;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.put_Orientation (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_IsStencilButtonCheckedChanged
   (
      this : in out InkToolbar;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.add_IsStencilButtonCheckedChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsStencilButtonCheckedChanged
   (
      this : in out InkToolbar;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.remove_IsStencilButtonCheckedChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMenuButton
   (
      this : in out InkToolbar;
      menu : WinUI3.Windows.UI.Xaml.Controls.InkToolbarMenuKind
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarMenuButton'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarMenuButton;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkToolbarMenuButton do
         m_Interface := QInterface (this.m_IInkToolbar.all);
         Hr := m_Interface.GetMenuButton (menu, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkToolbarMenuButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarMenuButton;
         Retval.m_IInkToolbarMenuButton.all := m_ComRetVal;
      end return;
   end;

   function get_TargetInkPresenter
   (
      this : in out InkToolbar
   )
   return WinUI3.Windows.UI.Input.Inking.InkPresenter'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkPresenter;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar3, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkPresenter do
         m_Interface := QInterface (this.m_IInkToolbar.all);
         Hr := m_Interface.get_TargetInkPresenter (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkPresenter := new WinUI3.Windows.UI.Input.Inking.IInkPresenter;
         Retval.m_IInkPresenter.all := m_ComRetVal;
      end return;
   end;

   procedure put_TargetInkPresenter
   (
      this : in out InkToolbar;
      value : WinUI3.Windows.UI.Input.Inking.InkPresenter'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbar3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbar_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbar3, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbar3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbar.all);
      Hr := m_Interface.put_TargetInkPresenter (value.m_IInkPresenter.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RadioButton

   procedure Initialize (this : in out RadioButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out RadioButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRadioButton, IRadioButton_Ptr);
   begin
      if this.m_IRadioButton /= null then
         if this.m_IRadioButton.all /= null then
            temp := this.m_IRadioButton.all.Release;
            Free (this.m_IRadioButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RadioButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RadioButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RadioButton");
      m_Factory    : access IRadioButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRadioButton;
   begin
      return RetVal : RadioButton do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRadioButton := new WinUI3.Windows.UI.Xaml.Controls.IRadioButton;
            Retval.m_IRadioButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RadioButton

   function get_GroupNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RadioButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRadioButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRadioButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RadioButton

   function get_GroupName
   (
      this : in out RadioButton
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRadioButton.all.get_GroupName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_GroupName
   (
      this : in out RadioButton;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRadioButton.all.put_GroupName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarToolButton

   procedure Initialize (this : in out InkToolbarToolButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarToolButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarToolButton, IInkToolbarToolButton_Ptr);
   begin
      if this.m_IInkToolbarToolButton /= null then
         if this.m_IInkToolbarToolButton.all /= null then
            temp := this.m_IInkToolbarToolButton.all.Release;
            Free (this.m_IInkToolbarToolButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarToolButton

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarToolButton

   function get_IsExtensionGlyphShownProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarToolButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarToolButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarToolButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExtensionGlyphShownProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarToolButton

   function get_ToolKind
   (
      this : in out InkToolbarToolButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarTool is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarTool;
   begin
      Hr := this.m_IInkToolbarToolButton.all.get_ToolKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsExtensionGlyphShown
   (
      this : in out InkToolbarToolButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInkToolbarToolButton.all.get_IsExtensionGlyphShown (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExtensionGlyphShown
   (
      this : in out InkToolbarToolButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarToolButton.all.put_IsExtensionGlyphShown (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarPenButton

   procedure Initialize (this : in out InkToolbarPenButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarPenButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarPenButton, IInkToolbarPenButton_Ptr);
   begin
      if this.m_IInkToolbarPenButton /= null then
         if this.m_IInkToolbarPenButton.all /= null then
            temp := this.m_IInkToolbarPenButton.all.Release;
            Free (this.m_IInkToolbarPenButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarPenButton

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarPenButton

   function get_PaletteProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaletteProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinStrokeWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinStrokeWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxStrokeWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxStrokeWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedBrushIndexProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedBrushIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedStrokeWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedStrokeWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarPenButton

   function get_Palette
   (
      this : in out InkToolbarPenButton
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      Hr := this.m_IInkToolbarPenButton.all.get_Palette (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Palette
   (
      this : in out InkToolbarPenButton;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarPenButton.all.put_Palette (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinStrokeWidth
   (
      this : in out InkToolbarPenButton
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IInkToolbarPenButton.all.get_MinStrokeWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinStrokeWidth
   (
      this : in out InkToolbarPenButton;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarPenButton.all.put_MinStrokeWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxStrokeWidth
   (
      this : in out InkToolbarPenButton
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IInkToolbarPenButton.all.get_MaxStrokeWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxStrokeWidth
   (
      this : in out InkToolbarPenButton;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarPenButton.all.put_MaxStrokeWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedBrush
   (
      this : in out InkToolbarPenButton
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IInkToolbarPenButton.all.get_SelectedBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   function get_SelectedBrushIndex
   (
      this : in out InkToolbarPenButton
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IInkToolbarPenButton.all.get_SelectedBrushIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedBrushIndex
   (
      this : in out InkToolbarPenButton;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarPenButton.all.put_SelectedBrushIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedStrokeWidth
   (
      this : in out InkToolbarPenButton
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IInkToolbarPenButton.all.get_SelectedStrokeWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedStrokeWidth
   (
      this : in out InkToolbarPenButton;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarPenButton.all.put_SelectedStrokeWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarBallpointPenButton

   procedure Initialize (this : in out InkToolbarBallpointPenButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarBallpointPenButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarBallpointPenButton, IInkToolbarBallpointPenButton_Ptr);
   begin
      if this.m_IInkToolbarBallpointPenButton /= null then
         if this.m_IInkToolbarBallpointPenButton.all /= null then
            temp := this.m_IInkToolbarBallpointPenButton.all.Release;
            Free (this.m_IInkToolbarBallpointPenButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarBallpointPenButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarBallpointPenButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarBallpointPenButton");
      m_Factory    : access IInkToolbarBallpointPenButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButton;
   begin
      return RetVal : InkToolbarBallpointPenButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarBallpointPenButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarBallpointPenButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarBallpointPenButton;
            Retval.m_IInkToolbarBallpointPenButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarBallpointPenButton

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarCustomPen

   procedure Initialize (this : in out InkToolbarCustomPen) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarCustomPen) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarCustomPen, IInkToolbarCustomPen_Ptr);
   begin
      if this.m_IInkToolbarCustomPen /= null then
         if this.m_IInkToolbarCustomPen.all /= null then
            temp := this.m_IInkToolbarCustomPen.all.Release;
            Free (this.m_IInkToolbarCustomPen);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarCustomPen

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarCustomPen is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarCustomPen");
      m_Factory    : access IInkToolbarCustomPenFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPen;
   begin
      return RetVal : InkToolbarCustomPen do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarCustomPenFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarCustomPen := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPen;
            Retval.m_IInkToolbarCustomPen.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarCustomPen

   function CreateInkDrawingAttributes
   (
      this : in out InkToolbarCustomPen;
      brush : WinUI3.Windows.UI.Xaml.Media.Brush'Class;
      strokeWidth : WinUI3.Double
   )
   return WinUI3.Windows.UI.Input.Inking.InkDrawingAttributes'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkDrawingAttributes;
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkDrawingAttributes do
         Hr := this.m_IInkToolbarCustomPen.all.CreateInkDrawingAttributes (brush.m_IBrush.all, strokeWidth, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkDrawingAttributes := new WinUI3.Windows.UI.Input.Inking.IInkDrawingAttributes;
         Retval.m_IInkDrawingAttributes.all := m_ComRetVal;
      end return;
   end;

   function CreateInkDrawingAttributesCore
   (
      this : in out InkToolbarCustomPen;
      brush : WinUI3.Windows.UI.Xaml.Media.Brush'Class;
      strokeWidth : WinUI3.Double
   )
   return WinUI3.Windows.UI.Input.Inking.InkDrawingAttributes'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPenOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkDrawingAttributes;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPen_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPenOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbarCustomPenOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkDrawingAttributes do
         m_Interface := QInterface (this.m_IInkToolbarCustomPen.all);
         Hr := m_Interface.CreateInkDrawingAttributesCore (brush.m_IBrush.all, strokeWidth, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkDrawingAttributes := new WinUI3.Windows.UI.Input.Inking.IInkDrawingAttributes;
         Retval.m_IInkDrawingAttributes.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarCustomPenButton

   procedure Initialize (this : in out InkToolbarCustomPenButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarCustomPenButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarCustomPenButton, IInkToolbarCustomPenButton_Ptr);
   begin
      if this.m_IInkToolbarCustomPenButton /= null then
         if this.m_IInkToolbarCustomPenButton.all /= null then
            temp := this.m_IInkToolbarCustomPenButton.all.Release;
            Free (this.m_IInkToolbarCustomPenButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarCustomPenButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarCustomPenButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarCustomPenButton");
      m_Factory    : access IInkToolbarCustomPenButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPenButton;
   begin
      return RetVal : InkToolbarCustomPenButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarCustomPenButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarCustomPenButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPenButton;
            Retval.m_IInkToolbarCustomPenButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarCustomPenButton

   function get_CustomPenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarCustomPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarCustomPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CustomPenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ConfigurationContentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarCustomPenButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPenButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarCustomPenButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ConfigurationContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarCustomPenButton

   function get_CustomPen
   (
      this : in out InkToolbarCustomPenButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarCustomPen'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPen;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkToolbarCustomPen do
         Hr := this.m_IInkToolbarCustomPenButton.all.get_CustomPen (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkToolbarCustomPen := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomPen;
         Retval.m_IInkToolbarCustomPen.all := m_ComRetVal;
      end return;
   end;

   procedure put_CustomPen
   (
      this : in out InkToolbarCustomPenButton;
      value : WinUI3.Windows.UI.Xaml.Controls.InkToolbarCustomPen'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarCustomPenButton.all.put_CustomPen (value.m_IInkToolbarCustomPen.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ConfigurationContent
   (
      this : in out InkToolbarCustomPenButton
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IInkToolbarCustomPenButton.all.get_ConfigurationContent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_ConfigurationContent
   (
      this : in out InkToolbarCustomPenButton;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarCustomPenButton.all.put_ConfigurationContent (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarToggleButton

   procedure Initialize (this : in out InkToolbarToggleButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarToggleButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarToggleButton, IInkToolbarToggleButton_Ptr);
   begin
      if this.m_IInkToolbarToggleButton /= null then
         if this.m_IInkToolbarToggleButton.all /= null then
            temp := this.m_IInkToolbarToggleButton.all.Release;
            Free (this.m_IInkToolbarToggleButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarToggleButton

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarToggleButton

   function get_ToggleKind
   (
      this : in out InkToolbarToggleButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarToggle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarToggle;
   begin
      Hr := this.m_IInkToolbarToggleButton.all.get_ToggleKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarCustomToggleButton

   procedure Initialize (this : in out InkToolbarCustomToggleButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarCustomToggleButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarCustomToggleButton, IInkToolbarCustomToggleButton_Ptr);
   begin
      if this.m_IInkToolbarCustomToggleButton /= null then
         if this.m_IInkToolbarCustomToggleButton.all /= null then
            temp := this.m_IInkToolbarCustomToggleButton.all.Release;
            Free (this.m_IInkToolbarCustomToggleButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarCustomToggleButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarCustomToggleButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarCustomToggleButton");
      m_Factory    : access IInkToolbarCustomToggleButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButton;
   begin
      return RetVal : InkToolbarCustomToggleButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarCustomToggleButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarCustomToggleButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomToggleButton;
            Retval.m_IInkToolbarCustomToggleButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarCustomToggleButton

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarCustomToolButton

   procedure Initialize (this : in out InkToolbarCustomToolButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarCustomToolButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarCustomToolButton, IInkToolbarCustomToolButton_Ptr);
   begin
      if this.m_IInkToolbarCustomToolButton /= null then
         if this.m_IInkToolbarCustomToolButton.all /= null then
            temp := this.m_IInkToolbarCustomToolButton.all.Release;
            Free (this.m_IInkToolbarCustomToolButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarCustomToolButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarCustomToolButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarCustomToolButton");
      m_Factory    : access IInkToolbarCustomToolButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomToolButton;
   begin
      return RetVal : InkToolbarCustomToolButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarCustomToolButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarCustomToolButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomToolButton;
            Retval.m_IInkToolbarCustomToolButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarCustomToolButton

   function get_ConfigurationContentProperty_InkToolbarCustomToolButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarCustomToolButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarCustomToolButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarCustomToolButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ConfigurationContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarCustomToolButton

   function get_ConfigurationContent
   (
      this : in out InkToolbarCustomToolButton
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IInkToolbarCustomToolButton.all.get_ConfigurationContent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_ConfigurationContent
   (
      this : in out InkToolbarCustomToolButton;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarCustomToolButton.all.put_ConfigurationContent (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarEraserButton

   procedure Initialize (this : in out InkToolbarEraserButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarEraserButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarEraserButton, IInkToolbarEraserButton_Ptr);
   begin
      if this.m_IInkToolbarEraserButton /= null then
         if this.m_IInkToolbarEraserButton.all /= null then
            temp := this.m_IInkToolbarEraserButton.all.Release;
            Free (this.m_IInkToolbarEraserButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarEraserButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarEraserButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarEraserButton");
      m_Factory    : access IInkToolbarEraserButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton;
   begin
      return RetVal : InkToolbarEraserButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarEraserButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarEraserButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton;
            Retval.m_IInkToolbarEraserButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarEraserButton

   function get_IsClearAllVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarEraserButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButtonStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarEraserButtonStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsClearAllVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarEraserButton

   function get_IsClearAllVisible
   (
      this : in out InkToolbarEraserButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbarEraserButton2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbarEraserButton.all);
      Hr := m_Interface.get_IsClearAllVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsClearAllVisible
   (
      this : in out InkToolbarEraserButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton_Interface, WinUI3.Windows.UI.Xaml.Controls.IInkToolbarEraserButton2, WinUI3.Windows.UI.Xaml.Controls.IID_IInkToolbarEraserButton2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IInkToolbarEraserButton.all);
      Hr := m_Interface.put_IsClearAllVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarFlyoutItem

   procedure Initialize (this : in out InkToolbarFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarFlyoutItem, IInkToolbarFlyoutItem_Ptr);
   begin
      if this.m_IInkToolbarFlyoutItem /= null then
         if this.m_IInkToolbarFlyoutItem.all /= null then
            temp := this.m_IInkToolbarFlyoutItem.all.Release;
            Free (this.m_IInkToolbarFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarFlyoutItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarFlyoutItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarFlyoutItem");
      m_Factory    : access IInkToolbarFlyoutItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarFlyoutItem;
   begin
      return RetVal : InkToolbarFlyoutItem do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarFlyoutItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarFlyoutItem := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarFlyoutItem;
            Retval.m_IInkToolbarFlyoutItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarFlyoutItem

   function get_KindProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KindProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCheckedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarFlyoutItem

   function get_Kind
   (
      this : in out InkToolbarFlyoutItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarFlyoutItemKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarFlyoutItemKind;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.get_Kind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Kind
   (
      this : in out InkToolbarFlyoutItem;
      value : WinUI3.Windows.UI.Xaml.Controls.InkToolbarFlyoutItemKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.put_Kind (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsChecked
   (
      this : in out InkToolbarFlyoutItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.get_IsChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsChecked
   (
      this : in out InkToolbarFlyoutItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.put_IsChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Checked
   (
      this : in out InkToolbarFlyoutItem;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.add_Checked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Checked
   (
      this : in out InkToolbarFlyoutItem;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.remove_Checked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Unchecked
   (
      this : in out InkToolbarFlyoutItem;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.add_Unchecked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Unchecked
   (
      this : in out InkToolbarFlyoutItem;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarFlyoutItem.all.remove_Unchecked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarHighlighterButton

   procedure Initialize (this : in out InkToolbarHighlighterButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarHighlighterButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarHighlighterButton, IInkToolbarHighlighterButton_Ptr);
   begin
      if this.m_IInkToolbarHighlighterButton /= null then
         if this.m_IInkToolbarHighlighterButton.all /= null then
            temp := this.m_IInkToolbarHighlighterButton.all.Release;
            Free (this.m_IInkToolbarHighlighterButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarHighlighterButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarHighlighterButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarHighlighterButton");
      m_Factory    : access IInkToolbarHighlighterButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarHighlighterButton;
   begin
      return RetVal : InkToolbarHighlighterButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarHighlighterButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarHighlighterButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarHighlighterButton;
            Retval.m_IInkToolbarHighlighterButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarHighlighterButton

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarIsStencilButtonCheckedChangedEventArgs

   procedure Initialize (this : in out InkToolbarIsStencilButtonCheckedChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarIsStencilButtonCheckedChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarIsStencilButtonCheckedChangedEventArgs, IInkToolbarIsStencilButtonCheckedChangedEventArgs_Ptr);
   begin
      if this.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs /= null then
         if this.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs.all /= null then
            temp := this.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs.all.Release;
            Free (this.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarIsStencilButtonCheckedChangedEventArgs

   function Constructor return InkToolbarIsStencilButtonCheckedChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarIsStencilButtonCheckedChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarIsStencilButtonCheckedChangedEventArgs;
   begin
      return RetVal : InkToolbarIsStencilButtonCheckedChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarIsStencilButtonCheckedChangedEventArgs;
            Retval.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarIsStencilButtonCheckedChangedEventArgs

   function get_StencilButton
   (
      this : in out InkToolbarIsStencilButtonCheckedChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarStencilButton'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButton;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkToolbarStencilButton do
         Hr := this.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs.all.get_StencilButton (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkToolbarStencilButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButton;
         Retval.m_IInkToolbarStencilButton.all := m_ComRetVal;
      end return;
   end;

   function get_StencilKind
   (
      this : in out InkToolbarIsStencilButtonCheckedChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarStencilKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarStencilKind;
   begin
      Hr := this.m_IInkToolbarIsStencilButtonCheckedChangedEventArgs.all.get_StencilKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarMenuButton

   procedure Initialize (this : in out InkToolbarMenuButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarMenuButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarMenuButton, IInkToolbarMenuButton_Ptr);
   begin
      if this.m_IInkToolbarMenuButton /= null then
         if this.m_IInkToolbarMenuButton.all /= null then
            temp := this.m_IInkToolbarMenuButton.all.Release;
            Free (this.m_IInkToolbarMenuButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarMenuButton

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarMenuButton

   function get_IsExtensionGlyphShownProperty_InkToolbarMenuButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarMenuButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarMenuButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarMenuButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExtensionGlyphShownProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarMenuButton

   function get_MenuKind
   (
      this : in out InkToolbarMenuButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarMenuKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarMenuKind;
   begin
      Hr := this.m_IInkToolbarMenuButton.all.get_MenuKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsExtensionGlyphShown
   (
      this : in out InkToolbarMenuButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInkToolbarMenuButton.all.get_IsExtensionGlyphShown (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExtensionGlyphShown
   (
      this : in out InkToolbarMenuButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarMenuButton.all.put_IsExtensionGlyphShown (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarPenConfigurationControl

   procedure Initialize (this : in out InkToolbarPenConfigurationControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarPenConfigurationControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarPenConfigurationControl, IInkToolbarPenConfigurationControl_Ptr);
   begin
      if this.m_IInkToolbarPenConfigurationControl /= null then
         if this.m_IInkToolbarPenConfigurationControl.all /= null then
            temp := this.m_IInkToolbarPenConfigurationControl.all.Release;
            Free (this.m_IInkToolbarPenConfigurationControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarPenConfigurationControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarPenConfigurationControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenConfigurationControl");
      m_Factory    : access IInkToolbarPenConfigurationControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControl;
   begin
      return RetVal : InkToolbarPenConfigurationControl do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenConfigurationControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarPenConfigurationControl := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControl;
            Retval.m_IInkToolbarPenConfigurationControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarPenConfigurationControl

   function get_PenButtonProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPenConfigurationControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenConfigurationControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPenConfigurationControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PenButtonProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarPenConfigurationControl

   function get_PenButton
   (
      this : in out InkToolbarPenConfigurationControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarPenButton'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButton;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.InkToolbarPenButton do
         Hr := this.m_IInkToolbarPenConfigurationControl.all.get_PenButton (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkToolbarPenButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPenButton;
         Retval.m_IInkToolbarPenButton.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarPencilButton

   procedure Initialize (this : in out InkToolbarPencilButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarPencilButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarPencilButton, IInkToolbarPencilButton_Ptr);
   begin
      if this.m_IInkToolbarPencilButton /= null then
         if this.m_IInkToolbarPencilButton.all /= null then
            temp := this.m_IInkToolbarPencilButton.all.Release;
            Free (this.m_IInkToolbarPencilButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarPencilButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarPencilButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarPencilButton");
      m_Factory    : access IInkToolbarPencilButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPencilButton;
   begin
      return RetVal : InkToolbarPencilButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarPencilButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarPencilButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarPencilButton;
            Retval.m_IInkToolbarPencilButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarPencilButton

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarRulerButton

   procedure Initialize (this : in out InkToolbarRulerButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarRulerButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarRulerButton, IInkToolbarRulerButton_Ptr);
   begin
      if this.m_IInkToolbarRulerButton /= null then
         if this.m_IInkToolbarRulerButton.all /= null then
            temp := this.m_IInkToolbarRulerButton.all.Release;
            Free (this.m_IInkToolbarRulerButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarRulerButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarRulerButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarRulerButton");
      m_Factory    : access IInkToolbarRulerButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarRulerButton;
   begin
      return RetVal : InkToolbarRulerButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarRulerButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarRulerButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarRulerButton;
            Retval.m_IInkToolbarRulerButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarRulerButton

   function get_RulerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarRulerButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarRulerButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarRulerButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RulerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarRulerButton

   function get_Ruler
   (
      this : in out InkToolbarRulerButton
   )
   return WinUI3.Windows.UI.Input.Inking.InkPresenterRuler'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkPresenterRuler;
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkPresenterRuler do
         Hr := this.m_IInkToolbarRulerButton.all.get_Ruler (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkPresenterRuler := new WinUI3.Windows.UI.Input.Inking.IInkPresenterRuler;
         Retval.m_IInkPresenterRuler.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for InkToolbarStencilButton

   procedure Initialize (this : in out InkToolbarStencilButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out InkToolbarStencilButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IInkToolbarStencilButton, IInkToolbarStencilButton_Ptr);
   begin
      if this.m_IInkToolbarStencilButton /= null then
         if this.m_IInkToolbarStencilButton.all /= null then
            temp := this.m_IInkToolbarStencilButton.all.Release;
            Free (this.m_IInkToolbarStencilButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for InkToolbarStencilButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return InkToolbarStencilButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarStencilButton");
      m_Factory    : access IInkToolbarStencilButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButton;
   begin
      return RetVal : InkToolbarStencilButton do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStencilButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IInkToolbarStencilButton := new WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButton;
            Retval.m_IInkToolbarStencilButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for InkToolbarStencilButton

   function get_RulerProperty_InkToolbarStencilButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarStencilButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStencilButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RulerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProtractorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarStencilButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStencilButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProtractorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedStencilProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarStencilButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStencilButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedStencilProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRulerItemVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarStencilButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStencilButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRulerItemVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsProtractorItemVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.InkToolbarStencilButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IInkToolbarStencilButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IInkToolbarStencilButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsProtractorItemVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for InkToolbarStencilButton

   function get_Ruler
   (
      this : in out InkToolbarStencilButton
   )
   return WinUI3.Windows.UI.Input.Inking.InkPresenterRuler'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkPresenterRuler;
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkPresenterRuler do
         Hr := this.m_IInkToolbarStencilButton.all.get_Ruler (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkPresenterRuler := new WinUI3.Windows.UI.Input.Inking.IInkPresenterRuler;
         Retval.m_IInkPresenterRuler.all := m_ComRetVal;
      end return;
   end;

   function get_Protractor
   (
      this : in out InkToolbarStencilButton
   )
   return WinUI3.Windows.UI.Input.Inking.InkPresenterProtractor'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Input.Inking.IInkPresenterProtractor;
   begin
      return RetVal : WinUI3.Windows.UI.Input.Inking.InkPresenterProtractor do
         Hr := this.m_IInkToolbarStencilButton.all.get_Protractor (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInkPresenterProtractor := new WinUI3.Windows.UI.Input.Inking.IInkPresenterProtractor;
         Retval.m_IInkPresenterProtractor.all := m_ComRetVal;
      end return;
   end;

   function get_SelectedStencil
   (
      this : in out InkToolbarStencilButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.InkToolbarStencilKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.InkToolbarStencilKind;
   begin
      Hr := this.m_IInkToolbarStencilButton.all.get_SelectedStencil (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedStencil
   (
      this : in out InkToolbarStencilButton;
      value : WinUI3.Windows.UI.Xaml.Controls.InkToolbarStencilKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarStencilButton.all.put_SelectedStencil (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsRulerItemVisible
   (
      this : in out InkToolbarStencilButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInkToolbarStencilButton.all.get_IsRulerItemVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRulerItemVisible
   (
      this : in out InkToolbarStencilButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarStencilButton.all.put_IsRulerItemVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsProtractorItemVisible
   (
      this : in out InkToolbarStencilButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IInkToolbarStencilButton.all.get_IsProtractorItemVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsProtractorItemVisible
   (
      this : in out InkToolbarStencilButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IInkToolbarStencilButton.all.put_IsProtractorItemVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for IsTextTrimmedChangedEventArgs

   procedure Initialize (this : in out IsTextTrimmedChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out IsTextTrimmedChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IIsTextTrimmedChangedEventArgs, IIsTextTrimmedChangedEventArgs_Ptr);
   begin
      if this.m_IIsTextTrimmedChangedEventArgs /= null then
         if this.m_IIsTextTrimmedChangedEventArgs.all /= null then
            temp := this.m_IIsTextTrimmedChangedEventArgs.all.Release;
            Free (this.m_IIsTextTrimmedChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for IsTextTrimmedChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemClickEventArgs

   procedure Initialize (this : in out ItemClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemClickEventArgs, IItemClickEventArgs_Ptr);
   begin
      if this.m_IItemClickEventArgs /= null then
         if this.m_IItemClickEventArgs.all /= null then
            temp := this.m_IItemClickEventArgs.all.Release;
            Free (this.m_IItemClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemClickEventArgs

   function Constructor return ItemClickEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemClickEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IItemClickEventArgs;
   begin
      return RetVal : ItemClickEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemClickEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IItemClickEventArgs;
            Retval.m_IItemClickEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemClickEventArgs

   function get_ClickedItem
   (
      this : in out ItemClickEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemClickEventArgs.all.get_ClickedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ItemClickEventHandler

   function Invoke
   (
      this : access ItemClickEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.IItemClickEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemCollection

   procedure Initialize (this : in out ItemCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemCollection

   -- Generic Interface Windows.Foundation.Collections.IObservableVector`1<System.Object>
   function add_VectorChanged
   (
      this : in out ItemCollection;
      vhnd : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IObservableVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      m_GenericIID     : aliased WinUI3.IID := (2072102250, 2437, 20877, (186, 169, 13, 169, 174, 0, 159, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IObservableVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.add_VectorChanged (vhnd, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VectorChanged
   (
      this : in out ItemCollection;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IObservableVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2072102250, 2437, 20877, (186, 169, 13, 169, 174, 0, 159, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IObservableVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.remove_VectorChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<System.Object>
   function GetAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Size
   (
      this : in out ItemCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out ItemCollection
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetView (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexOf
   (
      this : in out ItemCollection;
      value : WinUI3.IInspectable;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out ItemCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out ItemCollection;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out ItemCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out ItemCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out ItemCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.IInspectable_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out ItemCollection;
      items : WinUI3.IInspectable_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3005996196, 24146, 23335, (188, 93, 214, 106, 26, 38, 140, 42 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IInspectable.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<System.Object>
   function First
   (
      this : in out ItemCollection
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IInspectable.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      m_GenericIID     : aliased WinUI3.IID := (153846939, 24753, 21182, (164, 74, 111, 232, 233, 51, 203, 228 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IInspectable.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.First (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemContainerGenerator

   procedure Initialize (this : in out ItemContainerGenerator) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemContainerGenerator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemContainerGenerator, IItemContainerGenerator_Ptr);
   begin
      if this.m_IItemContainerGenerator /= null then
         if this.m_IItemContainerGenerator.all /= null then
            temp := this.m_IItemContainerGenerator.all.Release;
            Free (this.m_IItemContainerGenerator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemContainerGenerator

   function add_ItemsChanged
   (
      this : in out ItemContainerGenerator;
      handler : WinUI3.Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IItemContainerGenerator.all.add_ItemsChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemsChanged
   (
      this : in out ItemContainerGenerator;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.remove_ItemsChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ItemFromContainer
   (
      this : in out ItemContainerGenerator;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemContainerGenerator.all.ItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromItem
   (
      this : in out ItemContainerGenerator;
      item : WinUI3.IInspectable
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IItemContainerGenerator.all.ContainerFromItem (item, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function IndexFromContainer
   (
      this : in out ItemContainerGenerator;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemContainerGenerator.all.IndexFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromIndex
   (
      this : in out ItemContainerGenerator;
      index : WinUI3.Int32
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IItemContainerGenerator.all.ContainerFromIndex (index, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function GetItemContainerGeneratorForPanel
   (
      this : in out ItemContainerGenerator;
      panel_p : WinUI3.Windows.UI.Xaml.Controls.Panel'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemContainerGenerator'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IItemContainerGenerator;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemContainerGenerator do
         Hr := this.m_IItemContainerGenerator.all.GetItemContainerGeneratorForPanel (panel_p.m_IPanel.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemContainerGenerator := new WinUI3.Windows.UI.Xaml.Controls.IItemContainerGenerator;
         Retval.m_IItemContainerGenerator.all := m_ComRetVal;
      end return;
   end;

   procedure StartAt
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
      direction : WinUI3.Windows.UI.Xaml.Controls.Primitives.GeneratorDirection;
      allowStartAtRealizedItem : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.StartAt (position, direction, allowStartAtRealizedItem);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out ItemContainerGenerator
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GenerateNext
   (
      this : in out ItemContainerGenerator;
      isNewlyRealized : WinUI3.Boolean_Ptr
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_IItemContainerGenerator.all.GenerateNext (isNewlyRealized, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure PrepareItemContainer
   (
      this : in out ItemContainerGenerator;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.PrepareItemContainer (container.m_IDependencyObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAll
   (
      this : in out ItemContainerGenerator
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.RemoveAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Remove
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
      count : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.Remove (position, count);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GeneratorPositionFromIndex
   (
      this : in out ItemContainerGenerator;
      itemIndex : WinUI3.Int32
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.GeneratorPosition is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
   begin
      Hr := this.m_IItemContainerGenerator.all.GeneratorPositionFromIndex (itemIndex, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IndexFromGeneratorPosition
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Windows.UI.Xaml.Controls.Primitives.GeneratorPosition
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemContainerGenerator.all.IndexFromGeneratorPosition (position, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Recycle
   (
      this : in out ItemContainerGenerator;
      position : WinUI3.Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
      count : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemContainerGenerator.all.Recycle (position, count);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsPanelTemplate

   procedure Initialize (this : in out ItemsPanelTemplate) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsPanelTemplate) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsPanelTemplate, IItemsPanelTemplate_Ptr);
   begin
      if this.m_IItemsPanelTemplate /= null then
         if this.m_IItemsPanelTemplate.all /= null then
            temp := this.m_IItemsPanelTemplate.all.Release;
            Free (this.m_IItemsPanelTemplate);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsPanelTemplate

   function Constructor return ItemsPanelTemplate is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPanelTemplate");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsPanelTemplate;
   begin
      return RetVal : ItemsPanelTemplate do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsPanelTemplate := new WinUI3.Windows.UI.Xaml.Controls.IItemsPanelTemplate;
            Retval.m_IItemsPanelTemplate.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsPanelTemplate

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsPickedEventArgs

   procedure Initialize (this : in out ItemsPickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsPickedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsPickedEventArgs, IItemsPickedEventArgs_Ptr);
   begin
      if this.m_IItemsPickedEventArgs /= null then
         if this.m_IItemsPickedEventArgs.all /= null then
            temp := this.m_IItemsPickedEventArgs.all.Release;
            Free (this.m_IItemsPickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsPickedEventArgs

   function Constructor return ItemsPickedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPickedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsPickedEventArgs;
   begin
      return RetVal : ItemsPickedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsPickedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IItemsPickedEventArgs;
            Retval.m_IItemsPickedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsPickedEventArgs

   function get_AddedItems
   (
      this : in out ItemsPickedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IItemsPickedEventArgs.all.get_AddedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedItems
   (
      this : in out ItemsPickedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IItemsPickedEventArgs.all.get_RemovedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsPresenter

   procedure Initialize (this : in out ItemsPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsPresenter, IItemsPresenter_Ptr);
   begin
      if this.m_IItemsPresenter /= null then
         if this.m_IItemsPresenter.all /= null then
            temp := this.m_IItemsPresenter.all.Release;
            Free (this.m_IItemsPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsPresenter

   function Constructor return ItemsPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter;
   begin
      return RetVal : ItemsPresenter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsPresenter := new WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter;
            Retval.m_IItemsPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsPresenter

   function get_FooterProperty_ItemsPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTemplateProperty_ItemsPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FooterTransitionsProperty_ItemsPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FooterTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_ItemsPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ItemsPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTransitionsProperty_ItemsPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_ItemsPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsPresenter

   function get_Header
   (
      this : in out ItemsPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IItemsPresenter.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ItemsPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IItemsPresenter.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ItemsPresenter;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTransitions
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         Hr := this.m_IItemsPresenter.all.get_HeaderTransitions (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTransitions
   (
      this : in out ItemsPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_HeaderTransitions (value.m_GenericObject.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IItemsPresenter.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out ItemsPresenter;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsPresenter.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Footer
   (
      this : in out ItemsPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.get_Footer (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Footer
   (
      this : in out ItemsPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.put_Footer (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTemplate
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsPresenter2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IItemsPresenter.all);
         Hr := m_Interface.get_FooterTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTemplate
   (
      this : in out ItemsPresenter;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.put_FooterTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FooterTransitions
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsPresenter2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         m_Interface := QInterface (this.m_IItemsPresenter.all);
         Hr := m_Interface.get_FooterTransitions (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_FooterTransitions
   (
      this : in out ItemsPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.put_FooterTransitions (value.m_GenericObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out ItemsPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out ItemsPresenter;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out ItemsPresenter;
      orientation : WinUI3.Windows.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out ItemsPresenter;
      orientation : WinUI3.Windows.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsPresenter.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsStackPanel

   procedure Initialize (this : in out ItemsStackPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsStackPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsStackPanel, IItemsStackPanel_Ptr);
   begin
      if this.m_IItemsStackPanel /= null then
         if this.m_IItemsStackPanel.all /= null then
            temp := this.m_IItemsStackPanel.all.Release;
            Free (this.m_IItemsStackPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsStackPanel

   function Constructor return ItemsStackPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsStackPanel");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel;
   begin
      return RetVal : ItemsStackPanel do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsStackPanel := new WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel;
            Retval.m_IItemsStackPanel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsStackPanel

   function get_GroupPaddingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_ItemsStackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GroupHeaderPlacementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupHeaderPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CacheLengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CacheLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreStickyGroupHeadersEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanelStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsStackPanelStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreStickyGroupHeadersEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsStackPanel

   function get_GroupPadding
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IItemsStackPanel.all.get_GroupPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupPadding
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_GroupPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IItemsStackPanel.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstCacheIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_FirstCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_FirstVisibleIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_FirstVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastVisibleIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_LastVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastCacheIndex
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsStackPanel.all.get_LastCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollingDirection
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.PanelScrollingDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.PanelScrollingDirection;
   begin
      Hr := this.m_IItemsStackPanel.all.get_ScrollingDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_GroupHeaderPlacement
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.GroupHeaderPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.GroupHeaderPlacement;
   begin
      Hr := this.m_IItemsStackPanel.all.get_GroupHeaderPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupHeaderPlacement
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.GroupHeaderPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_GroupHeaderPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsUpdatingScrollMode
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemsUpdatingScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ItemsUpdatingScrollMode;
   begin
      Hr := this.m_IItemsStackPanel.all.get_ItemsUpdatingScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsUpdatingScrollMode
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Windows.UI.Xaml.Controls.ItemsUpdatingScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_ItemsUpdatingScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CacheLength
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsStackPanel.all.get_CacheLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CacheLength
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsStackPanel.all.put_CacheLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsStackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsStackPanel.all);
      Hr := m_Interface.get_AreStickyGroupHeadersEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsStackPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsStackPanel.all);
      Hr := m_Interface.put_AreStickyGroupHeadersEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ItemsWrapGrid

   procedure Initialize (this : in out ItemsWrapGrid) is
   begin
      null;
   end;

   procedure Finalize (this : in out ItemsWrapGrid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IItemsWrapGrid, IItemsWrapGrid_Ptr);
   begin
      if this.m_IItemsWrapGrid /= null then
         if this.m_IItemsWrapGrid.all /= null then
            temp := this.m_IItemsWrapGrid.all.Release;
            Free (this.m_IItemsWrapGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ItemsWrapGrid

   function Constructor return ItemsWrapGrid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid;
   begin
      return RetVal : ItemsWrapGrid do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IItemsWrapGrid := new WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid;
            Retval.m_IItemsWrapGrid.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ItemsWrapGrid

   function get_GroupPaddingProperty_ItemsWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_ItemsWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumRowsOrColumnsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumRowsOrColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GroupHeaderPlacementProperty_ItemsWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GroupHeaderPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CacheLengthProperty_ItemsWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CacheLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreStickyGroupHeadersEnabledProperty_ItemsWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ItemsWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGridStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IItemsWrapGridStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreStickyGroupHeadersEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ItemsWrapGrid

   function get_GroupPadding
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_GroupPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupPadding
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_GroupPadding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaximumRowsOrColumns
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_MaximumRowsOrColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaximumRowsOrColumns
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_MaximumRowsOrColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemWidth
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_ItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemWidth
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_ItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemHeight
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_ItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemHeight
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_ItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FirstCacheIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_FirstCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_FirstVisibleIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_FirstVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastVisibleIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_LastVisibleIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LastCacheIndex
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_LastCacheIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollingDirection
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Windows.UI.Xaml.Controls.PanelScrollingDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.PanelScrollingDirection;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_ScrollingDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_GroupHeaderPlacement
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.GroupHeaderPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.GroupHeaderPlacement;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_GroupHeaderPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GroupHeaderPlacement
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.GroupHeaderPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_GroupHeaderPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CacheLength
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IItemsWrapGrid.all.get_CacheLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CacheLength
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IItemsWrapGrid.all.put_CacheLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsWrapGrid
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsWrapGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsWrapGrid.all);
      Hr := m_Interface.get_AreStickyGroupHeadersEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreStickyGroupHeadersEnabled
   (
      this : in out ItemsWrapGrid;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid_Interface, WinUI3.Windows.UI.Xaml.Controls.IItemsWrapGrid2, WinUI3.Windows.UI.Xaml.Controls.IID_IItemsWrapGrid2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IItemsWrapGrid.all);
      Hr := m_Interface.put_AreStickyGroupHeadersEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListBox

   procedure Initialize (this : in out ListBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListBox, IListBox_Ptr);
   begin
      if this.m_IListBox /= null then
         if this.m_IListBox.all /= null then
            temp := this.m_IListBox.all.Release;
            Free (this.m_IListBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListBox");
      m_Factory    : access IListBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IListBox;
   begin
      return RetVal : ListBox do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListBox := new WinUI3.Windows.UI.Xaml.Controls.IListBox;
            Retval.m_IListBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListBox

   function get_SelectionModeProperty_ListBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SingleSelectionFollowsFocusProperty_ListBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SingleSelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListBox

   function get_SelectedItems
   (
      this : in out ListBox
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IListBox.all.get_SelectedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out ListBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.SelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SelectionMode;
   begin
      Hr := this.m_IListBox.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out ListBox;
      value : WinUI3.Windows.UI.Xaml.Controls.SelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListBox.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollIntoView
   (
      this : in out ListBox;
      item : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListBox.all.ScrollIntoView (item);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out ListBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListBox.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SingleSelectionFollowsFocus
   (
      this : in out ListBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IListBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IListBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListBox.all);
      Hr := m_Interface.get_SingleSelectionFollowsFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SingleSelectionFollowsFocus
   (
      this : in out ListBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IListBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IListBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IListBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IListBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IListBox.all);
      Hr := m_Interface.put_SingleSelectionFollowsFocus (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListBoxItem

   procedure Initialize (this : in out ListBoxItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListBoxItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListBoxItem, IListBoxItem_Ptr);
   begin
      if this.m_IListBoxItem /= null then
         if this.m_IListBoxItem.all /= null then
            temp := this.m_IListBoxItem.all.Release;
            Free (this.m_IListBoxItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListBoxItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListBoxItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListBoxItem");
      m_Factory    : access IListBoxItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IListBoxItem;
   begin
      return RetVal : ListBoxItem do
         Hr := RoGetActivationFactory (m_hString, IID_IListBoxItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListBoxItem := new WinUI3.Windows.UI.Xaml.Controls.IListBoxItem;
            Retval.m_IListBoxItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListBoxItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListPickerFlyout

   procedure Initialize (this : in out ListPickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListPickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListPickerFlyout, IListPickerFlyout_Ptr);
   begin
      if this.m_IListPickerFlyout /= null then
         if this.m_IListPickerFlyout.all /= null then
            temp := this.m_IListPickerFlyout.all.Release;
            Free (this.m_IListPickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListPickerFlyout

   function Constructor return ListPickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyout;
   begin
      return RetVal : ListPickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IListPickerFlyout := new WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyout;
            Retval.m_IListPickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListPickerFlyout

   function get_ItemsSourceProperty_ListPickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_ListPickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayMemberPathProperty_ListPickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayMemberPathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionModeProperty_ListPickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedIndexProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedValuePathProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListPickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IListPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedValuePathProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListPickerFlyout

   function get_ItemsSource
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListPickerFlyout.all.get_ItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out ListPickerFlyout;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_ItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplate
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IListPickerFlyout.all.get_ItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out ListPickerFlyout;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_ItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMemberPath
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IListPickerFlyout.all.get_DisplayMemberPath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisplayMemberPath
   (
      this : in out ListPickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IListPickerFlyout.all.put_DisplayMemberPath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionMode
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.Windows.UI.Xaml.Controls.ListPickerFlyoutSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ListPickerFlyoutSelectionMode;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out ListPickerFlyout;
      value : WinUI3.Windows.UI.Xaml.Controls.ListPickerFlyoutSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedIndex
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out ListPickerFlyout;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out ListPickerFlyout;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedValue
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedValue
   (
      this : in out ListPickerFlyout;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedValuePath
   (
      this : in out ListPickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedValuePath (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SelectedValuePath
   (
      this : in out ListPickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IListPickerFlyout.all.put_SelectedValuePath (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectedItems
   (
      this : in out ListPickerFlyout
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_IListPickerFlyout.all.get_SelectedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_ItemsPicked
   (
      this : in out ListPickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IListPickerFlyout.all.add_ItemsPicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemsPicked
   (
      this : in out ListPickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IListPickerFlyout.all.remove_ItemsPicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out ListPickerFlyout;
      target : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (3597783858, 8874, 21911, (141, 204, 36, 89, 234, 180, 148, 24 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (639278465, 62863, 21123, (148, 97, 202, 62, 49, 193, 18, 60 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IListPickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListPickerFlyoutPresenter

   procedure Initialize (this : in out ListPickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListPickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListPickerFlyoutPresenter, IListPickerFlyoutPresenter_Ptr);
   begin
      if this.m_IListPickerFlyoutPresenter /= null then
         if this.m_IListPickerFlyoutPresenter.all /= null then
            temp := this.m_IListPickerFlyoutPresenter.all.Release;
            Free (this.m_IListPickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListPickerFlyoutPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListView

   procedure Initialize (this : in out ListView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListView, IListView_Ptr);
   begin
      if this.m_IListView /= null then
         if this.m_IListView.all /= null then
            temp := this.m_IListView.all.Release;
            Free (this.m_IListView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListView");
      m_Factory    : access IListViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IListView;
   begin
      return RetVal : ListView do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListView := new WinUI3.Windows.UI.Xaml.Controls.IListView;
            Retval.m_IListView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListView

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewHeaderItem

   procedure Initialize (this : in out ListViewHeaderItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewHeaderItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewHeaderItem, IListViewHeaderItem_Ptr);
   begin
      if this.m_IListViewHeaderItem /= null then
         if this.m_IListViewHeaderItem.all /= null then
            temp := this.m_IListViewHeaderItem.all.Release;
            Free (this.m_IListViewHeaderItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewHeaderItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListViewHeaderItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewHeaderItem");
      m_Factory    : access IListViewHeaderItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IListViewHeaderItem;
   begin
      return RetVal : ListViewHeaderItem do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewHeaderItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListViewHeaderItem := new WinUI3.Windows.UI.Xaml.Controls.IListViewHeaderItem;
            Retval.m_IListViewHeaderItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewHeaderItem

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewItem

   procedure Initialize (this : in out ListViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewItem, IListViewItem_Ptr);
   begin
      if this.m_IListViewItem /= null then
         if this.m_IListViewItem.all /= null then
            temp := this.m_IListViewItem.all.Release;
            Free (this.m_IListViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ListViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ListViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewItem");
      m_Factory    : access IListViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IListViewItem;
   begin
      return RetVal : ListViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_IListViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IListViewItem := new WinUI3.Windows.UI.Xaml.Controls.IListViewItem;
            Retval.m_IListViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewItem

   function get_TemplateSettings
   (
      this : in out ListViewItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IListViewItemTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings do
         Hr := this.m_IListViewItem.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IListViewItemTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IListViewItemTemplateSettings;
         Retval.m_IListViewItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ListViewItemToKeyHandler

   function Invoke
   (
      this : access ListViewItemToKeyHandler_Delegate;
      item : WinUI3.IInspectable
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (item);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- Delegate ListViewKeyToItemHandler

   function Invoke
   (
      this : access ListViewKeyToItemHandler_Delegate;
      key : WinUI3.HString
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (key);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ListViewPersistenceHelper

   procedure Initialize (this : in out ListViewPersistenceHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out ListViewPersistenceHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IListViewPersistenceHelper, IListViewPersistenceHelper_Ptr);
   begin
      if this.m_IListViewPersistenceHelper /= null then
         if this.m_IListViewPersistenceHelper.all /= null then
            temp := this.m_IListViewPersistenceHelper.all.Release;
            Free (this.m_IListViewPersistenceHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ListViewPersistenceHelper

   function GetRelativeScrollPosition
   (
      listViewBase_p : WinUI3.Windows.UI.Xaml.Controls.ListViewBase'Class;
      itemToKeyHandler : WinUI3.Windows.UI.Xaml.Controls.ListViewItemToKeyHandler
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewPersistenceHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewPersistenceHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IListViewPersistenceHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRelativeScrollPosition (listViewBase_p.m_IListViewBase.all, itemToKeyHandler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure SetRelativeScrollPositionAsync
   (
      listViewBase_p : WinUI3.Windows.UI.Xaml.Controls.ListViewBase'Class;
      relativeScrollPosition : WinUI3.WString;
      keyToItemHandler : WinUI3.Windows.UI.Xaml.Controls.ListViewKeyToItemHandler
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ListViewPersistenceHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IListViewPersistenceHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_relativeScrollPosition : constant WinUI3.HString := To_HString (relativeScrollPosition);
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IListViewPersistenceHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRelativeScrollPositionAsync (listViewBase_p.m_IListViewBase.all, HStr_relativeScrollPosition, keyToItemHandler, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr = S_OK then
            m_Captured := m_Completed;
            Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            temp := m_ComRetVal.Release;
            temp := m_CompletedHandler.Release;
            if temp = 0 then
               Free (m_CompletedHandler);
            end if;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      tmp := WindowsDeleteString (HStr_relativeScrollPosition);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ListViewPersistenceHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaElement

   procedure Initialize (this : in out MediaElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaElement, IMediaElement_Ptr);
   begin
      if this.m_IMediaElement /= null then
         if this.m_IMediaElement.all /= null then
            temp := this.m_IMediaElement.all.Release;
            Free (this.m_IMediaElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MediaElement

   function Constructor return MediaElement is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMediaElement;
   begin
      return RetVal : MediaElement do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMediaElement := new WinUI3.Windows.UI.Xaml.Controls.IMediaElement;
            Retval.m_IMediaElement.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaElement

   function get_PosterSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PosterSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SourceProperty_MediaElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsMutedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsMutedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsAudioOnlyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsAudioOnlyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoPlayProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoPlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VolumeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VolumeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BalanceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BalanceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NaturalVideoHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NaturalVideoHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NaturalVideoWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NaturalVideoWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_NaturalDurationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_NaturalDurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PositionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PositionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DownloadProgressProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DownloadProgressProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BufferingProgressProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BufferingProgressProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DownloadProgressOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DownloadProgressOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CurrentStateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CurrentStateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanSeekProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanSeekProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanPauseProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanPauseProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AudioStreamCountProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AudioStreamCountProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AudioStreamIndexProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AudioStreamIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaybackRateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaybackRateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsLoopingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsLoopingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlayToSourceProperty_MediaElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlayToSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultPlaybackRateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultPlaybackRateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AspectRatioWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AspectRatioWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AspectRatioHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AspectRatioHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RealTimePlaybackProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RealTimePlaybackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AudioCategoryProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AudioCategoryProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AudioDeviceTypeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AudioDeviceTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProtectionManagerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProtectionManagerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Stereo3DVideoPackingModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Stereo3DVideoPackingModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Stereo3DVideoRenderModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Stereo3DVideoRenderModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStereo3DVideoProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStereo3DVideoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ActualStereo3DVideoPackingModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ActualStereo3DVideoPackingModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreTransportControlsEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreTransportControlsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty_MediaElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFullWindowProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFullWindowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlayToPreferredSourceUriProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaElementStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaElementStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlayToPreferredSourceUriProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaElement

   function get_PosterSource
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IMediaElement.all.get_PosterSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PosterSource
   (
      this : in out MediaElement;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_PosterSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IMediaElement.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out MediaElement;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_Source (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsMuted
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_IsMuted (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsMuted
   (
      this : in out MediaElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_IsMuted (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsAudioOnly
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_IsAudioOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AutoPlay
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_AutoPlay (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoPlay
   (
      this : in out MediaElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_AutoPlay (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Volume
   (
      this : in out MediaElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMediaElement.all.get_Volume (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Volume
   (
      this : in out MediaElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_Volume (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Balance
   (
      this : in out MediaElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMediaElement.all.get_Balance (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Balance
   (
      this : in out MediaElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_Balance (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_NaturalVideoHeight
   (
      this : in out MediaElement
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IMediaElement.all.get_NaturalVideoHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NaturalVideoWidth
   (
      this : in out MediaElement
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IMediaElement.all.get_NaturalVideoWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NaturalDuration
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Duration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Duration;
   begin
      Hr := this.m_IMediaElement.all.get_NaturalDuration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Position
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IMediaElement.all.get_Position (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Position
   (
      this : in out MediaElement;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_Position (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DownloadProgress
   (
      this : in out MediaElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMediaElement.all.get_DownloadProgress (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BufferingProgress
   (
      this : in out MediaElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMediaElement.all.get_BufferingProgress (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DownloadProgressOffset
   (
      this : in out MediaElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMediaElement.all.get_DownloadProgressOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CurrentState
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.MediaElementState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.MediaElementState;
   begin
      Hr := this.m_IMediaElement.all.get_CurrentState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Markers
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.TimelineMarkerCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.TimelineMarkerCollection do
         Hr := this.m_IMediaElement.all.get_Markers (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_CanSeek
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_CanSeek (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanPause
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_CanPause (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AudioStreamCount
   (
      this : in out MediaElement
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IMediaElement.all.get_AudioStreamCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AudioStreamIndex
   (
      this : in out MediaElement
   )
   return IReference_Int32.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Int32.Kind;
   begin
      Hr := this.m_IMediaElement.all.get_AudioStreamIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Int32 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_AudioStreamIndex
   (
      this : in out MediaElement;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_AudioStreamIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaybackRate
   (
      this : in out MediaElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMediaElement.all.get_PlaybackRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PlaybackRate
   (
      this : in out MediaElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_PlaybackRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsLooping
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_IsLooping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsLooping
   (
      this : in out MediaElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_IsLooping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlayToSource
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.Media.PlayTo.PlayToSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.PlayTo.IPlayToSource;
   begin
      return RetVal : WinUI3.Windows.Media.PlayTo.PlayToSource do
         Hr := this.m_IMediaElement.all.get_PlayToSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPlayToSource := new WinUI3.Windows.Media.PlayTo.IPlayToSource;
         Retval.m_IPlayToSource.all := m_ComRetVal;
      end return;
   end;

   function get_DefaultPlaybackRate
   (
      this : in out MediaElement
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IMediaElement.all.get_DefaultPlaybackRate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultPlaybackRate
   (
      this : in out MediaElement;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_DefaultPlaybackRate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AspectRatioWidth
   (
      this : in out MediaElement
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IMediaElement.all.get_AspectRatioWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AspectRatioHeight
   (
      this : in out MediaElement
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IMediaElement.all.get_AspectRatioHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_RealTimePlayback
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_RealTimePlayback (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RealTimePlayback
   (
      this : in out MediaElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_RealTimePlayback (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AudioCategory
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.AudioCategory is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.AudioCategory;
   begin
      Hr := this.m_IMediaElement.all.get_AudioCategory (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AudioCategory
   (
      this : in out MediaElement;
      value : WinUI3.Windows.UI.Xaml.Media.AudioCategory
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_AudioCategory (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AudioDeviceType
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.AudioDeviceType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.AudioDeviceType;
   begin
      Hr := this.m_IMediaElement.all.get_AudioDeviceType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AudioDeviceType
   (
      this : in out MediaElement;
      value : WinUI3.Windows.UI.Xaml.Media.AudioDeviceType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_AudioDeviceType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProtectionManager
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.Media.Protection.MediaProtectionManager'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Protection.IMediaProtectionManager;
   begin
      return RetVal : WinUI3.Windows.Media.Protection.MediaProtectionManager do
         Hr := this.m_IMediaElement.all.get_ProtectionManager (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaProtectionManager := new WinUI3.Windows.Media.Protection.IMediaProtectionManager;
         Retval.m_IMediaProtectionManager.all := m_ComRetVal;
      end return;
   end;

   procedure put_ProtectionManager
   (
      this : in out MediaElement;
      value : WinUI3.Windows.Media.Protection.MediaProtectionManager'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_ProtectionManager (value.m_IMediaProtectionManager.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stereo3DVideoPackingMode
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoPackingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoPackingMode;
   begin
      Hr := this.m_IMediaElement.all.get_Stereo3DVideoPackingMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stereo3DVideoPackingMode
   (
      this : in out MediaElement;
      value : WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoPackingMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_Stereo3DVideoPackingMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stereo3DVideoRenderMode
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoRenderMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoRenderMode;
   begin
      Hr := this.m_IMediaElement.all.get_Stereo3DVideoRenderMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stereo3DVideoRenderMode
   (
      this : in out MediaElement;
      value : WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoRenderMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.put_Stereo3DVideoRenderMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStereo3DVideo
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaElement.all.get_IsStereo3DVideo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_MediaOpened
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_MediaOpened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MediaOpened
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_MediaOpened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MediaEnded
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_MediaEnded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MediaEnded
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_MediaEnded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MediaFailed
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.ExceptionRoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_MediaFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MediaFailed
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_MediaFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DownloadProgressChanged
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_DownloadProgressChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DownloadProgressChanged
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_DownloadProgressChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BufferingProgressChanged
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_BufferingProgressChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BufferingProgressChanged
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_BufferingProgressChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CurrentStateChanged
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_CurrentStateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CurrentStateChanged
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_CurrentStateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_MarkerReached
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_MarkerReached (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_MarkerReached
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_MarkerReached (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RateChanged
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.Media.RateChangedRoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_RateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RateChanged
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_RateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VolumeChanged
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_VolumeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VolumeChanged
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_VolumeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SeekCompleted
   (
      this : in out MediaElement;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMediaElement.all.add_SeekCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SeekCompleted
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.remove_SeekCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out MediaElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.Stop;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Play
   (
      this : in out MediaElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.Play;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Pause
   (
      this : in out MediaElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.Pause;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CanPlayType
   (
      this : in out MediaElement;
      type_x : WinUI3.WString
   )
   return WinUI3.Windows.UI.Xaml.Media.MediaCanPlayResponse is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.MediaCanPlayResponse;
      HStr_type_x : constant WinUI3.HString := To_HString (type_x);
   begin
      Hr := this.m_IMediaElement.all.CanPlayType (HStr_type_x, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_type_x);
      return m_ComRetVal;
   end;

   procedure SetSource
   (
      this : in out MediaElement;
      stream : WinUI3.Windows.Storage.Streams.IRandomAccessStream;
      mimeType : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_mimeType : constant WinUI3.HString := To_HString (mimeType);
   begin
      Hr := this.m_IMediaElement.all.SetSource (stream, HStr_mimeType);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_mimeType);
   end;

   function GetAudioStreamLanguage
   (
      this : in out MediaElement;
      index : GenericObject
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMediaElement.all.GetAudioStreamLanguage (index, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure AddAudioEffect
   (
      this : in out MediaElement;
      effectID : WinUI3.WString;
      effectOptional : WinUI3.Boolean;
      effectConfiguration : WinUI3.Windows.Foundation.Collections.IPropertySet
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_effectID : constant WinUI3.HString := To_HString (effectID);
   begin
      Hr := this.m_IMediaElement.all.AddAudioEffect (HStr_effectID, effectOptional, effectConfiguration);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_effectID);
   end;

   procedure AddVideoEffect
   (
      this : in out MediaElement;
      effectID : WinUI3.WString;
      effectOptional : WinUI3.Boolean;
      effectConfiguration : WinUI3.Windows.Foundation.Collections.IPropertySet
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_effectID : constant WinUI3.HString := To_HString (effectID);
   begin
      Hr := this.m_IMediaElement.all.AddVideoEffect (HStr_effectID, effectOptional, effectConfiguration);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_effectID);
   end;

   procedure RemoveAllEffects
   (
      this : in out MediaElement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaElement.all.RemoveAllEffects;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualStereo3DVideoPackingMode
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoPackingMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stereo3DVideoPackingMode;
   begin
      Hr := this.m_IMediaElement.all.get_ActualStereo3DVideoPackingMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreTransportControlsEnabled
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.get_AreTransportControlsEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreTransportControlsEnabled
   (
      this : in out MediaElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.put_AreTransportControlsEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stretch;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.get_Stretch (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out MediaElement;
      value : WinUI3.Windows.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.put_Stretch (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFullWindow
   (
      this : in out MediaElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.get_IsFullWindow (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFullWindow
   (
      this : in out MediaElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.put_IsFullWindow (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetMediaStreamSource
   (
      this : in out MediaElement;
      source : WinUI3.Windows.Media.Core.IMediaSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.SetMediaStreamSource (source);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlayToPreferredSourceUri
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         m_Interface := QInterface (this.m_IMediaElement.all);
         Hr := m_Interface.get_PlayToPreferredSourceUri (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlayToPreferredSourceUri
   (
      this : in out MediaElement;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.put_PlayToPreferredSourceUri (value.m_IUriRuntimeClass.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransportControls
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.UI.Xaml.Controls.MediaTransportControls'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.MediaTransportControls do
         m_Interface := QInterface (this.m_IMediaElement.all);
         Hr := m_Interface.get_TransportControls (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaTransportControls := new WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls;
         Retval.m_IMediaTransportControls.all := m_ComRetVal;
      end return;
   end;

   procedure put_TransportControls
   (
      this : in out MediaElement;
      value : WinUI3.Windows.UI.Xaml.Controls.MediaTransportControls'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.put_TransportControls (value.m_IMediaTransportControls.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PartialMediaFailureDetected
   (
      this : in out MediaElement;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.add_PartialMediaFailureDetected (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PartialMediaFailureDetected
   (
      this : in out MediaElement;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.remove_PartialMediaFailureDetected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPlaybackSource
   (
      this : in out MediaElement;
      source : WinUI3.Windows.Media.Playback.IMediaPlaybackSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaElement.all);
      Hr := m_Interface.SetPlaybackSource (source);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetAsCastingSource
   (
      this : in out MediaElement
   )
   return WinUI3.Windows.Media.Casting.CastingSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaElement3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Casting.ICastingSource;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaElement_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaElement3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaElement3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Media.Casting.CastingSource do
         m_Interface := QInterface (this.m_IMediaElement.all);
         Hr := m_Interface.GetAsCastingSource (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICastingSource := new WinUI3.Windows.Media.Casting.ICastingSource;
         Retval.m_ICastingSource.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaPlayerElement

   procedure Initialize (this : in out MediaPlayerElement) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaPlayerElement) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaPlayerElement, IMediaPlayerElement_Ptr);
   begin
      if this.m_IMediaPlayerElement /= null then
         if this.m_IMediaPlayerElement.all /= null then
            temp := this.m_IMediaPlayerElement.all.Release;
            Free (this.m_IMediaPlayerElement);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MediaPlayerElement

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MediaPlayerElement is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory    : access IMediaPlayerElementFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElement;
   begin
      return RetVal : MediaPlayerElement do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMediaPlayerElement := new WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElement;
            Retval.m_IMediaPlayerElement.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaPlayerElement

   function get_SourceProperty_MediaPlayerElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AreTransportControlsEnabledProperty_MediaPlayerElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreTransportControlsEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PosterSourceProperty_MediaPlayerElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PosterSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty_MediaPlayerElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoPlayProperty_MediaPlayerElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoPlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFullWindowProperty_MediaPlayerElement
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFullWindowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MediaPlayerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerElement");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerElementStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerElementStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MediaPlayerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaPlayerElement

   function get_Source
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Windows.Media.Playback.IMediaPlaybackSource is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Playback.IMediaPlaybackSource;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_Source (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Source
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Windows.Media.Playback.IMediaPlaybackSource
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_Source (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TransportControls
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Windows.UI.Xaml.Controls.MediaTransportControls'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.MediaTransportControls do
         Hr := this.m_IMediaPlayerElement.all.get_TransportControls (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaTransportControls := new WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls;
         Retval.m_IMediaTransportControls.all := m_ComRetVal;
      end return;
   end;

   procedure put_TransportControls
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Windows.UI.Xaml.Controls.MediaTransportControls'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_TransportControls (value.m_IMediaTransportControls.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreTransportControlsEnabled
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_AreTransportControlsEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreTransportControlsEnabled
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_AreTransportControlsEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PosterSource
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IMediaPlayerElement.all.get_PosterSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PosterSource
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_PosterSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Windows.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Windows.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AutoPlay
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_AutoPlay (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AutoPlay
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_AutoPlay (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFullWindow
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerElement.all.get_IsFullWindow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFullWindow
   (
      this : in out MediaPlayerElement;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.put_IsFullWindow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MediaPlayer
   (
      this : in out MediaPlayerElement
   )
   return WinUI3.Windows.Media.Playback.MediaPlayer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Playback.IMediaPlayer;
   begin
      return RetVal : WinUI3.Windows.Media.Playback.MediaPlayer do
         Hr := this.m_IMediaPlayerElement.all.get_MediaPlayer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaPlayer := new WinUI3.Windows.Media.Playback.IMediaPlayer;
         Retval.m_IMediaPlayer.all := m_ComRetVal;
      end return;
   end;

   procedure SetMediaPlayer
   (
      this : in out MediaPlayerElement;
      mediaPlayer : WinUI3.Windows.Media.Playback.MediaPlayer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerElement.all.SetMediaPlayer (mediaPlayer.m_IMediaPlayer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaPlayerPresenter

   procedure Initialize (this : in out MediaPlayerPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaPlayerPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaPlayerPresenter, IMediaPlayerPresenter_Ptr);
   begin
      if this.m_IMediaPlayerPresenter /= null then
         if this.m_IMediaPlayerPresenter.all /= null then
            temp := this.m_IMediaPlayerPresenter.all.Release;
            Free (this.m_IMediaPlayerPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MediaPlayerPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MediaPlayerPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerPresenter");
      m_Factory    : access IMediaPlayerPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerPresenter;
   begin
      return RetVal : MediaPlayerPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMediaPlayerPresenter := new WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerPresenter;
            Retval.m_IMediaPlayerPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaPlayerPresenter

   function get_MediaPlayerProperty_MediaPlayerPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MediaPlayerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchProperty_MediaPlayerPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFullWindowProperty_MediaPlayerPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaPlayerPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaPlayerPresenterStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaPlayerPresenterStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFullWindowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaPlayerPresenter

   function get_MediaPlayer
   (
      this : in out MediaPlayerPresenter
   )
   return WinUI3.Windows.Media.Playback.MediaPlayer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Media.Playback.IMediaPlayer;
   begin
      return RetVal : WinUI3.Windows.Media.Playback.MediaPlayer do
         Hr := this.m_IMediaPlayerPresenter.all.get_MediaPlayer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMediaPlayer := new WinUI3.Windows.Media.Playback.IMediaPlayer;
         Retval.m_IMediaPlayer.all := m_ComRetVal;
      end return;
   end;

   procedure put_MediaPlayer
   (
      this : in out MediaPlayerPresenter;
      value : WinUI3.Windows.Media.Playback.MediaPlayer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.put_MediaPlayer (value.m_IMediaPlayer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out MediaPlayerPresenter
   )
   return WinUI3.Windows.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out MediaPlayerPresenter;
      value : WinUI3.Windows.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFullWindow
   (
      this : in out MediaPlayerPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.get_IsFullWindow (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFullWindow
   (
      this : in out MediaPlayerPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaPlayerPresenter.all.put_IsFullWindow (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaTransportControls

   procedure Initialize (this : in out MediaTransportControls) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaTransportControls) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaTransportControls, IMediaTransportControls_Ptr);
   begin
      if this.m_IMediaTransportControls /= null then
         if this.m_IMediaTransportControls.all /= null then
            temp := this.m_IMediaTransportControls.all.Release;
            Free (this.m_IMediaTransportControls);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MediaTransportControls

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MediaTransportControls is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory    : access IMediaTransportControlsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls;
   begin
      return RetVal : MediaTransportControls do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMediaTransportControls := new WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls;
            Retval.m_IMediaTransportControls.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaTransportControls

   function get_IsCompactOverlayButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactOverlayButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactOverlayEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactOverlayEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFullWindowButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFullWindowButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFullWindowEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFullWindowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastForwardButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastForwardButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastForwardEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastForwardEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastRewindButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastRewindButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsFastRewindEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsFastRewindEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStopButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStopButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsStopEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsStopEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsVolumeButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVolumeButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsVolumeEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVolumeEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPlaybackRateButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPlaybackRateButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPlaybackRateEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPlaybackRateEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSeekBarVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSeekBarVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSeekEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSeekEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsCompactProperty_MediaTransportControls
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCompactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowAndHideAutomaticallyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowAndHideAutomaticallyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRepeatEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRepeatEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsRepeatButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsRepeatButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipForwardButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipForwardButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipForwardEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipForwardEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipBackwardButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipBackwardButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSkipBackwardEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSkipBackwardEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsNextTrackButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsNextTrackButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPreviousTrackButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPreviousTrackButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FastPlayFallbackBehaviourProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControls");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FastPlayFallbackBehaviourProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaTransportControls

   function get_IsFullWindowButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFullWindowButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFullWindowButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFullWindowButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFullWindowEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFullWindowEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFullWindowEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFullWindowEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsZoomButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsZoomButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsZoomEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsZoomEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastForwardButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastForwardButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastForwardButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastForwardButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastForwardEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastForwardEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastForwardEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastForwardEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastRewindButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastRewindButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastRewindButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastRewindButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsFastRewindEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsFastRewindEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsFastRewindEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsFastRewindEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStopButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsStopButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStopButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsStopButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsStopEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsStopEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsStopEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsStopEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVolumeButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsVolumeButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVolumeButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsVolumeButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVolumeEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsVolumeEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVolumeEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsVolumeEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPlaybackRateButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsPlaybackRateButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPlaybackRateButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsPlaybackRateButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPlaybackRateEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsPlaybackRateEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPlaybackRateEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsPlaybackRateEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSeekBarVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSeekBarVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSeekBarVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSeekBarVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSeekEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsSeekEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSeekEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsSeekEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCompact
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IMediaTransportControls.all.get_IsCompact (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompact
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMediaTransportControls.all.put_IsCompact (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipForwardButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsSkipForwardButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipForwardButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsSkipForwardButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipForwardEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsSkipForwardEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipForwardEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsSkipForwardEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipBackwardButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsSkipBackwardButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipBackwardButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsSkipBackwardButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSkipBackwardEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsSkipBackwardEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSkipBackwardEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsSkipBackwardEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsNextTrackButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsNextTrackButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsNextTrackButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsNextTrackButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPreviousTrackButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsPreviousTrackButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPreviousTrackButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsPreviousTrackButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FastPlayFallbackBehaviour
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Windows.UI.Xaml.Media.FastPlayFallbackBehaviour is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.FastPlayFallbackBehaviour;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_FastPlayFallbackBehaviour (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FastPlayFallbackBehaviour
   (
      this : in out MediaTransportControls;
      value : WinUI3.Windows.UI.Xaml.Media.FastPlayFallbackBehaviour
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_FastPlayFallbackBehaviour (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ThumbnailRequested
   (
      this : in out MediaTransportControls;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.add_ThumbnailRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ThumbnailRequested
   (
      this : in out MediaTransportControls;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls2, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.remove_ThumbnailRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowAndHideAutomatically
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_ShowAndHideAutomatically (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowAndHideAutomatically
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_ShowAndHideAutomatically (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsRepeatEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsRepeatEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRepeatEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsRepeatEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsRepeatButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsRepeatButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsRepeatButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsRepeatButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Show
   (
      this : in out MediaTransportControls
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.Show;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Hide
   (
      this : in out MediaTransportControls
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls3, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.Hide;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCompactOverlayButtonVisible
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsCompactOverlayButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompactOverlayButtonVisible
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsCompactOverlayButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsCompactOverlayEnabled
   (
      this : in out MediaTransportControls
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.get_IsCompactOverlayEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsCompactOverlayEnabled
   (
      this : in out MediaTransportControls;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls_Interface, WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControls4, WinUI3.Windows.UI.Xaml.Controls.IID_IMediaTransportControls4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMediaTransportControls.all);
      Hr := m_Interface.put_IsCompactOverlayEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MediaTransportControlsHelper

   procedure Initialize (this : in out MediaTransportControlsHelper) is
   begin
      null;
   end;

   procedure Finalize (this : in out MediaTransportControlsHelper) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMediaTransportControlsHelper, IMediaTransportControlsHelper_Ptr);
   begin
      if this.m_IMediaTransportControlsHelper /= null then
         if this.m_IMediaTransportControlsHelper.all /= null then
            temp := this.m_IMediaTransportControlsHelper.all.Release;
            Free (this.m_IMediaTransportControlsHelper);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MediaTransportControlsHelper

   function get_DropoutOrderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControlsHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsHelperStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DropoutOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetDropoutOrder
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return IReference_Int32.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControlsHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Int32.Kind;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetDropoutOrder (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      m_GenericRetVal := QInterface_IReference_Int32 (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure SetDropoutOrder
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MediaTransportControlsHelper");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMediaTransportControlsHelperStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IMediaTransportControlsHelperStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetDropoutOrder (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MediaTransportControlsHelper

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuBar

   procedure Initialize (this : in out MenuBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuBar, IMenuBar_Ptr);
   begin
      if this.m_IMenuBar /= null then
         if this.m_IMenuBar.all /= null then
            temp := this.m_IMenuBar.all.Release;
            Free (this.m_IMenuBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuBar");
      m_Factory    : access IMenuBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuBar;
   begin
      return RetVal : MenuBar do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuBar := new WinUI3.Windows.UI.Xaml.Controls.IMenuBar;
            Retval.m_IMenuBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuBar

   function get_ItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuBar

   function get_Items
   (
      this : in out MenuBar
   )
   return IVector_IMenuBarItem.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuBarItem.Kind;
   begin
      Hr := this.m_IMenuBar.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuBarItem (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuBarItem

   procedure Initialize (this : in out MenuBarItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuBarItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuBarItem, IMenuBarItem_Ptr);
   begin
      if this.m_IMenuBarItem /= null then
         if this.m_IMenuBarItem.all /= null then
            temp := this.m_IMenuBarItem.all.Release;
            Free (this.m_IMenuBarItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuBarItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuBarItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuBarItem");
      m_Factory    : access IMenuBarItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuBarItem;
   begin
      return RetVal : MenuBarItem do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuBarItem := new WinUI3.Windows.UI.Xaml.Controls.IMenuBarItem;
            Retval.m_IMenuBarItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuBarItem

   function get_TitleProperty_MenuBarItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuBarItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuBarItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsProperty_MenuBarItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuBarItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuBarItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuBarItem

   function get_Title
   (
      this : in out MenuBarItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMenuBarItem.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out MenuBarItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMenuBarItem.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Items
   (
      this : in out MenuBarItem
   )
   return IVector_IMenuFlyoutItemBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuFlyoutItemBase.Kind;
   begin
      Hr := this.m_IMenuBarItem.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuFlyoutItemBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyout

   procedure Initialize (this : in out MenuFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyout, IMenuFlyout_Ptr);
   begin
      if this.m_IMenuFlyout /= null then
         if this.m_IMenuFlyout.all /= null then
            temp := this.m_IMenuFlyout.all.Release;
            Free (this.m_IMenuFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyout");
      m_Factory    : access IMenuFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuFlyout;
   begin
      return RetVal : MenuFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyout := new WinUI3.Windows.UI.Xaml.Controls.IMenuFlyout;
            Retval.m_IMenuFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyout

   function get_MenuFlyoutPresenterStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuFlyoutPresenterStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyout

   function get_Items
   (
      this : in out MenuFlyout
   )
   return IVector_IMenuFlyoutItemBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuFlyoutItemBase.Kind;
   begin
      Hr := this.m_IMenuFlyout.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuFlyoutItemBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_MenuFlyoutPresenterStyle
   (
      this : in out MenuFlyout
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IMenuFlyout.all.get_MenuFlyoutPresenterStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuFlyoutPresenterStyle
   (
      this : in out MenuFlyout;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyout.all.put_MenuFlyoutPresenterStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ShowAt
   (
      this : in out MenuFlyout;
      targetElement : WinUI3.Windows.UI.Xaml.UIElement'Class;
      point : WinUI3.Windows.Foundation.Point
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyout2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyout_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyout2, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyout2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyout.all);
      Hr := m_Interface.ShowAt (targetElement.m_IUIElement.all, point);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuBarItemFlyout

   procedure Initialize (this : in out MenuBarItemFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuBarItemFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuBarItemFlyout, IMenuBarItemFlyout_Ptr);
   begin
      if this.m_IMenuBarItemFlyout /= null then
         if this.m_IMenuBarItemFlyout.all /= null then
            temp := this.m_IMenuBarItemFlyout.all.Release;
            Free (this.m_IMenuBarItemFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuBarItemFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuBarItemFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuBarItemFlyout");
      m_Factory    : access IMenuBarItemFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuBarItemFlyout;
   begin
      return RetVal : MenuBarItemFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuBarItemFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuBarItemFlyout := new WinUI3.Windows.UI.Xaml.Controls.IMenuBarItemFlyout;
            Retval.m_IMenuBarItemFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuBarItemFlyout

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutItemBase

   procedure Initialize (this : in out MenuFlyoutItemBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutItemBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutItemBase, IMenuFlyoutItemBase_Ptr);
   begin
      if this.m_IMenuFlyoutItemBase /= null then
         if this.m_IMenuFlyoutItemBase.all /= null then
            temp := this.m_IMenuFlyoutItemBase.all.Release;
            Free (this.m_IMenuFlyoutItemBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutItemBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutItemBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutItem

   procedure Initialize (this : in out MenuFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutItem, IMenuFlyoutItem_Ptr);
   begin
      if this.m_IMenuFlyoutItem /= null then
         if this.m_IMenuFlyoutItem.all /= null then
            temp := this.m_IMenuFlyoutItem.all.Release;
            Free (this.m_IMenuFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyoutItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory    : access IMenuFlyoutItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem;
   begin
      return RetVal : MenuFlyoutItem do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyoutItem := new WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem;
            Retval.m_IMenuFlyoutItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyoutItem

   function get_TextProperty_MenuFlyoutItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandParameterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_MenuFlyoutItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_KeyboardAcceleratorTextOverrideProperty_MenuFlyoutItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItemStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutItemStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_KeyboardAcceleratorTextOverrideProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutItem

   function get_Text
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMenuFlyoutItem.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Command
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.Windows.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_IMenuFlyoutItem.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.Windows.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandParameter
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IMenuFlyoutItem.all.get_CommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CommandParameter
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutItem.all.put_CommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Click
   (
      this : in out MenuFlyoutItem;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IMenuFlyoutItem.all.add_Click (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Click
   (
      this : in out MenuFlyoutItem;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IMenuFlyoutItem.all.remove_Click (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Icon
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem2, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutItem2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconElement do
         m_Interface := QInterface (this.m_IMenuFlyoutItem.all);
         Hr := m_Interface.get_Icon (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Windows.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.Windows.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem2, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyoutItem.all);
      Hr := m_Interface.put_Icon (value.m_IIconElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_KeyboardAcceleratorTextOverride
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem3, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutItem3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyoutItem.all);
      Hr := m_Interface.get_KeyboardAcceleratorTextOverride (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_KeyboardAcceleratorTextOverride
   (
      this : in out MenuFlyoutItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem3 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem3, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutItem3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyoutItem.all);
      Hr := m_Interface.put_KeyboardAcceleratorTextOverride (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_TemplateSettings
   (
      this : in out MenuFlyoutItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.MenuFlyoutItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IMenuFlyoutItemTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutItem3, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutItem3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.MenuFlyoutItemTemplateSettings do
         m_Interface := QInterface (this.m_IMenuFlyoutItem.all);
         Hr := m_Interface.get_TemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMenuFlyoutItemTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IMenuFlyoutItemTemplateSettings;
         Retval.m_IMenuFlyoutItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutPresenter

   procedure Initialize (this : in out MenuFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutPresenter, IMenuFlyoutPresenter_Ptr);
   begin
      if this.m_IMenuFlyoutPresenter /= null then
         if this.m_IMenuFlyoutPresenter.all /= null then
            temp := this.m_IMenuFlyoutPresenter.all.Release;
            Free (this.m_IMenuFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutPresenter

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyoutPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutPresenter");
      m_Factory    : access IMenuFlyoutPresenterFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter;
   begin
      return RetVal : MenuFlyoutPresenter do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutPresenterFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyoutPresenter := new WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter;
            Retval.m_IMenuFlyoutPresenter.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyoutPresenter

   function get_IsDefaultShadowEnabledProperty_MenuFlyoutPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenterStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutPresenterStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutPresenter

   function get_TemplateSettings
   (
      this : in out MenuFlyoutPresenter
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.MenuFlyoutPresenterTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IMenuFlyoutPresenterTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutPresenter2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.MenuFlyoutPresenterTemplateSettings do
         m_Interface := QInterface (this.m_IMenuFlyoutPresenter.all);
         Hr := m_Interface.get_TemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IMenuFlyoutPresenterTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IMenuFlyoutPresenterTemplateSettings;
         Retval.m_IMenuFlyoutPresenterTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_IsDefaultShadowEnabled
   (
      this : in out MenuFlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyoutPresenter.all);
      Hr := m_Interface.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out MenuFlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutPresenter3, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutPresenter3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyoutPresenter.all);
      Hr := m_Interface.put_IsDefaultShadowEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutSeparator

   procedure Initialize (this : in out MenuFlyoutSeparator) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutSeparator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutSeparator, IMenuFlyoutSeparator_Ptr);
   begin
      if this.m_IMenuFlyoutSeparator /= null then
         if this.m_IMenuFlyoutSeparator.all /= null then
            temp := this.m_IMenuFlyoutSeparator.all.Release;
            Free (this.m_IMenuFlyoutSeparator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutSeparator

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return MenuFlyoutSeparator is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutSeparator");
      m_Factory    : access IMenuFlyoutSeparatorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSeparator;
   begin
      return RetVal : MenuFlyoutSeparator do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutSeparatorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IMenuFlyoutSeparator := new WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSeparator;
            Retval.m_IMenuFlyoutSeparator.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutSeparator

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for MenuFlyoutSubItem

   procedure Initialize (this : in out MenuFlyoutSubItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out MenuFlyoutSubItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IMenuFlyoutSubItem, IMenuFlyoutSubItem_Ptr);
   begin
      if this.m_IMenuFlyoutSubItem /= null then
         if this.m_IMenuFlyoutSubItem.all /= null then
            temp := this.m_IMenuFlyoutSubItem.all.Release;
            Free (this.m_IMenuFlyoutSubItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for MenuFlyoutSubItem

   function Constructor return MenuFlyoutSubItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutSubItem");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem;
   begin
      return RetVal : MenuFlyoutSubItem do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IMenuFlyoutSubItem := new WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem;
            Retval.m_IMenuFlyoutSubItem.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for MenuFlyoutSubItem

   function get_TextProperty_MenuFlyoutSubItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutSubItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutSubItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_MenuFlyoutSubItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.MenuFlyoutSubItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IMenuFlyoutSubItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for MenuFlyoutSubItem

   function get_Items
   (
      this : in out MenuFlyoutSubItem
   )
   return IVector_IMenuFlyoutItemBase.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IMenuFlyoutItemBase.Kind;
   begin
      Hr := this.m_IMenuFlyoutSubItem.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IMenuFlyoutItemBase (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Text
   (
      this : in out MenuFlyoutSubItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IMenuFlyoutSubItem.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out MenuFlyoutSubItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IMenuFlyoutSubItem.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Icon
   (
      this : in out MenuFlyoutSubItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutSubItem2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconElement do
         m_Interface := QInterface (this.m_IMenuFlyoutSubItem.all);
         Hr := m_Interface.get_Icon (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Windows.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out MenuFlyoutSubItem;
      value : WinUI3.Windows.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem_Interface, WinUI3.Windows.UI.Xaml.Controls.IMenuFlyoutSubItem2, WinUI3.Windows.UI.Xaml.Controls.IID_IMenuFlyoutSubItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IMenuFlyoutSubItem.all);
      Hr := m_Interface.put_Icon (value.m_IIconElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationView

   procedure Initialize (this : in out NavigationView) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationView, INavigationView_Ptr);
   begin
      if this.m_INavigationView /= null then
         if this.m_INavigationView.all /= null then
            temp := this.m_INavigationView.all.Release;
            Free (this.m_INavigationView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory    : access INavigationViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationView;
   begin
      return RetVal : NavigationView do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationView := new WinUI3.Windows.UI.Xaml.Controls.INavigationView;
            Retval.m_INavigationView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationView

   function get_IsPaneOpenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactModeThresholdWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactModeThresholdWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExpandedModeThresholdWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExpandedModeThresholdWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneFooterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneFooterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_NavigationView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_NavigationView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty_NavigationView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSettingsVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSettingsVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPaneToggleButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneToggleButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AlwaysShowHeaderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlwaysShowHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactPaneLengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenPaneLengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneToggleButtonStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneToggleButtonStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemsSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_NavigationView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SettingsItemProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SettingsItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AutoSuggestBoxProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoSuggestBoxProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemTemplateSelectorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemContainerStyleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemContainerStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MenuItemContainerStyleSelectorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MenuItemContainerStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneDisplayModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneDisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneHeaderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneCustomContentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneCustomContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentOverlayProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentOverlayProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPaneVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFollowsFocusProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_NavigationView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShoulderNavigationEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShoulderNavigationEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowLabelModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowLabelModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsBackButtonVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBackButtonVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsBackEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsBackEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneTitleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneTitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationView

   function get_IsPaneOpen
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_IsPaneOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneOpen
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_IsPaneOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactModeThresholdWidth
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_CompactModeThresholdWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompactModeThresholdWidth
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_CompactModeThresholdWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExpandedModeThresholdWidth
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_ExpandedModeThresholdWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ExpandedModeThresholdWidth
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_ExpandedModeThresholdWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneFooter
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_INavigationView.all.get_PaneFooter (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneFooter
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_PaneFooter (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out NavigationView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_INavigationView.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.NavigationViewDisplayMode;
   begin
      Hr := this.m_INavigationView.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSettingsVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_IsSettingsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSettingsVisible
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_IsSettingsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPaneToggleButtonVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_IsPaneToggleButtonVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneToggleButtonVisible
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_IsPaneToggleButtonVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlwaysShowHeader
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationView.all.get_AlwaysShowHeader (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlwaysShowHeader
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_AlwaysShowHeader (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactPaneLength
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_CompactPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompactPaneLength
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_CompactPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpenPaneLength
   (
      this : in out NavigationView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationView.all.get_OpenPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpenPaneLength
   (
      this : in out NavigationView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_OpenPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneToggleButtonStyle
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_INavigationView.all.get_PaneToggleButtonStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneToggleButtonStyle
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_PaneToggleButtonStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out NavigationView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItems
   (
      this : in out NavigationView
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_INavigationView.all.get_MenuItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_MenuItemsSource
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_MenuItemsSource (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MenuItemsSource
   (
      this : in out NavigationView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemsSource (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SettingsItem
   (
      this : in out NavigationView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.get_SettingsItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AutoSuggestBox
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.AutoSuggestBox'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.AutoSuggestBox do
         Hr := this.m_INavigationView.all.get_AutoSuggestBox (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAutoSuggestBox := new WinUI3.Windows.UI.Xaml.Controls.IAutoSuggestBox;
         Retval.m_IAutoSuggestBox.all := m_ComRetVal;
      end return;
   end;

   procedure put_AutoSuggestBox
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.AutoSuggestBox'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_AutoSuggestBox (value.m_IAutoSuggestBox.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemTemplate
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_INavigationView.all.get_MenuItemTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemTemplate
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemTemplateSelector
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector do
         Hr := this.m_INavigationView.all.get_MenuItemTemplateSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemTemplateSelector
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemTemplateSelector (value.m_IDataTemplateSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemContainerStyle
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_INavigationView.all.get_MenuItemContainerStyle (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemContainerStyle
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemContainerStyle (value.m_IStyle.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MenuItemContainerStyleSelector
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.StyleSelector do
         Hr := this.m_INavigationView.all.get_MenuItemContainerStyleSelector (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_MenuItemContainerStyleSelector
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.put_MenuItemContainerStyleSelector (value.m_IStyleSelector.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MenuItemFromContainer
   (
      this : in out NavigationView;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationView.all.MenuItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromMenuItem
   (
      this : in out NavigationView;
      item : WinUI3.IInspectable
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         Hr := this.m_INavigationView.all.ContainerFromMenuItem (item, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function add_SelectionChanged
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_INavigationView.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemInvoked
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_INavigationView.all.add_ItemInvoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemInvoked
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.remove_ItemInvoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DisplayModeChanged
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_INavigationView.all.add_DisplayModeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DisplayModeChanged
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationView.all.remove_DisplayModeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBackButtonVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewBackButtonVisible is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.NavigationViewBackButtonVisible;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_IsBackButtonVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBackButtonVisible
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.NavigationViewBackButtonVisible
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_IsBackButtonVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsBackEnabled
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_IsBackEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsBackEnabled
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_IsBackEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneTitle
   (
      this : in out NavigationView
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_PaneTitle (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PaneTitle
   (
      this : in out NavigationView;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneTitle (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function add_BackRequested
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_BackRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BackRequested
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_BackRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosed
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneClosed (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosed
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneClosed (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosing
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneClosing (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosing
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneClosing (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpened
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneOpened (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpened
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneOpened (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpening
   (
      this : in out NavigationView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.add_PaneOpening (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpening
   (
      this : in out NavigationView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.remove_PaneOpening (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneDisplayMode
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewPaneDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.NavigationViewPaneDisplayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_PaneDisplayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PaneDisplayMode
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.NavigationViewPaneDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneDisplayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneHeader
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_PaneHeader (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneHeader
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneHeader (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PaneCustomContent
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_PaneCustomContent (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneCustomContent
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_PaneCustomContent (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentOverlay
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_ContentOverlay (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentOverlay
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_ContentOverlay (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPaneVisible
   (
      this : in out NavigationView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_IsPaneVisible (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneVisible
   (
      this : in out NavigationView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_IsPaneVisible (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionFollowsFocus
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewSelectionFollowsFocus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.NavigationViewSelectionFollowsFocus;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_SelectionFollowsFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionFollowsFocus
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.NavigationViewSelectionFollowsFocus
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_SelectionFollowsFocus (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.NavigationViewTemplateSettings do
         m_Interface := QInterface (this.m_INavigationView.all);
         Hr := m_Interface.get_TemplateSettings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettings;
         Retval.m_INavigationViewTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_ShoulderNavigationEnabled
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewShoulderNavigationEnabled is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.NavigationViewShoulderNavigationEnabled;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_ShoulderNavigationEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShoulderNavigationEnabled
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.NavigationViewShoulderNavigationEnabled
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_ShoulderNavigationEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverflowLabelMode
   (
      this : in out NavigationView
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewOverflowLabelMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.NavigationViewOverflowLabelMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.get_OverflowLabelMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OverflowLabelMode
   (
      this : in out NavigationView;
      value : WinUI3.Windows.UI.Xaml.Controls.NavigationViewOverflowLabelMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationView_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationView3, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationView.all);
      Hr := m_Interface.put_OverflowLabelMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewBackRequestedEventArgs

   procedure Initialize (this : in out NavigationViewBackRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewBackRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewBackRequestedEventArgs, INavigationViewBackRequestedEventArgs_Ptr);
   begin
      if this.m_INavigationViewBackRequestedEventArgs /= null then
         if this.m_INavigationViewBackRequestedEventArgs.all /= null then
            temp := this.m_INavigationViewBackRequestedEventArgs.all.Release;
            Free (this.m_INavigationViewBackRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewBackRequestedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewDisplayModeChangedEventArgs

   procedure Initialize (this : in out NavigationViewDisplayModeChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewDisplayModeChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewDisplayModeChangedEventArgs, INavigationViewDisplayModeChangedEventArgs_Ptr);
   begin
      if this.m_INavigationViewDisplayModeChangedEventArgs /= null then
         if this.m_INavigationViewDisplayModeChangedEventArgs.all /= null then
            temp := this.m_INavigationViewDisplayModeChangedEventArgs.all.Release;
            Free (this.m_INavigationViewDisplayModeChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewDisplayModeChangedEventArgs

   function get_DisplayMode
   (
      this : in out NavigationViewDisplayModeChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.NavigationViewDisplayMode;
   begin
      Hr := this.m_INavigationViewDisplayModeChangedEventArgs.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemBase

   procedure Initialize (this : in out NavigationViewItemBase) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemBase) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemBase, INavigationViewItemBase_Ptr);
   begin
      if this.m_INavigationViewItemBase /= null then
         if this.m_INavigationViewItemBase.all /= null then
            temp := this.m_INavigationViewItemBase.all.Release;
            Free (this.m_INavigationViewItemBase);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemBase

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemBase

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItem

   procedure Initialize (this : in out NavigationViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItem, INavigationViewItem_Ptr);
   begin
      if this.m_INavigationViewItem /= null then
         if this.m_INavigationViewItem.all /= null then
            temp := this.m_INavigationViewItem.all.Release;
            Free (this.m_INavigationViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewItem");
      m_Factory    : access INavigationViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem;
   begin
      return RetVal : NavigationViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItem := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem;
            Retval.m_INavigationViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationViewItem

   function get_SelectsOnInvokedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectsOnInvokedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconProperty_NavigationViewItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactPaneLengthProperty_NavigationViewItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItem

   function get_Icon
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconElement do
         Hr := this.m_INavigationViewItem.all.get_Icon (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconElement := new WinUI3.Windows.UI.Xaml.Controls.IIconElement;
         Retval.m_IIconElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Icon
   (
      this : in out NavigationViewItem;
      value : WinUI3.Windows.UI.Xaml.Controls.IconElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationViewItem.all.put_Icon (value.m_IIconElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactPaneLength
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewItem.all.get_CompactPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectsOnInvoked
   (
      this : in out NavigationViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.get_SelectsOnInvoked (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectsOnInvoked
   (
      this : in out NavigationViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationViewItem2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_INavigationViewItem.all);
      Hr := m_Interface.put_SelectsOnInvoked (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemHeader

   procedure Initialize (this : in out NavigationViewItemHeader) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemHeader) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemHeader, INavigationViewItemHeader_Ptr);
   begin
      if this.m_INavigationViewItemHeader /= null then
         if this.m_INavigationViewItemHeader.all /= null then
            temp := this.m_INavigationViewItemHeader.all.Release;
            Free (this.m_INavigationViewItemHeader);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemHeader

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItemHeader is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewItemHeader");
      m_Factory    : access INavigationViewItemHeaderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemHeader;
   begin
      return RetVal : NavigationViewItemHeader do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemHeaderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItemHeader := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemHeader;
            Retval.m_INavigationViewItemHeader.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemHeader

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemInvokedEventArgs

   procedure Initialize (this : in out NavigationViewItemInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemInvokedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemInvokedEventArgs, INavigationViewItemInvokedEventArgs_Ptr);
   begin
      if this.m_INavigationViewItemInvokedEventArgs /= null then
         if this.m_INavigationViewItemInvokedEventArgs.all /= null then
            temp := this.m_INavigationViewItemInvokedEventArgs.all.Release;
            Free (this.m_INavigationViewItemInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemInvokedEventArgs

   function Constructor return NavigationViewItemInvokedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewItemInvokedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs;
   begin
      return RetVal : NavigationViewItemInvokedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_INavigationViewItemInvokedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs;
            Retval.m_INavigationViewItemInvokedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemInvokedEventArgs

   function get_InvokedItem
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationViewItemInvokedEventArgs.all.get_InvokedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSettingsInvoked
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewItemInvokedEventArgs.all.get_IsSettingsInvoked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_InvokedItemContainer
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewItemBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationViewItemInvokedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.NavigationViewItemBase do
         m_Interface := QInterface (this.m_INavigationViewItemInvokedEventArgs.all);
         Hr := m_Interface.get_InvokedItemContainer (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewItemBase := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemBase;
         Retval.m_INavigationViewItemBase.all := m_ComRetVal;
      end return;
   end;

   function get_RecommendedNavigationTransitionInfo
   (
      this : in out NavigationViewItemInvokedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemInvokedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationViewItemInvokedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo do
         m_Interface := QInterface (this.m_INavigationViewItemInvokedEventArgs.all);
         Hr := m_Interface.get_RecommendedNavigationTransitionInfo (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
         Retval.m_INavigationTransitionInfo.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewItemSeparator

   procedure Initialize (this : in out NavigationViewItemSeparator) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewItemSeparator) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewItemSeparator, INavigationViewItemSeparator_Ptr);
   begin
      if this.m_INavigationViewItemSeparator /= null then
         if this.m_INavigationViewItemSeparator.all /= null then
            temp := this.m_INavigationViewItemSeparator.all.Release;
            Free (this.m_INavigationViewItemSeparator);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewItemSeparator

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewItemSeparator is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewItemSeparator");
      m_Factory    : access INavigationViewItemSeparatorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemSeparator;
   begin
      return RetVal : NavigationViewItemSeparator do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewItemSeparatorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewItemSeparator := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemSeparator;
            Retval.m_INavigationViewItemSeparator.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewItemSeparator

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewList

   procedure Initialize (this : in out NavigationViewList) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewList) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewList, INavigationViewList_Ptr);
   begin
      if this.m_INavigationViewList /= null then
         if this.m_INavigationViewList.all /= null then
            temp := this.m_INavigationViewList.all.Release;
            Free (this.m_INavigationViewList);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewList

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewList is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewList");
      m_Factory    : access INavigationViewListFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewList;
   begin
      return RetVal : NavigationViewList do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewListFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewList := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewList;
            Retval.m_INavigationViewList.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewList

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewPaneClosingEventArgs

   procedure Initialize (this : in out NavigationViewPaneClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewPaneClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewPaneClosingEventArgs, INavigationViewPaneClosingEventArgs_Ptr);
   begin
      if this.m_INavigationViewPaneClosingEventArgs /= null then
         if this.m_INavigationViewPaneClosingEventArgs.all /= null then
            temp := this.m_INavigationViewPaneClosingEventArgs.all.Release;
            Free (this.m_INavigationViewPaneClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewPaneClosingEventArgs

   function get_Cancel
   (
      this : in out NavigationViewPaneClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewPaneClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out NavigationViewPaneClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_INavigationViewPaneClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewSelectionChangedEventArgs

   procedure Initialize (this : in out NavigationViewSelectionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewSelectionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewSelectionChangedEventArgs, INavigationViewSelectionChangedEventArgs_Ptr);
   begin
      if this.m_INavigationViewSelectionChangedEventArgs /= null then
         if this.m_INavigationViewSelectionChangedEventArgs.all /= null then
            temp := this.m_INavigationViewSelectionChangedEventArgs.all.Release;
            Free (this.m_INavigationViewSelectionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewSelectionChangedEventArgs

   function get_SelectedItem
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_INavigationViewSelectionChangedEventArgs.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_IsSettingsSelected
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewSelectionChangedEventArgs.all.get_IsSettingsSelected (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectedItemContainer
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.NavigationViewItemBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationViewSelectionChangedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.NavigationViewItemBase do
         m_Interface := QInterface (this.m_INavigationViewSelectionChangedEventArgs.all);
         Hr := m_Interface.get_SelectedItemContainer (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationViewItemBase := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewItemBase;
         Retval.m_INavigationViewItemBase.all := m_ComRetVal;
      end return;
   end;

   function get_RecommendedNavigationTransitionInfo
   (
      this : in out NavigationViewSelectionChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.INavigationViewSelectionChangedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_INavigationViewSelectionChangedEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.NavigationTransitionInfo do
         m_Interface := QInterface (this.m_INavigationViewSelectionChangedEventArgs.all);
         Hr := m_Interface.get_RecommendedNavigationTransitionInfo (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_INavigationTransitionInfo := new WinUI3.Windows.UI.Xaml.Media.Animation.INavigationTransitionInfo;
         Retval.m_INavigationTransitionInfo.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NavigationViewTemplateSettings

   procedure Initialize (this : in out NavigationViewTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out NavigationViewTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INavigationViewTemplateSettings, INavigationViewTemplateSettings_Ptr);
   begin
      if this.m_INavigationViewTemplateSettings /= null then
         if this.m_INavigationViewTemplateSettings.all /= null then
            temp := this.m_INavigationViewTemplateSettings.all.Release;
            Free (this.m_INavigationViewTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for NavigationViewTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return NavigationViewTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory    : access INavigationViewTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettings;
   begin
      return RetVal : NavigationViewTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_INavigationViewTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettings;
            Retval.m_INavigationViewTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for NavigationViewTemplateSettings

   function get_TopPaddingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopPaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowButtonVisibilityProperty_NavigationViewTemplateSettings
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneToggleButtonVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneToggleButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackButtonVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackButtonVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopPaneVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopPaneVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftPaneVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftPaneVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SingleSelectionFollowsFocusProperty_NavigationViewTemplateSettings
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.NavigationViewTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.INavigationViewTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_INavigationViewTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SingleSelectionFollowsFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NavigationViewTemplateSettings

   function get_TopPadding
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_TopPadding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_OverflowButtonVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_OverflowButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_PaneToggleButtonVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_PaneToggleButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_BackButtonVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_BackButtonVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TopPaneVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_TopPaneVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_LeftPaneVisibility
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_LeftPaneVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SingleSelectionFollowsFocus
   (
      this : in out NavigationViewTemplateSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_INavigationViewTemplateSettings.all.get_SingleSelectionFollowsFocus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for NotifyEventArgs

   procedure Initialize (this : in out NotifyEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out NotifyEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (INotifyEventArgs, INotifyEventArgs_Ptr);
   begin
      if this.m_INotifyEventArgs /= null then
         if this.m_INotifyEventArgs.all /= null then
            temp := this.m_INotifyEventArgs.all.Release;
            Free (this.m_INotifyEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for NotifyEventArgs

   function get_Value
   (
      this : in out NotifyEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_INotifyEventArgs.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_CallingUri
   (
      this : in out NotifyEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.INotifyEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.INotifyEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.INotifyEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_INotifyEventArgs2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         m_Interface := QInterface (this.m_INotifyEventArgs.all);
         Hr := m_Interface.get_CallingUri (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Delegate NotifyEventHandler

   function Invoke
   (
      this : access NotifyEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.INotifyEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UserControl

   procedure Initialize (this : in out UserControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out UserControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IUserControl, IUserControl_Ptr);
   begin
      if this.m_IUserControl /= null then
         if this.m_IUserControl.all /= null then
            temp := this.m_IUserControl.all.Release;
            Free (this.m_IUserControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for UserControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return UserControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.UserControl");
      m_Factory    : access IUserControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IUserControl;
   begin
      return RetVal : UserControl do
         Hr := RoGetActivationFactory (m_hString, IID_IUserControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IUserControl := new WinUI3.Windows.UI.Xaml.Controls.IUserControl;
            Retval.m_IUserControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for UserControl

   function get_ContentProperty_UserControl
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.UserControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IUserControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IUserControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UserControl

   function get_Content
   (
      this : in out UserControl
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IUserControl.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out UserControl;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IUserControl.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Page

   procedure Initialize (this : in out Page) is
   begin
      null;
   end;

   procedure Finalize (this : in out Page) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPage, IPage_Ptr);
   begin
      if this.m_IPage /= null then
         if this.m_IPage.all /= null then
            temp := this.m_IPage.all.Release;
            Free (this.m_IPage);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Page

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Page is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Page");
      m_Factory    : access IPageFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPage;
   begin
      return RetVal : Page do
         Hr := RoGetActivationFactory (m_hString, IID_IPageFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPage := new WinUI3.Windows.UI.Xaml.Controls.IPage;
            Retval.m_IPage.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Page

   function get_FrameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Page");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FrameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopAppBarProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Page");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopAppBarProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BottomAppBarProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Page");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPageStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPageStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BottomAppBarProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Page

   function get_Frame
   (
      this : in out Page
   )
   return WinUI3.Windows.UI.Xaml.Controls.Frame'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IFrame;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Frame do
         Hr := this.m_IPage.all.get_Frame (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFrame := new WinUI3.Windows.UI.Xaml.Controls.IFrame;
         Retval.m_IFrame.all := m_ComRetVal;
      end return;
   end;

   function get_NavigationCacheMode
   (
      this : in out Page
   )
   return WinUI3.Windows.UI.Xaml.Navigation.NavigationCacheMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Navigation.NavigationCacheMode;
   begin
      Hr := this.m_IPage.all.get_NavigationCacheMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_NavigationCacheMode
   (
      this : in out Page;
      value : WinUI3.Windows.UI.Xaml.Navigation.NavigationCacheMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPage.all.put_NavigationCacheMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopAppBar
   (
      this : in out Page
   )
   return WinUI3.Windows.UI.Xaml.Controls.AppBar'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IAppBar;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.AppBar do
         Hr := this.m_IPage.all.get_TopAppBar (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBar := new WinUI3.Windows.UI.Xaml.Controls.IAppBar;
         Retval.m_IAppBar.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopAppBar
   (
      this : in out Page;
      value : WinUI3.Windows.UI.Xaml.Controls.AppBar'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPage.all.put_TopAppBar (value.m_IAppBar.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BottomAppBar
   (
      this : in out Page
   )
   return WinUI3.Windows.UI.Xaml.Controls.AppBar'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IAppBar;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.AppBar do
         Hr := this.m_IPage.all.get_BottomAppBar (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IAppBar := new WinUI3.Windows.UI.Xaml.Controls.IAppBar;
         Retval.m_IAppBar.all := m_ComRetVal;
      end return;
   end;

   procedure put_BottomAppBar
   (
      this : in out Page;
      value : WinUI3.Windows.UI.Xaml.Controls.AppBar'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPage.all.put_BottomAppBar (value.m_IAppBar.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnNavigatedFrom
   (
      this : in out Page;
      e : WinUI3.Windows.UI.Xaml.Navigation.NavigationEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPageOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPage_Interface, WinUI3.Windows.UI.Xaml.Controls.IPageOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IPageOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPage.all);
      Hr := m_Interface.OnNavigatedFrom (e.m_INavigationEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnNavigatedTo
   (
      this : in out Page;
      e : WinUI3.Windows.UI.Xaml.Navigation.NavigationEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPageOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPage_Interface, WinUI3.Windows.UI.Xaml.Controls.IPageOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IPageOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPage.all);
      Hr := m_Interface.OnNavigatedTo (e.m_INavigationEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnNavigatingFrom
   (
      this : in out Page;
      e : WinUI3.Windows.UI.Xaml.Navigation.NavigatingCancelEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPageOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPage_Interface, WinUI3.Windows.UI.Xaml.Controls.IPageOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IPageOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPage.all);
      Hr := m_Interface.OnNavigatingFrom (e.m_INavigatingCancelEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ParallaxView

   procedure Initialize (this : in out ParallaxView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ParallaxView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IParallaxView, IParallaxView_Ptr);
   begin
      if this.m_IParallaxView /= null then
         if this.m_IParallaxView.all /= null then
            temp := this.m_IParallaxView.all.Release;
            Free (this.m_IParallaxView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ParallaxView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ParallaxView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory    : access IParallaxViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IParallaxView;
   begin
      return RetVal : ParallaxView do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IParallaxView := new WinUI3.Windows.UI.Xaml.Controls.IParallaxView;
            Retval.m_IParallaxView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ParallaxView

   function get_ChildProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChildProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSourceEndOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSourceEndOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSourceOffsetKindProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSourceOffsetKindProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSourceStartOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSourceStartOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHorizontalShiftRatioProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHorizontalShiftRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalShiftProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalShiftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHorizontalShiftClampedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHorizontalShiftClampedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsVerticalShiftClampedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVerticalShiftClampedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SourceProperty_ParallaxView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSourceEndOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSourceEndOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSourceOffsetKindProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSourceOffsetKindProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSourceStartOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSourceStartOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxVerticalShiftRatioProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxVerticalShiftRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalShiftProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ParallaxView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IParallaxViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IParallaxViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalShiftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ParallaxView

   function get_Child
   (
      this : in out ParallaxView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IParallaxView.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out ParallaxView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalShift
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalShift (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalShift
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalShift (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSourceEndOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalSourceEndOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSourceEndOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalSourceEndOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSourceOffsetKind
   (
      this : in out ParallaxView
   )
   return WinUI3.Windows.UI.Xaml.Controls.ParallaxSourceOffsetKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ParallaxSourceOffsetKind;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalSourceOffsetKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSourceOffsetKind
   (
      this : in out ParallaxView;
      value : WinUI3.Windows.UI.Xaml.Controls.ParallaxSourceOffsetKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalSourceOffsetKind (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSourceStartOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_HorizontalSourceStartOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSourceStartOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_HorizontalSourceStartOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHorizontalShiftClamped
   (
      this : in out ParallaxView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IParallaxView.all.get_IsHorizontalShiftClamped (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHorizontalShiftClamped
   (
      this : in out ParallaxView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_IsHorizontalShiftClamped (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVerticalShiftClamped
   (
      this : in out ParallaxView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IParallaxView.all.get_IsVerticalShiftClamped (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVerticalShiftClamped
   (
      this : in out ParallaxView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_IsVerticalShiftClamped (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHorizontalShiftRatio
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_MaxHorizontalShiftRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHorizontalShiftRatio
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_MaxHorizontalShiftRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxVerticalShiftRatio
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_MaxVerticalShiftRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxVerticalShiftRatio
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_MaxVerticalShiftRatio (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Source
   (
      this : in out ParallaxView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IParallaxView.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out ParallaxView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_Source (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalShift
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalShift (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalShift
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalShift (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSourceEndOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalSourceEndOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSourceEndOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalSourceEndOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSourceOffsetKind
   (
      this : in out ParallaxView
   )
   return WinUI3.Windows.UI.Xaml.Controls.ParallaxSourceOffsetKind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ParallaxSourceOffsetKind;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalSourceOffsetKind (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSourceOffsetKind
   (
      this : in out ParallaxView;
      value : WinUI3.Windows.UI.Xaml.Controls.ParallaxSourceOffsetKind
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalSourceOffsetKind (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSourceStartOffset
   (
      this : in out ParallaxView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IParallaxView.all.get_VerticalSourceStartOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSourceStartOffset
   (
      this : in out ParallaxView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.put_VerticalSourceStartOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RefreshAutomaticHorizontalOffsets
   (
      this : in out ParallaxView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.RefreshAutomaticHorizontalOffsets;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RefreshAutomaticVerticalOffsets
   (
      this : in out ParallaxView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IParallaxView.all.RefreshAutomaticVerticalOffsets;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PasswordBox

   procedure Initialize (this : in out PasswordBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out PasswordBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPasswordBox, IPasswordBox_Ptr);
   begin
      if this.m_IPasswordBox /= null then
         if this.m_IPasswordBox.all /= null then
            temp := this.m_IPasswordBox.all.Release;
            Free (this.m_IPasswordBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PasswordBox

   function Constructor return PasswordBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPasswordBox;
   begin
      return RetVal : PasswordBox do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPasswordBox := new WinUI3.Windows.UI.Xaml.Controls.IPasswordBox;
            Retval.m_IPasswordBox.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PasswordBox

   function get_CanPasteClipboardContentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanPasteClipboardContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_PasswordBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PasswordRevealModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PasswordRevealModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InputScopeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InputScopeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_PasswordBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_PasswordBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_PasswordBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocusProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreventKeyboardDisplayOnProgrammaticFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PasswordProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PasswordProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PasswordCharProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PasswordCharProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPasswordRevealButtonEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPasswordRevealButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PasswordBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPasswordBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPasswordBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PasswordBox

   function get_Password
   (
      this : in out PasswordBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPasswordBox.all.get_Password (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Password
   (
      this : in out PasswordBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPasswordBox.all.put_Password (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PasswordChar
   (
      this : in out PasswordBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPasswordBox.all.get_PasswordChar (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PasswordChar
   (
      this : in out PasswordBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPasswordBox.all.put_PasswordChar (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsPasswordRevealButtonEnabled
   (
      this : in out PasswordBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPasswordBox.all.get_IsPasswordRevealButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPasswordRevealButtonEnabled
   (
      this : in out PasswordBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_IsPasswordRevealButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLength
   (
      this : in out PasswordBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPasswordBox.all.get_MaxLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLength
   (
      this : in out PasswordBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.put_MaxLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PasswordChanged
   (
      this : in out PasswordBox;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPasswordBox.all.add_PasswordChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PasswordChanged
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.remove_PasswordChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out PasswordBox;
      handler : WinUI3.Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPasswordBox.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out PasswordBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPasswordBox.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out PasswordBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.get_Header (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out PasswordBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_Header (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out PasswordBox
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IPasswordBox.all);
         Hr := m_Interface.get_HeaderTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out PasswordBox;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_HeaderTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out PasswordBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.get_PlaceholderText (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out PasswordBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_PlaceholderText (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionHighlightColor
   (
      this : in out PasswordBox
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_IPasswordBox.all);
         Hr := m_Interface.get_SelectionHighlightColor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out PasswordBox;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out PasswordBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.get_PreventKeyboardDisplayOnProgrammaticFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out PasswordBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_PreventKeyboardDisplayOnProgrammaticFocus (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Paste
   (
      this : in out PasswordBox;
      handler : WinUI3.Windows.UI.Xaml.Controls.TextControlPasteEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.add_Paste (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Paste
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.remove_Paste (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PasswordRevealMode
   (
      this : in out PasswordBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.PasswordRevealMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.PasswordRevealMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.get_PasswordRevealMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PasswordRevealMode
   (
      this : in out PasswordBox;
      value : WinUI3.Windows.UI.Xaml.Controls.PasswordRevealMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_PasswordRevealMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out PasswordBox
   )
   return WinUI3.Windows.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextReadingOrder;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.get_TextReadingOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out PasswordBox;
      value : WinUI3.Windows.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_TextReadingOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputScope
   (
      this : in out PasswordBox
   )
   return WinUI3.Windows.UI.Xaml.Input.InputScope'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.IInputScope;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox3'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Input.InputScope do
         m_Interface := QInterface (this.m_IPasswordBox.all);
         Hr := m_Interface.get_InputScope (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputScope := new WinUI3.Windows.UI.Xaml.Input.IInputScope;
         Retval.m_IInputScope.all := m_ComRetVal;
      end return;
   end;

   procedure put_InputScope
   (
      this : in out PasswordBox;
      value : WinUI3.Windows.UI.Xaml.Input.InputScope'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_InputScope (value.m_IInputScope.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PasswordChanging
   (
      this : in out PasswordBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.add_PasswordChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PasswordChanging
   (
      this : in out PasswordBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.remove_PasswordChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanPasteClipboardContent
   (
      this : in out PasswordBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.get_CanPasteClipboardContent (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionFlyout
   (
      this : in out PasswordBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_IPasswordBox.all);
         Hr := m_Interface.get_SelectionFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out PasswordBox;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_SelectionFlyout (value.m_IFlyoutBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Description
   (
      this : in out PasswordBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.get_Description (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out PasswordBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.put_Description (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PasteFromClipboard
   (
      this : in out PasswordBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPasswordBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IPasswordBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IPasswordBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPasswordBox.all);
      Hr := m_Interface.PasteFromClipboard;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PasswordBoxPasswordChangingEventArgs

   procedure Initialize (this : in out PasswordBoxPasswordChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PasswordBoxPasswordChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPasswordBoxPasswordChangingEventArgs, IPasswordBoxPasswordChangingEventArgs_Ptr);
   begin
      if this.m_IPasswordBoxPasswordChangingEventArgs /= null then
         if this.m_IPasswordBoxPasswordChangingEventArgs.all /= null then
            temp := this.m_IPasswordBoxPasswordChangingEventArgs.all.Release;
            Free (this.m_IPasswordBoxPasswordChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PasswordBoxPasswordChangingEventArgs

   function get_IsContentChanging
   (
      this : in out PasswordBoxPasswordChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPasswordBoxPasswordChangingEventArgs.all.get_IsContentChanging (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathIcon

   procedure Initialize (this : in out PathIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathIcon, IPathIcon_Ptr);
   begin
      if this.m_IPathIcon /= null then
         if this.m_IPathIcon.all /= null then
            temp := this.m_IPathIcon.all.Release;
            Free (this.m_IPathIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathIcon

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PathIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PathIcon");
      m_Factory    : access IPathIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPathIcon;
   begin
      return RetVal : PathIcon do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPathIcon := new WinUI3.Windows.UI.Xaml.Controls.IPathIcon;
            Retval.m_IPathIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PathIcon

   function get_DataProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PathIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPathIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathIcon

   function get_Data
   (
      this : in out PathIcon
   )
   return WinUI3.Windows.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeometry;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Geometry do
         Hr := this.m_IPathIcon.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Windows.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_Data
   (
      this : in out PathIcon;
      value : WinUI3.Windows.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathIcon.all.put_Data (value.m_IGeometry.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PathIconSource

   procedure Initialize (this : in out PathIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out PathIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPathIconSource, IPathIconSource_Ptr);
   begin
      if this.m_IPathIconSource /= null then
         if this.m_IPathIconSource.all /= null then
            temp := this.m_IPathIconSource.all.Release;
            Free (this.m_IPathIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PathIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PathIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PathIconSource");
      m_Factory    : access IPathIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPathIconSource;
   begin
      return RetVal : PathIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPathIconSource := new WinUI3.Windows.UI.Xaml.Controls.IPathIconSource;
            Retval.m_IPathIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PathIconSource

   function get_DataProperty_PathIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PathIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPathIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPathIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PathIconSource

   function get_Data
   (
      this : in out PathIconSource
   )
   return WinUI3.Windows.UI.Xaml.Media.Geometry'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IGeometry;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Geometry do
         Hr := this.m_IPathIconSource.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IGeometry := new WinUI3.Windows.UI.Xaml.Media.IGeometry;
         Retval.m_IGeometry.all := m_ComRetVal;
      end return;
   end;

   procedure put_Data
   (
      this : in out PathIconSource;
      value : WinUI3.Windows.UI.Xaml.Media.Geometry'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPathIconSource.all.put_Data (value.m_IGeometry.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PersonPicture

   procedure Initialize (this : in out PersonPicture) is
   begin
      null;
   end;

   procedure Finalize (this : in out PersonPicture) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPersonPicture, IPersonPicture_Ptr);
   begin
      if this.m_IPersonPicture /= null then
         if this.m_IPersonPicture.all /= null then
            temp := this.m_IPersonPicture.all.Release;
            Free (this.m_IPersonPicture);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PersonPicture

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PersonPicture is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory    : access IPersonPictureFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPersonPicture;
   begin
      return RetVal : PersonPicture do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPersonPicture := new WinUI3.Windows.UI.Xaml.Controls.IPersonPicture;
            Retval.m_IPersonPicture.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PersonPicture

   function get_BadgeNumberProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeNumberProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BadgeGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BadgeImageSourceProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeImageSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BadgeTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BadgeTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsGroupProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsGroupProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContactProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContactProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InitialsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InitialsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreferSmallImageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreferSmallImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProfilePictureProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PersonPicture");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPersonPictureStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPersonPictureStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProfilePictureProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PersonPicture

   function get_BadgeNumber
   (
      this : in out PersonPicture
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPersonPicture.all.get_BadgeNumber (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BadgeNumber
   (
      this : in out PersonPicture;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeNumber (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BadgeGlyph
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_BadgeGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_BadgeGlyph
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_BadgeImageSource
   (
      this : in out PersonPicture
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IPersonPicture.all.get_BadgeImageSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_BadgeImageSource
   (
      this : in out PersonPicture;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeImageSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BadgeText
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_BadgeText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_BadgeText
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_BadgeText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IsGroup
   (
      this : in out PersonPicture
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPersonPicture.all.get_IsGroup (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsGroup
   (
      this : in out PersonPicture;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_IsGroup (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Contact
   (
      this : in out PersonPicture
   )
   return WinUI3.Windows.ApplicationModel.Contacts.Contact'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.Contacts.IContact;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.Contacts.Contact do
         Hr := this.m_IPersonPicture.all.get_Contact (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContact := new WinUI3.Windows.ApplicationModel.Contacts.IContact;
         Retval.m_IContact.all := m_ComRetVal;
      end return;
   end;

   procedure put_Contact
   (
      this : in out PersonPicture;
      value : WinUI3.Windows.ApplicationModel.Contacts.Contact'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_Contact (value.m_IContact.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayName
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_DisplayName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisplayName
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_DisplayName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Initials
   (
      this : in out PersonPicture
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IPersonPicture.all.get_Initials (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Initials
   (
      this : in out PersonPicture;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IPersonPicture.all.put_Initials (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PreferSmallImage
   (
      this : in out PersonPicture
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPersonPicture.all.get_PreferSmallImage (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreferSmallImage
   (
      this : in out PersonPicture;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_PreferSmallImage (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProfilePicture
   (
      this : in out PersonPicture
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IPersonPicture.all.get_ProfilePicture (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_ProfilePicture
   (
      this : in out PersonPicture;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPersonPicture.all.put_ProfilePicture (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerConfirmedEventArgs

   procedure Initialize (this : in out PickerConfirmedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerConfirmedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerConfirmedEventArgs, IPickerConfirmedEventArgs_Ptr);
   begin
      if this.m_IPickerConfirmedEventArgs /= null then
         if this.m_IPickerConfirmedEventArgs.all /= null then
            temp := this.m_IPickerConfirmedEventArgs.all.Release;
            Free (this.m_IPickerConfirmedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PickerConfirmedEventArgs

   function Constructor return PickerConfirmedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PickerConfirmedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPickerConfirmedEventArgs;
   begin
      return RetVal : PickerConfirmedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPickerConfirmedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IPickerConfirmedEventArgs;
            Retval.m_IPickerConfirmedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerConfirmedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerFlyout

   procedure Initialize (this : in out PickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerFlyout, IPickerFlyout_Ptr);
   begin
      if this.m_IPickerFlyout /= null then
         if this.m_IPickerFlyout.all /= null then
            temp := this.m_IPickerFlyout.all.Release;
            Free (this.m_IPickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PickerFlyout

   function Constructor return PickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PickerFlyout");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPickerFlyout;
   begin
      return RetVal : PickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPickerFlyout := new WinUI3.Windows.UI.Xaml.Controls.IPickerFlyout;
            Retval.m_IPickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PickerFlyout

   function get_ContentProperty_PickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ConfirmationButtonsVisibleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ConfirmationButtonsVisibleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerFlyout

   function get_Content
   (
      this : in out PickerFlyout
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IPickerFlyout.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out PickerFlyout;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPickerFlyout.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ConfirmationButtonsVisible
   (
      this : in out PickerFlyout
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPickerFlyout.all.get_ConfirmationButtonsVisible (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ConfirmationButtonsVisible
   (
      this : in out PickerFlyout;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPickerFlyout.all.put_ConfirmationButtonsVisible (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Confirmed
   (
      this : in out PickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPickerFlyout.all.add_Confirmed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Confirmed
   (
      this : in out PickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPickerFlyout.all.remove_Confirmed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out PickerFlyout;
      target : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_Boolean.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_Boolean.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Boolean;
      m_IID            : aliased WinUI3.IID := (3451252659, 22408, 20637, (155, 225, 113, 204, 184, 163, 54, 42 )); -- Boolean;
      m_HandlerIID     : aliased WinUI3.IID := (3251884450, 44567, 23135, (181, 162, 189, 204, 136, 68, 136, 154 ));
      m_Handler        : AsyncOperationCompletedHandler_Boolean.Kind := new AsyncOperationCompletedHandler_Boolean.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_Boolean.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_Boolean.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_Boolean.Kind_Delegate, AsyncOperationCompletedHandler_Boolean.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_IPickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PickerFlyoutPresenter

   procedure Initialize (this : in out PickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out PickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPickerFlyoutPresenter, IPickerFlyoutPresenter_Ptr);
   begin
      if this.m_IPickerFlyoutPresenter /= null then
         if this.m_IPickerFlyoutPresenter.all /= null then
            temp := this.m_IPickerFlyoutPresenter.all.Release;
            Free (this.m_IPickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PickerFlyoutPresenter

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Pivot

   procedure Initialize (this : in out Pivot) is
   begin
      null;
   end;

   procedure Finalize (this : in out Pivot) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivot, IPivot_Ptr);
   begin
      if this.m_IPivot /= null then
         if this.m_IPivot.all /= null then
            temp := this.m_IPivot.all.Release;
            Free (this.m_IPivot);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Pivot

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Pivot is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory    : access IPivotFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPivot;
   begin
      return RetVal : Pivot do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPivot := new WinUI3.Windows.UI.Xaml.Controls.IPivot;
            Retval.m_IPivot.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Pivot

   function get_TitleProperty_Pivot
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TitleTemplateProperty_Pivot
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_Pivot
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedIndexProperty_Pivot
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedIndexProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedItemProperty_Pivot
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedItemProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsLockedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsLockedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SlideInAnimationGroupProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SlideInAnimationGroupProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetSlideInAnimationGroup
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.PivotSlideInAnimationGroup is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.PivotSlideInAnimationGroup;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetSlideInAnimationGroup (element.m_IFrameworkElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetSlideInAnimationGroup
   (
      element : WinUI3.Windows.UI.Xaml.FrameworkElement'Class;
      value : WinUI3.Windows.UI.Xaml.Controls.PivotSlideInAnimationGroup
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetSlideInAnimationGroup (element.m_IFrameworkElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_HeaderFocusVisualPlacementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderFocusVisualPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHeaderItemsCarouselEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHeaderItemsCarouselEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftHeaderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftHeaderTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftHeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightHeaderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightHeaderTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Pivot");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightHeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Pivot

   function get_Title
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivot.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Title
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_Title (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TitleTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IPivot.all.get_TitleTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_TitleTemplate
   (
      this : in out Pivot;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_TitleTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IPivot.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out Pivot;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedIndex
   (
      this : in out Pivot
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IPivot.all.get_SelectedIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedIndex
   (
      this : in out Pivot;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_SelectedIndex (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedItem
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivot.all.get_SelectedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectedItem
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_SelectedItem (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsLocked
   (
      this : in out Pivot
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IPivot.all.get_IsLocked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsLocked
   (
      this : in out Pivot;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.put_IsLocked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out Pivot;
      handler : WinUI3.Windows.UI.Xaml.Controls.SelectionChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemLoading
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemLoading (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemLoading
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemLoading (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemLoaded
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemLoaded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemLoaded
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemLoaded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemUnloading
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemUnloading (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemUnloading
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemUnloading (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PivotItemUnloaded
   (
      this : in out Pivot;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IPivot.all.add_PivotItemUnloaded (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PivotItemUnloaded
   (
      this : in out Pivot;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivot.all.remove_PivotItemUnloaded (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftHeader
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.get_LeftHeader (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LeftHeader
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.put_LeftHeader (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftHeaderTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IPivot.all);
         Hr := m_Interface.get_LeftHeaderTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_LeftHeaderTemplate
   (
      this : in out Pivot;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.put_LeftHeaderTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightHeader
   (
      this : in out Pivot
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.get_RightHeader (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_RightHeader
   (
      this : in out Pivot;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.put_RightHeader (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightHeaderTemplate
   (
      this : in out Pivot
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IPivot.all);
         Hr := m_Interface.get_RightHeaderTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_RightHeaderTemplate
   (
      this : in out Pivot;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot2, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.put_RightHeaderTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderFocusVisualPlacement
   (
      this : in out Pivot
   )
   return WinUI3.Windows.UI.Xaml.Controls.PivotHeaderFocusVisualPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.PivotHeaderFocusVisualPlacement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot3, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.get_HeaderFocusVisualPlacement (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HeaderFocusVisualPlacement
   (
      this : in out Pivot;
      value : WinUI3.Windows.UI.Xaml.Controls.PivotHeaderFocusVisualPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot3, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.put_HeaderFocusVisualPlacement (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHeaderItemsCarouselEnabled
   (
      this : in out Pivot
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot3, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.get_IsHeaderItemsCarouselEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHeaderItemsCarouselEnabled
   (
      this : in out Pivot;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IPivot3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IPivot_Interface, WinUI3.Windows.UI.Xaml.Controls.IPivot3, WinUI3.Windows.UI.Xaml.Controls.IID_IPivot3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IPivot.all);
      Hr := m_Interface.put_IsHeaderItemsCarouselEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PivotItem

   procedure Initialize (this : in out PivotItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out PivotItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivotItem, IPivotItem_Ptr);
   begin
      if this.m_IPivotItem /= null then
         if this.m_IPivotItem.all /= null then
            temp := this.m_IPivotItem.all.Release;
            Free (this.m_IPivotItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PivotItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return PivotItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PivotItem");
      m_Factory    : access IPivotItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPivotItem;
   begin
      return RetVal : PivotItem do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IPivotItem := new WinUI3.Windows.UI.Xaml.Controls.IPivotItem;
            Retval.m_IPivotItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for PivotItem

   function get_HeaderProperty_PivotItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PivotItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IPivotItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IPivotItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PivotItem

   function get_Header
   (
      this : in out PivotItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IPivotItem.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out PivotItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivotItem.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for PivotItemEventArgs

   procedure Initialize (this : in out PivotItemEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out PivotItemEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IPivotItemEventArgs, IPivotItemEventArgs_Ptr);
   begin
      if this.m_IPivotItemEventArgs /= null then
         if this.m_IPivotItemEventArgs.all /= null then
            temp := this.m_IPivotItemEventArgs.all.Release;
            Free (this.m_IPivotItemEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for PivotItemEventArgs

   function Constructor return PivotItemEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.PivotItemEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IPivotItemEventArgs;
   begin
      return RetVal : PivotItemEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IPivotItemEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IPivotItemEventArgs;
            Retval.m_IPivotItemEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for PivotItemEventArgs

   function get_Item
   (
      this : in out PivotItemEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.PivotItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IPivotItem;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.PivotItem do
         Hr := this.m_IPivotItemEventArgs.all.get_Item (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IPivotItem := new WinUI3.Windows.UI.Xaml.Controls.IPivotItem;
         Retval.m_IPivotItem.all := m_ComRetVal;
      end return;
   end;

   procedure put_Item
   (
      this : in out PivotItemEventArgs;
      value : WinUI3.Windows.UI.Xaml.Controls.PivotItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IPivotItemEventArgs.all.put_Item (value.m_IPivotItem.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VirtualizingPanel

   procedure Initialize (this : in out VirtualizingPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out VirtualizingPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVirtualizingPanel, IVirtualizingPanel_Ptr);
   begin
      if this.m_IVirtualizingPanel /= null then
         if this.m_IVirtualizingPanel.all /= null then
            temp := this.m_IVirtualizingPanel.all.Release;
            Free (this.m_IVirtualizingPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VirtualizingPanel

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VirtualizingPanel

   function get_ItemContainerGenerator
   (
      this : in out VirtualizingPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.ItemContainerGenerator'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IItemContainerGenerator;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ItemContainerGenerator do
         Hr := this.m_IVirtualizingPanel.all.get_ItemContainerGenerator (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IItemContainerGenerator := new WinUI3.Windows.UI.Xaml.Controls.IItemContainerGenerator;
         Retval.m_IItemContainerGenerator.all := m_ComRetVal;
      end return;
   end;

   procedure AddInternalChild
   (
      this : in out VirtualizingPanel;
      child : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelProtected, WinUI3.Windows.UI.Xaml.Controls.IID_IVirtualizingPanelProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.AddInternalChild (child.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertInternalChild
   (
      this : in out VirtualizingPanel;
      index : WinUI3.Int32;
      child : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelProtected, WinUI3.Windows.UI.Xaml.Controls.IID_IVirtualizingPanelProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.InsertInternalChild (index, child.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveInternalChildRange
   (
      this : in out VirtualizingPanel;
      index : WinUI3.Int32;
      range_x : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelProtected := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelProtected, WinUI3.Windows.UI.Xaml.Controls.IID_IVirtualizingPanelProtected'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.RemoveInternalChildRange (index, range_x);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnItemsChanged
   (
      this : in out VirtualizingPanel;
      sender : WinUI3.IInspectable;
      args : WinUI3.Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IVirtualizingPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.OnItemsChanged (sender, args.m_IItemsChangedEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnClearChildren
   (
      this : in out VirtualizingPanel
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IVirtualizingPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.OnClearChildren;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure BringIndexIntoView
   (
      this : in out VirtualizingPanel;
      index : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IVirtualizingPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingPanel.all);
      Hr := m_Interface.BringIndexIntoView (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Slider

   procedure Initialize (this : in out Slider) is
   begin
      null;
   end;

   procedure Finalize (this : in out Slider) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISlider, ISlider_Ptr);
   begin
      if this.m_ISlider /= null then
         if this.m_ISlider.all /= null then
            temp := this.m_ISlider.all.Release;
            Free (this.m_ISlider);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Slider

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return Slider is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory    : access ISliderFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISlider;
   begin
      return RetVal : Slider do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISlider := new WinUI3.Windows.UI.Xaml.Controls.ISlider;
            Retval.m_ISlider.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Slider

   function get_HeaderProperty_Slider
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_Slider
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IntermediateValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IntermediateValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StepFrequencyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StepFrequencyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SnapsToProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SnapsToProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TickFrequencyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TickFrequencyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TickPlacementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TickPlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_Slider
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsDirectionReversedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDirectionReversedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsThumbToolTipEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsThumbToolTipEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ThumbToolTipValueConverterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Slider");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISliderStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISliderStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ThumbToolTipValueConverterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Slider

   function get_IntermediateValue
   (
      this : in out Slider
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISlider.all.get_IntermediateValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IntermediateValue
   (
      this : in out Slider;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_IntermediateValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StepFrequency
   (
      this : in out Slider
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISlider.all.get_StepFrequency (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StepFrequency
   (
      this : in out Slider;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_StepFrequency (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SnapsTo
   (
      this : in out Slider
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.SliderSnapsTo is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.SliderSnapsTo;
   begin
      Hr := this.m_ISlider.all.get_SnapsTo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SnapsTo
   (
      this : in out Slider;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.SliderSnapsTo
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_SnapsTo (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TickFrequency
   (
      this : in out Slider
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISlider.all.get_TickFrequency (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TickFrequency
   (
      this : in out Slider;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_TickFrequency (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TickPlacement
   (
      this : in out Slider
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.TickPlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.TickPlacement;
   begin
      Hr := this.m_ISlider.all.get_TickPlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TickPlacement
   (
      this : in out Slider;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.TickPlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_TickPlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out Slider
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_ISlider.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out Slider;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDirectionReversed
   (
      this : in out Slider
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISlider.all.get_IsDirectionReversed (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDirectionReversed
   (
      this : in out Slider;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_IsDirectionReversed (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsThumbToolTipEnabled
   (
      this : in out Slider
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISlider.all.get_IsThumbToolTipEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsThumbToolTipEnabled
   (
      this : in out Slider;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_IsThumbToolTipEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ThumbToolTipValueConverter
   (
      this : in out Slider
   )
   return WinUI3.Windows.UI.Xaml.Data.IValueConverter is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Data.IValueConverter;
   begin
      Hr := this.m_ISlider.all.get_ThumbToolTipValueConverter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ThumbToolTipValueConverter
   (
      this : in out Slider;
      value : WinUI3.Windows.UI.Xaml.Data.IValueConverter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISlider.all.put_ThumbToolTipValueConverter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out Slider
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISlider2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISlider_Interface, WinUI3.Windows.UI.Xaml.Controls.ISlider2, WinUI3.Windows.UI.Xaml.Controls.IID_ISlider2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISlider.all);
      Hr := m_Interface.get_Header (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out Slider;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISlider2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISlider_Interface, WinUI3.Windows.UI.Xaml.Controls.ISlider2, WinUI3.Windows.UI.Xaml.Controls.IID_ISlider2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISlider.all);
      Hr := m_Interface.put_Header (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out Slider
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISlider2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISlider_Interface, WinUI3.Windows.UI.Xaml.Controls.ISlider2, WinUI3.Windows.UI.Xaml.Controls.IID_ISlider2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_ISlider.all);
         Hr := m_Interface.get_HeaderTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out Slider;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISlider2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISlider_Interface, WinUI3.Windows.UI.Xaml.Controls.ISlider2, WinUI3.Windows.UI.Xaml.Controls.IID_ISlider2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISlider.all);
      Hr := m_Interface.put_HeaderTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProgressBar

   procedure Initialize (this : in out ProgressBar) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProgressBar) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProgressBar, IProgressBar_Ptr);
   begin
      if this.m_IProgressBar /= null then
         if this.m_IProgressBar.all /= null then
            temp := this.m_IProgressBar.all.Release;
            Free (this.m_IProgressBar);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ProgressBar

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ProgressBar is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ProgressBar");
      m_Factory    : access IProgressBarFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IProgressBar;
   begin
      return RetVal : ProgressBar do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IProgressBar := new WinUI3.Windows.UI.Xaml.Controls.IProgressBar;
            Retval.m_IProgressBar.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ProgressBar

   function get_IsIndeterminateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ProgressBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IProgressBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsIndeterminateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowErrorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ProgressBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IProgressBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowErrorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ShowPausedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ProgressBar");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IProgressBarStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressBarStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ShowPausedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProgressBar

   function get_IsIndeterminate
   (
      this : in out ProgressBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressBar.all.get_IsIndeterminate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsIndeterminate
   (
      this : in out ProgressBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressBar.all.put_IsIndeterminate (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowError
   (
      this : in out ProgressBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressBar.all.get_ShowError (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowError
   (
      this : in out ProgressBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressBar.all.put_ShowError (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ShowPaused
   (
      this : in out ProgressBar
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressBar.all.get_ShowPaused (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ShowPaused
   (
      this : in out ProgressBar;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressBar.all.put_ShowPaused (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ProgressBar
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IProgressBarTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings do
         Hr := this.m_IProgressBar.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IProgressBarTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IProgressBarTemplateSettings;
         Retval.m_IProgressBarTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ProgressRing

   procedure Initialize (this : in out ProgressRing) is
   begin
      null;
   end;

   procedure Finalize (this : in out ProgressRing) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IProgressRing, IProgressRing_Ptr);
   begin
      if this.m_IProgressRing /= null then
         if this.m_IProgressRing.all /= null then
            temp := this.m_IProgressRing.all.Release;
            Free (this.m_IProgressRing);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ProgressRing

   function Constructor return ProgressRing is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ProgressRing");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IProgressRing;
   begin
      return RetVal : ProgressRing do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IProgressRing := new WinUI3.Windows.UI.Xaml.Controls.IProgressRing;
            Retval.m_IProgressRing.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ProgressRing

   function get_IsActiveProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ProgressRing");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IProgressRingStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IProgressRingStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsActiveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ProgressRing

   function get_IsActive
   (
      this : in out ProgressRing
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IProgressRing.all.get_IsActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsActive
   (
      this : in out ProgressRing;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IProgressRing.all.put_IsActive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ProgressRing
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.ProgressRingTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IProgressRingTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.ProgressRingTemplateSettings do
         Hr := this.m_IProgressRing.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IProgressRingTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IProgressRingTemplateSettings;
         Retval.m_IProgressRingTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingControl

   procedure Initialize (this : in out RatingControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingControl, IRatingControl_Ptr);
   begin
      if this.m_IRatingControl /= null then
         if this.m_IRatingControl.all /= null then
            temp := this.m_IRatingControl.all.Release;
            Free (this.m_IRatingControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory    : access IRatingControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRatingControl;
   begin
      return RetVal : RatingControl do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingControl := new WinUI3.Windows.UI.Xaml.Controls.IRatingControl;
            Retval.m_IRatingControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RatingControl

   function get_CaptionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CaptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InitialSetValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InitialSetValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsClearEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsClearEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsReadOnlyProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsReadOnlyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxRatingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxRatingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemInfoProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemInfoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ValueProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ValueProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingControl

   function get_Caption
   (
      this : in out RatingControl
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingControl.all.get_Caption (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Caption
   (
      this : in out RatingControl;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingControl.all.put_Caption (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_InitialSetValue
   (
      this : in out RatingControl
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRatingControl.all.get_InitialSetValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_InitialSetValue
   (
      this : in out RatingControl;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_InitialSetValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsClearEnabled
   (
      this : in out RatingControl
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRatingControl.all.get_IsClearEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsClearEnabled
   (
      this : in out RatingControl;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_IsClearEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsReadOnly
   (
      this : in out RatingControl
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRatingControl.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsReadOnly
   (
      this : in out RatingControl;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_IsReadOnly (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxRating
   (
      this : in out RatingControl
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRatingControl.all.get_MaxRating (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxRating
   (
      this : in out RatingControl;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_MaxRating (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderValue
   (
      this : in out RatingControl
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRatingControl.all.get_PlaceholderValue (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PlaceholderValue
   (
      this : in out RatingControl;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_PlaceholderValue (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemInfo
   (
      this : in out RatingControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.RatingItemInfo'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRatingItemInfo;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RatingItemInfo do
         Hr := this.m_IRatingControl.all.get_ItemInfo (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRatingItemInfo := new WinUI3.Windows.UI.Xaml.Controls.IRatingItemInfo;
         Retval.m_IRatingItemInfo.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemInfo
   (
      this : in out RatingControl;
      value : WinUI3.Windows.UI.Xaml.Controls.RatingItemInfo'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_ItemInfo (value.m_IRatingItemInfo.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Value
   (
      this : in out RatingControl
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRatingControl.all.get_Value (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Value
   (
      this : in out RatingControl;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.put_Value (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ValueChanged
   (
      this : in out RatingControl;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRatingControl.all.add_ValueChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ValueChanged
   (
      this : in out RatingControl;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingControl.all.remove_ValueChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingItemInfo

   procedure Initialize (this : in out RatingItemInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingItemInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingItemInfo, IRatingItemInfo_Ptr);
   begin
      if this.m_IRatingItemInfo /= null then
         if this.m_IRatingItemInfo.all /= null then
            temp := this.m_IRatingItemInfo.all.Release;
            Free (this.m_IRatingItemInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingItemInfo

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingItemInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemInfo");
      m_Factory    : access IRatingItemInfoFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRatingItemInfo;
   begin
      return RetVal : RatingItemInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemInfoFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingItemInfo := new WinUI3.Windows.UI.Xaml.Controls.IRatingItemInfo;
            Retval.m_IRatingItemInfo.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingItemInfo

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingItemFontInfo

   procedure Initialize (this : in out RatingItemFontInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingItemFontInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingItemFontInfo, IRatingItemFontInfo_Ptr);
   begin
      if this.m_IRatingItemFontInfo /= null then
         if this.m_IRatingItemFontInfo.all /= null then
            temp := this.m_IRatingItemFontInfo.all.Release;
            Free (this.m_IRatingItemFontInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingItemFontInfo

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingItemFontInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory    : access IRatingItemFontInfoFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfo;
   begin
      return RetVal : RatingItemFontInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingItemFontInfo := new WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfo;
            Retval.m_IRatingItemFontInfo.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RatingItemFontInfo

   function get_DisabledGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlyphProperty_RatingItemFontInfo
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverPlaceholderGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverPlaceholderGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UnsetGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemFontInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemFontInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemFontInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UnsetGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingItemFontInfo

   function get_DisabledGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_DisabledGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_DisabledGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_DisabledGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Glyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_Glyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Glyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_Glyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PointerOverGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_PointerOverGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PointerOverGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_PointerOverGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PointerOverPlaceholderGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_PointerOverPlaceholderGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PointerOverPlaceholderGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_PointerOverPlaceholderGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PlaceholderGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_PlaceholderGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_PlaceholderGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_UnsetGlyph
   (
      this : in out RatingItemFontInfo
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRatingItemFontInfo.all.get_UnsetGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_UnsetGlyph
   (
      this : in out RatingItemFontInfo;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IRatingItemFontInfo.all.put_UnsetGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RatingItemImageInfo

   procedure Initialize (this : in out RatingItemImageInfo) is
   begin
      null;
   end;

   procedure Finalize (this : in out RatingItemImageInfo) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRatingItemImageInfo, IRatingItemImageInfo_Ptr);
   begin
      if this.m_IRatingItemImageInfo /= null then
         if this.m_IRatingItemImageInfo.all /= null then
            temp := this.m_IRatingItemImageInfo.all.Release;
            Free (this.m_IRatingItemImageInfo);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RatingItemImageInfo

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RatingItemImageInfo is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory    : access IRatingItemImageInfoFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfo;
   begin
      return RetVal : RatingItemImageInfo do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRatingItemImageInfo := new WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfo;
            Retval.m_IRatingItemImageInfo.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RatingItemImageInfo

   function get_DisabledImageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ImageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderImageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverImageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PointerOverPlaceholderImageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PointerOverPlaceholderImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_UnsetImageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RatingItemImageInfo");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRatingItemImageInfoStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRatingItemImageInfoStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UnsetImageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RatingItemImageInfo

   function get_DisabledImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_DisabledImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_DisabledImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_DisabledImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Image
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_Image (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_Image
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_Image (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_PlaceholderImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_PlaceholderImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_PointerOverImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_PointerOverImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PointerOverPlaceholderImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_PointerOverPlaceholderImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_PointerOverPlaceholderImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_PointerOverPlaceholderImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_UnsetImage
   (
      this : in out RatingItemImageInfo
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_IRatingItemImageInfo.all.get_UnsetImage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_UnsetImage
   (
      this : in out RatingItemImageInfo;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRatingItemImageInfo.all.put_UnsetImage (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshContainer

   procedure Initialize (this : in out RefreshContainer) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshContainer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshContainer, IRefreshContainer_Ptr);
   begin
      if this.m_IRefreshContainer /= null then
         if this.m_IRefreshContainer.all /= null then
            temp := this.m_IRefreshContainer.all.Release;
            Free (this.m_IRefreshContainer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RefreshContainer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RefreshContainer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshContainer");
      m_Factory    : access IRefreshContainerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRefreshContainer;
   begin
      return RetVal : RefreshContainer do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshContainerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRefreshContainer := new WinUI3.Windows.UI.Xaml.Controls.IRefreshContainer;
            Retval.m_IRefreshContainer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RefreshContainer

   function get_VisualizerProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshContainer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRefreshContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VisualizerProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PullDirectionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshContainer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRefreshContainerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshContainerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PullDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshContainer

   function get_Visualizer
   (
      this : in out RefreshContainer
   )
   return WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizer do
         Hr := this.m_IRefreshContainer.all.get_Visualizer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRefreshVisualizer := new WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizer;
         Retval.m_IRefreshVisualizer.all := m_ComRetVal;
      end return;
   end;

   procedure put_Visualizer
   (
      this : in out RefreshContainer;
      value : WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.put_Visualizer (value.m_IRefreshVisualizer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PullDirection
   (
      this : in out RefreshContainer
   )
   return WinUI3.Windows.UI.Xaml.Controls.RefreshPullDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.RefreshPullDirection;
   begin
      Hr := this.m_IRefreshContainer.all.get_PullDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PullDirection
   (
      this : in out RefreshContainer;
      value : WinUI3.Windows.UI.Xaml.Controls.RefreshPullDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.put_PullDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RefreshRequested
   (
      this : in out RefreshContainer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRefreshContainer.all.add_RefreshRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RefreshRequested
   (
      this : in out RefreshContainer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.remove_RefreshRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RequestRefresh
   (
      this : in out RefreshContainer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshContainer.all.RequestRefresh;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshInteractionRatioChangedEventArgs

   procedure Initialize (this : in out RefreshInteractionRatioChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshInteractionRatioChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshInteractionRatioChangedEventArgs, IRefreshInteractionRatioChangedEventArgs_Ptr);
   begin
      if this.m_IRefreshInteractionRatioChangedEventArgs /= null then
         if this.m_IRefreshInteractionRatioChangedEventArgs.all /= null then
            temp := this.m_IRefreshInteractionRatioChangedEventArgs.all.Release;
            Free (this.m_IRefreshInteractionRatioChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshInteractionRatioChangedEventArgs

   function get_InteractionRatio
   (
      this : in out RefreshInteractionRatioChangedEventArgs
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRefreshInteractionRatioChangedEventArgs.all.get_InteractionRatio (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshRequestedEventArgs

   procedure Initialize (this : in out RefreshRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshRequestedEventArgs, IRefreshRequestedEventArgs_Ptr);
   begin
      if this.m_IRefreshRequestedEventArgs /= null then
         if this.m_IRefreshRequestedEventArgs.all /= null then
            temp := this.m_IRefreshRequestedEventArgs.all.Release;
            Free (this.m_IRefreshRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshRequestedEventArgs

   function GetDeferral
   (
      this : in out RefreshRequestedEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IRefreshRequestedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshStateChangedEventArgs

   procedure Initialize (this : in out RefreshStateChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshStateChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshStateChangedEventArgs, IRefreshStateChangedEventArgs_Ptr);
   begin
      if this.m_IRefreshStateChangedEventArgs /= null then
         if this.m_IRefreshStateChangedEventArgs.all /= null then
            temp := this.m_IRefreshStateChangedEventArgs.all.Release;
            Free (this.m_IRefreshStateChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshStateChangedEventArgs

   function get_OldState
   (
      this : in out RefreshStateChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerState;
   begin
      Hr := this.m_IRefreshStateChangedEventArgs.all.get_OldState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewState
   (
      this : in out RefreshStateChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerState;
   begin
      Hr := this.m_IRefreshStateChangedEventArgs.all.get_NewState (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RefreshVisualizer

   procedure Initialize (this : in out RefreshVisualizer) is
   begin
      null;
   end;

   procedure Finalize (this : in out RefreshVisualizer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRefreshVisualizer, IRefreshVisualizer_Ptr);
   begin
      if this.m_IRefreshVisualizer /= null then
         if this.m_IRefreshVisualizer.all /= null then
            temp := this.m_IRefreshVisualizer.all.Release;
            Free (this.m_IRefreshVisualizer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RefreshVisualizer

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RefreshVisualizer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory    : access IRefreshVisualizerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizer;
   begin
      return RetVal : RefreshVisualizer do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRefreshVisualizer := new WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizer;
            Retval.m_IRefreshVisualizer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RefreshVisualizer

   function get_InfoProviderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InfoProviderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_RefreshVisualizer
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentProperty_RefreshVisualizer
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RefreshVisualizer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRefreshVisualizerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRefreshVisualizerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RefreshVisualizer

   procedure RequestRefresh
   (
      this : in out RefreshVisualizer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.RequestRefresh;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out RefreshVisualizer
   )
   return WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerOrientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerOrientation;
   begin
      Hr := this.m_IRefreshVisualizer.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out RefreshVisualizer;
      value : WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerOrientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Content
   (
      this : in out RefreshVisualizer
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IRefreshVisualizer.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out RefreshVisualizer;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_State
   (
      this : in out RefreshVisualizer
   )
   return WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.RefreshVisualizerState;
   begin
      Hr := this.m_IRefreshVisualizer.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_RefreshRequested
   (
      this : in out RefreshVisualizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRefreshVisualizer.all.add_RefreshRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RefreshRequested
   (
      this : in out RefreshVisualizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.remove_RefreshRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_RefreshStateChanged
   (
      this : in out RefreshVisualizer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRefreshVisualizer.all.add_RefreshStateChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_RefreshStateChanged
   (
      this : in out RefreshVisualizer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRefreshVisualizer.all.remove_RefreshStateChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RelativePanel

   procedure Initialize (this : in out RelativePanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out RelativePanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRelativePanel, IRelativePanel_Ptr);
   begin
      if this.m_IRelativePanel /= null then
         if this.m_IRelativePanel.all /= null then
            temp := this.m_IRelativePanel.all.Release;
            Free (this.m_IRelativePanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RelativePanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RelativePanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory    : access IRelativePanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRelativePanel;
   begin
      return RetVal : RelativePanel do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRelativePanel := new WinUI3.Windows.UI.Xaml.Controls.IRelativePanel;
            Retval.m_IRelativePanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RelativePanel

   function get_LeftOfProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftOfProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetLeftOf
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetLeftOf (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetLeftOf
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetLeftOf (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AboveProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AboveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAbove
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAbove (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAbove
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAbove (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_RightOfProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightOfProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRightOf
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRightOf (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRightOf
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRightOf (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_BelowProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BelowProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetBelow
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetBelow (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetBelow
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetBelow (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignHorizontalCenterWithProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignHorizontalCenterWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignHorizontalCenterWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignHorizontalCenterWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignHorizontalCenterWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignHorizontalCenterWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignVerticalCenterWithProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignVerticalCenterWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignVerticalCenterWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignVerticalCenterWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignVerticalCenterWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignVerticalCenterWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignLeftWithProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignLeftWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignLeftWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignLeftWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignLeftWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignLeftWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignTopWithProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignTopWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignTopWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignTopWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignTopWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignTopWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignRightWithProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignRightWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignRightWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignRightWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignRightWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignRightWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignBottomWithProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignBottomWithProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignBottomWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignBottomWith (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignBottomWith
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignBottomWith (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignLeftWithPanelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignLeftWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignLeftWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignLeftWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignLeftWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignLeftWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignTopWithPanelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignTopWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignTopWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignTopWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignTopWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignTopWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignRightWithPanelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignRightWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignRightWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignRightWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignRightWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignRightWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignBottomWithPanelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignBottomWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignBottomWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignBottomWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignBottomWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignBottomWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignHorizontalCenterWithPanelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignHorizontalCenterWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignHorizontalCenterWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignHorizontalCenterWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignHorizontalCenterWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignHorizontalCenterWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AlignVerticalCenterWithPanelProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AlignVerticalCenterWithPanelProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetAlignVerticalCenterWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetAlignVerticalCenterWithPanel (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetAlignVerticalCenterWithPanel
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetAlignVerticalCenterWithPanel (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_BorderBrushProperty_RelativePanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_RelativePanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_RelativePanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_RelativePanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty_RelativePanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RelativePanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRelativePanelStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRelativePanelStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RelativePanel

   function get_BorderBrush
   (
      this : in out RelativePanel
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IRelativePanel.all.get_BorderBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out RelativePanel;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_BorderBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out RelativePanel
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRelativePanel.all.get_BorderThickness (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out RelativePanel;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_BorderThickness (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out RelativePanel
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
   begin
      Hr := this.m_IRelativePanel.all.get_CornerRadius (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out RelativePanel;
      value : WinUI3.Windows.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_CornerRadius (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out RelativePanel
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRelativePanel.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out RelativePanel;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRelativePanel.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out RelativePanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRelativePanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRelativePanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IRelativePanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IRelativePanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRelativePanel.all);
      Hr := m_Interface.get_BackgroundSizing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out RelativePanel;
      value : WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRelativePanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRelativePanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IRelativePanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IRelativePanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRelativePanel.all);
      Hr := m_Interface.put_BackgroundSizing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditBox

   procedure Initialize (this : in out RichEditBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichEditBox, IRichEditBox_Ptr);
   begin
      if this.m_IRichEditBox /= null then
         if this.m_IRichEditBox.all /= null then
            temp := this.m_IRichEditBox.all.Release;
            Free (this.m_IRichEditBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RichEditBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return RichEditBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory    : access IRichEditBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRichEditBox;
   begin
      return RetVal : RichEditBox do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IRichEditBox := new WinUI3.Windows.UI.Xaml.Controls.IRichEditBox;
            Retval.m_IRichEditBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RichEditBox

   function get_DesiredCandidateWindowAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesiredCandidateWindowAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClipboardCopyFormatProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClipboardCopyFormatProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentLinkForegroundColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentLinkForegroundColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentLinkBackgroundColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentLinkBackgroundColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContentLinkProvidersProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentLinkProvidersProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HandwritingViewProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HandwritingViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHandwritingViewEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHandwritingViewEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterCasingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterCasingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisabledFormattingAcceleratorsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisabledFormattingAcceleratorsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocusProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreventKeyboardDisplayOnProgrammaticFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProofingMenuFlyoutProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProofingMenuFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsReadOnlyProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsReadOnlyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AcceptsReturnProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AcceptsReturnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSpellCheckEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSpellCheckEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextPredictionEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextPredictionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InputScopeProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InputScopeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorWhenNotFocusedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorWhenNotFocusedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLengthProperty_RichEditBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichEditBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichEditBoxStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditBox

   function get_IsReadOnly
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsReadOnly
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_IsReadOnly (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AcceptsReturn
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_AcceptsReturn (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AcceptsReturn
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_AcceptsReturn (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_IRichEditBox.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_IRichEditBox.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSpellCheckEnabled
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_IsSpellCheckEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSpellCheckEnabled
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_IsSpellCheckEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextPredictionEnabled
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBox.all.get_IsTextPredictionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextPredictionEnabled
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_IsTextPredictionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Document
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Text.ITextDocument is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.ITextDocument;
   begin
      Hr := this.m_IRichEditBox.all.get_Document (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_InputScope
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Input.InputScope'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.IInputScope;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Input.InputScope do
         Hr := this.m_IRichEditBox.all.get_InputScope (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputScope := new WinUI3.Windows.UI.Xaml.Input.IInputScope;
         Retval.m_IInputScope.all := m_ComRetVal;
      end return;
   end;

   procedure put_InputScope
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Input.InputScope'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.put_InputScope (value.m_IInputScope.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanged
   (
      this : in out RichEditBox;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_TextChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_TextChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out RichEditBox;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out RichEditBox;
      handler : WinUI3.Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichEditBox.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBox.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out RichEditBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_Header (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out RichEditBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_Header (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_HeaderTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_HeaderTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out RichEditBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_PlaceholderText (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out RichEditBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_PlaceholderText (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionHighlightColor
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_SelectionHighlightColor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_PreventKeyboardDisplayOnProgrammaticFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_PreventKeyboardDisplayOnProgrammaticFocus (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_IsColorFontEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_IsColorFontEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Paste
   (
      this : in out RichEditBox;
      handler : WinUI3.Windows.UI.Xaml.Controls.TextControlPasteEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_Paste (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Paste
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_Paste (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionStarted
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_TextCompositionStarted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionStarted
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_TextCompositionStarted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionChanged
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_TextCompositionChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_TextCompositionChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionEnded
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_TextCompositionEnded (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionEnded
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_TextCompositionEnded (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextReadingOrder;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_TextReadingOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_TextReadingOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredCandidateWindowAlignment
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.CandidateWindowAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CandidateWindowAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_DesiredCandidateWindowAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredCandidateWindowAlignment
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Controls.CandidateWindowAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_DesiredCandidateWindowAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CandidateWindowBoundsChanged
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_CandidateWindowBoundsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CandidateWindowBoundsChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_CandidateWindowBoundsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanging
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_TextChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanging
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_TextChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetLinguisticAlternativesAsync
   (
      this : in out RichEditBox
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.GetLinguisticAlternativesAsync (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_ClipboardCopyFormat
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.RichEditClipboardFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.RichEditClipboardFormat;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_ClipboardCopyFormat (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ClipboardCopyFormat
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Controls.RichEditClipboardFormat
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox4, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_ClipboardCopyFormat (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionHighlightColorWhenNotFocused
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_SelectionHighlightColorWhenNotFocused (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColorWhenNotFocused
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_SelectionHighlightColorWhenNotFocused (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLength
   (
      this : in out RichEditBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_MaxLength (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLength
   (
      this : in out RichEditBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_MaxLength (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_HorizontalTextAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_HorizontalTextAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterCasing
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.CharacterCasing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CharacterCasing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_CharacterCasing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterCasing
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Controls.CharacterCasing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_CharacterCasing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisabledFormattingAccelerators
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.DisabledFormattingAccelerators is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.DisabledFormattingAccelerators;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_DisabledFormattingAccelerators (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisabledFormattingAccelerators
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Controls.DisabledFormattingAccelerators
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_DisabledFormattingAccelerators (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CopyingToClipboard
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_CopyingToClipboard (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CopyingToClipboard
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_CopyingToClipboard (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CuttingToClipboard
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_CuttingToClipboard (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CuttingToClipboard
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_CuttingToClipboard (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentLinkForegroundColor
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_ContentLinkForegroundColor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentLinkForegroundColor
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_ContentLinkForegroundColor (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentLinkBackgroundColor
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_ContentLinkBackgroundColor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentLinkBackgroundColor
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_ContentLinkBackgroundColor (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentLinkProviders
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Documents.ContentLinkProviderCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.IContentLinkProviderCollection;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.ContentLinkProviderCollection do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_ContentLinkProviders (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IContentLinkProviderCollection := new WinUI3.Windows.UI.Xaml.Documents.IContentLinkProviderCollection;
         Retval.m_IContentLinkProviderCollection.all := m_ComRetVal;
      end return;
   end;

   procedure put_ContentLinkProviders
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Documents.ContentLinkProviderCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_ContentLinkProviders (value.m_IContentLinkProviderCollection.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HandwritingView
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.HandwritingView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IHandwritingView;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.HandwritingView do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_HandwritingView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHandwritingView := new WinUI3.Windows.UI.Xaml.Controls.IHandwritingView;
         Retval.m_IHandwritingView.all := m_ComRetVal;
      end return;
   end;

   procedure put_HandwritingView
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Controls.HandwritingView'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_HandwritingView (value.m_IHandwritingView.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHandwritingViewEnabled
   (
      this : in out RichEditBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_IsHandwritingViewEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHandwritingViewEnabled
   (
      this : in out RichEditBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_IsHandwritingViewEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContentLinkChanged
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_ContentLinkChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContentLinkChanged
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_ContentLinkChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContentLinkInvoked
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_ContentLinkInvoked (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContentLinkInvoked
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox7, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_ContentLinkInvoked (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextDocument
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Text.RichEditTextDocument'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.ITextDocument;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Text.RichEditTextDocument do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_TextDocument (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextDocument := new WinUI3.Windows.UI.Text.ITextDocument;
         Retval.m_ITextDocument.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionFlyout
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_SelectionFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out RichEditBox;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_SelectionFlyout (value.m_IFlyoutBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProofingMenuFlyout
   (
      this : in out RichEditBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_IRichEditBox.all);
         Hr := m_Interface.get_ProofingMenuFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   function get_Description
   (
      this : in out RichEditBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.get_Description (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out RichEditBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.put_Description (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanging
   (
      this : in out RichEditBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.add_SelectionChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanging
   (
      this : in out RichEditBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBox_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBox8, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBox.all);
      Hr := m_Interface.remove_SelectionChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditBoxSelectionChangingEventArgs

   procedure Initialize (this : in out RichEditBoxSelectionChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditBoxSelectionChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichEditBoxSelectionChangingEventArgs, IRichEditBoxSelectionChangingEventArgs_Ptr);
   begin
      if this.m_IRichEditBoxSelectionChangingEventArgs /= null then
         if this.m_IRichEditBoxSelectionChangingEventArgs.all /= null then
            temp := this.m_IRichEditBoxSelectionChangingEventArgs.all.Release;
            Free (this.m_IRichEditBoxSelectionChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditBoxSelectionChangingEventArgs

   function get_SelectionStart
   (
      this : in out RichEditBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.get_SelectionStart (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionLength
   (
      this : in out RichEditBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.get_SelectionLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out RichEditBoxSelectionChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out RichEditBoxSelectionChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichEditBoxSelectionChangingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditBoxTextChangingEventArgs

   procedure Initialize (this : in out RichEditBoxTextChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditBoxTextChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichEditBoxTextChangingEventArgs, IRichEditBoxTextChangingEventArgs_Ptr);
   begin
      if this.m_IRichEditBoxTextChangingEventArgs /= null then
         if this.m_IRichEditBoxTextChangingEventArgs.all /= null then
            temp := this.m_IRichEditBoxTextChangingEventArgs.all.Release;
            Free (this.m_IRichEditBoxTextChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditBoxTextChangingEventArgs

   function get_IsContentChanging
   (
      this : in out RichEditBoxTextChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichEditBoxTextChangingEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichEditBoxTextChangingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichEditBoxTextChangingEventArgs.all);
      Hr := m_Interface.get_IsContentChanging (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichTextBlock

   procedure Initialize (this : in out RichTextBlock) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichTextBlock) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichTextBlock, IRichTextBlock_Ptr);
   begin
      if this.m_IRichTextBlock /= null then
         if this.m_IRichTextBlock.all /= null then
            temp := this.m_IRichTextBlock.all.Release;
            Free (this.m_IRichTextBlock);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RichTextBlock

   function Constructor return RichTextBlock is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock;
   begin
      return RetVal : RichTextBlock do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRichTextBlock := new WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock;
            Retval.m_IRichTextBlock.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RichTextBlock

   function get_MaxLinesProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextLineBoundsProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextLineBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpticalMarginAlignmentProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpticalMarginAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextTrimmingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextTrimmingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineHeightProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineStackingStrategyProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineStackingStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowContentTargetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowContentTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextSelectionEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextSelectionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasOverflowContentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasOverflowContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextIndentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextIndentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextDecorationsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextDecorationsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextTrimmedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextTrimmedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty_RichTextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichTextBlock

   function get_FontSize
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out RichTextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_IRichTextBlock.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_IRichTextBlock.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_IRichTextBlock.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextTrimming
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextTrimming is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextTrimming;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextTrimming (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextTrimming
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.TextTrimming
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextTrimming (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Blocks
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.BlockCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.BlockCollection do
         Hr := this.m_IRichTextBlock.all.get_Blocks (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Padding
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRichTextBlock.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineHeight
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_LineHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineHeight
   (
      this : in out RichTextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_LineHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineStackingStrategy
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.LineStackingStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.LineStackingStrategy;
   begin
      Hr := this.m_IRichTextBlock.all.get_LineStackingStrategy (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineStackingStrategy
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.LineStackingStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_LineStackingStrategy (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out RichTextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IRichTextBlock.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out RichTextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OverflowContentTarget
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Controls.RichTextBlockOverflow'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RichTextBlockOverflow do
         Hr := this.m_IRichTextBlock.all.get_OverflowContentTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRichTextBlockOverflow := new WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow;
         Retval.m_IRichTextBlockOverflow.all := m_ComRetVal;
      end return;
   end;

   procedure put_OverflowContentTarget
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.Controls.RichTextBlockOverflow'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_OverflowContentTarget (value.m_IRichTextBlockOverflow.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextSelectionEnabled
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.get_IsTextSelectionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextSelectionEnabled
   (
      this : in out RichTextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_IsTextSelectionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasOverflowContent
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.get_HasOverflowContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectedText
   (
      this : in out RichTextBlock
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IRichTextBlock.all.get_SelectedText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ContentStart
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_ContentStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_ContentEnd
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_ContentEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionStart
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_SelectionStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionEnd
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.get_SelectionEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_BaselineOffset
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_BaselineOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_SelectionChanged
   (
      this : in out RichTextBlock;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichTextBlock.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out RichTextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out RichTextBlock;
      handler : WinUI3.Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IRichTextBlock.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out RichTextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out RichTextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Select_x
   (
      this : in out RichTextBlock;
      start : WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class;
      end_x : WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.Select_x (start.m_ITextPointer.all, end_x.m_ITextPointer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetPositionFromPoint
   (
      this : in out RichTextBlock;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlock.all.GetPositionFromPoint (point, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function Focus
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.FocusState
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlock.all.Focus (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_TextIndent
   (
      this : in out RichTextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlock.all.get_TextIndent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextIndent
   (
      this : in out RichTextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlock.all.put_TextIndent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLines
   (
      this : in out RichTextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_MaxLines (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out RichTextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_MaxLines (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextLineBounds
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextLineBounds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextLineBounds;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_TextLineBounds (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextLineBounds
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.TextLineBounds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_TextLineBounds (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionHighlightColor
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_IRichTextBlock.all);
         Hr := m_Interface.get_SelectionHighlightColor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpticalMarginAlignment
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.OpticalMarginAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.OpticalMarginAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_OpticalMarginAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpticalMarginAlignment
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.OpticalMarginAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_OpticalMarginAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_IsColorFontEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out RichTextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_IsColorFontEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextReadingOrder;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_TextReadingOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_TextReadingOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out RichTextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_IsTextScaleFactorEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextDecorations
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Text.TextDecorations is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.TextDecorations;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock4, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_TextDecorations (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextDecorations
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Text.TextDecorations
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock4, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_TextDecorations (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextTrimmed
   (
      this : in out RichTextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_IsTextTrimmed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_HorizontalTextAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_HorizontalTextAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextHighlighters
   (
      this : in out RichTextBlock
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.get_TextHighlighters (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_IsTextTrimmedChanged
   (
      this : in out RichTextBlock;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.add_IsTextTrimmedChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsTextTrimmedChanged
   (
      this : in out RichTextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.remove_IsTextTrimmedChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionFlyout
   (
      this : in out RichTextBlock
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock6'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_IRichTextBlock.all);
         Hr := m_Interface.get_SelectionFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out RichTextBlock;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.put_SelectionFlyout (value.m_IFlyoutBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CopySelectionToClipboard
   (
      this : in out RichTextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlock.all);
      Hr := m_Interface.CopySelectionToClipboard;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichTextBlockOverflow

   procedure Initialize (this : in out RichTextBlockOverflow) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichTextBlockOverflow) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRichTextBlockOverflow, IRichTextBlockOverflow_Ptr);
   begin
      if this.m_IRichTextBlockOverflow /= null then
         if this.m_IRichTextBlockOverflow.all /= null then
            temp := this.m_IRichTextBlockOverflow.all.Release;
            Free (this.m_IRichTextBlockOverflow);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RichTextBlockOverflow

   function Constructor return RichTextBlockOverflow is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlockOverflow");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow;
   begin
      return RetVal : RichTextBlockOverflow do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRichTextBlockOverflow := new WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow;
            Retval.m_IRichTextBlockOverflow.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RichTextBlockOverflow

   function get_IsTextTrimmedProperty_RichTextBlockOverflow
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextTrimmedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OverflowContentTargetProperty_RichTextBlockOverflow
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OverflowContentTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_RichTextBlockOverflow
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasOverflowContentProperty_RichTextBlockOverflow
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasOverflowContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLinesProperty_RichTextBlockOverflow
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RichTextBlockOverflow");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflowStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRichTextBlockOverflowStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichTextBlockOverflow

   function get_OverflowContentTarget
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Windows.UI.Xaml.Controls.RichTextBlockOverflow'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RichTextBlockOverflow do
         Hr := this.m_IRichTextBlockOverflow.all.get_OverflowContentTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRichTextBlockOverflow := new WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow;
         Retval.m_IRichTextBlockOverflow.all := m_ComRetVal;
      end return;
   end;

   procedure put_OverflowContentTarget
   (
      this : in out RichTextBlockOverflow;
      value : WinUI3.Windows.UI.Xaml.Controls.RichTextBlockOverflow'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.put_OverflowContentTarget (value.m_IRichTextBlockOverflow.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out RichTextBlockOverflow;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ContentSource
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Windows.UI.Xaml.Controls.RichTextBlock'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RichTextBlock do
         Hr := this.m_IRichTextBlockOverflow.all.get_ContentSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRichTextBlock := new WinUI3.Windows.UI.Xaml.Controls.IRichTextBlock;
         Retval.m_IRichTextBlock.all := m_ComRetVal;
      end return;
   end;

   function get_HasOverflowContent
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_HasOverflowContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContentStart
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlockOverflow.all.get_ContentStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_ContentEnd
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlockOverflow.all.get_ContentEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_BaselineOffset
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.get_BaselineOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetPositionFromPoint
   (
      this : in out RichTextBlockOverflow;
      point : WinUI3.Windows.Foundation.Point
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_IRichTextBlockOverflow.all.GetPositionFromPoint (point, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function Focus
   (
      this : in out RichTextBlockOverflow;
      value : WinUI3.Windows.UI.Xaml.FocusState
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IRichTextBlockOverflow.all.Focus (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MaxLines
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlockOverflow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlockOverflow.all);
      Hr := m_Interface.get_MaxLines (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out RichTextBlockOverflow;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow2, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlockOverflow2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlockOverflow.all);
      Hr := m_Interface.put_MaxLines (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextTrimmed
   (
      this : in out RichTextBlockOverflow
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlockOverflow3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlockOverflow.all);
      Hr := m_Interface.get_IsTextTrimmed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_IsTextTrimmedChanged
   (
      this : in out RichTextBlockOverflow;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlockOverflow3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlockOverflow.all);
      Hr := m_Interface.add_IsTextTrimmedChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsTextTrimmedChanged
   (
      this : in out RichTextBlockOverflow;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow_Interface, WinUI3.Windows.UI.Xaml.Controls.IRichTextBlockOverflow3, WinUI3.Windows.UI.Xaml.Controls.IID_IRichTextBlockOverflow3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IRichTextBlockOverflow.all);
      Hr := m_Interface.remove_IsTextTrimmedChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RowDefinition

   procedure Initialize (this : in out RowDefinition) is
   begin
      null;
   end;

   procedure Finalize (this : in out RowDefinition) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IRowDefinition, IRowDefinition_Ptr);
   begin
      if this.m_IRowDefinition /= null then
         if this.m_IRowDefinition.all /= null then
            temp := this.m_IRowDefinition.all.Release;
            Free (this.m_IRowDefinition);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for RowDefinition

   function Constructor return RowDefinition is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RowDefinition");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
   begin
      return RetVal : RowDefinition do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IRowDefinition := new WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
            Retval.m_IRowDefinition.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for RowDefinition

   function get_HeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RowDefinition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRowDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRowDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RowDefinition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRowDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRowDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.RowDefinition");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IRowDefinitionStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IRowDefinitionStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RowDefinition

   function get_Height
   (
      this : in out RowDefinition
   )
   return WinUI3.Windows.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.GridLength;
   begin
      Hr := this.m_IRowDefinition.all.get_Height (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Height
   (
      this : in out RowDefinition;
      value : WinUI3.Windows.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRowDefinition.all.put_Height (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxHeight
   (
      this : in out RowDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRowDefinition.all.get_MaxHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxHeight
   (
      this : in out RowDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRowDefinition.all.put_MaxHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinHeight
   (
      this : in out RowDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRowDefinition.all.get_MinHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinHeight
   (
      this : in out RowDefinition;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IRowDefinition.all.put_MinHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ActualHeight
   (
      this : in out RowDefinition
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IRowDefinition.all.get_ActualHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RowDefinitionCollection

   procedure Initialize (this : in out RowDefinitionCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out RowDefinitionCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RowDefinitionCollection

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Controls.RowDefinition>
   function GetAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Controls.RowDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RowDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRowDefinition := new WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
         Retval.m_IRowDefinition.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out RowDefinitionCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out RowDefinitionCollection
   )
   return WinUI3.Windows.UI.Xaml.Controls.RowDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RowDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRowDefinition := new WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
         Retval.m_IRowDefinition.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out RowDefinitionCollection;
      value : WinUI3.Windows.UI.Xaml.Controls.RowDefinition'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IRowDefinition.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.RowDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IRowDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.RowDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IRowDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out RowDefinitionCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out RowDefinitionCollection;
      value : WinUI3.Windows.UI.Xaml.Controls.RowDefinition'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IRowDefinition.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out RowDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out RowDefinitionCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out RowDefinitionCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Controls.IRowDefinition_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out RowDefinitionCollection;
      items : WinUI3.Windows.UI.Xaml.Controls.IRowDefinition_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (1646418305, 31245, 23864, (128, 136, 124, 107, 182, 217, 89, 190 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Controls.RowDefinition>
   function First
   (
      this : in out RowDefinitionCollection
   )
   return WinUI3.Windows.UI.Xaml.Controls.RowDefinition'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IRowDefinition.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
      m_GenericIID     : aliased WinUI3.IID := (2884588074, 29560, 20559, (148, 6, 151, 217, 244, 38, 67, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IRowDefinition.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.RowDefinition do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IRowDefinition := new WinUI3.Windows.UI.Xaml.Controls.IRowDefinition;
         Retval.m_IRowDefinition.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollContentPresenter

   procedure Initialize (this : in out ScrollContentPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollContentPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollContentPresenter, IScrollContentPresenter_Ptr);
   begin
      if this.m_IScrollContentPresenter /= null then
         if this.m_IScrollContentPresenter.all /= null then
            temp := this.m_IScrollContentPresenter.all.Release;
            Free (this.m_IScrollContentPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollContentPresenter

   function Constructor return ScrollContentPresenter is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollContentPresenter");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter;
   begin
      return RetVal : ScrollContentPresenter do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollContentPresenter := new WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter;
            Retval.m_IScrollContentPresenter.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScrollContentPresenter

   function get_CanContentRenderOutsideBoundsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollContentPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanContentRenderOutsideBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SizesContentToTemplatedParentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollContentPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollContentPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SizesContentToTemplatedParentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollContentPresenter

   function get_CanVerticallyScroll
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_CanVerticallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanVerticallyScroll
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_CanVerticallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanHorizontallyScroll
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_CanHorizontallyScroll (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanHorizontallyScroll
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_CanHorizontallyScroll (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExtentWidth
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalOffset
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollOwner
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IScrollContentPresenter.all.get_ScrollOwner (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ScrollOwner
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.put_ScrollOwner (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineUp
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineDown
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineLeft
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LineRight
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.LineRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageUp
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageDown
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageLeft
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PageRight
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.PageRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelUp
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelUp;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelDown
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelDown;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelLeft
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelLeft;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MouseWheelRight
   (
      this : in out ScrollContentPresenter
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.MouseWheelRight;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetHorizontalOffset
   (
      this : in out ScrollContentPresenter;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.SetHorizontalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetVerticalOffset
   (
      this : in out ScrollContentPresenter;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollContentPresenter.all.SetVerticalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function MakeVisible
   (
      this : in out ScrollContentPresenter;
      visual : WinUI3.Windows.UI.Xaml.UIElement'Class;
      rectangle : WinUI3.Windows.Foundation.Rect
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_IScrollContentPresenter.all.MakeVisible (visual.m_IUIElement.all, rectangle, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanContentRenderOutsideBounds
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollContentPresenter.all);
      Hr := m_Interface.get_CanContentRenderOutsideBounds (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanContentRenderOutsideBounds
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollContentPresenter.all);
      Hr := m_Interface.put_CanContentRenderOutsideBounds (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SizesContentToTemplatedParent
   (
      this : in out ScrollContentPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollContentPresenter.all);
      Hr := m_Interface.get_SizesContentToTemplatedParent (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SizesContentToTemplatedParent
   (
      this : in out ScrollContentPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollContentPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollContentPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollContentPresenter.all);
      Hr := m_Interface.put_SizesContentToTemplatedParent (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewer

   procedure Initialize (this : in out ScrollViewer) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewer, IScrollViewer_Ptr);
   begin
      if this.m_IScrollViewer /= null then
         if this.m_IScrollViewer.all /= null then
            temp := this.m_IScrollViewer.all.Release;
            Free (this.m_IScrollViewer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollViewer

   function Constructor return ScrollViewer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IScrollViewer;
   begin
      return RetVal : ScrollViewer do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollViewer := new WinUI3.Windows.UI.Xaml.Controls.IScrollViewer;
            Retval.m_IScrollViewer.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ScrollViewer

   function get_ReduceViewportForCoreInputViewOcclusionsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ReduceViewportForCoreInputViewOcclusionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalAnchorRatioProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalAnchorRatioProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalAnchorRatioProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanContentRenderOutsideBoundsProperty_ScrollViewer
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanContentRenderOutsideBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetCanContentRenderOutsideBounds
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetCanContentRenderOutsideBounds (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetCanContentRenderOutsideBounds
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      canContentRenderOutsideBounds : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetCanContentRenderOutsideBounds (element.m_IDependencyObject.all, canContentRenderOutsideBounds);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_HorizontalSnapPointsAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSnapPointsAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSnapPointsAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSnapPointsAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalSnapPointsTypeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalSnapPointsTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalSnapPointsTypeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalSnapPointsTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomSnapPointsTypeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomSnapPointsTypeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ViewportWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ViewportWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScrollableWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScrollableWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedHorizontalScrollBarVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedHorizontalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExtentWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExtentWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalOffsetProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ViewportHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ViewportHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ScrollableHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ScrollableHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ComputedVerticalScrollBarVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ComputedVerticalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExtentHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExtentHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinZoomFactorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxZoomFactorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomFactorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomFactorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomSnapPointsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomSnapPointsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalScrollBarVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetHorizontalScrollBarVisibility
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHorizontalScrollBarVisibility (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetHorizontalScrollBarVisibility
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      horizontalScrollBarVisibility : WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetHorizontalScrollBarVisibility (element.m_IDependencyObject.all, horizontalScrollBarVisibility);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_VerticalScrollBarVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollBarVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetVerticalScrollBarVisibility
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVerticalScrollBarVisibility (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetVerticalScrollBarVisibility
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      verticalScrollBarVisibility : WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetVerticalScrollBarVisibility (element.m_IDependencyObject.all, verticalScrollBarVisibility);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsHorizontalRailEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHorizontalRailEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsHorizontalRailEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsHorizontalRailEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsHorizontalRailEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isHorizontalRailEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsHorizontalRailEnabled (element.m_IDependencyObject.all, isHorizontalRailEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsVerticalRailEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVerticalRailEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsVerticalRailEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsVerticalRailEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsVerticalRailEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isVerticalRailEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsVerticalRailEnabled (element.m_IDependencyObject.all, isVerticalRailEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsHorizontalScrollChainingEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHorizontalScrollChainingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsHorizontalScrollChainingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsHorizontalScrollChainingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsHorizontalScrollChainingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isHorizontalScrollChainingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsHorizontalScrollChainingEnabled (element.m_IDependencyObject.all, isHorizontalScrollChainingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsVerticalScrollChainingEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVerticalScrollChainingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsVerticalScrollChainingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsVerticalScrollChainingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsVerticalScrollChainingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isVerticalScrollChainingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsVerticalScrollChainingEnabled (element.m_IDependencyObject.all, isVerticalScrollChainingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsZoomChainingEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomChainingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsZoomChainingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsZoomChainingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsZoomChainingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isZoomChainingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsZoomChainingEnabled (element.m_IDependencyObject.all, isZoomChainingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsScrollInertiaEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsScrollInertiaEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsScrollInertiaEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsScrollInertiaEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsScrollInertiaEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isScrollInertiaEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsScrollInertiaEnabled (element.m_IDependencyObject.all, isScrollInertiaEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsZoomInertiaEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomInertiaEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsZoomInertiaEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsZoomInertiaEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsZoomInertiaEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isZoomInertiaEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsZoomInertiaEnabled (element.m_IDependencyObject.all, isZoomInertiaEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_HorizontalScrollModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetHorizontalScrollMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetHorizontalScrollMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetHorizontalScrollMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      horizontalScrollMode : WinUI3.Windows.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetHorizontalScrollMode (element.m_IDependencyObject.all, horizontalScrollMode);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_VerticalScrollModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalScrollModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetVerticalScrollMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVerticalScrollMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetVerticalScrollMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      verticalScrollMode : WinUI3.Windows.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetVerticalScrollMode (element.m_IDependencyObject.all, verticalScrollMode);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ZoomModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetZoomMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.ZoomMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ZoomMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetZoomMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetZoomMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      zoomMode : WinUI3.Windows.UI.Xaml.Controls.ZoomMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetZoomMode (element.m_IDependencyObject.all, zoomMode);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsDeferredScrollingEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDeferredScrollingEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsDeferredScrollingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsDeferredScrollingEnabled (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetIsDeferredScrollingEnabled
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      isDeferredScrollingEnabled : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetIsDeferredScrollingEnabled (element.m_IDependencyObject.all, isDeferredScrollingEnabled);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_BringIntoViewOnFocusChangeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BringIntoViewOnFocusChangeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetBringIntoViewOnFocusChange
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetBringIntoViewOnFocusChange (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetBringIntoViewOnFocusChange
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      bringIntoViewOnFocusChange : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetBringIntoViewOnFocusChange (element.m_IDependencyObject.all, bringIntoViewOnFocusChange);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_TopLeftHeaderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopLeftHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LeftHeaderProperty_ScrollViewer
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopHeaderProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewer");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IScrollViewerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IScrollViewerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopHeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewer

   function get_HorizontalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollBarVisibility
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalScrollBarVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollBarVisibility
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.ScrollBarVisibility
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalScrollBarVisibility (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHorizontalRailEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsHorizontalRailEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHorizontalRailEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsHorizontalRailEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVerticalRailEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsVerticalRailEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVerticalRailEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsVerticalRailEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHorizontalScrollChainingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsHorizontalScrollChainingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHorizontalScrollChainingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsHorizontalScrollChainingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsVerticalScrollChainingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsVerticalScrollChainingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsVerticalScrollChainingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsVerticalScrollChainingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomChainingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsZoomChainingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomChainingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsZoomChainingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsScrollInertiaEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsScrollInertiaEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsScrollInertiaEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsScrollInertiaEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomInertiaEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsZoomInertiaEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomInertiaEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsZoomInertiaEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalScrollMode
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalScrollMode
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalScrollMode
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ScrollMode;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalScrollMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalScrollMode
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.ScrollMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalScrollMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomMode
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.ZoomMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ZoomMode;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomMode
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.ZoomMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_ZoomMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSnapPointsAlignment
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalSnapPointsAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSnapPointsAlignment
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalSnapPointsAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSnapPointsAlignment
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalSnapPointsAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSnapPointsAlignment
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalSnapPointsAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalSnapPointsType
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.SnapPointsType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SnapPointsType;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalSnapPointsType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalSnapPointsType
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.SnapPointsType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_HorizontalSnapPointsType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalSnapPointsType
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.SnapPointsType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SnapPointsType;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalSnapPointsType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalSnapPointsType
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.SnapPointsType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_VerticalSnapPointsType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomSnapPointsType
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Controls.SnapPointsType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SnapPointsType;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomSnapPointsType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomSnapPointsType
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.Controls.SnapPointsType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_ZoomSnapPointsType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalOffset
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportWidth
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ViewportWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableWidth
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ScrollableWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedHorizontalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_IScrollViewer.all.get_ComputedHorizontalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentWidth
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ExtentWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ViewportHeight
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ViewportHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ScrollableHeight
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ScrollableHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ComputedVerticalScrollBarVisibility
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_IScrollViewer.all.get_ComputedVerticalScrollBarVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ExtentHeight
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewer.all.get_ExtentHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_MinZoomFactor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewer.all.get_MinZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinZoomFactor
   (
      this : in out ScrollViewer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_MinZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxZoomFactor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewer.all.get_MaxZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxZoomFactor
   (
      this : in out ScrollViewer;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_MaxZoomFactor (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomFactor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomSnapPoints
   (
      this : in out ScrollViewer
   )
   return IVector_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_Single.Kind;
   begin
      Hr := this.m_IScrollViewer.all.get_ZoomSnapPoints (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function add_ViewChanged
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IScrollViewer.all.add_ViewChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChanged
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.remove_ViewChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollToHorizontalOffset
   (
      this : in out ScrollViewer;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.ScrollToHorizontalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollToVerticalOffset
   (
      this : in out ScrollViewer;
      offset : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.ScrollToVerticalOffset (offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ZoomToFactor
   (
      this : in out ScrollViewer;
      factor : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.ZoomToFactor (factor);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InvalidateScrollInfo
   (
      this : in out ScrollViewer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.InvalidateScrollInfo;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsDeferredScrollingEnabled
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_IsDeferredScrollingEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDeferredScrollingEnabled
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_IsDeferredScrollingEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BringIntoViewOnFocusChange
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewer.all.get_BringIntoViewOnFocusChange (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BringIntoViewOnFocusChange
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IScrollViewer.all.put_BringIntoViewOnFocusChange (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopLeftHeader
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IScrollViewer.all);
         Hr := m_Interface.get_TopLeftHeader (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopLeftHeader
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.put_TopLeftHeader (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LeftHeader
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IScrollViewer.all);
         Hr := m_Interface.get_LeftHeader (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_LeftHeader
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.put_LeftHeader (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopHeader
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IScrollViewer.all);
         Hr := m_Interface.get_TopHeader (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopHeader
   (
      this : in out ScrollViewer;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.put_TopHeader (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChanging
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.add_ViewChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChanging
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.remove_ViewChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ChangeView
   (
      this : in out ScrollViewer;
      horizontalOffset : GenericObject;
      verticalOffset : GenericObject;
      zoomFactor : GenericObject
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.ChangeView (horizontalOffset, verticalOffset, zoomFactor, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ChangeView
   (
      this : in out ScrollViewer;
      horizontalOffset : GenericObject;
      verticalOffset : GenericObject;
      zoomFactor : GenericObject;
      disableAnimation : WinUI3.Boolean
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer2, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.ChangeView (horizontalOffset, verticalOffset, zoomFactor, disableAnimation, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_DirectManipulationStarted
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.add_DirectManipulationStarted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DirectManipulationStarted
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.remove_DirectManipulationStarted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DirectManipulationCompleted
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.add_DirectManipulationCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DirectManipulationCompleted
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer3, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.remove_DirectManipulationCompleted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ReduceViewportForCoreInputViewOcclusions
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.get_ReduceViewportForCoreInputViewOcclusions (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ReduceViewportForCoreInputViewOcclusions
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.put_ReduceViewportForCoreInputViewOcclusions (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalAnchorRatio
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.get_HorizontalAnchorRatio (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalAnchorRatio
   (
      this : in out ScrollViewer;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.put_HorizontalAnchorRatio (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalAnchorRatio
   (
      this : in out ScrollViewer
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.get_VerticalAnchorRatio (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalAnchorRatio
   (
      this : in out ScrollViewer;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.put_VerticalAnchorRatio (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanContentRenderOutsideBounds
   (
      this : in out ScrollViewer
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.get_CanContentRenderOutsideBounds (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanContentRenderOutsideBounds
   (
      this : in out ScrollViewer;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.put_CanContentRenderOutsideBounds (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_AnchorRequested
   (
      this : in out ScrollViewer;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.add_AnchorRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_AnchorRequested
   (
      this : in out ScrollViewer;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollViewer4, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollViewer4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.remove_AnchorRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CurrentAnchor
   (
      this : in out ScrollViewer
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_IScrollViewer.all);
         Hr := m_Interface.get_CurrentAnchor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure RegisterAnchorCandidate
   (
      this : in out ScrollViewer;
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.RegisterAnchorCandidate (element.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure UnregisterAnchorCandidate
   (
      this : in out ScrollViewer;
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IScrollAnchorProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IScrollViewer_Interface, WinUI3.Windows.UI.Xaml.Controls.IScrollAnchorProvider, WinUI3.Windows.UI.Xaml.Controls.IID_IScrollAnchorProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IScrollViewer.all);
      Hr := m_Interface.UnregisterAnchorCandidate (element.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewerView

   procedure Initialize (this : in out ScrollViewerView) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewerView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewerView, IScrollViewerView_Ptr);
   begin
      if this.m_IScrollViewerView /= null then
         if this.m_IScrollViewerView.all /= null then
            temp := this.m_IScrollViewerView.all.Release;
            Free (this.m_IScrollViewerView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewerView

   function get_HorizontalOffset
   (
      this : in out ScrollViewerView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewerView.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_VerticalOffset
   (
      this : in out ScrollViewerView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IScrollViewerView.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ZoomFactor
   (
      this : in out ScrollViewerView
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_IScrollViewerView.all.get_ZoomFactor (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewerViewChangedEventArgs

   procedure Initialize (this : in out ScrollViewerViewChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewerViewChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewerViewChangedEventArgs, IScrollViewerViewChangedEventArgs_Ptr);
   begin
      if this.m_IScrollViewerViewChangedEventArgs /= null then
         if this.m_IScrollViewerViewChangedEventArgs.all /= null then
            temp := this.m_IScrollViewerViewChangedEventArgs.all.Release;
            Free (this.m_IScrollViewerViewChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ScrollViewerViewChangedEventArgs

   function Constructor return ScrollViewerViewChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs;
   begin
      return RetVal : ScrollViewerViewChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IScrollViewerViewChangedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs;
            Retval.m_IScrollViewerViewChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewerViewChangedEventArgs

   function get_IsIntermediate
   (
      this : in out ScrollViewerViewChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewerViewChangedEventArgs.all.get_IsIntermediate (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ScrollViewerViewChangingEventArgs

   procedure Initialize (this : in out ScrollViewerViewChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ScrollViewerViewChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IScrollViewerViewChangingEventArgs, IScrollViewerViewChangingEventArgs_Ptr);
   begin
      if this.m_IScrollViewerViewChangingEventArgs /= null then
         if this.m_IScrollViewerViewChangingEventArgs.all /= null then
            temp := this.m_IScrollViewerViewChangingEventArgs.all.Release;
            Free (this.m_IScrollViewerViewChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ScrollViewerViewChangingEventArgs

   function get_NextView
   (
      this : in out ScrollViewerViewChangingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollViewerView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IScrollViewerView;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ScrollViewerView do
         Hr := this.m_IScrollViewerViewChangingEventArgs.all.get_NextView (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollViewerView := new WinUI3.Windows.UI.Xaml.Controls.IScrollViewerView;
         Retval.m_IScrollViewerView.all := m_ComRetVal;
      end return;
   end;

   function get_FinalView
   (
      this : in out ScrollViewerViewChangingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.ScrollViewerView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IScrollViewerView;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.ScrollViewerView do
         Hr := this.m_IScrollViewerViewChangingEventArgs.all.get_FinalView (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IScrollViewerView := new WinUI3.Windows.UI.Xaml.Controls.IScrollViewerView;
         Retval.m_IScrollViewerView.all := m_ComRetVal;
      end return;
   end;

   function get_IsInertial
   (
      this : in out ScrollViewerViewChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IScrollViewerViewChangingEventArgs.all.get_IsInertial (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SearchBox

   procedure Initialize (this : in out SearchBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out SearchBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISearchBox, ISearchBox_Ptr);
   begin
      if this.m_ISearchBox /= null then
         if this.m_ISearchBox.all /= null then
            temp := this.m_ISearchBox.all.Release;
            Free (this.m_ISearchBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SearchBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SearchBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBox");
      m_Factory    : access ISearchBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISearchBox;
   begin
      return RetVal : SearchBox do
         Hr := RoGetActivationFactory (m_hString, IID_ISearchBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISearchBox := new WinUI3.Windows.UI.Xaml.Controls.ISearchBox;
            Retval.m_ISearchBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SearchBox

   function get_SearchHistoryEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISearchBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISearchBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SearchHistoryEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SearchHistoryContextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISearchBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISearchBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SearchHistoryContextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_SearchBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISearchBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISearchBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_QueryTextProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISearchBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISearchBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_QueryTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FocusOnKeyboardInputProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISearchBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISearchBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FocusOnKeyboardInputProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ChooseSuggestionOnEnterProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISearchBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISearchBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ChooseSuggestionOnEnterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SearchBox

   function get_SearchHistoryEnabled
   (
      this : in out SearchBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISearchBox.all.get_SearchHistoryEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SearchHistoryEnabled
   (
      this : in out SearchBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.put_SearchHistoryEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SearchHistoryContext
   (
      this : in out SearchBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBox.all.get_SearchHistoryContext (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SearchHistoryContext
   (
      this : in out SearchBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISearchBox.all.put_SearchHistoryContext (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_PlaceholderText
   (
      this : in out SearchBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBox.all.get_PlaceholderText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out SearchBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISearchBox.all.put_PlaceholderText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_QueryText
   (
      this : in out SearchBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBox.all.get_QueryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_QueryText
   (
      this : in out SearchBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISearchBox.all.put_QueryText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_FocusOnKeyboardInput
   (
      this : in out SearchBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISearchBox.all.get_FocusOnKeyboardInput (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FocusOnKeyboardInput
   (
      this : in out SearchBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.put_FocusOnKeyboardInput (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ChooseSuggestionOnEnter
   (
      this : in out SearchBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISearchBox.all.get_ChooseSuggestionOnEnter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ChooseSuggestionOnEnter
   (
      this : in out SearchBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.put_ChooseSuggestionOnEnter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_QueryChanged
   (
      this : in out SearchBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISearchBox.all.add_QueryChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_QueryChanged
   (
      this : in out SearchBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.remove_QueryChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SuggestionsRequested
   (
      this : in out SearchBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISearchBox.all.add_SuggestionsRequested (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SuggestionsRequested
   (
      this : in out SearchBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.remove_SuggestionsRequested (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_QuerySubmitted
   (
      this : in out SearchBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISearchBox.all.add_QuerySubmitted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_QuerySubmitted
   (
      this : in out SearchBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.remove_QuerySubmitted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ResultSuggestionChosen
   (
      this : in out SearchBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISearchBox.all.add_ResultSuggestionChosen (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ResultSuggestionChosen
   (
      this : in out SearchBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.remove_ResultSuggestionChosen (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PrepareForFocusOnKeyboardInput
   (
      this : in out SearchBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISearchBox.all.add_PrepareForFocusOnKeyboardInput (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PrepareForFocusOnKeyboardInput
   (
      this : in out SearchBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.remove_PrepareForFocusOnKeyboardInput (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetLocalContentSuggestionSettings
   (
      this : in out SearchBox;
      settings : WinUI3.Windows.ApplicationModel.Search.LocalContentSuggestionSettings'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISearchBox.all.SetLocalContentSuggestionSettings (settings.m_ILocalContentSuggestionSettings.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SearchBoxQueryChangedEventArgs

   procedure Initialize (this : in out SearchBoxQueryChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SearchBoxQueryChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISearchBoxQueryChangedEventArgs, ISearchBoxQueryChangedEventArgs_Ptr);
   begin
      if this.m_ISearchBoxQueryChangedEventArgs /= null then
         if this.m_ISearchBoxQueryChangedEventArgs.all /= null then
            temp := this.m_ISearchBoxQueryChangedEventArgs.all.Release;
            Free (this.m_ISearchBoxQueryChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SearchBoxQueryChangedEventArgs

   function get_QueryText
   (
      this : in out SearchBoxQueryChangedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBoxQueryChangedEventArgs.all.get_QueryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Language
   (
      this : in out SearchBoxQueryChangedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBoxQueryChangedEventArgs.all.get_Language (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_LinguisticDetails
   (
      this : in out SearchBoxQueryChangedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.Search.SearchQueryLinguisticDetails'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.Search.ISearchQueryLinguisticDetails;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.Search.SearchQueryLinguisticDetails do
         Hr := this.m_ISearchBoxQueryChangedEventArgs.all.get_LinguisticDetails (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISearchQueryLinguisticDetails := new WinUI3.Windows.ApplicationModel.Search.ISearchQueryLinguisticDetails;
         Retval.m_ISearchQueryLinguisticDetails.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SearchBoxQuerySubmittedEventArgs

   procedure Initialize (this : in out SearchBoxQuerySubmittedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SearchBoxQuerySubmittedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISearchBoxQuerySubmittedEventArgs, ISearchBoxQuerySubmittedEventArgs_Ptr);
   begin
      if this.m_ISearchBoxQuerySubmittedEventArgs /= null then
         if this.m_ISearchBoxQuerySubmittedEventArgs.all /= null then
            temp := this.m_ISearchBoxQuerySubmittedEventArgs.all.Release;
            Free (this.m_ISearchBoxQuerySubmittedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SearchBoxQuerySubmittedEventArgs

   function get_QueryText
   (
      this : in out SearchBoxQuerySubmittedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBoxQuerySubmittedEventArgs.all.get_QueryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Language
   (
      this : in out SearchBoxQuerySubmittedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBoxQuerySubmittedEventArgs.all.get_Language (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_LinguisticDetails
   (
      this : in out SearchBoxQuerySubmittedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.Search.SearchQueryLinguisticDetails'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.Search.ISearchQueryLinguisticDetails;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.Search.SearchQueryLinguisticDetails do
         Hr := this.m_ISearchBoxQuerySubmittedEventArgs.all.get_LinguisticDetails (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISearchQueryLinguisticDetails := new WinUI3.Windows.ApplicationModel.Search.ISearchQueryLinguisticDetails;
         Retval.m_ISearchQueryLinguisticDetails.all := m_ComRetVal;
      end return;
   end;

   function get_KeyModifiers
   (
      this : in out SearchBoxQuerySubmittedEventArgs
   )
   return WinUI3.Windows.System.VirtualKeyModifiers is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.System.VirtualKeyModifiers;
   begin
      Hr := this.m_ISearchBoxQuerySubmittedEventArgs.all.get_KeyModifiers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SearchBoxResultSuggestionChosenEventArgs

   procedure Initialize (this : in out SearchBoxResultSuggestionChosenEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SearchBoxResultSuggestionChosenEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISearchBoxResultSuggestionChosenEventArgs, ISearchBoxResultSuggestionChosenEventArgs_Ptr);
   begin
      if this.m_ISearchBoxResultSuggestionChosenEventArgs /= null then
         if this.m_ISearchBoxResultSuggestionChosenEventArgs.all /= null then
            temp := this.m_ISearchBoxResultSuggestionChosenEventArgs.all.Release;
            Free (this.m_ISearchBoxResultSuggestionChosenEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SearchBoxResultSuggestionChosenEventArgs

   function Constructor return SearchBoxResultSuggestionChosenEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SearchBoxResultSuggestionChosenEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISearchBoxResultSuggestionChosenEventArgs;
   begin
      return RetVal : SearchBoxResultSuggestionChosenEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISearchBoxResultSuggestionChosenEventArgs := new WinUI3.Windows.UI.Xaml.Controls.ISearchBoxResultSuggestionChosenEventArgs;
            Retval.m_ISearchBoxResultSuggestionChosenEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SearchBoxResultSuggestionChosenEventArgs

   function get_Tag
   (
      this : in out SearchBoxResultSuggestionChosenEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBoxResultSuggestionChosenEventArgs.all.get_Tag (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_KeyModifiers
   (
      this : in out SearchBoxResultSuggestionChosenEventArgs
   )
   return WinUI3.Windows.System.VirtualKeyModifiers is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.System.VirtualKeyModifiers;
   begin
      Hr := this.m_ISearchBoxResultSuggestionChosenEventArgs.all.get_KeyModifiers (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SearchBoxSuggestionsRequestedEventArgs

   procedure Initialize (this : in out SearchBoxSuggestionsRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SearchBoxSuggestionsRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISearchBoxSuggestionsRequestedEventArgs, ISearchBoxSuggestionsRequestedEventArgs_Ptr);
   begin
      if this.m_ISearchBoxSuggestionsRequestedEventArgs /= null then
         if this.m_ISearchBoxSuggestionsRequestedEventArgs.all /= null then
            temp := this.m_ISearchBoxSuggestionsRequestedEventArgs.all.Release;
            Free (this.m_ISearchBoxSuggestionsRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SearchBoxSuggestionsRequestedEventArgs

   function get_QueryText
   (
      this : in out SearchBoxSuggestionsRequestedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBoxSuggestionsRequestedEventArgs.all.get_QueryText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Language
   (
      this : in out SearchBoxSuggestionsRequestedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISearchBoxSuggestionsRequestedEventArgs.all.get_Language (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_LinguisticDetails
   (
      this : in out SearchBoxSuggestionsRequestedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.Search.SearchQueryLinguisticDetails'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.Search.ISearchQueryLinguisticDetails;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.Search.SearchQueryLinguisticDetails do
         Hr := this.m_ISearchBoxSuggestionsRequestedEventArgs.all.get_LinguisticDetails (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISearchQueryLinguisticDetails := new WinUI3.Windows.ApplicationModel.Search.ISearchQueryLinguisticDetails;
         Retval.m_ISearchQueryLinguisticDetails.all := m_ComRetVal;
      end return;
   end;

   function get_Request
   (
      this : in out SearchBoxSuggestionsRequestedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.Search.SearchSuggestionsRequest'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.Search.ISearchSuggestionsRequest;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.Search.SearchSuggestionsRequest do
         Hr := this.m_ISearchBoxSuggestionsRequestedEventArgs.all.get_Request (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISearchSuggestionsRequest := new WinUI3.Windows.ApplicationModel.Search.ISearchSuggestionsRequest;
         Retval.m_ISearchSuggestionsRequest.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SectionsInViewChangedEventArgs

   procedure Initialize (this : in out SectionsInViewChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SectionsInViewChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISectionsInViewChangedEventArgs, ISectionsInViewChangedEventArgs_Ptr);
   begin
      if this.m_ISectionsInViewChangedEventArgs /= null then
         if this.m_ISectionsInViewChangedEventArgs.all /= null then
            temp := this.m_ISectionsInViewChangedEventArgs.all.Release;
            Free (this.m_ISectionsInViewChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SectionsInViewChangedEventArgs

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SectionsInViewChangedEventArgs

   function get_AddedSections
   (
      this : in out SectionsInViewChangedEventArgs
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_ISectionsInViewChangedEventArgs.all.get_AddedSections (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedSections
   (
      this : in out SectionsInViewChangedEventArgs
   )
   return IVector_IHubSection.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IHubSection.Kind;
   begin
      Hr := this.m_ISectionsInViewChangedEventArgs.all.get_RemovedSections (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IHubSection (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SectionsInViewChangedEventHandler

   function Invoke
   (
      this : access SectionsInViewChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.ISectionsInViewChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SelectionChangedEventArgs

   procedure Initialize (this : in out SelectionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SelectionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISelectionChangedEventArgs, ISelectionChangedEventArgs_Ptr);
   begin
      if this.m_ISelectionChangedEventArgs /= null then
         if this.m_ISelectionChangedEventArgs.all /= null then
            temp := this.m_ISelectionChangedEventArgs.all.Release;
            Free (this.m_ISelectionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SelectionChangedEventArgs

   function Constructor
   (
      removedItems : GenericObject;
      addedItems : GenericObject;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SelectionChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SelectionChangedEventArgs");
      m_Factory    : access ISelectionChangedEventArgsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISelectionChangedEventArgs;
   begin
      return RetVal : SelectionChangedEventArgs do
         Hr := RoGetActivationFactory (m_hString, IID_ISelectionChangedEventArgsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithRemovedItemsAndAddedItems (removedItems, addedItems, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISelectionChangedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.ISelectionChangedEventArgs;
            Retval.m_ISelectionChangedEventArgs.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SelectionChangedEventArgs

   function get_AddedItems
   (
      this : in out SelectionChangedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ISelectionChangedEventArgs.all.get_AddedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_RemovedItems
   (
      this : in out SelectionChangedEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ISelectionChangedEventArgs.all.get_RemovedItems (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SelectionChangedEventHandler

   function Invoke
   (
      this : access SelectionChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.ISelectionChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SemanticZoom

   procedure Initialize (this : in out SemanticZoom) is
   begin
      null;
   end;

   procedure Finalize (this : in out SemanticZoom) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISemanticZoom, ISemanticZoom_Ptr);
   begin
      if this.m_ISemanticZoom /= null then
         if this.m_ISemanticZoom.all /= null then
            temp := this.m_ISemanticZoom.all.Release;
            Free (this.m_ISemanticZoom);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SemanticZoom

   function Constructor return SemanticZoom is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoom");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoom;
   begin
      return RetVal : SemanticZoom do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISemanticZoom := new WinUI3.Windows.UI.Xaml.Controls.ISemanticZoom;
            Retval.m_ISemanticZoom.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SemanticZoom

   function get_ZoomedInViewProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomedInViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ZoomedOutViewProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ZoomedOutViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomedInViewActiveProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomedInViewActiveProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanChangeViewsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanChangeViewsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsZoomOutButtonEnabledProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoom");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISemanticZoomStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsZoomOutButtonEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SemanticZoom

   function get_ZoomedInView
   (
      this : in out SemanticZoom
   )
   return WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation;
   begin
      Hr := this.m_ISemanticZoom.all.get_ZoomedInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomedInView
   (
      this : in out SemanticZoom;
      value : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_ZoomedInView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ZoomedOutView
   (
      this : in out SemanticZoom
   )
   return WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation;
   begin
      Hr := this.m_ISemanticZoom.all.get_ZoomedOutView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ZoomedOutView
   (
      this : in out SemanticZoom;
      value : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomInformation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_ZoomedOutView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomedInViewActive
   (
      this : in out SemanticZoom
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoom.all.get_IsZoomedInViewActive (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomedInViewActive
   (
      this : in out SemanticZoom;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_IsZoomedInViewActive (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanChangeViews
   (
      this : in out SemanticZoom
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoom.all.get_CanChangeViews (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanChangeViews
   (
      this : in out SemanticZoom;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_CanChangeViews (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChangeStarted
   (
      this : in out SemanticZoom;
      handler : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISemanticZoom.all.add_ViewChangeStarted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChangeStarted
   (
      this : in out SemanticZoom;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.remove_ViewChangeStarted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ViewChangeCompleted
   (
      this : in out SemanticZoom;
      handler : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISemanticZoom.all.add_ViewChangeCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ViewChangeCompleted
   (
      this : in out SemanticZoom;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.remove_ViewChangeCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ToggleActiveView
   (
      this : in out SemanticZoom
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.ToggleActiveView;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsZoomOutButtonEnabled
   (
      this : in out SemanticZoom
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoom.all.get_IsZoomOutButtonEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsZoomOutButtonEnabled
   (
      this : in out SemanticZoom;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoom.all.put_IsZoomOutButtonEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SemanticZoomLocation

   procedure Initialize (this : in out SemanticZoomLocation) is
   begin
      null;
   end;

   procedure Finalize (this : in out SemanticZoomLocation) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISemanticZoomLocation, ISemanticZoomLocation_Ptr);
   begin
      if this.m_ISemanticZoomLocation /= null then
         if this.m_ISemanticZoomLocation.all /= null then
            temp := this.m_ISemanticZoomLocation.all.Release;
            Free (this.m_ISemanticZoomLocation);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SemanticZoomLocation

   function Constructor return SemanticZoomLocation is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoomLocation");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomLocation;
   begin
      return RetVal : SemanticZoomLocation do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISemanticZoomLocation := new WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomLocation;
            Retval.m_ISemanticZoomLocation.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SemanticZoomLocation

   function get_Item
   (
      this : in out SemanticZoomLocation
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISemanticZoomLocation.all.get_Item (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Item
   (
      this : in out SemanticZoomLocation;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomLocation.all.put_Item (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Bounds
   (
      this : in out SemanticZoomLocation
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ISemanticZoomLocation.all.get_Bounds (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Bounds
   (
      this : in out SemanticZoomLocation;
      value : WinUI3.Windows.Foundation.Rect
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomLocation.all.put_Bounds (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SemanticZoomViewChangedEventArgs

   procedure Initialize (this : in out SemanticZoomViewChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SemanticZoomViewChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISemanticZoomViewChangedEventArgs, ISemanticZoomViewChangedEventArgs_Ptr);
   begin
      if this.m_ISemanticZoomViewChangedEventArgs /= null then
         if this.m_ISemanticZoomViewChangedEventArgs.all /= null then
            temp := this.m_ISemanticZoomViewChangedEventArgs.all.Release;
            Free (this.m_ISemanticZoomViewChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SemanticZoomViewChangedEventArgs

   function Constructor return SemanticZoomViewChangedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs;
   begin
      return RetVal : SemanticZoomViewChangedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISemanticZoomViewChangedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs;
            Retval.m_ISemanticZoomViewChangedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SemanticZoomViewChangedEventArgs

   function get_IsSourceZoomedInView
   (
      this : in out SemanticZoomViewChangedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.get_IsSourceZoomedInView (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSourceZoomedInView
   (
      this : in out SemanticZoomViewChangedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.put_IsSourceZoomedInView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SourceItem
   (
      this : in out SemanticZoomViewChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomLocation;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation do
         Hr := this.m_ISemanticZoomViewChangedEventArgs.all.get_SourceItem (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoomLocation := new WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomLocation;
         Retval.m_ISemanticZoomLocation.all := m_ComRetVal;
      end return;
   end;

   procedure put_SourceItem
   (
      this : in out SemanticZoomViewChangedEventArgs;
      value : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.put_SourceItem (value.m_ISemanticZoomLocation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DestinationItem
   (
      this : in out SemanticZoomViewChangedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomLocation;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation do
         Hr := this.m_ISemanticZoomViewChangedEventArgs.all.get_DestinationItem (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISemanticZoomLocation := new WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomLocation;
         Retval.m_ISemanticZoomLocation.all := m_ComRetVal;
      end return;
   end;

   procedure put_DestinationItem
   (
      this : in out SemanticZoomViewChangedEventArgs;
      value : WinUI3.Windows.UI.Xaml.Controls.SemanticZoomLocation'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISemanticZoomViewChangedEventArgs.all.put_DestinationItem (value.m_ISemanticZoomLocation.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate SemanticZoomViewChangedEventHandler

   function Invoke
   (
      this : access SemanticZoomViewChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SettingsFlyout

   procedure Initialize (this : in out SettingsFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out SettingsFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISettingsFlyout, ISettingsFlyout_Ptr);
   begin
      if this.m_ISettingsFlyout /= null then
         if this.m_ISettingsFlyout.all /= null then
            temp := this.m_ISettingsFlyout.all.Release;
            Free (this.m_ISettingsFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SettingsFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SettingsFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SettingsFlyout");
      m_Factory    : access ISettingsFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISettingsFlyout;
   begin
      return RetVal : SettingsFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_ISettingsFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISettingsFlyout := new WinUI3.Windows.UI.Xaml.Controls.ISettingsFlyout;
            Retval.m_ISettingsFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SettingsFlyout

   function get_TitleProperty_SettingsFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SettingsFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISettingsFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISettingsFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SettingsFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISettingsFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISettingsFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderForegroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SettingsFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISettingsFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISettingsFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IconSourceProperty_SettingsFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SettingsFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISettingsFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISettingsFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SettingsFlyout

   function get_Title
   (
      this : in out SettingsFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISettingsFlyout.all.get_Title (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Title
   (
      this : in out SettingsFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISettingsFlyout.all.put_Title (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_HeaderBackground
   (
      this : in out SettingsFlyout
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ISettingsFlyout.all.get_HeaderBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderBackground
   (
      this : in out SettingsFlyout;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISettingsFlyout.all.put_HeaderBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderForeground
   (
      this : in out SettingsFlyout
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ISettingsFlyout.all.get_HeaderForeground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderForeground
   (
      this : in out SettingsFlyout;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISettingsFlyout.all.put_HeaderForeground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IconSource
   (
      this : in out SettingsFlyout
   )
   return WinUI3.Windows.UI.Xaml.Media.ImageSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IImageSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.ImageSource do
         Hr := this.m_ISettingsFlyout.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IImageSource := new WinUI3.Windows.UI.Xaml.Media.IImageSource;
         Retval.m_IImageSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out SettingsFlyout;
      value : WinUI3.Windows.UI.Xaml.Media.ImageSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISettingsFlyout.all.put_IconSource (value.m_IImageSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out SettingsFlyout
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.ISettingsFlyoutTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings do
         Hr := this.m_ISettingsFlyout.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISettingsFlyoutTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.ISettingsFlyoutTemplateSettings;
         Retval.m_ISettingsFlyoutTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_BackClick
   (
      this : in out SettingsFlyout;
      handler : WinUI3.Windows.UI.Xaml.Controls.BackClickEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISettingsFlyout.all.add_BackClick (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BackClick
   (
      this : in out SettingsFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISettingsFlyout.all.remove_BackClick (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Show
   (
      this : in out SettingsFlyout
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISettingsFlyout.all.Show;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ShowIndependent
   (
      this : in out SettingsFlyout
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISettingsFlyout.all.ShowIndependent;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Hide
   (
      this : in out SettingsFlyout
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISettingsFlyout.all.Hide;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitButton

   procedure Initialize (this : in out SplitButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitButton, ISplitButton_Ptr);
   begin
      if this.m_ISplitButton /= null then
         if this.m_ISplitButton.all /= null then
            temp := this.m_ISplitButton.all.Release;
            Free (this.m_ISplitButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplitButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SplitButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitButton");
      m_Factory    : access ISplitButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISplitButton;
   begin
      return RetVal : SplitButton do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISplitButton := new WinUI3.Windows.UI.Xaml.Controls.ISplitButton;
            Retval.m_ISplitButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplitButton

   function get_FlyoutProperty_SplitButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty_SplitButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandParameterProperty_SplitButton
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitButton");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitButtonStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitButton

   function get_Flyout
   (
      this : in out SplitButton
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         Hr := this.m_ISplitButton.all.get_Flyout (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_Flyout
   (
      this : in out SplitButton;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.put_Flyout (value.m_IFlyoutBase.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Command
   (
      this : in out SplitButton
   )
   return WinUI3.Windows.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_ISplitButton.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out SplitButton;
      value : WinUI3.Windows.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandParameter
   (
      this : in out SplitButton
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISplitButton.all.get_CommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CommandParameter
   (
      this : in out SplitButton;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.put_CommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Click
   (
      this : in out SplitButton;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitButton.all.add_Click (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Click
   (
      this : in out SplitButton;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitButton.all.remove_Click (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitButtonAutomationPeer

   procedure Initialize (this : in out SplitButtonAutomationPeer) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitButtonAutomationPeer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitButtonAutomationPeer, ISplitButtonAutomationPeer_Ptr);
   begin
      if this.m_ISplitButtonAutomationPeer /= null then
         if this.m_ISplitButtonAutomationPeer.all /= null then
            temp := this.m_ISplitButtonAutomationPeer.all.Release;
            Free (this.m_ISplitButtonAutomationPeer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplitButtonAutomationPeer

   function Constructor
   (
      owner : WinUI3.Windows.UI.Xaml.Controls.SplitButton'Class;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SplitButtonAutomationPeer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitButtonAutomationPeer");
      m_Factory    : access ISplitButtonAutomationPeerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer;
   begin
      return RetVal : SplitButtonAutomationPeer do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitButtonAutomationPeerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (owner.m_ISplitButton.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISplitButtonAutomationPeer := new WinUI3.Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer;
            Retval.m_ISplitButtonAutomationPeer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitButtonAutomationPeer

   function get_ExpandCollapseState
   (
      this : in out SplitButtonAutomationPeer
   )
   return WinUI3.Windows.UI.Xaml.Automation.ExpandCollapseState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Automation.ExpandCollapseState;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitButtonAutomationPeer.all);
      Hr := m_Interface.get_ExpandCollapseState (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Collapse
   (
      this : in out SplitButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitButtonAutomationPeer.all);
      Hr := m_Interface.Collapse;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Expand
   (
      this : in out SplitButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitButtonAutomationPeer.all);
      Hr := m_Interface.Expand;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Invoke
   (
      this : in out SplitButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IInvokeProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IInvokeProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IInvokeProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitButtonAutomationPeer.all);
      Hr := m_Interface.Invoke;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitButtonClickEventArgs

   procedure Initialize (this : in out SplitButtonClickEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitButtonClickEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitButtonClickEventArgs, ISplitButtonClickEventArgs_Ptr);
   begin
      if this.m_ISplitButtonClickEventArgs /= null then
         if this.m_ISplitButtonClickEventArgs.all /= null then
            temp := this.m_ISplitButtonClickEventArgs.all.Release;
            Free (this.m_ISplitButtonClickEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitButtonClickEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitView

   procedure Initialize (this : in out SplitView) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitView, ISplitView_Ptr);
   begin
      if this.m_ISplitView /= null then
         if this.m_ISplitView.all /= null then
            temp := this.m_ISplitView.all.Release;
            Free (this.m_ISplitView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SplitView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SplitView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory    : access ISplitViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISplitView;
   begin
      return RetVal : SplitView do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISplitView := new WinUI3.Windows.UI.Xaml.Controls.ISplitView;
            Retval.m_ISplitView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SplitView

   function get_ContentProperty_SplitView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsPaneOpenProperty_SplitView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsPaneOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpenPaneLengthProperty_SplitView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpenPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompactPaneLengthProperty_SplitView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompactPaneLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PanePlacementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PanePlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DisplayModeProperty_SplitView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DisplayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TemplateSettingsProperty_SplitView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaneBackgroundProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaneBackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_SplitView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SplitView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISplitViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISplitViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitView

   function get_Content
   (
      this : in out SplitView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_ISplitView.all.get_Content (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Content
   (
      this : in out SplitView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_Content (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane
   (
      this : in out SplitView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_ISplitView.all.get_Pane (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Pane
   (
      this : in out SplitView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_Pane (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsPaneOpen
   (
      this : in out SplitView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISplitView.all.get_IsPaneOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsPaneOpen
   (
      this : in out SplitView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_IsPaneOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpenPaneLength
   (
      this : in out SplitView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitView.all.get_OpenPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpenPaneLength
   (
      this : in out SplitView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_OpenPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CompactPaneLength
   (
      this : in out SplitView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ISplitView.all.get_CompactPaneLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CompactPaneLength
   (
      this : in out SplitView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_CompactPaneLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PanePlacement
   (
      this : in out SplitView
   )
   return WinUI3.Windows.UI.Xaml.Controls.SplitViewPanePlacement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SplitViewPanePlacement;
   begin
      Hr := this.m_ISplitView.all.get_PanePlacement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PanePlacement
   (
      this : in out SplitView;
      value : WinUI3.Windows.UI.Xaml.Controls.SplitViewPanePlacement
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_PanePlacement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DisplayMode
   (
      this : in out SplitView
   )
   return WinUI3.Windows.UI.Xaml.Controls.SplitViewDisplayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SplitViewDisplayMode;
   begin
      Hr := this.m_ISplitView.all.get_DisplayMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DisplayMode
   (
      this : in out SplitView;
      value : WinUI3.Windows.UI.Xaml.Controls.SplitViewDisplayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_DisplayMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out SplitView
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.ISplitViewTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings do
         Hr := this.m_ISplitView.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISplitViewTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.ISplitViewTemplateSettings;
         Retval.m_ISplitViewTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_PaneBackground
   (
      this : in out SplitView
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ISplitView.all.get_PaneBackground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PaneBackground
   (
      this : in out SplitView;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.put_PaneBackground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosing
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitView.all.add_PaneClosing (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosing
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.remove_PaneClosing (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneClosed
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISplitView.all.add_PaneClosed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneClosed
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitView.all.remove_PaneClosed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out SplitView
   )
   return WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISplitView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitView_Interface, WinUI3.Windows.UI.Xaml.Controls.ISplitView2, WinUI3.Windows.UI.Xaml.Controls.IID_ISplitView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitView.all);
      Hr := m_Interface.get_LightDismissOverlayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out SplitView;
      value : WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISplitView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitView_Interface, WinUI3.Windows.UI.Xaml.Controls.ISplitView2, WinUI3.Windows.UI.Xaml.Controls.IID_ISplitView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitView.all);
      Hr := m_Interface.put_LightDismissOverlayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpening
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISplitView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitView_Interface, WinUI3.Windows.UI.Xaml.Controls.ISplitView3, WinUI3.Windows.UI.Xaml.Controls.IID_ISplitView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitView.all);
      Hr := m_Interface.add_PaneOpening (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpening
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISplitView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitView_Interface, WinUI3.Windows.UI.Xaml.Controls.ISplitView3, WinUI3.Windows.UI.Xaml.Controls.IID_ISplitView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitView.all);
      Hr := m_Interface.remove_PaneOpening (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PaneOpened
   (
      this : in out SplitView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISplitView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitView_Interface, WinUI3.Windows.UI.Xaml.Controls.ISplitView3, WinUI3.Windows.UI.Xaml.Controls.IID_ISplitView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitView.all);
      Hr := m_Interface.add_PaneOpened (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PaneOpened
   (
      this : in out SplitView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISplitView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISplitView_Interface, WinUI3.Windows.UI.Xaml.Controls.ISplitView3, WinUI3.Windows.UI.Xaml.Controls.IID_ISplitView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISplitView.all);
      Hr := m_Interface.remove_PaneOpened (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SplitViewPaneClosingEventArgs

   procedure Initialize (this : in out SplitViewPaneClosingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SplitViewPaneClosingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISplitViewPaneClosingEventArgs, ISplitViewPaneClosingEventArgs_Ptr);
   begin
      if this.m_ISplitViewPaneClosingEventArgs /= null then
         if this.m_ISplitViewPaneClosingEventArgs.all /= null then
            temp := this.m_ISplitViewPaneClosingEventArgs.all.Release;
            Free (this.m_ISplitViewPaneClosingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SplitViewPaneClosingEventArgs

   function get_Cancel
   (
      this : in out SplitViewPaneClosingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ISplitViewPaneClosingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out SplitViewPaneClosingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISplitViewPaneClosingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StackPanel

   procedure Initialize (this : in out StackPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out StackPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStackPanel, IStackPanel_Ptr);
   begin
      if this.m_IStackPanel /= null then
         if this.m_IStackPanel.all /= null then
            temp := this.m_IStackPanel.all.Release;
            Free (this.m_IStackPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StackPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return StackPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory    : access IStackPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IStackPanel;
   begin
      return RetVal : StackPanel do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStackPanel := new WinUI3.Windows.UI.Xaml.Controls.IStackPanel;
            Retval.m_IStackPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for StackPanel

   function get_AreScrollSnapPointsRegularProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreScrollSnapPointsRegularProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_StackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderBrushProperty_StackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BorderThicknessProperty_StackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BorderThicknessProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CornerRadiusProperty_StackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CornerRadiusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_StackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SpacingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundSizingProperty_StackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IStackPanelStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IStackPanelStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundSizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StackPanel

   function get_AreScrollSnapPointsRegular
   (
      this : in out StackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IStackPanel.all.get_AreScrollSnapPointsRegular (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreScrollSnapPointsRegular
   (
      this : in out StackPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_AreScrollSnapPointsRegular (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out StackPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IStackPanel.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out StackPanel;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IStackPanel.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderBrush
   (
      this : in out StackPanel
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_IStackPanel.all);
         Hr := m_Interface.get_BorderBrush (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_BorderBrush
   (
      this : in out StackPanel;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.put_BorderBrush (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BorderThickness
   (
      this : in out StackPanel
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_BorderThickness (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BorderThickness
   (
      this : in out StackPanel;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.put_BorderThickness (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CornerRadius
   (
      this : in out StackPanel
   )
   return WinUI3.Windows.UI.Xaml.CornerRadius is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.CornerRadius;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_CornerRadius (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CornerRadius
   (
      this : in out StackPanel;
      value : WinUI3.Windows.UI.Xaml.CornerRadius
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.put_CornerRadius (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Padding
   (
      this : in out StackPanel
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_Padding (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out StackPanel;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.put_Padding (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Spacing
   (
      this : in out StackPanel
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel4, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_Spacing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Spacing
   (
      this : in out StackPanel;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel4, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.put_Spacing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BackgroundSizing
   (
      this : in out StackPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel5, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_BackgroundSizing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BackgroundSizing
   (
      this : in out StackPanel;
      value : WinUI3.Windows.UI.Xaml.Controls.BackgroundSizing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStackPanel5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IStackPanel5, WinUI3.Windows.UI.Xaml.Controls.IID_IStackPanel5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.put_BackgroundSizing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AreHorizontalSnapPointsRegular
   (
      this : in out StackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_AreHorizontalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_AreVerticalSnapPointsRegular
   (
      this : in out StackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.get_AreVerticalSnapPointsRegular (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_HorizontalSnapPointsChanged
   (
      this : in out StackPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.add_HorizontalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_HorizontalSnapPointsChanged
   (
      this : in out StackPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.remove_HorizontalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_VerticalSnapPointsChanged
   (
      this : in out StackPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.add_VerticalSnapPointsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_VerticalSnapPointsChanged
   (
      this : in out StackPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.remove_VerticalSnapPointsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetIrregularSnapPoints
   (
      this : in out StackPanel;
      orientation : WinUI3.Windows.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment
   )
   return IVectorView_Single.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_Single.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.GetIrregularSnapPoints (orientation, alignment, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_Single (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function GetRegularSnapPoints
   (
      this : in out StackPanel;
      orientation : WinUI3.Windows.UI.Xaml.Controls.Orientation;
      alignment : WinUI3.Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
      offset : WinUI3.Single_Ptr
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo, WinUI3.Windows.UI.Xaml.Controls.Primitives.IID_IScrollSnapPointsInfo'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.GetRegularSnapPoints (orientation, alignment, offset, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure GetInsertionIndexes
   (
      this : in out StackPanel;
      position : WinUI3.Windows.Foundation.Point;
      first : WinUI3.Int32_Ptr;
      second : WinUI3.Int32_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IInsertionPanel := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IInsertionPanel, WinUI3.Windows.UI.Xaml.Controls.IID_IInsertionPanel'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IStackPanel.all);
      Hr := m_Interface.GetInsertionIndexes (position, first, second);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for StyleSelector

   procedure Initialize (this : in out StyleSelector) is
   begin
      null;
   end;

   procedure Finalize (this : in out StyleSelector) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IStyleSelector, IStyleSelector_Ptr);
   begin
      if this.m_IStyleSelector /= null then
         if this.m_IStyleSelector.all /= null then
            temp := this.m_IStyleSelector.all.Release;
            Free (this.m_IStyleSelector);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for StyleSelector

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return StyleSelector is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.StyleSelector");
      m_Factory    : access IStyleSelectorFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
   begin
      return RetVal : StyleSelector do
         Hr := RoGetActivationFactory (m_hString, IID_IStyleSelectorFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IStyleSelector := new WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
            Retval.m_IStyleSelector.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for StyleSelector

   function SelectStyle
   (
      this : in out StyleSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         Hr := this.m_IStyleSelector.all.SelectStyle (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   function SelectStyleCore
   (
      this : in out StyleSelector;
      item : WinUI3.IInspectable;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IStyleSelectorOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IStyleSelector_Interface, WinUI3.Windows.UI.Xaml.Controls.IStyleSelectorOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IStyleSelectorOverrides'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_IStyleSelector.all);
         Hr := m_Interface.SelectStyleCore (item, container.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwapChainBackgroundPanel

   procedure Initialize (this : in out SwapChainBackgroundPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwapChainBackgroundPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwapChainBackgroundPanel, ISwapChainBackgroundPanel_Ptr);
   begin
      if this.m_ISwapChainBackgroundPanel /= null then
         if this.m_ISwapChainBackgroundPanel.all /= null then
            temp := this.m_ISwapChainBackgroundPanel.all.Release;
            Free (this.m_ISwapChainBackgroundPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwapChainBackgroundPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwapChainBackgroundPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwapChainBackgroundPanel");
      m_Factory    : access ISwapChainBackgroundPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel;
   begin
      return RetVal : SwapChainBackgroundPanel do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainBackgroundPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwapChainBackgroundPanel := new WinUI3.Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel;
            Retval.m_ISwapChainBackgroundPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwapChainBackgroundPanel

   function CreateCoreIndependentInputSource
   (
      this : in out SwapChainBackgroundPanel;
      deviceTypes : WinUI3.Windows.UI.Core.CoreInputDeviceTypes
   )
   return WinUI3.Windows.UI.Core.CoreIndependentInputSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Core.ICoreInputSourceBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel2, WinUI3.Windows.UI.Xaml.Controls.IID_ISwapChainBackgroundPanel2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Core.CoreIndependentInputSource do
         m_Interface := QInterface (this.m_ISwapChainBackgroundPanel.all);
         Hr := m_Interface.CreateCoreIndependentInputSource (deviceTypes, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreInputSourceBase := new WinUI3.Windows.UI.Core.ICoreInputSourceBase;
         Retval.m_ICoreInputSourceBase.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwapChainPanel

   procedure Initialize (this : in out SwapChainPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwapChainPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwapChainPanel, ISwapChainPanel_Ptr);
   begin
      if this.m_ISwapChainPanel /= null then
         if this.m_ISwapChainPanel.all /= null then
            temp := this.m_ISwapChainPanel.all.Release;
            Free (this.m_ISwapChainPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwapChainPanel

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwapChainPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwapChainPanel");
      m_Factory    : access ISwapChainPanelFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISwapChainPanel;
   begin
      return RetVal : SwapChainPanel do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainPanelFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwapChainPanel := new WinUI3.Windows.UI.Xaml.Controls.ISwapChainPanel;
            Retval.m_ISwapChainPanel.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwapChainPanel

   function get_CompositionScaleXProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwapChainPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwapChainPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompositionScaleXProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CompositionScaleYProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwapChainPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwapChainPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwapChainPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CompositionScaleYProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwapChainPanel

   function get_CompositionScaleX
   (
      this : in out SwapChainPanel
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_ISwapChainPanel.all.get_CompositionScaleX (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CompositionScaleY
   (
      this : in out SwapChainPanel
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_ISwapChainPanel.all.get_CompositionScaleY (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_CompositionScaleChanged
   (
      this : in out SwapChainPanel;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISwapChainPanel.all.add_CompositionScaleChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CompositionScaleChanged
   (
      this : in out SwapChainPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwapChainPanel.all.remove_CompositionScaleChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CreateCoreIndependentInputSource
   (
      this : in out SwapChainPanel;
      deviceTypes : WinUI3.Windows.UI.Core.CoreInputDeviceTypes
   )
   return WinUI3.Windows.UI.Core.CoreIndependentInputSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Core.ICoreInputSourceBase;
   begin
      return RetVal : WinUI3.Windows.UI.Core.CoreIndependentInputSource do
         Hr := this.m_ISwapChainPanel.all.CreateCoreIndependentInputSource (deviceTypes, m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICoreInputSourceBase := new WinUI3.Windows.UI.Core.ICoreInputSourceBase;
         Retval.m_ICoreInputSourceBase.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeControl

   procedure Initialize (this : in out SwipeControl) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeControl) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeControl, ISwipeControl_Ptr);
   begin
      if this.m_ISwipeControl /= null then
         if this.m_ISwipeControl.all /= null then
            temp := this.m_ISwipeControl.all.Release;
            Free (this.m_ISwipeControl);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeControl

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwipeControl is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeControl");
      m_Factory    : access ISwipeControlFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeControl;
   begin
      return RetVal : SwipeControl do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwipeControl := new WinUI3.Windows.UI.Xaml.Controls.ISwipeControl;
            Retval.m_ISwipeControl.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeControl

   function get_LeftItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LeftItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RightItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RightItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TopItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TopItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BottomItemsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeControl");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeControlStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeControlStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BottomItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeControl

   function get_LeftItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_LeftItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_LeftItems
   (
      this : in out SwipeControl;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_LeftItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_RightItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_RightItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_RightItems
   (
      this : in out SwipeControl;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_RightItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TopItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_TopItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_TopItems
   (
      this : in out SwipeControl;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_TopItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BottomItems
   (
      this : in out SwipeControl
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeItems do
         Hr := this.m_ISwipeControl.all.get_BottomItems (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItems := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
         Retval.m_ISwipeItems.all := m_ComRetVal;
      end return;
   end;

   procedure put_BottomItems
   (
      this : in out SwipeControl;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItems'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.put_BottomItems (value.m_ISwipeItems.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Close
   (
      this : in out SwipeControl
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeControl.all.Close;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeItem

   procedure Initialize (this : in out SwipeItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeItem, ISwipeItem_Ptr);
   begin
      if this.m_ISwipeItem /= null then
         if this.m_ISwipeItem.all /= null then
            temp := this.m_ISwipeItem.all.Release;
            Free (this.m_ISwipeItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwipeItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory    : access ISwipeItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
   begin
      return RetVal : SwipeItem do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwipeItem := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
            Retval.m_ISwipeItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeItem

   function get_IconSourceProperty_SwipeItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IconSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_SwipeItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BackgroundProperty_SwipeItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BackgroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_SwipeItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandProperty_SwipeItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CommandParameterProperty_SwipeItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CommandParameterProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_BehaviorOnInvokedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_BehaviorOnInvokedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeItem

   function get_Text
   (
      this : in out SwipeItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ISwipeItem.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out SwipeItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ISwipeItem.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_IconSource
   (
      this : in out SwipeItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.IconSource'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IIconSource;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.IconSource do
         Hr := this.m_ISwipeItem.all.get_IconSource (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IIconSource := new WinUI3.Windows.UI.Xaml.Controls.IIconSource;
         Retval.m_IIconSource.all := m_ComRetVal;
      end return;
   end;

   procedure put_IconSource
   (
      this : in out SwipeItem;
      value : WinUI3.Windows.UI.Xaml.Controls.IconSource'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_IconSource (value.m_IIconSource.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Background
   (
      this : in out SwipeItem
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ISwipeItem.all.get_Background (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Background
   (
      this : in out SwipeItem;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_Background (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out SwipeItem
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ISwipeItem.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out SwipeItem;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Command
   (
      this : in out SwipeItem
   )
   return WinUI3.Windows.UI.Xaml.Input.ICommand is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.ICommand;
   begin
      Hr := this.m_ISwipeItem.all.get_Command (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Command
   (
      this : in out SwipeItem;
      value : WinUI3.Windows.UI.Xaml.Input.ICommand
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_Command (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CommandParameter
   (
      this : in out SwipeItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ISwipeItem.all.get_CommandParameter (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CommandParameter
   (
      this : in out SwipeItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_CommandParameter (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_BehaviorOnInvoked
   (
      this : in out SwipeItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeBehaviorOnInvoked is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SwipeBehaviorOnInvoked;
   begin
      Hr := this.m_ISwipeItem.all.get_BehaviorOnInvoked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_BehaviorOnInvoked
   (
      this : in out SwipeItem;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeBehaviorOnInvoked
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.put_BehaviorOnInvoked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Invoked
   (
      this : in out SwipeItem;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ISwipeItem.all.add_Invoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Invoked
   (
      this : in out SwipeItem;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItem.all.remove_Invoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeItemInvokedEventArgs

   procedure Initialize (this : in out SwipeItemInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeItemInvokedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeItemInvokedEventArgs, ISwipeItemInvokedEventArgs_Ptr);
   begin
      if this.m_ISwipeItemInvokedEventArgs /= null then
         if this.m_ISwipeItemInvokedEventArgs.all /= null then
            temp := this.m_ISwipeItemInvokedEventArgs.all.Release;
            Free (this.m_ISwipeItemInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeItemInvokedEventArgs

   function get_SwipeControl
   (
      this : in out SwipeItemInvokedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeControl'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeControl;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeControl do
         Hr := this.m_ISwipeItemInvokedEventArgs.all.get_SwipeControl (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeControl := new WinUI3.Windows.UI.Xaml.Controls.ISwipeControl;
         Retval.m_ISwipeControl.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SwipeItems

   procedure Initialize (this : in out SwipeItems) is
   begin
      null;
   end;

   procedure Finalize (this : in out SwipeItems) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISwipeItems, ISwipeItems_Ptr);
   begin
      if this.m_ISwipeItems /= null then
         if this.m_ISwipeItems.all /= null then
            temp := this.m_ISwipeItems.all.Release;
            Free (this.m_ISwipeItems);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SwipeItems

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SwipeItems is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItems");
      m_Factory    : access ISwipeItemsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
   begin
      return RetVal : SwipeItems do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISwipeItems := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItems;
            Retval.m_ISwipeItems.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SwipeItems

   function get_ModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SwipeItems");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISwipeItemsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISwipeItemsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SwipeItems

   function get_Mode
   (
      this : in out SwipeItems
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.SwipeMode;
   begin
      Hr := this.m_ISwipeItems.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Mode
   (
      this : in out SwipeItems;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISwipeItems.all.put_Mode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.Controls.SwipeItem>
   function GetAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeItem do
         m_Interface := QInterface (this.m_ISwipeItems.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItem := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
         Retval.m_ISwipeItem.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out SwipeItems
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out SwipeItems
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeItem do
         m_Interface := QInterface (this.m_ISwipeItems.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItem := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
         Retval.m_ISwipeItem.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out SwipeItems;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItem'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.IndexOf (value.m_ISwipeItem.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.SetAt (index, value.m_ISwipeItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.InsertAt (index, value.m_ISwipeItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out SwipeItems;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out SwipeItems;
      value : WinUI3.Windows.UI.Xaml.Controls.SwipeItem'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.Append (value.m_ISwipeItem.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out SwipeItems
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out SwipeItems
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out SwipeItems;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.Controls.ISwipeItem_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out SwipeItems;
      items : WinUI3.Windows.UI.Xaml.Controls.ISwipeItem_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (2470010956, 63884, 23704, (153, 118, 151, 222, 141, 43, 113, 101 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IVector_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_ISwipeItems.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.Controls.SwipeItem>
   function First
   (
      this : in out SwipeItems
   )
   return WinUI3.Windows.UI.Xaml.Controls.SwipeItem'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_ISwipeItem.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
      m_GenericIID     : aliased WinUI3.IID := (4139048368, 34417, 21366, (186, 196, 110, 22, 187, 251, 86, 167 ));
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ISwipeItems_Interface, IIterable_ISwipeItem.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.SwipeItem do
         m_Interface := QInterface (this.m_ISwipeItems.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISwipeItem := new WinUI3.Windows.UI.Xaml.Controls.ISwipeItem;
         Retval.m_ISwipeItem.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SymbolIcon

   procedure Initialize (this : in out SymbolIcon) is
   begin
      null;
   end;

   procedure Finalize (this : in out SymbolIcon) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISymbolIcon, ISymbolIcon_Ptr);
   begin
      if this.m_ISymbolIcon /= null then
         if this.m_ISymbolIcon.all /= null then
            temp := this.m_ISymbolIcon.all.Release;
            Free (this.m_ISymbolIcon);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SymbolIcon

   function Constructor
   (
      symbol : WinUI3.Windows.UI.Xaml.Controls.Symbol
   )
   return SymbolIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SymbolIcon");
      m_Factory    : access ISymbolIconFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISymbolIcon;
   begin
      return RetVal : SymbolIcon do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithSymbol (symbol, m_ComRetVal'Access);
            Retval.m_ISymbolIcon := new WinUI3.Windows.UI.Xaml.Controls.ISymbolIcon;
            Retval.m_ISymbolIcon.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor return SymbolIcon is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SymbolIcon");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISymbolIcon;
   begin
      return RetVal : SymbolIcon do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ISymbolIcon := new WinUI3.Windows.UI.Xaml.Controls.ISymbolIcon;
            Retval.m_ISymbolIcon.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SymbolIcon

   function get_SymbolProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SymbolIcon");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISymbolIconStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SymbolProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SymbolIcon

   function get_Symbol
   (
      this : in out SymbolIcon
   )
   return WinUI3.Windows.UI.Xaml.Controls.Symbol is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Symbol;
   begin
      Hr := this.m_ISymbolIcon.all.get_Symbol (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Symbol
   (
      this : in out SymbolIcon;
      value : WinUI3.Windows.UI.Xaml.Controls.Symbol
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISymbolIcon.all.put_Symbol (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for SymbolIconSource

   procedure Initialize (this : in out SymbolIconSource) is
   begin
      null;
   end;

   procedure Finalize (this : in out SymbolIconSource) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ISymbolIconSource, ISymbolIconSource_Ptr);
   begin
      if this.m_ISymbolIconSource /= null then
         if this.m_ISymbolIconSource.all /= null then
            temp := this.m_ISymbolIconSource.all.Release;
            Free (this.m_ISymbolIconSource);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for SymbolIconSource

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return SymbolIconSource is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SymbolIconSource");
      m_Factory    : access ISymbolIconSourceFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ISymbolIconSource;
   begin
      return RetVal : SymbolIconSource do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconSourceFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ISymbolIconSource := new WinUI3.Windows.UI.Xaml.Controls.ISymbolIconSource;
            Retval.m_ISymbolIconSource.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for SymbolIconSource

   function get_SymbolProperty_SymbolIconSource
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.SymbolIconSource");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ISymbolIconSourceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ISymbolIconSourceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SymbolProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for SymbolIconSource

   function get_Symbol
   (
      this : in out SymbolIconSource
   )
   return WinUI3.Windows.UI.Xaml.Controls.Symbol is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Symbol;
   begin
      Hr := this.m_ISymbolIconSource.all.get_Symbol (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Symbol
   (
      this : in out SymbolIconSource;
      value : WinUI3.Windows.UI.Xaml.Controls.Symbol
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ISymbolIconSource.all.put_Symbol (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBlock

   procedure Initialize (this : in out TextBlock) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBlock) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBlock, ITextBlock_Ptr);
   begin
      if this.m_ITextBlock /= null then
         if this.m_ITextBlock.all /= null then
            temp := this.m_ITextBlock.all.Release;
            Free (this.m_ITextBlock);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextBlock

   function Constructor return TextBlock is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITextBlock;
   begin
      return RetVal : TextBlock do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITextBlock := new WinUI3.Windows.UI.Xaml.Controls.ITextBlock;
            Retval.m_ITextBlock.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TextBlock

   function get_SelectionFlyoutProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextScaleFactorEnabledProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextScaleFactorEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontSizeProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontFamilyProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontFamilyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontWeightProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontWeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStyleProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_FontStretchProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_FontStretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterSpacingProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterSpacingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ForegroundProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextTrimmingProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextTrimmingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PaddingProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PaddingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineHeightProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LineStackingStrategyProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LineStackingStrategyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextSelectionEnabledProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextSelectionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectedTextProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextTrimmedProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextTrimmedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextDecorationsProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextDecorationsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLinesProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLinesProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextLineBoundsProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextLineBoundsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OpticalMarginAlignmentProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OpticalMarginAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_TextBlock
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBlock");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBlockStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBlockStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBlock

   function get_FontSize
   (
      this : in out TextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITextBlock.all.get_FontSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontSize
   (
      this : in out TextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontFamily
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Media.FontFamily'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IFontFamily;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.FontFamily do
         Hr := this.m_ITextBlock.all.get_FontFamily (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFontFamily := new WinUI3.Windows.UI.Xaml.Media.IFontFamily;
         Retval.m_IFontFamily.all := m_ComRetVal;
      end return;
   end;

   procedure put_FontFamily
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.Media.FontFamily'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontFamily (value.m_IFontFamily.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontWeight
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := this.m_ITextBlock.all.get_FontWeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontWeight
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.FontWeight
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontWeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStyle
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.FontStyle is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
   begin
      Hr := this.m_ITextBlock.all.get_FontStyle (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStyle
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.FontStyle
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontStyle (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FontStretch
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.FontStretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
   begin
      Hr := this.m_ITextBlock.all.get_FontStretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FontStretch
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.FontStretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_FontStretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterSpacing
   (
      this : in out TextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBlock.all.get_CharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterSpacing
   (
      this : in out TextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_CharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Foreground
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ITextBlock.all.get_Foreground (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_Foreground
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_Foreground (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_ITextBlock.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextTrimming
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextTrimming is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextTrimming;
   begin
      Hr := this.m_ITextBlock.all.get_TextTrimming (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextTrimming
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.TextTrimming
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextTrimming (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_ITextBlock.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Text
   (
      this : in out TextBlock
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBlock.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out TextBlock;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextBlock.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Inlines
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.InlineCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.InlineCollection do
         Hr := this.m_ITextBlock.all.get_Inlines (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   function get_Padding
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_ITextBlock.all.get_Padding (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Padding
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.Thickness
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_Padding (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineHeight
   (
      this : in out TextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITextBlock.all.get_LineHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineHeight
   (
      this : in out TextBlock;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_LineHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LineStackingStrategy
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.LineStackingStrategy is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.LineStackingStrategy;
   begin
      Hr := this.m_ITextBlock.all.get_LineStackingStrategy (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LineStackingStrategy
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.LineStackingStrategy
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_LineStackingStrategy (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextSelectionEnabled
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBlock.all.get_IsTextSelectionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextSelectionEnabled
   (
      this : in out TextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.put_IsTextSelectionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedText
   (
      this : in out TextBlock
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBlock.all.get_SelectedText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_ContentStart
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_ContentStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_ContentEnd
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_ContentEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionStart
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_SelectionStart (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_SelectionEnd
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Documents.TextPointer do
         Hr := this.m_ITextBlock.all.get_SelectionEnd (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITextPointer := new WinUI3.Windows.UI.Xaml.Documents.ITextPointer;
         Retval.m_ITextPointer.all := m_ComRetVal;
      end return;
   end;

   function get_BaselineOffset
   (
      this : in out TextBlock
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITextBlock.all.get_BaselineOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_SelectionChanged
   (
      this : in out TextBlock;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBlock.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out TextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out TextBlock;
      handler : WinUI3.Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBlock.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out TextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out TextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Select_x
   (
      this : in out TextBlock;
      start : WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class;
      end_x : WinUI3.Windows.UI.Xaml.Documents.TextPointer'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBlock.all.Select_x (start.m_ITextPointer.all, end_x.m_ITextPointer.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Focus
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.FocusState
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBlock.all.Focus (value, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionHighlightColor
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_ITextBlock.all);
         Hr := m_Interface.get_SelectionHighlightColor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLines
   (
      this : in out TextBlock
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_MaxLines (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLines
   (
      this : in out TextBlock;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_MaxLines (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextLineBounds
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextLineBounds is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextLineBounds;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_TextLineBounds (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextLineBounds
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.TextLineBounds
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_TextLineBounds (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OpticalMarginAlignment
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.OpticalMarginAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.OpticalMarginAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_OpticalMarginAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OpticalMarginAlignment
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.OpticalMarginAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_OpticalMarginAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_IsColorFontEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out TextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_IsColorFontEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextReadingOrder;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_TextReadingOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_TextReadingOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextScaleFactorEnabled
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_IsTextScaleFactorEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextScaleFactorEnabled
   (
      this : in out TextBlock;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_IsTextScaleFactorEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetAlphaMask
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Composition.CompositionBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Composition.ICompositionBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock4, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Composition.CompositionBrush do
         m_Interface := QInterface (this.m_ITextBlock.all);
         Hr := m_Interface.GetAlphaMask (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ICompositionBrush := new WinUI3.Windows.UI.Composition.ICompositionBrush;
         Retval.m_ICompositionBrush.all := m_ComRetVal;
      end return;
   end;

   function get_TextDecorations
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Text.TextDecorations is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.TextDecorations;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_TextDecorations (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextDecorations
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Text.TextDecorations
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock5, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_TextDecorations (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextTrimmed
   (
      this : in out TextBlock
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_IsTextTrimmed (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_HorizontalTextAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_HorizontalTextAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextHighlighters
   (
      this : in out TextBlock
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.get_TextHighlighters (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_IsTextTrimmedChanged
   (
      this : in out TextBlock;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.add_IsTextTrimmedChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsTextTrimmedChanged
   (
      this : in out TextBlock;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.remove_IsTextTrimmedChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionFlyout
   (
      this : in out TextBlock
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock7, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock7'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_ITextBlock.all);
         Hr := m_Interface.get_SelectionFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out TextBlock;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock7, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.put_SelectionFlyout (value.m_IFlyoutBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CopySelectionToClipboard
   (
      this : in out TextBlock
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBlock7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBlock_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBlock7, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBlock7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBlock.all);
      Hr := m_Interface.CopySelectionToClipboard;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBox

   procedure Initialize (this : in out TextBox) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBox, ITextBox_Ptr);
   begin
      if this.m_ITextBox /= null then
         if this.m_ITextBox.all /= null then
            temp := this.m_ITextBox.all.Release;
            Free (this.m_ITextBox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextBox

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TextBox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory    : access ITextBoxFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITextBox;
   begin
      return RetVal : TextBox do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITextBox := new WinUI3.Windows.UI.Xaml.Controls.ITextBox;
            Retval.m_ITextBox.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TextBox

   function get_HandwritingViewProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HandwritingViewProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsHandwritingViewEnabledProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics7_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics7'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsHandwritingViewEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanPasteClipboardContentProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanPasteClipboardContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanUndoProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanUndoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanRedoProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanRedoProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionFlyoutProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ProofingMenuFlyoutProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ProofingMenuFlyoutProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DescriptionProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics8_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics8'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DescriptionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderTextProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderTextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocusProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PreventKeyboardDisplayOnProgrammaticFocusProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsColorFontEnabledProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsColorFontEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_SelectionHighlightColorWhenNotFocusedProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionHighlightColorWhenNotFocusedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaxLengthProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxLengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsReadOnlyProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsReadOnlyProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AcceptsReturnProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AcceptsReturnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextAlignmentProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextWrappingProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextWrappingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsSpellCheckEnabledProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsSpellCheckEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsTextPredictionEnabledProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsTextPredictionEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_InputScopeProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_InputScopeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DesiredCandidateWindowAlignmentProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DesiredCandidateWindowAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TextReadingOrderProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TextReadingOrderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalTextAlignmentProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalTextAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CharacterCasingProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CharacterCasingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlaceholderForegroundProperty_TextBox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextBox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITextBoxStatics6_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITextBoxStatics6'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlaceholderForegroundProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBox

   function get_Text
   (
      this : in out TextBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBox.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out TextBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextBox.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectedText
   (
      this : in out TextBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBox.all.get_SelectedText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SelectedText
   (
      this : in out TextBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextBox.all.put_SelectedText (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionLength
   (
      this : in out TextBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBox.all.get_SelectionLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionLength
   (
      this : in out TextBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_SelectionLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectionStart
   (
      this : in out TextBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBox.all.get_SelectionStart (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionStart
   (
      this : in out TextBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_SelectionStart (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaxLength
   (
      this : in out TextBox
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBox.all.get_MaxLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaxLength
   (
      this : in out TextBox;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_MaxLength (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsReadOnly
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_IsReadOnly (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsReadOnly
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_IsReadOnly (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AcceptsReturn
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_AcceptsReturn (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AcceptsReturn
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_AcceptsReturn (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextAlignment
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
   begin
      Hr := this.m_ITextBox.all.get_TextAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextAlignment
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_TextAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextWrapping
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.TextWrapping is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextWrapping;
   begin
      Hr := this.m_ITextBox.all.get_TextWrapping (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextWrapping
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.TextWrapping
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_TextWrapping (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsSpellCheckEnabled
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_IsSpellCheckEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsSpellCheckEnabled
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_IsSpellCheckEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsTextPredictionEnabled
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBox.all.get_IsTextPredictionEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsTextPredictionEnabled
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_IsTextPredictionEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_InputScope
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Input.InputScope'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Input.IInputScope;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Input.InputScope do
         Hr := this.m_ITextBox.all.get_InputScope (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IInputScope := new WinUI3.Windows.UI.Xaml.Input.IInputScope;
         Retval.m_IInputScope.all := m_ComRetVal;
      end return;
   end;

   procedure put_InputScope
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Input.InputScope'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.put_InputScope (value.m_IInputScope.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanged
   (
      this : in out TextBox;
      handler : WinUI3.Windows.UI.Xaml.Controls.TextChangedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_TextChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_TextChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanged
   (
      this : in out TextBox;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_SelectionChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_SelectionChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContextMenuOpening
   (
      this : in out TextBox;
      handler : WinUI3.Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITextBox.all.add_ContextMenuOpening (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContextMenuOpening
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.remove_ContextMenuOpening (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Select_x
   (
      this : in out TextBox;
      start : WinUI3.Int32;
      length : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.Select_x (start, length);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBox.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetRectFromCharacterIndex
   (
      this : in out TextBox;
      charIndex : WinUI3.Int32;
      trailingEdge : WinUI3.Boolean
   )
   return WinUI3.Windows.Foundation.Rect is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.Rect;
   begin
      Hr := this.m_ITextBox.all.GetRectFromCharacterIndex (charIndex, trailingEdge, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Header
   (
      this : in out TextBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_Header (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out TextBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_Header (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_ITextBox.all);
         Hr := m_Interface.get_HeaderTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_HeaderTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderText
   (
      this : in out TextBox
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_PlaceholderText (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_PlaceholderText
   (
      this : in out TextBox;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_PlaceholderText (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_SelectionHighlightColor
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_ITextBox.all);
         Hr := m_Interface.get_SelectionHighlightColor (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColor
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_SelectionHighlightColor (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_PreventKeyboardDisplayOnProgrammaticFocus (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PreventKeyboardDisplayOnProgrammaticFocus
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_PreventKeyboardDisplayOnProgrammaticFocus (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsColorFontEnabled
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_IsColorFontEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsColorFontEnabled
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_IsColorFontEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Paste
   (
      this : in out TextBox;
      handler : WinUI3.Windows.UI.Xaml.Controls.TextControlPasteEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_Paste (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Paste
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_Paste (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionStarted
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_TextCompositionStarted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionStarted
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_TextCompositionStarted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionChanged
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_TextCompositionChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_TextCompositionChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextCompositionEnded
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_TextCompositionEnded (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextCompositionEnded
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_TextCompositionEnded (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TextReadingOrder
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.TextReadingOrder is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextReadingOrder;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_TextReadingOrder (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TextReadingOrder
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.TextReadingOrder
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_TextReadingOrder (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DesiredCandidateWindowAlignment
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.CandidateWindowAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CandidateWindowAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_DesiredCandidateWindowAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DesiredCandidateWindowAlignment
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Controls.CandidateWindowAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_DesiredCandidateWindowAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CandidateWindowBoundsChanged
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_CandidateWindowBoundsChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CandidateWindowBoundsChanged
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_CandidateWindowBoundsChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TextChanging
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_TextChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TextChanging
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox3, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_TextChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetLinguisticAlternativesAsync
   (
      this : in out TextBox
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (798143785, 4507, 22362, (164, 25, 57, 4, 180, 228, 26, 242 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (2088278462, 24366, 23539, (173, 229, 173, 152, 183, 114, 199, 205 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox4, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.GetLinguisticAlternativesAsync (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   function get_SelectionHighlightColorWhenNotFocused
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox5, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush do
         m_Interface := QInterface (this.m_ITextBox.all);
         Hr := m_Interface.get_SelectionHighlightColorWhenNotFocused (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ISolidColorBrush := new WinUI3.Windows.UI.Xaml.Media.ISolidColorBrush;
         Retval.m_ISolidColorBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionHighlightColorWhenNotFocused
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Media.SolidColorBrush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox5, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_SelectionHighlightColorWhenNotFocused (value.m_ISolidColorBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalTextAlignment
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.TextAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.TextAlignment;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_HorizontalTextAlignment (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalTextAlignment
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.TextAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_HorizontalTextAlignment (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterCasing
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.CharacterCasing is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.CharacterCasing;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_CharacterCasing (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterCasing
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Controls.CharacterCasing
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_CharacterCasing (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlaceholderForeground
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         m_Interface := QInterface (this.m_ITextBox.all);
         Hr := m_Interface.get_PlaceholderForeground (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlaceholderForeground
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_PlaceholderForeground (value.m_IBrush.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CopyingToClipboard
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_CopyingToClipboard (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CopyingToClipboard
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_CopyingToClipboard (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CuttingToClipboard
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_CuttingToClipboard (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CuttingToClipboard
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_CuttingToClipboard (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_BeforeTextChanging
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_BeforeTextChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_BeforeTextChanging
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox6, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_BeforeTextChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HandwritingView
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.HandwritingView'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IHandwritingView;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox7, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox7'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.HandwritingView do
         m_Interface := QInterface (this.m_ITextBox.all);
         Hr := m_Interface.get_HandwritingView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHandwritingView := new WinUI3.Windows.UI.Xaml.Controls.IHandwritingView;
         Retval.m_IHandwritingView.all := m_ComRetVal;
      end return;
   end;

   procedure put_HandwritingView
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Controls.HandwritingView'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox7, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_HandwritingView (value.m_IHandwritingView.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsHandwritingViewEnabled
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox7, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_IsHandwritingViewEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsHandwritingViewEnabled
   (
      this : in out TextBox;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox7, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_IsHandwritingViewEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanPasteClipboardContent
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_CanPasteClipboardContent (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanUndo
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_CanUndo (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanRedo
   (
      this : in out TextBox
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_CanRedo (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionFlyout
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_ITextBox.all);
         Hr := m_Interface.get_SelectionFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   procedure put_SelectionFlyout
   (
      this : in out TextBox;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_SelectionFlyout (value.m_IFlyoutBase.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ProofingMenuFlyout
   (
      this : in out TextBox
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.FlyoutBase do
         m_Interface := QInterface (this.m_ITextBox.all);
         Hr := m_Interface.get_ProofingMenuFlyout (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IFlyoutBase := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IFlyoutBase;
         Retval.m_IFlyoutBase.all := m_ComRetVal;
      end return;
   end;

   function get_Description
   (
      this : in out TextBox
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.get_Description (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Description
   (
      this : in out TextBox;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.put_Description (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectionChanging
   (
      this : in out TextBox;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.add_SelectionChanging (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectionChanging
   (
      this : in out TextBox;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.remove_SelectionChanging (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Undo
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.Undo;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Redo
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.Redo;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure PasteFromClipboard
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.PasteFromClipboard;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CopySelectionToClipboard
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.CopySelectionToClipboard;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CutSelectionToClipboard
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.CutSelectionToClipboard;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ClearUndoRedoHistory
   (
      this : in out TextBox
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBox8 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBox_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBox8, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBox8'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBox.all);
      Hr := m_Interface.ClearUndoRedoHistory;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBoxBeforeTextChangingEventArgs

   procedure Initialize (this : in out TextBoxBeforeTextChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBoxBeforeTextChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBoxBeforeTextChangingEventArgs, ITextBoxBeforeTextChangingEventArgs_Ptr);
   begin
      if this.m_ITextBoxBeforeTextChangingEventArgs /= null then
         if this.m_ITextBoxBeforeTextChangingEventArgs.all /= null then
            temp := this.m_ITextBoxBeforeTextChangingEventArgs.all.Release;
            Free (this.m_ITextBoxBeforeTextChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBoxBeforeTextChangingEventArgs

   function get_NewText
   (
      this : in out TextBoxBeforeTextChangingEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextBoxBeforeTextChangingEventArgs.all.get_NewText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function get_Cancel
   (
      this : in out TextBoxBeforeTextChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBoxBeforeTextChangingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TextBoxBeforeTextChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBoxBeforeTextChangingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBoxSelectionChangingEventArgs

   procedure Initialize (this : in out TextBoxSelectionChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBoxSelectionChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBoxSelectionChangingEventArgs, ITextBoxSelectionChangingEventArgs_Ptr);
   begin
      if this.m_ITextBoxSelectionChangingEventArgs /= null then
         if this.m_ITextBoxSelectionChangingEventArgs.all /= null then
            temp := this.m_ITextBoxSelectionChangingEventArgs.all.Release;
            Free (this.m_ITextBoxSelectionChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBoxSelectionChangingEventArgs

   function get_SelectionStart
   (
      this : in out TextBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.get_SelectionStart (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_SelectionLength
   (
      this : in out TextBoxSelectionChangingEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.get_SelectionLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Cancel
   (
      this : in out TextBoxSelectionChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TextBoxSelectionChangingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextBoxSelectionChangingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextBoxTextChangingEventArgs

   procedure Initialize (this : in out TextBoxTextChangingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextBoxTextChangingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextBoxTextChangingEventArgs, ITextBoxTextChangingEventArgs_Ptr);
   begin
      if this.m_ITextBoxTextChangingEventArgs /= null then
         if this.m_ITextBoxTextChangingEventArgs.all /= null then
            temp := this.m_ITextBoxTextChangingEventArgs.all.Release;
            Free (this.m_ITextBoxTextChangingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextBoxTextChangingEventArgs

   function get_IsContentChanging
   (
      this : in out TextBoxTextChangingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.ITextBoxTextChangingEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_ITextBoxTextChangingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextBoxTextChangingEventArgs.all);
      Hr := m_Interface.get_IsContentChanging (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextChangedEventArgs

   procedure Initialize (this : in out TextChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextChangedEventArgs, ITextChangedEventArgs_Ptr);
   begin
      if this.m_ITextChangedEventArgs /= null then
         if this.m_ITextChangedEventArgs.all /= null then
            temp := this.m_ITextChangedEventArgs.all.Release;
            Free (this.m_ITextChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextChangedEventArgs

   -----------------------------------------------------------------------------
   -- Delegate TextChangedEventHandler

   function Invoke
   (
      this : access TextChangedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.ITextChangedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCommandBarFlyout

   procedure Initialize (this : in out TextCommandBarFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCommandBarFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCommandBarFlyout, ITextCommandBarFlyout_Ptr);
   begin
      if this.m_ITextCommandBarFlyout /= null then
         if this.m_ITextCommandBarFlyout.all /= null then
            temp := this.m_ITextCommandBarFlyout.all.Release;
            Free (this.m_ITextCommandBarFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TextCommandBarFlyout

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TextCommandBarFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TextCommandBarFlyout");
      m_Factory    : access ITextCommandBarFlyoutFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITextCommandBarFlyout;
   begin
      return RetVal : TextCommandBarFlyout do
         Hr := RoGetActivationFactory (m_hString, IID_ITextCommandBarFlyoutFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITextCommandBarFlyout := new WinUI3.Windows.UI.Xaml.Controls.ITextCommandBarFlyout;
            Retval.m_ITextCommandBarFlyout.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCommandBarFlyout

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCompositionChangedEventArgs

   procedure Initialize (this : in out TextCompositionChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCompositionChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCompositionChangedEventArgs, ITextCompositionChangedEventArgs_Ptr);
   begin
      if this.m_ITextCompositionChangedEventArgs /= null then
         if this.m_ITextCompositionChangedEventArgs.all /= null then
            temp := this.m_ITextCompositionChangedEventArgs.all.Release;
            Free (this.m_ITextCompositionChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCompositionChangedEventArgs

   function get_StartIndex
   (
      this : in out TextCompositionChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionChangedEventArgs.all.get_StartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Length
   (
      this : in out TextCompositionChangedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionChangedEventArgs.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCompositionEndedEventArgs

   procedure Initialize (this : in out TextCompositionEndedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCompositionEndedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCompositionEndedEventArgs, ITextCompositionEndedEventArgs_Ptr);
   begin
      if this.m_ITextCompositionEndedEventArgs /= null then
         if this.m_ITextCompositionEndedEventArgs.all /= null then
            temp := this.m_ITextCompositionEndedEventArgs.all.Release;
            Free (this.m_ITextCompositionEndedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCompositionEndedEventArgs

   function get_StartIndex
   (
      this : in out TextCompositionEndedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionEndedEventArgs.all.get_StartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Length
   (
      this : in out TextCompositionEndedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionEndedEventArgs.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextCompositionStartedEventArgs

   procedure Initialize (this : in out TextCompositionStartedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextCompositionStartedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextCompositionStartedEventArgs, ITextCompositionStartedEventArgs_Ptr);
   begin
      if this.m_ITextCompositionStartedEventArgs /= null then
         if this.m_ITextCompositionStartedEventArgs.all /= null then
            temp := this.m_ITextCompositionStartedEventArgs.all.Release;
            Free (this.m_ITextCompositionStartedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextCompositionStartedEventArgs

   function get_StartIndex
   (
      this : in out TextCompositionStartedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionStartedEventArgs.all.get_StartIndex (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Length
   (
      this : in out TextCompositionStartedEventArgs
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextCompositionStartedEventArgs.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextControlCopyingToClipboardEventArgs

   procedure Initialize (this : in out TextControlCopyingToClipboardEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextControlCopyingToClipboardEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextControlCopyingToClipboardEventArgs, ITextControlCopyingToClipboardEventArgs_Ptr);
   begin
      if this.m_ITextControlCopyingToClipboardEventArgs /= null then
         if this.m_ITextControlCopyingToClipboardEventArgs.all /= null then
            temp := this.m_ITextControlCopyingToClipboardEventArgs.all.Release;
            Free (this.m_ITextControlCopyingToClipboardEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextControlCopyingToClipboardEventArgs

   function get_Handled
   (
      this : in out TextControlCopyingToClipboardEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextControlCopyingToClipboardEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TextControlCopyingToClipboardEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextControlCopyingToClipboardEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextControlCuttingToClipboardEventArgs

   procedure Initialize (this : in out TextControlCuttingToClipboardEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextControlCuttingToClipboardEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextControlCuttingToClipboardEventArgs, ITextControlCuttingToClipboardEventArgs_Ptr);
   begin
      if this.m_ITextControlCuttingToClipboardEventArgs /= null then
         if this.m_ITextControlCuttingToClipboardEventArgs.all /= null then
            temp := this.m_ITextControlCuttingToClipboardEventArgs.all.Release;
            Free (this.m_ITextControlCuttingToClipboardEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextControlCuttingToClipboardEventArgs

   function get_Handled
   (
      this : in out TextControlCuttingToClipboardEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextControlCuttingToClipboardEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TextControlCuttingToClipboardEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextControlCuttingToClipboardEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TextControlPasteEventArgs

   procedure Initialize (this : in out TextControlPasteEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TextControlPasteEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextControlPasteEventArgs, ITextControlPasteEventArgs_Ptr);
   begin
      if this.m_ITextControlPasteEventArgs /= null then
         if this.m_ITextControlPasteEventArgs.all /= null then
            temp := this.m_ITextControlPasteEventArgs.all.Release;
            Free (this.m_ITextControlPasteEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TextControlPasteEventArgs

   function get_Handled
   (
      this : in out TextControlPasteEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextControlPasteEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TextControlPasteEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextControlPasteEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Delegate TextControlPasteEventHandler

   function Invoke
   (
      this : access TextControlPasteEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.ITextControlPasteEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickedEventArgs

   procedure Initialize (this : in out TimePickedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickedEventArgs, ITimePickedEventArgs_Ptr);
   begin
      if this.m_ITimePickedEventArgs /= null then
         if this.m_ITimePickedEventArgs.all /= null then
            temp := this.m_ITimePickedEventArgs.all.Release;
            Free (this.m_ITimePickedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimePickedEventArgs

   function Constructor return TimePickedEventArgs is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePickedEventArgs");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITimePickedEventArgs;
   begin
      return RetVal : TimePickedEventArgs do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITimePickedEventArgs := new WinUI3.Windows.UI.Xaml.Controls.ITimePickedEventArgs;
            Retval.m_ITimePickedEventArgs.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickedEventArgs

   function get_OldTime
   (
      this : in out TimePickedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickedEventArgs.all.get_OldTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewTime
   (
      this : in out TimePickedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickedEventArgs.all.get_NewTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePicker

   procedure Initialize (this : in out TimePicker) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePicker) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePicker, ITimePicker_Ptr);
   begin
      if this.m_ITimePicker /= null then
         if this.m_ITimePicker.all /= null then
            temp := this.m_ITimePicker.all.Release;
            Free (this.m_ITimePicker);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimePicker

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TimePicker is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory    : access ITimePickerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITimePicker;
   begin
      return RetVal : TimePicker do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITimePicker := new WinUI3.Windows.UI.Xaml.Controls.ITimePicker;
            Retval.m_ITimePicker.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TimePicker

   function get_SelectedTimeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectedTimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_LightDismissOverlayModeProperty_TimePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_LightDismissOverlayModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_TimePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_TimePicker
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ClockIdentifierProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClockIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinuteIncrementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinuteIncrementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TimeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePicker");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePicker

   function get_Header
   (
      this : in out TimePicker
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITimePicker.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out TimePicker;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out TimePicker
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_ITimePicker.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out TimePicker;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ClockIdentifier
   (
      this : in out TimePicker
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITimePicker.all.get_ClockIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ClockIdentifier
   (
      this : in out TimePicker;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITimePicker.all.put_ClockIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_MinuteIncrement
   (
      this : in out TimePicker
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITimePicker.all.get_MinuteIncrement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinuteIncrement
   (
      this : in out TimePicker;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_MinuteIncrement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Time
   (
      this : in out TimePicker
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePicker.all.get_Time (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Time
   (
      this : in out TimePicker;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.put_Time (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TimeChanged
   (
      this : in out TimePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITimePicker.all.add_TimeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TimeChanged
   (
      this : in out TimePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePicker.all.remove_TimeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_LightDismissOverlayMode
   (
      this : in out TimePicker
   )
   return WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePicker2, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePicker.all);
      Hr := m_Interface.get_LightDismissOverlayMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_LightDismissOverlayMode
   (
      this : in out TimePicker;
      value : WinUI3.Windows.UI.Xaml.Controls.LightDismissOverlayMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePicker2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePicker2, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePicker2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePicker.all);
      Hr := m_Interface.put_LightDismissOverlayMode (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedTime
   (
      this : in out TimePicker
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePicker.all);
      Hr := m_Interface.get_SelectedTime (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_SelectedTime
   (
      this : in out TimePicker;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePicker.all);
      Hr := m_Interface.put_SelectedTime (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SelectedTimeChanged
   (
      this : in out TimePicker;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePicker.all);
      Hr := m_Interface.add_SelectedTimeChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SelectedTimeChanged
   (
      this : in out TimePicker;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePicker3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePicker_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePicker3, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePicker3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePicker.all);
      Hr := m_Interface.remove_SelectedTimeChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerFlyout

   procedure Initialize (this : in out TimePickerFlyout) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerFlyout) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerFlyout, ITimePickerFlyout_Ptr);
   begin
      if this.m_ITimePickerFlyout /= null then
         if this.m_ITimePickerFlyout.all /= null then
            temp := this.m_ITimePickerFlyout.all.Release;
            Free (this.m_ITimePickerFlyout);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TimePickerFlyout

   function Constructor return TimePickerFlyout is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePickerFlyout");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyout;
   begin
      return RetVal : TimePickerFlyout do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_ITimePickerFlyout := new WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyout;
            Retval.m_ITimePickerFlyout.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TimePickerFlyout

   function get_ClockIdentifierProperty_TimePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ClockIdentifierProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TimeProperty_TimePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TimeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinuteIncrementProperty_TimePickerFlyout
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePickerFlyout");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinuteIncrementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerFlyout

   function get_ClockIdentifier
   (
      this : in out TimePickerFlyout
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITimePickerFlyout.all.get_ClockIdentifier (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ClockIdentifier
   (
      this : in out TimePickerFlyout;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITimePickerFlyout.all.put_ClockIdentifier (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_Time
   (
      this : in out TimePickerFlyout
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickerFlyout.all.get_Time (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Time
   (
      this : in out TimePickerFlyout;
      value : WinUI3.Windows.Foundation.TimeSpan
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePickerFlyout.all.put_Time (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinuteIncrement
   (
      this : in out TimePickerFlyout
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITimePickerFlyout.all.get_MinuteIncrement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinuteIncrement
   (
      this : in out TimePickerFlyout;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePickerFlyout.all.put_MinuteIncrement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_TimePicked
   (
      this : in out TimePickerFlyout;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITimePickerFlyout.all.add_TimePicked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_TimePicked
   (
      this : in out TimePickerFlyout;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITimePickerFlyout.all.remove_TimePicked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function ShowAtAsync
   (
      this : in out TimePickerFlyout;
      target : WinUI3.Windows.UI.Xaml.FrameworkElement'Class
   )
   return WinUI3.GenericObject is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_GenericObject.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_GenericObject.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.GenericObject;
      m_IID            : aliased WinUI3.IID := (615055789, 37135, 23567, (178, 60, 103, 0, 117, 119, 165, 88 )); -- GenericObject;
      m_HandlerIID     : aliased WinUI3.IID := (3778524791, 49135, 21680, (178, 0, 149, 197, 194, 144, 42, 37 ));
      m_Handler        : AsyncOperationCompletedHandler_GenericObject.Kind := new AsyncOperationCompletedHandler_GenericObject.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_GenericObject.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_GenericObject.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_GenericObject.Kind_Delegate, AsyncOperationCompletedHandler_GenericObject.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

   begin
      Hr := this.m_ITimePickerFlyout.all.ShowAtAsync (target.m_IFrameworkElement.all, m_ComRetVal'Access);
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      return m_RetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerFlyoutPresenter

   procedure Initialize (this : in out TimePickerFlyoutPresenter) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerFlyoutPresenter) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerFlyoutPresenter, ITimePickerFlyoutPresenter_Ptr);
   begin
      if this.m_ITimePickerFlyoutPresenter /= null then
         if this.m_ITimePickerFlyoutPresenter.all /= null then
            temp := this.m_ITimePickerFlyoutPresenter.all.Release;
            Free (this.m_ITimePickerFlyoutPresenter);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TimePickerFlyoutPresenter

   function get_IsDefaultShadowEnabledProperty_TimePickerFlyoutPresenter
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TimePickerFlyoutPresenter");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenterStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITimePickerFlyoutPresenterStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsDefaultShadowEnabledProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerFlyoutPresenter

   function get_IsDefaultShadowEnabled
   (
      this : in out TimePickerFlyoutPresenter
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePickerFlyoutPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePickerFlyoutPresenter.all);
      Hr := m_Interface.get_IsDefaultShadowEnabled (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsDefaultShadowEnabled
   (
      this : in out TimePickerFlyoutPresenter;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter_Interface, WinUI3.Windows.UI.Xaml.Controls.ITimePickerFlyoutPresenter2, WinUI3.Windows.UI.Xaml.Controls.IID_ITimePickerFlyoutPresenter2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITimePickerFlyoutPresenter.all);
      Hr := m_Interface.put_IsDefaultShadowEnabled (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerSelectedValueChangedEventArgs

   procedure Initialize (this : in out TimePickerSelectedValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerSelectedValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerSelectedValueChangedEventArgs, ITimePickerSelectedValueChangedEventArgs_Ptr);
   begin
      if this.m_ITimePickerSelectedValueChangedEventArgs /= null then
         if this.m_ITimePickerSelectedValueChangedEventArgs.all /= null then
            temp := this.m_ITimePickerSelectedValueChangedEventArgs.all.Release;
            Free (this.m_ITimePickerSelectedValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerSelectedValueChangedEventArgs

   function get_OldTime
   (
      this : in out TimePickerSelectedValueChangedEventArgs
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
   begin
      Hr := this.m_ITimePickerSelectedValueChangedEventArgs.all.get_OldTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_NewTime
   (
      this : in out TimePickerSelectedValueChangedEventArgs
   )
   return IReference_TimeSpan.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_TimeSpan.Kind;
   begin
      Hr := this.m_ITimePickerSelectedValueChangedEventArgs.all.get_NewTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_TimeSpan (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TimePickerValueChangedEventArgs

   procedure Initialize (this : in out TimePickerValueChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TimePickerValueChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITimePickerValueChangedEventArgs, ITimePickerValueChangedEventArgs_Ptr);
   begin
      if this.m_ITimePickerValueChangedEventArgs /= null then
         if this.m_ITimePickerValueChangedEventArgs.all /= null then
            temp := this.m_ITimePickerValueChangedEventArgs.all.Release;
            Free (this.m_ITimePickerValueChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TimePickerValueChangedEventArgs

   function get_OldTime
   (
      this : in out TimePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickerValueChangedEventArgs.all.get_OldTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_NewTime
   (
      this : in out TimePickerValueChangedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_ITimePickerValueChangedEventArgs.all.get_NewTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleMenuFlyoutItem

   procedure Initialize (this : in out ToggleMenuFlyoutItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleMenuFlyoutItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleMenuFlyoutItem, IToggleMenuFlyoutItem_Ptr);
   begin
      if this.m_IToggleMenuFlyoutItem /= null then
         if this.m_IToggleMenuFlyoutItem.all /= null then
            temp := this.m_IToggleMenuFlyoutItem.all.Release;
            Free (this.m_IToggleMenuFlyoutItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleMenuFlyoutItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToggleMenuFlyoutItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleMenuFlyoutItem");
      m_Factory    : access IToggleMenuFlyoutItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IToggleMenuFlyoutItem;
   begin
      return RetVal : ToggleMenuFlyoutItem do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleMenuFlyoutItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToggleMenuFlyoutItem := new WinUI3.Windows.UI.Xaml.Controls.IToggleMenuFlyoutItem;
            Retval.m_IToggleMenuFlyoutItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToggleMenuFlyoutItem

   function get_IsCheckedProperty_ToggleMenuFlyoutItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleMenuFlyoutItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleMenuFlyoutItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleMenuFlyoutItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsCheckedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleMenuFlyoutItem

   function get_IsChecked
   (
      this : in out ToggleMenuFlyoutItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToggleMenuFlyoutItem.all.get_IsChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsChecked
   (
      this : in out ToggleMenuFlyoutItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleMenuFlyoutItem.all.put_IsChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSplitButton

   procedure Initialize (this : in out ToggleSplitButton) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSplitButton) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSplitButton, IToggleSplitButton_Ptr);
   begin
      if this.m_IToggleSplitButton /= null then
         if this.m_IToggleSplitButton.all /= null then
            temp := this.m_IToggleSplitButton.all.Release;
            Free (this.m_IToggleSplitButton);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleSplitButton

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToggleSplitButton is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSplitButton");
      m_Factory    : access IToggleSplitButtonFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButton;
   begin
      return RetVal : ToggleSplitButton do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSplitButtonFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToggleSplitButton := new WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButton;
            Retval.m_IToggleSplitButton.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSplitButton

   function get_IsChecked
   (
      this : in out ToggleSplitButton
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToggleSplitButton.all.get_IsChecked (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsChecked
   (
      this : in out ToggleSplitButton;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSplitButton.all.put_IsChecked (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_IsCheckedChanged
   (
      this : in out ToggleSplitButton;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToggleSplitButton.all.add_IsCheckedChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_IsCheckedChanged
   (
      this : in out ToggleSplitButton;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSplitButton.all.remove_IsCheckedChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSplitButtonAutomationPeer

   procedure Initialize (this : in out ToggleSplitButtonAutomationPeer) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSplitButtonAutomationPeer) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSplitButtonAutomationPeer, IToggleSplitButtonAutomationPeer_Ptr);
   begin
      if this.m_IToggleSplitButtonAutomationPeer /= null then
         if this.m_IToggleSplitButtonAutomationPeer.all /= null then
            temp := this.m_IToggleSplitButtonAutomationPeer.all.Release;
            Free (this.m_IToggleSplitButtonAutomationPeer);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleSplitButtonAutomationPeer

   function Constructor
   (
      owner : WinUI3.Windows.UI.Xaml.Controls.ToggleSplitButton'Class;
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToggleSplitButtonAutomationPeer is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSplitButtonAutomationPeer");
      m_Factory    : access IToggleSplitButtonAutomationPeerFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer;
   begin
      return RetVal : ToggleSplitButtonAutomationPeer do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSplitButtonAutomationPeerFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (owner.m_IToggleSplitButton.all, baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToggleSplitButtonAutomationPeer := new WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer;
            Retval.m_IToggleSplitButtonAutomationPeer.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSplitButtonAutomationPeer

   function get_ExpandCollapseState
   (
      this : in out ToggleSplitButtonAutomationPeer
   )
   return WinUI3.Windows.UI.Xaml.Automation.ExpandCollapseState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Automation.ExpandCollapseState;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSplitButtonAutomationPeer.all);
      Hr := m_Interface.get_ExpandCollapseState (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Collapse
   (
      this : in out ToggleSplitButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSplitButtonAutomationPeer.all);
      Hr := m_Interface.Collapse;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Expand
   (
      this : in out ToggleSplitButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IExpandCollapseProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSplitButtonAutomationPeer.all);
      Hr := m_Interface.Expand;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ToggleState
   (
      this : in out ToggleSplitButtonAutomationPeer
   )
   return WinUI3.Windows.UI.Xaml.Automation.ToggleState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IToggleProvider := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Automation.ToggleState;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IToggleProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IToggleProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSplitButtonAutomationPeer.all);
      Hr := m_Interface.get_ToggleState (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Toggle
   (
      this : in out ToggleSplitButtonAutomationPeer
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Automation.Provider.IToggleProvider := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSplitButtonAutomationPeer_Interface, WinUI3.Windows.UI.Xaml.Automation.Provider.IToggleProvider, WinUI3.Windows.UI.Xaml.Automation.Provider.IID_IToggleProvider'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSplitButtonAutomationPeer.all);
      Hr := m_Interface.Toggle;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSplitButtonIsCheckedChangedEventArgs

   procedure Initialize (this : in out ToggleSplitButtonIsCheckedChangedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSplitButtonIsCheckedChangedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSplitButtonIsCheckedChangedEventArgs, IToggleSplitButtonIsCheckedChangedEventArgs_Ptr);
   begin
      if this.m_IToggleSplitButtonIsCheckedChangedEventArgs /= null then
         if this.m_IToggleSplitButtonIsCheckedChangedEventArgs.all /= null then
            temp := this.m_IToggleSplitButtonIsCheckedChangedEventArgs.all.Release;
            Free (this.m_IToggleSplitButtonIsCheckedChangedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSplitButtonIsCheckedChangedEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToggleSwitch

   procedure Initialize (this : in out ToggleSwitch) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToggleSwitch) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToggleSwitch, IToggleSwitch_Ptr);
   begin
      if this.m_IToggleSwitch /= null then
         if this.m_IToggleSwitch.all /= null then
            temp := this.m_IToggleSwitch.all.Release;
            Free (this.m_IToggleSwitch);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToggleSwitch

   function Constructor return ToggleSwitch is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IToggleSwitch;
   begin
      return RetVal : ToggleSwitch do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IToggleSwitch := new WinUI3.Windows.UI.Xaml.Controls.IToggleSwitch;
            Retval.m_IToggleSwitch.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToggleSwitch

   function get_IsOnProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOnProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderProperty_ToggleSwitch
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HeaderTemplateProperty_ToggleSwitch
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HeaderTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OnContentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OnContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OnContentTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OnContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OffContentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OffContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OffContentTemplateProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToggleSwitch");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToggleSwitchStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OffContentTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToggleSwitch

   function get_IsOn
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToggleSwitch.all.get_IsOn (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOn
   (
      this : in out ToggleSwitch;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_IsOn (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Header
   (
      this : in out ToggleSwitch
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IToggleSwitch.all.get_Header (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Header
   (
      this : in out ToggleSwitch;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_Header (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HeaderTemplate
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IToggleSwitch.all.get_HeaderTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_HeaderTemplate
   (
      this : in out ToggleSwitch;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_HeaderTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OnContent
   (
      this : in out ToggleSwitch
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IToggleSwitch.all.get_OnContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OnContent
   (
      this : in out ToggleSwitch;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OnContent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OnContentTemplate
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IToggleSwitch.all.get_OnContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_OnContentTemplate
   (
      this : in out ToggleSwitch;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OnContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OffContent
   (
      this : in out ToggleSwitch
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_IToggleSwitch.all.get_OffContent (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_OffContent
   (
      this : in out ToggleSwitch;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OffContent (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_OffContentTemplate
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         Hr := this.m_IToggleSwitch.all.get_OffContentTemplate (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_OffContentTemplate
   (
      this : in out ToggleSwitch;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.put_OffContentTemplate (value.m_IDataTemplate.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ToggleSwitch
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IToggleSwitchTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings do
         Hr := this.m_IToggleSwitch.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IToggleSwitchTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IToggleSwitchTemplateSettings;
         Retval.m_IToggleSwitchTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_Toggled
   (
      this : in out ToggleSwitch;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToggleSwitch.all.add_Toggled (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Toggled
   (
      this : in out ToggleSwitch;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToggleSwitch.all.remove_Toggled (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnToggled
   (
      this : in out ToggleSwitch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnToggled;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOnContentChanged
   (
      this : in out ToggleSwitch;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnOnContentChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnOffContentChanged
   (
      this : in out ToggleSwitch;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnOffContentChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnHeaderChanged
   (
      this : in out ToggleSwitch;
      oldContent : WinUI3.IInspectable;
      newContent : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToggleSwitch_Interface, WinUI3.Windows.UI.Xaml.Controls.IToggleSwitchOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IToggleSwitchOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToggleSwitch.all);
      Hr := m_Interface.OnHeaderChanged (oldContent, newContent);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToolTip

   procedure Initialize (this : in out ToolTip) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToolTip) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToolTip, IToolTip_Ptr);
   begin
      if this.m_IToolTip /= null then
         if this.m_IToolTip.all /= null then
            temp := this.m_IToolTip.all.Release;
            Free (this.m_IToolTip);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for ToolTip

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return ToolTip is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTip");
      m_Factory    : access IToolTipFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IToolTip;
   begin
      return RetVal : ToolTip do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_IToolTip := new WinUI3.Windows.UI.Xaml.Controls.IToolTip;
            Retval.m_IToolTip.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToolTip

   function get_PlacementRectProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementRectProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalOffsetProperty_ToolTip
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsOpenProperty_ToolTip
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsOpenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PlacementTargetProperty_ToolTip
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalOffsetProperty_ToolTip
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTip");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalOffsetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToolTip

   function get_HorizontalOffset
   (
      this : in out ToolTip
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToolTip.all.get_HorizontalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalOffset
   (
      this : in out ToolTip;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_HorizontalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsOpen
   (
      this : in out ToolTip
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IToolTip.all.get_IsOpen (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsOpen
   (
      this : in out ToolTip;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_IsOpen (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Placement
   (
      this : in out ToolTip
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.PlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.PlacementMode;
   begin
      Hr := this.m_IToolTip.all.get_Placement (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Placement
   (
      this : in out ToolTip;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.PlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_Placement (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlacementTarget
   (
      this : in out ToolTip
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IToolTip.all.get_PlacementTarget (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_PlacementTarget
   (
      this : in out ToolTip;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_PlacementTarget (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalOffset
   (
      this : in out ToolTip
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IToolTip.all.get_VerticalOffset (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalOffset
   (
      this : in out ToolTip;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.put_VerticalOffset (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TemplateSettings
   (
      this : in out ToolTip
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.IToolTipTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings do
         Hr := this.m_IToolTip.all.get_TemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IToolTipTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.Primitives.IToolTipTemplateSettings;
         Retval.m_IToolTipTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function add_Closed
   (
      this : in out ToolTip;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToolTip.all.add_Closed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Closed
   (
      this : in out ToolTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.remove_Closed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Opened
   (
      this : in out ToolTip;
      handler : WinUI3.Windows.UI.Xaml.RoutedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IToolTip.all.add_Opened (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Opened
   (
      this : in out ToolTip;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IToolTip.all.remove_Opened (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PlacementRect
   (
      this : in out ToolTip
   )
   return IReference_Rect.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IToolTip2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IReference_Rect.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToolTip_Interface, WinUI3.Windows.UI.Xaml.Controls.IToolTip2, WinUI3.Windows.UI.Xaml.Controls.IID_IToolTip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToolTip.all);
      Hr := m_Interface.get_PlacementRect (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IReference_Rect (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_PlacementRect
   (
      this : in out ToolTip;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IToolTip2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IToolTip_Interface, WinUI3.Windows.UI.Xaml.Controls.IToolTip2, WinUI3.Windows.UI.Xaml.Controls.IID_IToolTip2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IToolTip.all);
      Hr := m_Interface.put_PlacementRect (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for ToolTipService

   procedure Initialize (this : in out ToolTipService) is
   begin
      null;
   end;

   procedure Finalize (this : in out ToolTipService) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IToolTipService, IToolTipService_Ptr);
   begin
      if this.m_IToolTipService /= null then
         if this.m_IToolTipService.all /= null then
            temp := this.m_IToolTipService.all.Release;
            Free (this.m_IToolTipService);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for ToolTipService

   function get_PlacementProperty_ToolTipService
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetPlacement
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.Primitives.PlacementMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Primitives.PlacementMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetPlacement (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetPlacement
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Windows.UI.Xaml.Controls.Primitives.PlacementMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetPlacement (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_PlacementTargetProperty_ToolTipService
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PlacementTargetProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetPlacementTarget
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.UIElement is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.GetPlacementTarget (element.m_IDependencyObject.all, m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
            Retval.m_IUIElement.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   procedure SetPlacementTarget
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetPlacementTarget (element.m_IDependencyObject.all, value.m_IUIElement.all);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ToolTipProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ToolTipProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetToolTip
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetToolTip (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetToolTip
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.ToolTipService");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IToolTipServiceStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IToolTipServiceStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetToolTip (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for ToolTipService

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeView

   procedure Initialize (this : in out TreeView) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeView, ITreeView_Ptr);
   begin
      if this.m_ITreeView /= null then
         if this.m_ITreeView.all /= null then
            temp := this.m_ITreeView.all.Release;
            Free (this.m_ITreeView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory    : access ITreeViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeView;
   begin
      return RetVal : TreeView do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeView := new WinUI3.Windows.UI.Xaml.Controls.ITreeView;
            Retval.m_ITreeView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeView

   function get_SelectionModeProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SelectionModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanDragItemsProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanDragItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanReorderItemsProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanReorderItemsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemTemplateSelectorProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemTemplateSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerStyleSelectorProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerStyleSelectorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemContainerTransitionsProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemContainerTransitionsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsSourceProperty_TreeView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeView

   function get_RootNodes
   (
      this : in out TreeView
   )
   return IVector_ITreeViewNode.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_ITreeViewNode.Kind;
   begin
      Hr := this.m_ITreeView.all.get_RootNodes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_ITreeViewNode (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SelectionMode
   (
      this : in out TreeView
   )
   return WinUI3.Windows.UI.Xaml.Controls.TreeViewSelectionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.TreeViewSelectionMode;
   begin
      Hr := this.m_ITreeView.all.get_SelectionMode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_SelectionMode
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.Controls.TreeViewSelectionMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.put_SelectionMode (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_SelectedNodes
   (
      this : in out TreeView
   )
   return IVector_ITreeViewNode.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_ITreeViewNode.Kind;
   begin
      Hr := this.m_ITreeView.all.get_SelectedNodes (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_ITreeViewNode (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure Expand
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.Controls.TreeViewNode'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.Expand (value.m_ITreeViewNode.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Collapse
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.Controls.TreeViewNode'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.Collapse (value.m_ITreeViewNode.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SelectAll
   (
      this : in out TreeView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.SelectAll;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ItemInvoked
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITreeView.all.add_ItemInvoked (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ItemInvoked
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.remove_ItemInvoked (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Expanding
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITreeView.all.add_Expanding (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Expanding
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.remove_Expanding (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_Collapsed
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITreeView.all.add_Collapsed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_Collapsed
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeView.all.remove_Collapsed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function NodeFromContainer
   (
      this : in out TreeView;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.TreeViewNode do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.NodeFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function ContainerFromNode
   (
      this : in out TreeView;
      node : WinUI3.Windows.UI.Xaml.Controls.TreeViewNode'Class
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.ContainerFromNode (node.m_ITreeViewNode.all, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function ItemFromContainer
   (
      this : in out TreeView;
      container : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.ItemFromContainer (container.m_IDependencyObject.all, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ContainerFromItem
   (
      this : in out TreeView;
      item : WinUI3.IInspectable
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.ContainerFromItem (item, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   function get_CanDragItems
   (
      this : in out TreeView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_CanDragItems (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanDragItems
   (
      this : in out TreeView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_CanDragItems (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CanReorderItems
   (
      this : in out TreeView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_CanReorderItems (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CanReorderItems
   (
      this : in out TreeView;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_CanReorderItems (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplate
   (
      this : in out TreeView
   )
   return WinUI3.Windows.UI.Xaml.DataTemplate'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDataTemplate;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DataTemplate do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemTemplate (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplate := new WinUI3.Windows.UI.Xaml.IDataTemplate;
         Retval.m_IDataTemplate.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplate
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.DataTemplate'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemTemplate (value.m_IDataTemplate.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemTemplateSelector
   (
      this : in out TreeView
   )
   return WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemTemplateSelector (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataTemplateSelector := new WinUI3.Windows.UI.Xaml.Controls.IDataTemplateSelector;
         Retval.m_IDataTemplateSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemTemplateSelector
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.Controls.DataTemplateSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemTemplateSelector (value.m_IDataTemplateSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerStyle
   (
      this : in out TreeView
   )
   return WinUI3.Windows.UI.Xaml.Style'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IStyle;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Style do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemContainerStyle (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyle := new WinUI3.Windows.UI.Xaml.IStyle;
         Retval.m_IStyle.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyle
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.Style'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemContainerStyle (value.m_IStyle.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerStyleSelector
   (
      this : in out TreeView
   )
   return WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.StyleSelector do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemContainerStyleSelector (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IStyleSelector := new WinUI3.Windows.UI.Xaml.Controls.IStyleSelector;
         Retval.m_IStyleSelector.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerStyleSelector
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.Controls.StyleSelector'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemContainerStyleSelector (value.m_IStyleSelector.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemContainerTransitions
   (
      this : in out TreeView
   )
   return WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection do
         m_Interface := QInterface (this.m_ITreeView.all);
         Hr := m_Interface.get_ItemContainerTransitions (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_GenericObject := new WinUI3.GenericObject;
         Retval.m_GenericObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_ItemContainerTransitions
   (
      this : in out TreeView;
      value : WinUI3.Windows.UI.Xaml.Media.Animation.TransitionCollection'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemContainerTransitions (value.m_GenericObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsSource
   (
      this : in out TreeView
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.get_ItemsSource (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out TreeView;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.put_ItemsSource (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsStarting
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.add_DragItemsStarting (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsStarting
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.remove_DragItemsStarting (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DragItemsCompleted
   (
      this : in out TreeView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.add_DragItemsCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DragItemsCompleted
   (
      this : in out TreeView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeView_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeView2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeView.all);
      Hr := m_Interface.remove_DragItemsCompleted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewCollapsedEventArgs

   procedure Initialize (this : in out TreeViewCollapsedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewCollapsedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewCollapsedEventArgs, ITreeViewCollapsedEventArgs_Ptr);
   begin
      if this.m_ITreeViewCollapsedEventArgs /= null then
         if this.m_ITreeViewCollapsedEventArgs.all /= null then
            temp := this.m_ITreeViewCollapsedEventArgs.all.Release;
            Free (this.m_ITreeViewCollapsedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewCollapsedEventArgs

   function get_Node
   (
      this : in out TreeViewCollapsedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.TreeViewNode do
         Hr := this.m_ITreeViewCollapsedEventArgs.all.get_Node (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function get_Item
   (
      this : in out TreeViewCollapsedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeViewCollapsedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeViewCollapsedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewCollapsedEventArgs.all);
      Hr := m_Interface.get_Item (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewDragItemsCompletedEventArgs

   procedure Initialize (this : in out TreeViewDragItemsCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewDragItemsCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewDragItemsCompletedEventArgs, ITreeViewDragItemsCompletedEventArgs_Ptr);
   begin
      if this.m_ITreeViewDragItemsCompletedEventArgs /= null then
         if this.m_ITreeViewDragItemsCompletedEventArgs.all /= null then
            temp := this.m_ITreeViewDragItemsCompletedEventArgs.all.Release;
            Free (this.m_ITreeViewDragItemsCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewDragItemsCompletedEventArgs

   function get_DropResult
   (
      this : in out TreeViewDragItemsCompletedEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.DataPackageOperation;
   begin
      Hr := this.m_ITreeViewDragItemsCompletedEventArgs.all.get_DropResult (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Items
   (
      this : in out TreeViewDragItemsCompletedEventArgs
   )
   return IVectorView_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVectorView_IInspectable.Kind;
   begin
      Hr := this.m_ITreeViewDragItemsCompletedEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVectorView_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewDragItemsStartingEventArgs

   procedure Initialize (this : in out TreeViewDragItemsStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewDragItemsStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewDragItemsStartingEventArgs, ITreeViewDragItemsStartingEventArgs_Ptr);
   begin
      if this.m_ITreeViewDragItemsStartingEventArgs /= null then
         if this.m_ITreeViewDragItemsStartingEventArgs.all /= null then
            temp := this.m_ITreeViewDragItemsStartingEventArgs.all.Release;
            Free (this.m_ITreeViewDragItemsStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewDragItemsStartingEventArgs

   function get_Cancel
   (
      this : in out TreeViewDragItemsStartingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out TreeViewDragItemsStartingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Data
   (
      this : in out TreeViewDragItemsStartingEventArgs
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.get_Data (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   function get_Items
   (
      this : in out TreeViewDragItemsStartingEventArgs
   )
   return IVector_IInspectable.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IInspectable.Kind;
   begin
      Hr := this.m_ITreeViewDragItemsStartingEventArgs.all.get_Items (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IInspectable (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewExpandingEventArgs

   procedure Initialize (this : in out TreeViewExpandingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewExpandingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewExpandingEventArgs, ITreeViewExpandingEventArgs_Ptr);
   begin
      if this.m_ITreeViewExpandingEventArgs /= null then
         if this.m_ITreeViewExpandingEventArgs.all /= null then
            temp := this.m_ITreeViewExpandingEventArgs.all.Release;
            Free (this.m_ITreeViewExpandingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewExpandingEventArgs

   function get_Node
   (
      this : in out TreeViewExpandingEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.TreeViewNode do
         Hr := this.m_ITreeViewExpandingEventArgs.all.get_Node (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function get_Item
   (
      this : in out TreeViewExpandingEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeViewExpandingEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeViewExpandingEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewExpandingEventArgs.all);
      Hr := m_Interface.get_Item (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewItem

   procedure Initialize (this : in out TreeViewItem) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewItem) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewItem, ITreeViewItem_Ptr);
   begin
      if this.m_ITreeViewItem /= null then
         if this.m_ITreeViewItem.all /= null then
            temp := this.m_ITreeViewItem.all.Release;
            Free (this.m_ITreeViewItem);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewItem

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewItem is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory    : access ITreeViewItemFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem;
   begin
      return RetVal : TreeViewItem do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewItem := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem;
            Retval.m_ITreeViewItem.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeViewItem

   function get_GlyphOpacityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphOpacityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlyphBrushProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphBrushProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ExpandedGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExpandedGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CollapsedGlyphProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CollapsedGlyphProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_GlyphSizeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_GlyphSizeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsExpandedProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExpandedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TreeViewItemTemplateSettingsProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TreeViewItemTemplateSettingsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasUnrealizedChildrenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasUnrealizedChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemsSourceProperty_TreeViewItem
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItem");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemsSourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewItem

   function get_GlyphOpacity
   (
      this : in out TreeViewItem
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITreeViewItem.all.get_GlyphOpacity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlyphOpacity
   (
      this : in out TreeViewItem;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_GlyphOpacity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_GlyphBrush
   (
      this : in out TreeViewItem
   )
   return WinUI3.Windows.UI.Xaml.Media.Brush'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.IBrush;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Media.Brush do
         Hr := this.m_ITreeViewItem.all.get_GlyphBrush (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IBrush := new WinUI3.Windows.UI.Xaml.Media.IBrush;
         Retval.m_IBrush.all := m_ComRetVal;
      end return;
   end;

   procedure put_GlyphBrush
   (
      this : in out TreeViewItem;
      value : WinUI3.Windows.UI.Xaml.Media.Brush'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_GlyphBrush (value.m_IBrush.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExpandedGlyph
   (
      this : in out TreeViewItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITreeViewItem.all.get_ExpandedGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_ExpandedGlyph
   (
      this : in out TreeViewItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITreeViewItem.all.put_ExpandedGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_CollapsedGlyph
   (
      this : in out TreeViewItem
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITreeViewItem.all.get_CollapsedGlyph (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_CollapsedGlyph
   (
      this : in out TreeViewItem;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITreeViewItem.all.put_CollapsedGlyph (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_GlyphSize
   (
      this : in out TreeViewItem
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITreeViewItem.all.get_GlyphSize (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_GlyphSize
   (
      this : in out TreeViewItem;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_GlyphSize (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsExpanded
   (
      this : in out TreeViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewItem.all.get_IsExpanded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExpanded
   (
      this : in out TreeViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItem.all.put_IsExpanded (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TreeViewItemTemplateSettings
   (
      this : in out TreeViewItem
   )
   return WinUI3.Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings do
         Hr := this.m_ITreeViewItem.all.get_TreeViewItemTemplateSettings (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewItemTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
         Retval.m_ITreeViewItemTemplateSettings.all := m_ComRetVal;
      end return;
   end;

   function get_HasUnrealizedChildren
   (
      this : in out TreeViewItem
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.get_HasUnrealizedChildren (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HasUnrealizedChildren
   (
      this : in out TreeViewItem;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.put_HasUnrealizedChildren (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemsSource
   (
      this : in out TreeViewItem
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.get_ItemsSource (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemsSource
   (
      this : in out TreeViewItem;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem_Interface, WinUI3.Windows.UI.Xaml.Controls.ITreeViewItem2, WinUI3.Windows.UI.Xaml.Controls.IID_ITreeViewItem2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITreeViewItem.all);
      Hr := m_Interface.put_ItemsSource (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewItemInvokedEventArgs

   procedure Initialize (this : in out TreeViewItemInvokedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewItemInvokedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewItemInvokedEventArgs, ITreeViewItemInvokedEventArgs_Ptr);
   begin
      if this.m_ITreeViewItemInvokedEventArgs /= null then
         if this.m_ITreeViewItemInvokedEventArgs.all /= null then
            temp := this.m_ITreeViewItemInvokedEventArgs.all.Release;
            Free (this.m_ITreeViewItemInvokedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewItemInvokedEventArgs

   function get_InvokedItem
   (
      this : in out TreeViewItemInvokedEventArgs
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITreeViewItemInvokedEventArgs.all.get_InvokedItem (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out TreeViewItemInvokedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewItemInvokedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Handled
   (
      this : in out TreeViewItemInvokedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewItemInvokedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewItemTemplateSettings

   procedure Initialize (this : in out TreeViewItemTemplateSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewItemTemplateSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewItemTemplateSettings, ITreeViewItemTemplateSettings_Ptr);
   begin
      if this.m_ITreeViewItemTemplateSettings /= null then
         if this.m_ITreeViewItemTemplateSettings.all /= null then
            temp := this.m_ITreeViewItemTemplateSettings.all.Release;
            Free (this.m_ITreeViewItemTemplateSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewItemTemplateSettings

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewItemTemplateSettings is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory    : access ITreeViewItemTemplateSettingsFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
   begin
      return RetVal : TreeViewItemTemplateSettings do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewItemTemplateSettings := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettings;
            Retval.m_ITreeViewItemTemplateSettings.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeViewItemTemplateSettings

   function get_ExpandedGlyphVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ExpandedGlyphVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CollapsedGlyphVisibilityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CollapsedGlyphVisibilityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IndentationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IndentationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DragItemsCountProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewItemTemplateSettings");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewItemTemplateSettingsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewItemTemplateSettingsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DragItemsCountProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewItemTemplateSettings

   function get_ExpandedGlyphVisibility
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_ExpandedGlyphVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CollapsedGlyphVisibility
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Visibility is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Visibility;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_CollapsedGlyphVisibility (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Indentation
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Windows.UI.Xaml.Thickness is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Thickness;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_Indentation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DragItemsCount
   (
      this : in out TreeViewItemTemplateSettings
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITreeViewItemTemplateSettings.all.get_DragItemsCount (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewList

   procedure Initialize (this : in out TreeViewList) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewList) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewList, ITreeViewList_Ptr);
   begin
      if this.m_ITreeViewList /= null then
         if this.m_ITreeViewList.all /= null then
            temp := this.m_ITreeViewList.all.Release;
            Free (this.m_ITreeViewList);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewList

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewList is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewList");
      m_Factory    : access ITreeViewListFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewList;
   begin
      return RetVal : TreeViewList do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewListFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewList := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewList;
            Retval.m_ITreeViewList.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewList

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TreeViewNode

   procedure Initialize (this : in out TreeViewNode) is
   begin
      null;
   end;

   procedure Finalize (this : in out TreeViewNode) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITreeViewNode, ITreeViewNode_Ptr);
   begin
      if this.m_ITreeViewNode /= null then
         if this.m_ITreeViewNode.all /= null then
            temp := this.m_ITreeViewNode.all.Release;
            Free (this.m_ITreeViewNode);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TreeViewNode

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TreeViewNode is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewNode");
      m_Factory    : access ITreeViewNodeFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : TreeViewNode do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITreeViewNode := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
            Retval.m_ITreeViewNode.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TreeViewNode

   function get_ContentProperty_TreeViewNode
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DepthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DepthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_IsExpandedProperty_TreeViewNode
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsExpandedProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HasChildrenProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TreeViewNode");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITreeViewNodeStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITreeViewNodeStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HasChildrenProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TreeViewNode

   function get_Content
   (
      this : in out TreeViewNode
   )
   return WinUI3.IInspectable is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.IInspectable;
   begin
      Hr := this.m_ITreeViewNode.all.get_Content (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Content
   (
      this : in out TreeViewNode;
      value : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewNode.all.put_Content (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Parent
   (
      this : in out TreeViewNode
   )
   return WinUI3.Windows.UI.Xaml.Controls.TreeViewNode'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.TreeViewNode do
         Hr := this.m_ITreeViewNode.all.get_Parent (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_ITreeViewNode := new WinUI3.Windows.UI.Xaml.Controls.ITreeViewNode;
         Retval.m_ITreeViewNode.all := m_ComRetVal;
      end return;
   end;

   function get_IsExpanded
   (
      this : in out TreeViewNode
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewNode.all.get_IsExpanded (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsExpanded
   (
      this : in out TreeViewNode;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewNode.all.put_IsExpanded (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HasChildren
   (
      this : in out TreeViewNode
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewNode.all.get_HasChildren (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Depth
   (
      this : in out TreeViewNode
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITreeViewNode.all.get_Depth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_HasUnrealizedChildren
   (
      this : in out TreeViewNode
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITreeViewNode.all.get_HasUnrealizedChildren (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HasUnrealizedChildren
   (
      this : in out TreeViewNode;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITreeViewNode.all.put_HasUnrealizedChildren (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Children
   (
      this : in out TreeViewNode
   )
   return IVector_ITreeViewNode.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_ITreeViewNode.Kind;
   begin
      Hr := this.m_ITreeViewNode.all.get_Children (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_ITreeViewNode (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for TwoPaneView

   procedure Initialize (this : in out TwoPaneView) is
   begin
      null;
   end;

   procedure Finalize (this : in out TwoPaneView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITwoPaneView, ITwoPaneView_Ptr);
   begin
      if this.m_ITwoPaneView /= null then
         if this.m_ITwoPaneView.all /= null then
            temp := this.m_ITwoPaneView.all.Release;
            Free (this.m_ITwoPaneView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for TwoPaneView

   function Constructor
   (
      baseInterface : WinUI3.IInspectable;
      innerInterface : access WinUI3.IInspectable
   )
   return TwoPaneView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory    : access ITwoPaneViewFactory_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.ITwoPaneView;
   begin
      return RetVal : TwoPaneView do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewFactory'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstance (baseInterface, innerInterface, m_ComRetVal'Access);
            Retval.m_ITwoPaneView := new WinUI3.Windows.UI.Xaml.Controls.ITwoPaneView;
            Retval.m_ITwoPaneView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for TwoPaneView

   function get_Pane1Property
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane1Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Pane2Property
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane2Property (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Pane1LengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane1LengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_Pane2LengthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_Pane2LengthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_PanePriorityProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_PanePriorityProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ModeProperty_TwoPaneView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_WideModeConfigurationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_WideModeConfigurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_TallModeConfigurationProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_TallModeConfigurationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinWideModeWidthProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinWideModeWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MinTallModeHeightProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.TwoPaneView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.ITwoPaneViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_ITwoPaneViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinTallModeHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for TwoPaneView

   function get_Pane1
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_ITwoPaneView.all.get_Pane1 (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Pane1
   (
      this : in out TwoPaneView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane1 (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane2
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_ITwoPaneView.all.get_Pane2 (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Pane2
   (
      this : in out TwoPaneView;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane2 (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane1Length
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.GridLength;
   begin
      Hr := this.m_ITwoPaneView.all.get_Pane1Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Pane1Length
   (
      this : in out TwoPaneView;
      value : WinUI3.Windows.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane1Length (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Pane2Length
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.GridLength is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.GridLength;
   begin
      Hr := this.m_ITwoPaneView.all.get_Pane2Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Pane2Length
   (
      this : in out TwoPaneView;
      value : WinUI3.Windows.UI.Xaml.GridLength
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_Pane2Length (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_PanePriority
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewPriority is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewPriority;
   begin
      Hr := this.m_ITwoPaneView.all.get_PanePriority (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_PanePriority
   (
      this : in out TwoPaneView;
      value : WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewPriority
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_PanePriority (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Mode
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewMode;
   begin
      Hr := this.m_ITwoPaneView.all.get_Mode (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WideModeConfiguration
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewWideModeConfiguration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewWideModeConfiguration;
   begin
      Hr := this.m_ITwoPaneView.all.get_WideModeConfiguration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_WideModeConfiguration
   (
      this : in out TwoPaneView;
      value : WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewWideModeConfiguration
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_WideModeConfiguration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_TallModeConfiguration
   (
      this : in out TwoPaneView
   )
   return WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewTallModeConfiguration is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewTallModeConfiguration;
   begin
      Hr := this.m_ITwoPaneView.all.get_TallModeConfiguration (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_TallModeConfiguration
   (
      this : in out TwoPaneView;
      value : WinUI3.Windows.UI.Xaml.Controls.TwoPaneViewTallModeConfiguration
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_TallModeConfiguration (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinWideModeWidth
   (
      this : in out TwoPaneView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITwoPaneView.all.get_MinWideModeWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinWideModeWidth
   (
      this : in out TwoPaneView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_MinWideModeWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MinTallModeHeight
   (
      this : in out TwoPaneView
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_ITwoPaneView.all.get_MinTallModeHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MinTallModeHeight
   (
      this : in out TwoPaneView;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.put_MinTallModeHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ModeChanged
   (
      this : in out TwoPaneView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_ITwoPaneView.all.add_ModeChanged (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ModeChanged
   (
      this : in out TwoPaneView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITwoPaneView.all.remove_ModeChanged (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for UIElementCollection

   procedure Initialize (this : in out UIElementCollection) is
   begin
      null;
   end;

   procedure Finalize (this : in out UIElementCollection) is
   begin
      null;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for UIElementCollection

   procedure Move
   (
      this : in out UIElementCollection;
      oldIndex : WinUI3.UInt32;
      newIndex : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IUIElementCollection := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, WinUI3.Windows.UI.Xaml.Controls.IUIElementCollection, WinUI3.Windows.UI.Xaml.Controls.IID_IUIElementCollection'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Move (oldIndex, newIndex);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IVector`1<Windows.UI.Xaml.UIElement>
   function GetAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetAt (index, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function get_Size
   (
      this : in out UIElementCollection
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.get_Size (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetView
   (
      this : in out UIElementCollection
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.GetView (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   function IndexOf
   (
      this : in out UIElementCollection;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class;
      index : WinUI3.UInt32_Ptr
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.IndexOf (value.m_IUIElement.all, index, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.SetAt (index, value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure InsertAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.InsertAt (index, value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAt
   (
      this : in out UIElementCollection;
      index : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAt (index);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Append
   (
      this : in out UIElementCollection;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Append (value.m_IUIElement.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure RemoveAtEnd
   (
      this : in out UIElementCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.RemoveAtEnd;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Clear
   (
      this : in out UIElementCollection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.Clear;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMany
   (
      this : in out UIElementCollection;
      startIndex : WinUI3.UInt32;
      items : WinUI3.Windows.UI.Xaml.IUIElement_Array
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.GetMany (startIndex, WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address), m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ReplaceAll
   (
      this : in out UIElementCollection;
      items : WinUI3.Windows.UI.Xaml.IUIElement_Array
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IVector_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_GenericIID     : aliased WinUI3.IID := (3032605612, 34664, 23453, (166, 97, 246, 51, 48, 184, 80, 123 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IVector_IUIElement.Kind, m_GenericIID'Unchecked_Access);
      function Convert_items is new Ada.Unchecked_Conversion (Address, WinUI3.GenericObject_Ptr);
   begin
      m_Interface := QInterface (this.m_GenericObject.all);
      Hr := m_Interface.ReplaceAll (WinUI3.UInt32(items'Length), Convert_items (items (items'First)'Address));
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -- Generic Interface Windows.Foundation.Collections.IIterable`1<Windows.UI.Xaml.UIElement>
   function First
   (
      this : in out UIElementCollection
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : IIterable_IUIElement.Kind := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
      m_GenericIID     : aliased WinUI3.IID := (1122134753, 54103, 22504, (187, 72, 247, 92, 159, 246, 157, 145 ));
      function QInterface is new Generic_QueryInterface (WinUI3.GenericObject_Interface, IIterable_IUIElement.Kind, m_GenericIID'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         m_Interface := QInterface (this.m_GenericObject.all);
         Hr := m_Interface.First (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VariableSizedWrapGrid

   procedure Initialize (this : in out VariableSizedWrapGrid) is
   begin
      null;
   end;

   procedure Finalize (this : in out VariableSizedWrapGrid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVariableSizedWrapGrid, IVariableSizedWrapGrid_Ptr);
   begin
      if this.m_IVariableSizedWrapGrid /= null then
         if this.m_IVariableSizedWrapGrid.all /= null then
            temp := this.m_IVariableSizedWrapGrid.all.Release;
            Free (this.m_IVariableSizedWrapGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VariableSizedWrapGrid

   function Constructor return VariableSizedWrapGrid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGrid;
   begin
      return RetVal : VariableSizedWrapGrid do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IVariableSizedWrapGrid := new WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGrid;
            Retval.m_IVariableSizedWrapGrid.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for VariableSizedWrapGrid

   function get_ItemHeightProperty_VariableSizedWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemWidthProperty_VariableSizedWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_VariableSizedWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalChildrenAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalChildrenAlignmentProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumRowsOrColumnsProperty_VariableSizedWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumRowsOrColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_RowSpanProperty_VariableSizedWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_RowSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetRowSpan
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetRowSpan (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetRowSpan
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetRowSpan (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_ColumnSpanProperty_VariableSizedWrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ColumnSpanProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetColumnSpan
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetColumnSpan (element.m_IUIElement.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetColumnSpan
   (
      element : WinUI3.Windows.UI.Xaml.UIElement'Class;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VariableSizedWrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVariableSizedWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVariableSizedWrapGridStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetColumnSpan (element.m_IUIElement.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VariableSizedWrapGrid

   function get_ItemHeight
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_ItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemHeight
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_ItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemWidth
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_ItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemWidth
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_ItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Windows.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_HorizontalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Windows.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_HorizontalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Windows.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_VerticalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalChildrenAlignment
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Windows.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_VerticalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaximumRowsOrColumns
   (
      this : in out VariableSizedWrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.get_MaximumRowsOrColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaximumRowsOrColumns
   (
      this : in out VariableSizedWrapGrid;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVariableSizedWrapGrid.all.put_MaximumRowsOrColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for Viewbox

   procedure Initialize (this : in out Viewbox) is
   begin
      null;
   end;

   procedure Finalize (this : in out Viewbox) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IViewbox, IViewbox_Ptr);
   begin
      if this.m_IViewbox /= null then
         if this.m_IViewbox.all /= null then
            temp := this.m_IViewbox.all.Release;
            Free (this.m_IViewbox);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for Viewbox

   function Constructor return Viewbox is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Viewbox");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IViewbox;
   begin
      return RetVal : Viewbox do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IViewbox := new WinUI3.Windows.UI.Xaml.Controls.IViewbox;
            Retval.m_IViewbox.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for Viewbox

   function get_StretchProperty_Viewbox
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Viewbox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IViewboxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IViewboxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_StretchDirectionProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.Viewbox");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IViewboxStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IViewboxStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_StretchDirectionProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for Viewbox

   function get_Child
   (
      this : in out Viewbox
   )
   return WinUI3.Windows.UI.Xaml.UIElement'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IUIElement;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.UIElement do
         Hr := this.m_IViewbox.all.get_Child (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUIElement := new WinUI3.Windows.UI.Xaml.IUIElement;
         Retval.m_IUIElement.all := m_ComRetVal;
      end return;
   end;

   procedure put_Child
   (
      this : in out Viewbox;
      value : WinUI3.Windows.UI.Xaml.UIElement'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IViewbox.all.put_Child (value.m_IUIElement.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Stretch
   (
      this : in out Viewbox
   )
   return WinUI3.Windows.UI.Xaml.Media.Stretch is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Media.Stretch;
   begin
      Hr := this.m_IViewbox.all.get_Stretch (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Stretch
   (
      this : in out Viewbox;
      value : WinUI3.Windows.UI.Xaml.Media.Stretch
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IViewbox.all.put_Stretch (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StretchDirection
   (
      this : in out Viewbox
   )
   return WinUI3.Windows.UI.Xaml.Controls.StretchDirection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.StretchDirection;
   begin
      Hr := this.m_IViewbox.all.get_StretchDirection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StretchDirection
   (
      this : in out Viewbox;
      value : WinUI3.Windows.UI.Xaml.Controls.StretchDirection
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IViewbox.all.put_StretchDirection (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for VirtualizingStackPanel

   procedure Initialize (this : in out VirtualizingStackPanel) is
   begin
      null;
   end;

   procedure Finalize (this : in out VirtualizingStackPanel) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IVirtualizingStackPanel, IVirtualizingStackPanel_Ptr);
   begin
      if this.m_IVirtualizingStackPanel /= null then
         if this.m_IVirtualizingStackPanel.all /= null then
            temp := this.m_IVirtualizingStackPanel.all.Release;
            Free (this.m_IVirtualizingStackPanel);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for VirtualizingStackPanel

   function Constructor return VirtualizingStackPanel is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanel;
   begin
      return RetVal : VirtualizingStackPanel do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IVirtualizingStackPanel := new WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanel;
            Retval.m_IVirtualizingStackPanel.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for VirtualizingStackPanel

   function get_AreScrollSnapPointsRegularProperty_VirtualizingStackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AreScrollSnapPointsRegularProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_VirtualizingStackPanel
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VirtualizationModeProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VirtualizationModeProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetVirtualizationMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Windows.UI.Xaml.Controls.VirtualizationMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.VirtualizationMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetVirtualizationMode (element.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure SetVirtualizationMode
   (
      element : WinUI3.Windows.UI.Xaml.DependencyObject'Class;
      value : WinUI3.Windows.UI.Xaml.Controls.VirtualizationMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.SetVirtualizationMode (element.m_IDependencyObject.all, value);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_IsVirtualizingProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_IsVirtualizingProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function GetIsVirtualizing
   (
      o : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.VirtualizingStackPanel");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IVirtualizingStackPanelStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.GetIsVirtualizing (o.m_IDependencyObject.all, m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for VirtualizingStackPanel

   function get_AreScrollSnapPointsRegular
   (
      this : in out VirtualizingStackPanel
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.get_AreScrollSnapPointsRegular (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AreScrollSnapPointsRegular
   (
      this : in out VirtualizingStackPanel;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.put_AreScrollSnapPointsRegular (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out VirtualizingStackPanel
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out VirtualizingStackPanel;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_CleanUpVirtualizedItemEvent
   (
      this : in out VirtualizingStackPanel;
      handler : WinUI3.Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.add_CleanUpVirtualizedItemEvent (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_CleanUpVirtualizedItemEvent
   (
      this : in out VirtualizingStackPanel;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IVirtualizingStackPanel.all.remove_CleanUpVirtualizedItemEvent (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure OnCleanUpVirtualizedItem
   (
      this : in out VirtualizingStackPanel;
      e : WinUI3.Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventArgs'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelOverrides := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanel_Interface, WinUI3.Windows.UI.Xaml.Controls.IVirtualizingStackPanelOverrides, WinUI3.Windows.UI.Xaml.Controls.IID_IVirtualizingStackPanelOverrides'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IVirtualizingStackPanel.all);
      Hr := m_Interface.OnCleanUpVirtualizedItem (e.m_ICleanUpVirtualizedItemEventArgs.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebView

   procedure Initialize (this : in out WebView) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebView) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebView, IWebView_Ptr);
   begin
      if this.m_IWebView /= null then
         if this.m_IWebView.all /= null then
            temp := this.m_IWebView.all.Release;
            Free (this.m_IWebView);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for WebView

   function Constructor
   (
      executionMode : WinUI3.Windows.UI.Xaml.Controls.WebViewExecutionMode
   )
   return WebView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory    : access IWebViewFactory4_Interface'Class := null;
      temp         : WinUI3.UInt32 := 0;
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IWebView;
   begin
      return RetVal : WebView do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewFactory4'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.CreateInstanceWithExecutionMode (executionMode, m_ComRetVal'Access);
            Retval.m_IWebView := new WinUI3.Windows.UI.Xaml.Controls.IWebView;
            Retval.m_IWebView.all := m_ComRetVal;
            temp := m_Factory.Release;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function Constructor return WebView is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IWebView;
   begin
      return RetVal : WebView do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IWebView := new WinUI3.Windows.UI.Xaml.Controls.IWebView;
            Retval.m_IWebView.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for WebView

   function get_DefaultExecutionMode
   return WinUI3.Windows.UI.Xaml.Controls.WebViewExecutionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.WebViewExecutionMode;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_DefaultExecutionMode (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   procedure ClearTemporaryWebDataAsync is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics4_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

   begin
      Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics4'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.ClearTemporaryWebDataAsync (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr = S_OK then
            m_Captured := m_Completed;
            Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            temp := m_ComRetVal.Release;
            temp := m_CompletedHandler.Release;
            if temp = 0 then
               Free (m_CompletedHandler);
            end if;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
   end;

   function get_AnyScriptNotifyUri
   return IVector_IUriRuntimeClass.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IUriRuntimeClass.Kind;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_AnyScriptNotifyUri (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      m_GenericRetVal := QInterface_IVector_IUriRuntimeClass (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_SourceProperty_WebView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_AllowedScriptNotifyUrisProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AllowedScriptNotifyUrisProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DataTransferPackageProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DataTransferPackageProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ContainsFullScreenElementProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics3_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics3'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ContainsFullScreenElementProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusLeftProperty_WebView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusLeftProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusRightProperty_WebView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusRightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusUpProperty_WebView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusUpProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_XYFocusDownProperty_WebView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics5_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics5'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_XYFocusDownProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoBackProperty_WebView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoBackProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_CanGoForwardProperty_WebView
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_CanGoForwardProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DocumentTitleProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DocumentTitleProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_DefaultBackgroundColorProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebView");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewStatics2_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewStatics2'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_DefaultBackgroundColorProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebView

   function get_Source
   (
      this : in out WebView
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebView.all.get_Source (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   procedure put_Source
   (
      this : in out WebView;
      value : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView.all.put_Source (value.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AllowedScriptNotifyUris
   (
      this : in out WebView
   )
   return IVector_IUriRuntimeClass.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IUriRuntimeClass.Kind;
   begin
      Hr := this.m_IWebView.all.get_AllowedScriptNotifyUris (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IUriRuntimeClass (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   procedure put_AllowedScriptNotifyUris
   (
      this : in out WebView;
      value : GenericObject
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView.all.put_AllowedScriptNotifyUris (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DataTransferPackage
   (
      this : in out WebView
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         Hr := this.m_IWebView.all.get_DataTransferPackage (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
         Retval.m_IDataPackage.all := m_ComRetVal;
      end return;
   end;

   function add_LoadCompleted
   (
      this : in out WebView;
      handler : WinUI3.Windows.UI.Xaml.Navigation.LoadCompletedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView.all.add_LoadCompleted (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LoadCompleted
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView.all.remove_LoadCompleted (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ScriptNotify
   (
      this : in out WebView;
      handler : WinUI3.Windows.UI.Xaml.Controls.NotifyEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView.all.add_ScriptNotify (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ScriptNotify
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView.all.remove_ScriptNotify (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationFailed
   (
      this : in out WebView;
      handler : WinUI3.Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
   begin
      Hr := this.m_IWebView.all.add_NavigationFailed (handler, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationFailed
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView.all.remove_NavigationFailed (token);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function InvokeScript
   (
      this : in out WebView;
      scriptName : WinUI3.WString;
      arguments : WinUI3.HString_Array
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      HStr_scriptName : constant WinUI3.HString := To_HString (scriptName);
      function Convert_arguments is new Ada.Unchecked_Conversion (Address, WinUI3.HString_Ptr);
   begin
      Hr := this.m_IWebView.all.InvokeScript (HStr_scriptName, WinUI3.UInt32(arguments'Length), Convert_arguments (arguments (arguments'First)'Address), m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_scriptName);
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure Navigate
   (
      this : in out WebView;
      source : WinUI3.Windows.Foundation.Uri'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebView.all.Navigate (source.m_IUriRuntimeClass.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure NavigateToString
   (
      this : in out WebView;
      text : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_text : constant WinUI3.HString := To_HString (text);
   begin
      Hr := this.m_IWebView.all.NavigateToString (HStr_text);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_text);
   end;

   function get_CanGoBack
   (
      this : in out WebView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.get_CanGoBack (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_CanGoForward
   (
      this : in out WebView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.get_CanGoForward (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DocumentTitle
   (
      this : in out WebView
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.get_DocumentTitle (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   function add_NavigationStarting
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_NavigationStarting (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationStarting
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_NavigationStarting (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_ContentLoading
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_ContentLoading (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContentLoading
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_ContentLoading (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_DOMContentLoaded
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_DOMContentLoaded (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_DOMContentLoaded
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_DOMContentLoaded (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoForward
   (
      this : in out WebView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.GoForward;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GoBack
   (
      this : in out WebView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.GoBack;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Refresh
   (
      this : in out WebView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.Refresh;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Stop
   (
      this : in out WebView
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.Stop;
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure CapturePreviewToStreamAsync
   (
      this : in out WebView;
      stream : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IAsyncAction := null;

      procedure IAsyncAction_Callback (asyncInfo : WinUI3.Windows.Foundation.IAsyncAction; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
      begin
         if asyncStatus = Completed_e then
            Hr := asyncInfo.GetResults;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      m_CompletedHandler : WinUI3.Windows.Foundation.AsyncActionCompletedHandler := new WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate'(IAsyncAction_Callback'Access, 1, null);
      procedure Free is new Ada.Unchecked_Deallocation (WinUI3.Windows.Foundation.AsyncActionCompletedHandler_Delegate, WinUI3.Windows.Foundation.AsyncActionCompletedHandler);

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.CapturePreviewToStreamAsync (stream, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_Captured := m_Completed;
         Hr := m_ComRetVal.Put_Completed (m_CompletedHandler);
         while m_Captured = m_Compare loop
            m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
            m_Captured := m_Completed;
         end loop;
         temp := m_ComRetVal.Release;
         temp := m_CompletedHandler.Release;
         if temp = 0 then
            Free (m_CompletedHandler);
         end if;
      end if;
   end;

   function InvokeScriptAsync
   (
      this : in out WebView;
      scriptName : WinUI3.WString;
      arguments : GenericObject
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_scriptName : constant WinUI3.HString := To_HString (scriptName);
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_HString.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_HString.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.HString;
      AdaRetval        : WString;
      m_IID            : aliased WinUI3.IID := (1042277891, 63639, 21091, (179, 40, 8, 6, 66, 107, 138, 121 )); -- HString;
      m_HandlerIID     : aliased WinUI3.IID := (3080352799, 32693, 20654, (158, 153, 145, 18, 1, 236, 61, 65 ));
      m_Handler        : AsyncOperationCompletedHandler_HString.Kind := new AsyncOperationCompletedHandler_HString.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_HString.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_HString.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_HString.Kind_Delegate, AsyncOperationCompletedHandler_HString.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.InvokeScriptAsync (HStr_scriptName, arguments, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr = S_OK then
         m_AsyncOperation := QI (m_ComRetVal);
         temp := m_ComRetVal.Release;
         if m_AsyncOperation /= null then
            Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
            while m_Captured = m_Compare loop
               m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
               m_Captured := m_Completed;
            end loop;
            if m_AsyncStatus = Completed_e then
               Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
            end if;
            temp := m_AsyncOperation.Release;
            temp := m_Handler.Release;
            if temp = 0 then
               Free (m_Handler);
            end if;
         end if;
      end if;
      tmp := WindowsDeleteString (HStr_scriptName);
      AdaRetval := To_Ada (m_RetVal);
      tmp := WindowsDeleteString (m_RetVal);
      return AdaRetVal;
   end;

   function CaptureSelectedContentToDataPackageAsync
   (
      this : in out WebView
   )
   return WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_Temp           : WinUI3.Int32 := 0;
      m_Completed      : WinUI3.UInt32 := 0;
      m_Captured       : WinUI3.UInt32 := 0;
      m_Compare        : constant WinUI3.UInt32 := 0;

      use type IAsyncOperation_DataPackage.Kind;

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus);

      m_AsyncOperation : aliased IAsyncOperation_DataPackage.Kind;
      m_AsyncStatus    : aliased WinUI3.Windows.Foundation.AsyncStatus;
      m_ComRetVal      : aliased WinUI3.GenericObject := null;
      m_RetVal         : aliased WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
      m_IID            : aliased WinUI3.IID := (2708417799, 60115, 21476, (148, 144, 117, 189, 186, 235, 122, 91 )); -- Windows.ApplicationModel.DataTransfer.DataPackage;
      m_HandlerIID     : aliased WinUI3.IID := (2839165849, 59718, 22478, (170, 217, 194, 61, 19, 140, 53, 62 ));
      m_Handler        : AsyncOperationCompletedHandler_DataPackage.Kind := new AsyncOperationCompletedHandler_DataPackage.Kind_Delegate'(IAsyncOperation_Callback'Access, 1, m_HandlerIID'Unchecked_Access);

      function QI is new Generic_QueryInterface (GenericObject_Interface, IAsyncOperation_DataPackage.Kind, m_IID'Unchecked_Access);
      function Convert is new Ada.Unchecked_Conversion (AsyncOperationCompletedHandler_DataPackage.Kind, GenericObject);
      procedure Free is new Ada.Unchecked_Deallocation (AsyncOperationCompletedHandler_DataPackage.Kind_Delegate, AsyncOperationCompletedHandler_DataPackage.Kind);

      procedure IAsyncOperation_Callback (asyncInfo : WinUI3.GenericObject; asyncStatus: WinUI3.Windows.Foundation.AsyncStatus) is
         pragma unreferenced (asyncInfo);
      begin
         if asyncStatus = Completed_e then
            m_AsyncStatus := AsyncStatus;
         end if;
         m_Completed := 1;
         WakeByAddressSingle (m_Completed'Address);
      end;

      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.ApplicationModel.DataTransfer.DataPackage do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.CaptureSelectedContentToDataPackageAsync (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr = S_OK then
            m_AsyncOperation := QI (m_ComRetVal);
            temp := m_ComRetVal.Release;
            if m_AsyncOperation /= null then
               Hr := m_AsyncOperation.Put_Completed (Convert (m_Handler));
               while m_Captured = m_Compare loop
                  m_Temp := WaitOnAddress (m_Completed'Address, m_Compare'Address, 4, 4294967295);
                  m_Captured := m_Completed;
               end loop;
               if m_AsyncStatus = Completed_e then
                  Hr := m_AsyncOperation.GetResults (m_RetVal'Access);
                  Retval.m_IDataPackage := new WinUI3.Windows.ApplicationModel.DataTransfer.IDataPackage;
                  Retval.m_IDataPackage.all := m_RetVal;
               end if;
               temp := m_AsyncOperation.Release;
               temp := m_Handler.Release;
               if temp = 0 then
                  Free (m_Handler);
               end if;
            end if;
         end if;
      end return;
   end;

   procedure NavigateToLocalStreamUri
   (
      this : in out WebView;
      source : WinUI3.Windows.Foundation.Uri'Class;
      streamResolver : WinUI3.Windows.Web.IUriToStreamResolver
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.NavigateToLocalStreamUri (source.m_IUriRuntimeClass.all, streamResolver);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function BuildLocalStreamUri
   (
      this : in out WebView;
      contentIdentifier : WinUI3.WString;
      relativePath : WinUI3.WString
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
      HStr_contentIdentifier : constant WinUI3.HString := To_HString (contentIdentifier);
      HStr_relativePath : constant WinUI3.HString := To_HString (relativePath);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.BuildLocalStreamUri (HStr_contentIdentifier, HStr_relativePath, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
         tmp := WindowsDeleteString (HStr_contentIdentifier);
         tmp := WindowsDeleteString (HStr_relativePath);
      end return;
   end;

   function get_DefaultBackgroundColor
   (
      this : in out WebView
   )
   return WinUI3.Windows.UI.Color is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.get_DefaultBackgroundColor (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultBackgroundColor
   (
      this : in out WebView;
      value : WinUI3.Windows.UI.Color
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.put_DefaultBackgroundColor (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NavigationCompleted
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_NavigationCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NavigationCompleted
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_NavigationCompleted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FrameNavigationStarting
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_FrameNavigationStarting (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FrameNavigationStarting
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_FrameNavigationStarting (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FrameContentLoading
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_FrameContentLoading (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FrameContentLoading
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_FrameContentLoading (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FrameDOMContentLoaded
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_FrameDOMContentLoaded (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FrameDOMContentLoaded
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_FrameDOMContentLoaded (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_FrameNavigationCompleted
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_FrameNavigationCompleted (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_FrameNavigationCompleted
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_FrameNavigationCompleted (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_LongRunningScriptDetected
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_LongRunningScriptDetected (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_LongRunningScriptDetected
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_LongRunningScriptDetected (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UnsafeContentWarningDisplaying
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_UnsafeContentWarningDisplaying (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UnsafeContentWarningDisplaying
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_UnsafeContentWarningDisplaying (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_UnviewableContentIdentified
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_UnviewableContentIdentified (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UnviewableContentIdentified
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_UnviewableContentIdentified (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure NavigateWithHttpRequestMessage
   (
      this : in out WebView;
      requestMessage : WinUI3.Windows.Web.Http.HttpRequestMessage'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.NavigateWithHttpRequestMessage (requestMessage.m_IHttpRequestMessage.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Focus
   (
      this : in out WebView;
      value : WinUI3.Windows.UI.Xaml.FocusState
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.Focus (value, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_ContainsFullScreenElement
   (
      this : in out WebView
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView3, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.get_ContainsFullScreenElement (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function add_ContainsFullScreenElementChanged
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView3 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView3, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_ContainsFullScreenElementChanged (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_ContainsFullScreenElementChanged
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView3 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView3, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView3'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_ContainsFullScreenElementChanged (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ExecutionMode
   (
      this : in out WebView
   )
   return WinUI3.Windows.UI.Xaml.Controls.WebViewExecutionMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.WebViewExecutionMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.get_ExecutionMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_DeferredPermissionRequests
   (
      this : in out WebView
   )
   return IVector_IWebViewDeferredPermissionRequest.Kind is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.GenericObject;
      m_GenericRetval  : aliased IVector_IWebViewDeferredPermissionRequest.Kind;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.get_DeferredPermissionRequests (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      m_GenericRetVal := QInterface_IVector_IWebViewDeferredPermissionRequest (m_ComRetVal);
      temp := m_ComRetVal.Release;
      return m_GenericRetVal;
   end;

   function get_Settings
   (
      this : in out WebView
   )
   return WinUI3.Windows.UI.Xaml.Controls.WebViewSettings'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IWebViewSettings;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.WebViewSettings do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.get_Settings (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWebViewSettings := new WinUI3.Windows.UI.Xaml.Controls.IWebViewSettings;
         Retval.m_IWebViewSettings.all := m_ComRetVal;
      end return;
   end;

   function add_UnsupportedUriSchemeIdentified
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_UnsupportedUriSchemeIdentified (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_UnsupportedUriSchemeIdentified
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_UnsupportedUriSchemeIdentified (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_NewWindowRequested
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_NewWindowRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_NewWindowRequested
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_NewWindowRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_PermissionRequested
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_PermissionRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_PermissionRequested
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_PermissionRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure AddWebAllowedObject
   (
      this : in out WebView;
      name : WinUI3.WString;
      pObject : WinUI3.IInspectable
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_name : constant WinUI3.HString := To_HString (name);
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.AddWebAllowedObject (HStr_name, pObject);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_name);
   end;

   function DeferredPermissionRequestById
   (
      this : in out WebView;
      id : WinUI3.UInt32
   )
   return WinUI3.Windows.UI.Xaml.Controls.WebViewDeferredPermissionRequest'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView4 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IWebViewDeferredPermissionRequest;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView4, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView4'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.WebViewDeferredPermissionRequest do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.DeferredPermissionRequestById (id, m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWebViewDeferredPermissionRequest := new WinUI3.Windows.UI.Xaml.Controls.IWebViewDeferredPermissionRequest;
         Retval.m_IWebViewDeferredPermissionRequest.all := m_ComRetVal;
      end return;
   end;

   function get_XYFocusLeft
   (
      this : in out WebView
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.get_XYFocusLeft (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusLeft
   (
      this : in out WebView;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.put_XYFocusLeft (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusRight
   (
      this : in out WebView
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.get_XYFocusRight (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusRight
   (
      this : in out WebView;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.put_XYFocusRight (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusUp
   (
      this : in out WebView
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.get_XYFocusUp (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusUp
   (
      this : in out WebView;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.put_XYFocusUp (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_XYFocusDown
   (
      this : in out WebView
   )
   return WinUI3.Windows.UI.Xaml.DependencyObject'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyObject;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyObject do
         m_Interface := QInterface (this.m_IWebView.all);
         Hr := m_Interface.get_XYFocusDown (m_ComRetVal'Access);
         temp := m_Interface.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDependencyObject := new WinUI3.Windows.UI.Xaml.IDependencyObject;
         Retval.m_IDependencyObject.all := m_ComRetVal;
      end return;
   end;

   procedure put_XYFocusDown
   (
      this : in out WebView;
      value : WinUI3.Windows.UI.Xaml.DependencyObject'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView5 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView5, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView5'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.put_XYFocusDown (value.m_IDependencyObject.all);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_SeparateProcessLost
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView6 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView6, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_SeparateProcessLost (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_SeparateProcessLost
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView6 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView6, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView6'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_SeparateProcessLost (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function add_WebResourceRequested
   (
      this : in out WebView;
      handler : GenericObject
   )
   return WinUI3.Windows.Foundation.EventRegistrationToken is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView7 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.EventRegistrationToken;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView7, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.add_WebResourceRequested (handler, m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure remove_WebResourceRequested
   (
      this : in out WebView;
      token : WinUI3.Windows.Foundation.EventRegistrationToken
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebView7 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebView_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebView7, WinUI3.Windows.UI.Xaml.Controls.IID_IWebView7'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebView.all);
      Hr := m_Interface.remove_WebResourceRequested (token);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewBrush

   procedure Initialize (this : in out WebViewBrush) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewBrush) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewBrush, IWebViewBrush_Ptr);
   begin
      if this.m_IWebViewBrush /= null then
         if this.m_IWebViewBrush.all /= null then
            temp := this.m_IWebViewBrush.all.Release;
            Free (this.m_IWebViewBrush);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for WebViewBrush

   function Constructor return WebViewBrush is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebViewBrush");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IWebViewBrush;
   begin
      return RetVal : WebViewBrush do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IWebViewBrush := new WinUI3.Windows.UI.Xaml.Controls.IWebViewBrush;
            Retval.m_IWebViewBrush.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for WebViewBrush

   function get_SourceNameProperty
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WebViewBrush");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWebViewBrushStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWebViewBrushStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_SourceNameProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewBrush

   function get_SourceName
   (
      this : in out WebViewBrush
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_IWebViewBrush.all.get_SourceName (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_SourceName
   (
      this : in out WebViewBrush;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_IWebViewBrush.all.put_SourceName (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   procedure Redraw
   (
      this : in out WebViewBrush
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewBrush.all.Redraw;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetSource
   (
      this : in out WebViewBrush;
      source : WinUI3.Windows.UI.Xaml.Controls.WebView'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewBrush.all.SetSource (source.m_IWebView.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewContentLoadingEventArgs

   procedure Initialize (this : in out WebViewContentLoadingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewContentLoadingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewContentLoadingEventArgs, IWebViewContentLoadingEventArgs_Ptr);
   begin
      if this.m_IWebViewContentLoadingEventArgs /= null then
         if this.m_IWebViewContentLoadingEventArgs.all /= null then
            temp := this.m_IWebViewContentLoadingEventArgs.all.Release;
            Free (this.m_IWebViewContentLoadingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewContentLoadingEventArgs

   function get_Uri
   (
      this : in out WebViewContentLoadingEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewContentLoadingEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewDOMContentLoadedEventArgs

   procedure Initialize (this : in out WebViewDOMContentLoadedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewDOMContentLoadedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewDOMContentLoadedEventArgs, IWebViewDOMContentLoadedEventArgs_Ptr);
   begin
      if this.m_IWebViewDOMContentLoadedEventArgs /= null then
         if this.m_IWebViewDOMContentLoadedEventArgs.all /= null then
            temp := this.m_IWebViewDOMContentLoadedEventArgs.all.Release;
            Free (this.m_IWebViewDOMContentLoadedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewDOMContentLoadedEventArgs

   function get_Uri
   (
      this : in out WebViewDOMContentLoadedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewDOMContentLoadedEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewDeferredPermissionRequest

   procedure Initialize (this : in out WebViewDeferredPermissionRequest) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewDeferredPermissionRequest) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewDeferredPermissionRequest, IWebViewDeferredPermissionRequest_Ptr);
   begin
      if this.m_IWebViewDeferredPermissionRequest /= null then
         if this.m_IWebViewDeferredPermissionRequest.all /= null then
            temp := this.m_IWebViewDeferredPermissionRequest.all.Release;
            Free (this.m_IWebViewDeferredPermissionRequest);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewDeferredPermissionRequest

   function get_Uri
   (
      this : in out WebViewDeferredPermissionRequest
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewDeferredPermissionRequest.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_PermissionType
   (
      this : in out WebViewDeferredPermissionRequest
   )
   return WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionType;
   begin
      Hr := this.m_IWebViewDeferredPermissionRequest.all.get_PermissionType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Id
   (
      this : in out WebViewDeferredPermissionRequest
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IWebViewDeferredPermissionRequest.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Allow
   (
      this : in out WebViewDeferredPermissionRequest
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewDeferredPermissionRequest.all.Allow;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Deny
   (
      this : in out WebViewDeferredPermissionRequest
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewDeferredPermissionRequest.all.Deny;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewLongRunningScriptDetectedEventArgs

   procedure Initialize (this : in out WebViewLongRunningScriptDetectedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewLongRunningScriptDetectedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewLongRunningScriptDetectedEventArgs, IWebViewLongRunningScriptDetectedEventArgs_Ptr);
   begin
      if this.m_IWebViewLongRunningScriptDetectedEventArgs /= null then
         if this.m_IWebViewLongRunningScriptDetectedEventArgs.all /= null then
            temp := this.m_IWebViewLongRunningScriptDetectedEventArgs.all.Release;
            Free (this.m_IWebViewLongRunningScriptDetectedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewLongRunningScriptDetectedEventArgs

   function get_ExecutionTime
   (
      this : in out WebViewLongRunningScriptDetectedEventArgs
   )
   return WinUI3.Windows.Foundation.TimeSpan is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.TimeSpan;
   begin
      Hr := this.m_IWebViewLongRunningScriptDetectedEventArgs.all.get_ExecutionTime (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_StopPageScriptExecution
   (
      this : in out WebViewLongRunningScriptDetectedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebViewLongRunningScriptDetectedEventArgs.all.get_StopPageScriptExecution (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StopPageScriptExecution
   (
      this : in out WebViewLongRunningScriptDetectedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewLongRunningScriptDetectedEventArgs.all.put_StopPageScriptExecution (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewNavigationCompletedEventArgs

   procedure Initialize (this : in out WebViewNavigationCompletedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewNavigationCompletedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewNavigationCompletedEventArgs, IWebViewNavigationCompletedEventArgs_Ptr);
   begin
      if this.m_IWebViewNavigationCompletedEventArgs /= null then
         if this.m_IWebViewNavigationCompletedEventArgs.all /= null then
            temp := this.m_IWebViewNavigationCompletedEventArgs.all.Release;
            Free (this.m_IWebViewNavigationCompletedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewNavigationCompletedEventArgs

   function get_Uri
   (
      this : in out WebViewNavigationCompletedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewNavigationCompletedEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_IsSuccess
   (
      this : in out WebViewNavigationCompletedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebViewNavigationCompletedEventArgs.all.get_IsSuccess (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_WebErrorStatus
   (
      this : in out WebViewNavigationCompletedEventArgs
   )
   return WinUI3.Windows.Web.WebErrorStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Web.WebErrorStatus;
   begin
      Hr := this.m_IWebViewNavigationCompletedEventArgs.all.get_WebErrorStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewNavigationFailedEventArgs

   procedure Initialize (this : in out WebViewNavigationFailedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewNavigationFailedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewNavigationFailedEventArgs, IWebViewNavigationFailedEventArgs_Ptr);
   begin
      if this.m_IWebViewNavigationFailedEventArgs /= null then
         if this.m_IWebViewNavigationFailedEventArgs.all /= null then
            temp := this.m_IWebViewNavigationFailedEventArgs.all.Release;
            Free (this.m_IWebViewNavigationFailedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewNavigationFailedEventArgs

   function get_Uri
   (
      this : in out WebViewNavigationFailedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewNavigationFailedEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_WebErrorStatus
   (
      this : in out WebViewNavigationFailedEventArgs
   )
   return WinUI3.Windows.Web.WebErrorStatus is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Web.WebErrorStatus;
   begin
      Hr := this.m_IWebViewNavigationFailedEventArgs.all.get_WebErrorStatus (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Delegate WebViewNavigationFailedEventHandler

   function Invoke
   (
      this : access WebViewNavigationFailedEventHandler_Delegate;
      sender : WinUI3.IInspectable;
      e : WinUI3.Windows.UI.Xaml.Controls.IWebViewNavigationFailedEventArgs
   )
   return WinUI3.Hresult is
      Hr : constant WinUI3.HResult := S_OK;
   begin
      this.Callback (sender, e);
      return Hr;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewNavigationStartingEventArgs

   procedure Initialize (this : in out WebViewNavigationStartingEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewNavigationStartingEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewNavigationStartingEventArgs, IWebViewNavigationStartingEventArgs_Ptr);
   begin
      if this.m_IWebViewNavigationStartingEventArgs /= null then
         if this.m_IWebViewNavigationStartingEventArgs.all /= null then
            temp := this.m_IWebViewNavigationStartingEventArgs.all.Release;
            Free (this.m_IWebViewNavigationStartingEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewNavigationStartingEventArgs

   function get_Uri
   (
      this : in out WebViewNavigationStartingEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewNavigationStartingEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_Cancel
   (
      this : in out WebViewNavigationStartingEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebViewNavigationStartingEventArgs.all.get_Cancel (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Cancel
   (
      this : in out WebViewNavigationStartingEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewNavigationStartingEventArgs.all.put_Cancel (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewNewWindowRequestedEventArgs

   procedure Initialize (this : in out WebViewNewWindowRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewNewWindowRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewNewWindowRequestedEventArgs, IWebViewNewWindowRequestedEventArgs_Ptr);
   begin
      if this.m_IWebViewNewWindowRequestedEventArgs /= null then
         if this.m_IWebViewNewWindowRequestedEventArgs.all /= null then
            temp := this.m_IWebViewNewWindowRequestedEventArgs.all.Release;
            Free (this.m_IWebViewNewWindowRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewNewWindowRequestedEventArgs

   function get_Uri
   (
      this : in out WebViewNewWindowRequestedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewNewWindowRequestedEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_Referrer
   (
      this : in out WebViewNewWindowRequestedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewNewWindowRequestedEventArgs.all.get_Referrer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_Handled
   (
      this : in out WebViewNewWindowRequestedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebViewNewWindowRequestedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out WebViewNewWindowRequestedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewNewWindowRequestedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewPermissionRequest

   procedure Initialize (this : in out WebViewPermissionRequest) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewPermissionRequest) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewPermissionRequest, IWebViewPermissionRequest_Ptr);
   begin
      if this.m_IWebViewPermissionRequest /= null then
         if this.m_IWebViewPermissionRequest.all /= null then
            temp := this.m_IWebViewPermissionRequest.all.Release;
            Free (this.m_IWebViewPermissionRequest);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewPermissionRequest

   function get_Uri
   (
      this : in out WebViewPermissionRequest
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewPermissionRequest.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_PermissionType
   (
      this : in out WebViewPermissionRequest
   )
   return WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionType;
   begin
      Hr := this.m_IWebViewPermissionRequest.all.get_PermissionType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Id
   (
      this : in out WebViewPermissionRequest
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_IWebViewPermissionRequest.all.get_Id (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_State
   (
      this : in out WebViewPermissionRequest
   )
   return WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionState is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionState;
   begin
      Hr := this.m_IWebViewPermissionRequest.all.get_State (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Defer
   (
      this : in out WebViewPermissionRequest
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewPermissionRequest.all.Defer;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Allow
   (
      this : in out WebViewPermissionRequest
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewPermissionRequest.all.Allow;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Deny
   (
      this : in out WebViewPermissionRequest
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewPermissionRequest.all.Deny;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewPermissionRequestedEventArgs

   procedure Initialize (this : in out WebViewPermissionRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewPermissionRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewPermissionRequestedEventArgs, IWebViewPermissionRequestedEventArgs_Ptr);
   begin
      if this.m_IWebViewPermissionRequestedEventArgs /= null then
         if this.m_IWebViewPermissionRequestedEventArgs.all /= null then
            temp := this.m_IWebViewPermissionRequestedEventArgs.all.Release;
            Free (this.m_IWebViewPermissionRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewPermissionRequestedEventArgs

   function get_PermissionRequest
   (
      this : in out WebViewPermissionRequestedEventArgs
   )
   return WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionRequest'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.IWebViewPermissionRequest;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.Controls.WebViewPermissionRequest do
         Hr := this.m_IWebViewPermissionRequestedEventArgs.all.get_PermissionRequest (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IWebViewPermissionRequest := new WinUI3.Windows.UI.Xaml.Controls.IWebViewPermissionRequest;
         Retval.m_IWebViewPermissionRequest.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewSeparateProcessLostEventArgs

   procedure Initialize (this : in out WebViewSeparateProcessLostEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewSeparateProcessLostEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewSeparateProcessLostEventArgs, IWebViewSeparateProcessLostEventArgs_Ptr);
   begin
      if this.m_IWebViewSeparateProcessLostEventArgs /= null then
         if this.m_IWebViewSeparateProcessLostEventArgs.all /= null then
            temp := this.m_IWebViewSeparateProcessLostEventArgs.all.Release;
            Free (this.m_IWebViewSeparateProcessLostEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewSeparateProcessLostEventArgs

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewSettings

   procedure Initialize (this : in out WebViewSettings) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewSettings) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewSettings, IWebViewSettings_Ptr);
   begin
      if this.m_IWebViewSettings /= null then
         if this.m_IWebViewSettings.all /= null then
            temp := this.m_IWebViewSettings.all.Release;
            Free (this.m_IWebViewSettings);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewSettings

   function get_IsJavaScriptEnabled
   (
      this : in out WebViewSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebViewSettings.all.get_IsJavaScriptEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsJavaScriptEnabled
   (
      this : in out WebViewSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewSettings.all.put_IsJavaScriptEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IsIndexedDBEnabled
   (
      this : in out WebViewSettings
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebViewSettings.all.get_IsIndexedDBEnabled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IsIndexedDBEnabled
   (
      this : in out WebViewSettings;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewSettings.all.put_IsIndexedDBEnabled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewUnsupportedUriSchemeIdentifiedEventArgs

   procedure Initialize (this : in out WebViewUnsupportedUriSchemeIdentifiedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewUnsupportedUriSchemeIdentifiedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewUnsupportedUriSchemeIdentifiedEventArgs, IWebViewUnsupportedUriSchemeIdentifiedEventArgs_Ptr);
   begin
      if this.m_IWebViewUnsupportedUriSchemeIdentifiedEventArgs /= null then
         if this.m_IWebViewUnsupportedUriSchemeIdentifiedEventArgs.all /= null then
            temp := this.m_IWebViewUnsupportedUriSchemeIdentifiedEventArgs.all.Release;
            Free (this.m_IWebViewUnsupportedUriSchemeIdentifiedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewUnsupportedUriSchemeIdentifiedEventArgs

   function get_Uri
   (
      this : in out WebViewUnsupportedUriSchemeIdentifiedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewUnsupportedUriSchemeIdentifiedEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_Handled
   (
      this : in out WebViewUnsupportedUriSchemeIdentifiedEventArgs
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_IWebViewUnsupportedUriSchemeIdentifiedEventArgs.all.get_Handled (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Handled
   (
      this : in out WebViewUnsupportedUriSchemeIdentifiedEventArgs;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewUnsupportedUriSchemeIdentifiedEventArgs.all.put_Handled (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewUnviewableContentIdentifiedEventArgs

   procedure Initialize (this : in out WebViewUnviewableContentIdentifiedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewUnviewableContentIdentifiedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewUnviewableContentIdentifiedEventArgs, IWebViewUnviewableContentIdentifiedEventArgs_Ptr);
   begin
      if this.m_IWebViewUnviewableContentIdentifiedEventArgs /= null then
         if this.m_IWebViewUnviewableContentIdentifiedEventArgs.all /= null then
            temp := this.m_IWebViewUnviewableContentIdentifiedEventArgs.all.Release;
            Free (this.m_IWebViewUnviewableContentIdentifiedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewUnviewableContentIdentifiedEventArgs

   function get_Uri
   (
      this : in out WebViewUnviewableContentIdentifiedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewUnviewableContentIdentifiedEventArgs.all.get_Uri (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_Referrer
   (
      this : in out WebViewUnviewableContentIdentifiedEventArgs
   )
   return WinUI3.Windows.Foundation.Uri'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IUriRuntimeClass;
   begin
      return RetVal : WinUI3.Windows.Foundation.Uri do
         Hr := this.m_IWebViewUnviewableContentIdentifiedEventArgs.all.get_Referrer (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IUriRuntimeClass := new WinUI3.Windows.Foundation.IUriRuntimeClass;
         Retval.m_IUriRuntimeClass.all := m_ComRetVal;
      end return;
   end;

   function get_MediaType
   (
      this : in out WebViewUnviewableContentIdentifiedEventArgs
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
      function QInterface is new Generic_QueryInterface (WinUI3.Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs_Interface, WinUI3.Windows.UI.Xaml.Controls.IWebViewUnviewableContentIdentifiedEventArgs2, WinUI3.Windows.UI.Xaml.Controls.IID_IWebViewUnviewableContentIdentifiedEventArgs2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_IWebViewUnviewableContentIdentifiedEventArgs.all);
      Hr := m_Interface.get_MediaType (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WebViewWebResourceRequestedEventArgs

   procedure Initialize (this : in out WebViewWebResourceRequestedEventArgs) is
   begin
      null;
   end;

   procedure Finalize (this : in out WebViewWebResourceRequestedEventArgs) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWebViewWebResourceRequestedEventArgs, IWebViewWebResourceRequestedEventArgs_Ptr);
   begin
      if this.m_IWebViewWebResourceRequestedEventArgs /= null then
         if this.m_IWebViewWebResourceRequestedEventArgs.all /= null then
            temp := this.m_IWebViewWebResourceRequestedEventArgs.all.Release;
            Free (this.m_IWebViewWebResourceRequestedEventArgs);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WebViewWebResourceRequestedEventArgs

   function get_Request
   (
      this : in out WebViewWebResourceRequestedEventArgs
   )
   return WinUI3.Windows.Web.Http.HttpRequestMessage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Web.Http.IHttpRequestMessage;
   begin
      return RetVal : WinUI3.Windows.Web.Http.HttpRequestMessage do
         Hr := this.m_IWebViewWebResourceRequestedEventArgs.all.get_Request (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHttpRequestMessage := new WinUI3.Windows.Web.Http.IHttpRequestMessage;
         Retval.m_IHttpRequestMessage.all := m_ComRetVal;
      end return;
   end;

   function get_Response
   (
      this : in out WebViewWebResourceRequestedEventArgs
   )
   return WinUI3.Windows.Web.Http.HttpResponseMessage'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Web.Http.IHttpResponseMessage;
   begin
      return RetVal : WinUI3.Windows.Web.Http.HttpResponseMessage do
         Hr := this.m_IWebViewWebResourceRequestedEventArgs.all.get_Response (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IHttpResponseMessage := new WinUI3.Windows.Web.Http.IHttpResponseMessage;
         Retval.m_IHttpResponseMessage.all := m_ComRetVal;
      end return;
   end;

   procedure put_Response
   (
      this : in out WebViewWebResourceRequestedEventArgs;
      value : WinUI3.Windows.Web.Http.HttpResponseMessage'Class
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWebViewWebResourceRequestedEventArgs.all.put_Response (value.m_IHttpResponseMessage.all);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDeferral
   (
      this : in out WebViewWebResourceRequestedEventArgs
   )
   return WinUI3.Windows.Foundation.Deferral'Class is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.Foundation.IDeferral;
   begin
      return RetVal : WinUI3.Windows.Foundation.Deferral do
         Hr := this.m_IWebViewWebResourceRequestedEventArgs.all.GetDeferral (m_ComRetVal'Access);
         if Hr /= S_OK then
            raise Program_Error;
         end if;
         Retval.m_IDeferral := new WinUI3.Windows.Foundation.IDeferral;
         Retval.m_IDeferral.all := m_ComRetVal;
      end return;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for WrapGrid

   procedure Initialize (this : in out WrapGrid) is
   begin
      null;
   end;

   procedure Finalize (this : in out WrapGrid) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IWrapGrid, IWrapGrid_Ptr);
   begin
      if this.m_IWrapGrid /= null then
         if this.m_IWrapGrid.all /= null then
            temp := this.m_IWrapGrid.all.Release;
            Free (this.m_IWrapGrid);
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Constructors for WrapGrid

   function Constructor return WrapGrid is
      Hr           : WinUI3.HResult := S_OK;
      tmp          : WinUI3.HResult := S_OK;
      m_hString    : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WrapGrid");
      m_ComRetVal  : aliased WinUI3.Windows.UI.Xaml.Controls.IWrapGrid;
   begin
      return RetVal : WrapGrid do
         Hr := RoActivateInstance (m_hString, m_ComRetVal'Address);
         if Hr = S_OK then
            Retval.m_IWrapGrid := new WinUI3.Windows.UI.Xaml.Controls.IWrapGrid;
            Retval.m_IWrapGrid.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for WrapGrid

   function get_ItemWidthProperty_WrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemWidthProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_ItemHeightProperty_WrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_ItemHeightProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_OrientationProperty_WrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_OrientationProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_HorizontalChildrenAlignmentProperty_WrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_HorizontalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_VerticalChildrenAlignmentProperty_WrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_VerticalChildrenAlignmentProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   function get_MaximumRowsOrColumnsProperty_WrapGrid
   return WinUI3.Windows.UI.Xaml.DependencyProperty is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Windows.UI.Xaml.Controls.WrapGrid");
      m_Factory        : access WinUI3.Windows.UI.Xaml.Controls.IWrapGridStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.IDependencyProperty;
   begin
      return RetVal : WinUI3.Windows.UI.Xaml.DependencyProperty do
         Hr := RoGetActivationFactory (m_hString, IID_IWrapGridStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaximumRowsOrColumnsProperty (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
            Retval.m_IDependencyProperty := new WinUI3.Windows.UI.Xaml.IDependencyProperty;
            Retval.m_IDependencyProperty.all := m_ComRetVal;
         end if;
         tmp := WindowsDeleteString (m_hString);
      end return;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for WrapGrid

   function get_ItemWidth
   (
      this : in out WrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IWrapGrid.all.get_ItemWidth (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemWidth
   (
      this : in out WrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_ItemWidth (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_ItemHeight
   (
      this : in out WrapGrid
   )
   return WinUI3.Double is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Double;
   begin
      Hr := this.m_IWrapGrid.all.get_ItemHeight (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ItemHeight
   (
      this : in out WrapGrid;
      value : WinUI3.Double
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_ItemHeight (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Orientation
   (
      this : in out WrapGrid
   )
   return WinUI3.Windows.UI.Xaml.Controls.Orientation is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.Controls.Orientation;
   begin
      Hr := this.m_IWrapGrid.all.get_Orientation (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Orientation
   (
      this : in out WrapGrid;
      value : WinUI3.Windows.UI.Xaml.Controls.Orientation
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_Orientation (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_HorizontalChildrenAlignment
   (
      this : in out WrapGrid
   )
   return WinUI3.Windows.UI.Xaml.HorizontalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.HorizontalAlignment;
   begin
      Hr := this.m_IWrapGrid.all.get_HorizontalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_HorizontalChildrenAlignment
   (
      this : in out WrapGrid;
      value : WinUI3.Windows.UI.Xaml.HorizontalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_HorizontalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_VerticalChildrenAlignment
   (
      this : in out WrapGrid
   )
   return WinUI3.Windows.UI.Xaml.VerticalAlignment is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Xaml.VerticalAlignment;
   begin
      Hr := this.m_IWrapGrid.all.get_VerticalChildrenAlignment (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_VerticalChildrenAlignment
   (
      this : in out WrapGrid;
      value : WinUI3.Windows.UI.Xaml.VerticalAlignment
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_VerticalChildrenAlignment (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_MaximumRowsOrColumns
   (
      this : in out WrapGrid
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_IWrapGrid.all.get_MaximumRowsOrColumns (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_MaximumRowsOrColumns
   (
      this : in out WrapGrid;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_IWrapGrid.all.put_MaximumRowsOrColumns (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

end WinUI3.Windows.UI.Xaml.Controls;
