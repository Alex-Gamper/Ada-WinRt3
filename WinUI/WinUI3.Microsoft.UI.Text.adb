--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2023 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-WinRT                                                               --
--    Version   : 3.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with WinUI3.Windows.Foundation; use WinUI3.Windows.Foundation;
with WinUI3.Windows.Storage.Streams;
with WinUI3.Windows.UI;
with WinUI3.Windows.UI.Text;
with Ada.Unchecked_Deallocation;
--------------------------------------------------------------------------------
package body WinUI3.Microsoft.UI.Text is

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for FontWeights

   procedure Initialize (this : in out FontWeights) is
   begin
      null;
   end;

   procedure Finalize (this : in out FontWeights) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (IFontWeights, IFontWeights_Ptr);
   begin
      if this.m_IFontWeights /= null then
         if this.m_IFontWeights.all /= null then
            temp := this.m_IFontWeights.all.Release;
            if temp < 1 then
               Free (this.m_IFontWeights);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Static Interfaces for FontWeights

   function get_Black
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Black (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_Bold
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Bold (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_ExtraBlack
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_ExtraBlack (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_ExtraBold
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_ExtraBold (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_ExtraLight
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_ExtraLight (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_Light
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Light (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_Medium
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Medium (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_Normal
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Normal (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_SemiBold
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_SemiBold (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_SemiLight
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_SemiLight (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   function get_Thin
   return WinUI3.Windows.UI.Text.FontWeight is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.FontWeights");
      m_Factory        : access WinUI3.Microsoft.UI.Text.IFontWeightsStatics_Interface'Class := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontWeight;
   begin
      Hr := RoGetActivationFactory (m_hString, IID_IFontWeightsStatics'Access , m_Factory'Address);
      if Hr = S_OK then
         Hr := m_Factory.get_Thin (m_ComRetVal'Access);
         temp := m_Factory.Release;
         if Hr /= S_OK then
            raise Program_Error;
         end if;
      end if;
      tmp := WindowsDeleteString (m_hString);
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for FontWeights

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditTextDocument

   procedure Initialize (this : in out RichEditTextDocument) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditTextDocument) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextDocument, ITextDocument_Ptr);
   begin
      if this.m_ITextDocument /= null then
         if this.m_ITextDocument.all /= null then
            temp := this.m_ITextDocument.all.Release;
            if temp < 1 then
               Free (this.m_ITextDocument);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditTextDocument

   function get_CaretType
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Microsoft.UI.Text.CaretType is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.CaretType;
   begin
      Hr := this.m_ITextDocument.all.get_CaretType (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CaretType
   (
      this : in out RichEditTextDocument;
      value : WinUI3.Microsoft.UI.Text.CaretType
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.put_CaretType (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_DefaultTabStop
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Single is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Single;
   begin
      Hr := this.m_ITextDocument.all.get_DefaultTabStop (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_DefaultTabStop
   (
      this : in out RichEditTextDocument;
      value : WinUI3.Single
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.put_DefaultTabStop (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Selection
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Microsoft.UI.Text.ITextSelection is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextSelection;
   begin
      Hr := this.m_ITextDocument.all.get_Selection (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_UndoLimit
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.UInt32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.UInt32;
   begin
      Hr := this.m_ITextDocument.all.get_UndoLimit (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_UndoLimit
   (
      this : in out RichEditTextDocument;
      value : WinUI3.UInt32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.put_UndoLimit (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function CanCopy
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextDocument.all.CanCopy (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function CanPaste
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextDocument.all.CanPaste (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function CanRedo
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextDocument.all.CanRedo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function CanUndo
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextDocument.all.CanUndo (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function ApplyDisplayUpdates
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextDocument.all.ApplyDisplayUpdates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function BatchDisplayUpdates
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextDocument.all.BatchDisplayUpdates (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure BeginUndoGroup
   (
      this : in out RichEditTextDocument
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.BeginUndoGroup;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure EndUndoGroup
   (
      this : in out RichEditTextDocument
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.EndUndoGroup;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetDefaultCharacterFormat
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Microsoft.UI.Text.ITextCharacterFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextCharacterFormat;
   begin
      Hr := this.m_ITextDocument.all.GetDefaultCharacterFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetDefaultParagraphFormat
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Microsoft.UI.Text.ITextParagraphFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextParagraphFormat;
   begin
      Hr := this.m_ITextDocument.all.GetDefaultParagraphFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetRange
   (
      this : in out RichEditTextDocument;
      startPosition : WinUI3.Int32;
      endPosition : WinUI3.Int32
   )
   return WinUI3.Microsoft.UI.Text.ITextRange is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextRange;
   begin
      Hr := this.m_ITextDocument.all.GetRange (startPosition, endPosition, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetRangeFromPoint
   (
      this : in out RichEditTextDocument;
      point : WinUI3.Windows.Foundation.Point;
      options : WinUI3.Microsoft.UI.Text.PointOptions
   )
   return WinUI3.Microsoft.UI.Text.ITextRange is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextRange;
   begin
      Hr := this.m_ITextDocument.all.GetRangeFromPoint (point, options, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure GetText
   (
      this : in out RichEditTextDocument;
      options : WinUI3.Microsoft.UI.Text.TextGetOptions;
      value : WinUI3.HString_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.GetText (options, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure LoadFromStream
   (
      this : in out RichEditTextDocument;
      options : WinUI3.Microsoft.UI.Text.TextSetOptions;
      value : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.LoadFromStream (options, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Redo
   (
      this : in out RichEditTextDocument
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.Redo;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SaveToStream
   (
      this : in out RichEditTextDocument;
      options : WinUI3.Microsoft.UI.Text.TextGetOptions;
      value : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.SaveToStream (options, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDefaultCharacterFormat
   (
      this : in out RichEditTextDocument;
      value : WinUI3.Microsoft.UI.Text.ITextCharacterFormat
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.SetDefaultCharacterFormat (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetDefaultParagraphFormat
   (
      this : in out RichEditTextDocument;
      value : WinUI3.Microsoft.UI.Text.ITextParagraphFormat
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.SetDefaultParagraphFormat (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetText
   (
      this : in out RichEditTextDocument;
      options : WinUI3.Microsoft.UI.Text.TextSetOptions;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextDocument.all.SetText (options, HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   procedure Undo
   (
      this : in out RichEditTextDocument
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.Undo;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_AlignmentIncludesTrailingWhitespace
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextDocument.all.get_AlignmentIncludesTrailingWhitespace (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_AlignmentIncludesTrailingWhitespace
   (
      this : in out RichEditTextDocument;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.put_AlignmentIncludesTrailingWhitespace (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_IgnoreTrailingCharacterSpacing
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextDocument.all.get_IgnoreTrailingCharacterSpacing (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_IgnoreTrailingCharacterSpacing
   (
      this : in out RichEditTextDocument;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.put_IgnoreTrailingCharacterSpacing (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ClearUndoRedoHistory
   (
      this : in out RichEditTextDocument
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextDocument.all.ClearUndoRedoHistory;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetMathMode
   (
      this : in out RichEditTextDocument
   )
   return WinUI3.Microsoft.UI.Text.RichEditMathMode is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Text.ITextDocument2 := null;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.RichEditMathMode;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Text.ITextDocument_Interface, WinUI3.Microsoft.UI.Text.ITextDocument2, WinUI3.Microsoft.UI.Text.IID_ITextDocument2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextDocument.all);
      Hr := m_Interface.GetMathMode (m_ComRetVal'Access);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure SetMathMode
   (
      this : in out RichEditTextDocument;
      mode : WinUI3.Microsoft.UI.Text.RichEditMathMode
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Text.ITextDocument2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Text.ITextDocument_Interface, WinUI3.Microsoft.UI.Text.ITextDocument2, WinUI3.Microsoft.UI.Text.IID_ITextDocument2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextDocument.all);
      Hr := m_Interface.SetMathMode (mode);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GetMathML
   (
      this : in out RichEditTextDocument;
      value : WinUI3.HString_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Text.ITextDocument2 := null;
      temp             : WinUI3.UInt32 := 0;
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Text.ITextDocument_Interface, WinUI3.Microsoft.UI.Text.ITextDocument2, WinUI3.Microsoft.UI.Text.IID_ITextDocument2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextDocument.all);
      Hr := m_Interface.GetMathML (value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetMathML
   (
      this : in out RichEditTextDocument;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      m_Interface      : WinUI3.Microsoft.UI.Text.ITextDocument2 := null;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
      function QInterface is new Generic_QueryInterface (WinUI3.Microsoft.UI.Text.ITextDocument_Interface, WinUI3.Microsoft.UI.Text.ITextDocument2, WinUI3.Microsoft.UI.Text.IID_ITextDocument2'Unchecked_Access);
   begin
      m_Interface := QInterface (this.m_ITextDocument.all);
      Hr := m_Interface.SetMathML (HStr_value);
      temp := m_Interface.Release;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   -----------------------------------------------------------------------------
   -- RuntimeClass Initialization/Finalization for RichEditTextRange

   procedure Initialize (this : in out RichEditTextRange) is
   begin
      null;
   end;

   procedure Finalize (this : in out RichEditTextRange) is
      temp : WinUI3.UInt32 := 0;
      procedure Free is new Ada.Unchecked_Deallocation (ITextRange, ITextRange_Ptr);
   begin
      if this.m_ITextRange /= null then
         if this.m_ITextRange.all /= null then
            temp := this.m_ITextRange.all.Release;
            if temp < 1 then
               Free (this.m_ITextRange);
            end if;
         end if;
      end if;
   end;

   -----------------------------------------------------------------------------
   -- Implemented Interfaces for RichEditTextRange

   function get_Character
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Wide_Char is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Wide_Char;
   begin
      Hr := this.m_ITextRange.all.get_Character (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Character
   (
      this : in out RichEditTextRange;
      value : WinUI3.Wide_Char
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.put_Character (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_CharacterFormat
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Microsoft.UI.Text.ITextCharacterFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextCharacterFormat;
   begin
      Hr := this.m_ITextRange.all.get_CharacterFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_CharacterFormat
   (
      this : in out RichEditTextRange;
      value : WinUI3.Microsoft.UI.Text.ITextCharacterFormat
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.put_CharacterFormat (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_FormattedText
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Microsoft.UI.Text.ITextRange is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextRange;
   begin
      Hr := this.m_ITextRange.all.get_FormattedText (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_FormattedText
   (
      this : in out RichEditTextRange;
      value : WinUI3.Microsoft.UI.Text.ITextRange
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.put_FormattedText (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_EndPosition
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.get_EndPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_EndPosition
   (
      this : in out RichEditTextRange;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.put_EndPosition (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Gravity
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Microsoft.UI.Text.RangeGravity is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.RangeGravity;
   begin
      Hr := this.m_ITextRange.all.get_Gravity (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_Gravity
   (
      this : in out RichEditTextRange;
      value : WinUI3.Microsoft.UI.Text.RangeGravity
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.put_Gravity (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_Length
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.get_Length (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Link
   (
      this : in out RichEditTextRange
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextRange.all.get_Link (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Link
   (
      this : in out RichEditTextRange;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextRange.all.put_Link (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function get_ParagraphFormat
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Microsoft.UI.Text.ITextParagraphFormat is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextParagraphFormat;
   begin
      Hr := this.m_ITextRange.all.get_ParagraphFormat (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_ParagraphFormat
   (
      this : in out RichEditTextRange;
      value : WinUI3.Microsoft.UI.Text.ITextParagraphFormat
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.put_ParagraphFormat (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StartPosition
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.get_StartPosition (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure put_StartPosition
   (
      this : in out RichEditTextRange;
      value : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.put_StartPosition (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function get_StoryLength
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.get_StoryLength (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function get_Text
   (
      this : in out RichEditTextRange
   )
   return WinUI3.WString is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.HString;
      AdaRetval        : WString;
   begin
      Hr := this.m_ITextRange.all.get_Text (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      AdaRetval := To_Ada (m_ComRetVal);
      tmp := WindowsDeleteString (m_ComRetVal);
      return AdaRetVal;
   end;

   procedure put_Text
   (
      this : in out RichEditTextRange;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextRange.all.put_Text (HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   function CanPaste
   (
      this : in out RichEditTextRange;
      format : WinUI3.Int32
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextRange.all.CanPaste (format, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure ChangeCase
   (
      this : in out RichEditTextRange;
      value : WinUI3.Microsoft.UI.Text.LetterCase
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.ChangeCase (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Collapse
   (
      this : in out RichEditTextRange;
      value : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.Collapse (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Copy
   (
      this : in out RichEditTextRange
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.Copy;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure Cut
   (
      this : in out RichEditTextRange
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.Cut;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function Delete
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit;
      count : WinUI3.Int32
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.Delete (unit, count, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function EndOf
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit;
      extend : WinUI3.Boolean
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.EndOf (unit, extend, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Expand
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.Expand (unit, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function FindText
   (
      this : in out RichEditTextRange;
      value : WinUI3.WString;
      scanLength : WinUI3.Int32;
      options : WinUI3.Microsoft.UI.Text.FindOptions
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextRange.all.FindText (HStr_value, scanLength, options, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
      return m_ComRetVal;
   end;

   procedure GetCharacterUtf32
   (
      this : in out RichEditTextRange;
      value : WinUI3.UInt32_Ptr;
      offset : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.GetCharacterUtf32 (value, offset);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function GetClone
   (
      this : in out RichEditTextRange
   )
   return WinUI3.Microsoft.UI.Text.ITextRange is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Microsoft.UI.Text.ITextRange;
   begin
      Hr := this.m_ITextRange.all.GetClone (m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function GetIndex
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.GetIndex (unit, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure GetPoint
   (
      this : in out RichEditTextRange;
      horizontalAlign : WinUI3.Microsoft.UI.Text.HorizontalCharacterAlignment;
      verticalAlign : WinUI3.Microsoft.UI.Text.VerticalCharacterAlignment;
      options : WinUI3.Microsoft.UI.Text.PointOptions;
      point : WinUI3.Windows.Foundation.Point_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.GetPoint (horizontalAlign, verticalAlign, options, point);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GetRect
   (
      this : in out RichEditTextRange;
      options : WinUI3.Microsoft.UI.Text.PointOptions;
      rect : WinUI3.Windows.Foundation.Rect_Ptr;
      hit : WinUI3.Int32_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.GetRect (options, rect, hit);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GetText
   (
      this : in out RichEditTextRange;
      options : WinUI3.Microsoft.UI.Text.TextGetOptions;
      value : WinUI3.HString_Ptr
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.GetText (options, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure GetTextViaStream
   (
      this : in out RichEditTextRange;
      options : WinUI3.Microsoft.UI.Text.TextGetOptions;
      value : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.GetTextViaStream (options, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function InRange
   (
      this : in out RichEditTextRange;
      range_x : WinUI3.Microsoft.UI.Text.ITextRange
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextRange.all.InRange (range_x, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure InsertImage
   (
      this : in out RichEditTextRange;
      width : WinUI3.Int32;
      height : WinUI3.Int32;
      ascent : WinUI3.Int32;
      verticalAlign : WinUI3.Microsoft.UI.Text.VerticalCharacterAlignment;
      alternateText : WinUI3.WString;
      value : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_alternateText : constant WinUI3.HString := To_HString (alternateText);
   begin
      Hr := this.m_ITextRange.all.InsertImage (width, height, ascent, verticalAlign, HStr_alternateText, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_alternateText);
   end;

   function InStory
   (
      this : in out RichEditTextRange;
      range_x : WinUI3.Microsoft.UI.Text.ITextRange
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextRange.all.InStory (range_x, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function IsEqual
   (
      this : in out RichEditTextRange;
      range_x : WinUI3.Microsoft.UI.Text.ITextRange
   )
   return WinUI3.Boolean is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Boolean;
   begin
      Hr := this.m_ITextRange.all.IsEqual (range_x, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function Move
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit;
      count : WinUI3.Int32
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.Move (unit, count, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function MoveEnd
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit;
      count : WinUI3.Int32
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.MoveEnd (unit, count, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   function MoveStart
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit;
      count : WinUI3.Int32
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.MoveStart (unit, count, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   procedure Paste
   (
      this : in out RichEditTextRange;
      format : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.Paste (format);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure ScrollIntoView
   (
      this : in out RichEditTextRange;
      value : WinUI3.Microsoft.UI.Text.PointOptions
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.ScrollIntoView (value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure MatchSelection
   (
      this : in out RichEditTextRange
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.MatchSelection;
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetIndex
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit;
      index : WinUI3.Int32;
      extend : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.SetIndex (unit, index, extend);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetPoint
   (
      this : in out RichEditTextRange;
      point : WinUI3.Windows.Foundation.Point;
      options : WinUI3.Microsoft.UI.Text.PointOptions;
      extend : WinUI3.Boolean
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.SetPoint (point, options, extend);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetRange
   (
      this : in out RichEditTextRange;
      startPosition : WinUI3.Int32;
      endPosition : WinUI3.Int32
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.SetRange (startPosition, endPosition);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   procedure SetText
   (
      this : in out RichEditTextRange;
      options : WinUI3.Microsoft.UI.Text.TextSetOptions;
      value : WinUI3.WString
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      HStr_value : constant WinUI3.HString := To_HString (value);
   begin
      Hr := this.m_ITextRange.all.SetText (options, HStr_value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      tmp := WindowsDeleteString (HStr_value);
   end;

   procedure SetTextViaStream
   (
      this : in out RichEditTextRange;
      options : WinUI3.Microsoft.UI.Text.TextSetOptions;
      value : WinUI3.Windows.Storage.Streams.IRandomAccessStream
   ) is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
   begin
      Hr := this.m_ITextRange.all.SetTextViaStream (options, value);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
   end;

   function StartOf
   (
      this : in out RichEditTextRange;
      unit : WinUI3.Microsoft.UI.Text.TextRangeUnit;
      extend : WinUI3.Boolean
   )
   return WinUI3.Int32 is
      Hr               : WinUI3.HResult := S_OK;
      tmp              : WinUI3.HResult := S_OK;
      temp             : WinUI3.UInt32 := 0;
      m_ComRetVal      : aliased WinUI3.Int32;
   begin
      Hr := this.m_ITextRange.all.StartOf (unit, extend, m_ComRetVal'Access);
      if Hr /= S_OK then
         raise Program_Error;
      end if;
      return m_ComRetVal;
   end;

   -----------------------------------------------------------------------------
   -- Static RuntimeClass
   package body TextConstants is

      function get_AutoColor
      return WinUI3.Windows.UI.Color is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_AutoColor (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_MinUnitCount
      return WinUI3.Int32 is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Int32;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MinUnitCount (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_MaxUnitCount
      return WinUI3.Int32 is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Int32;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_MaxUnitCount (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_UndefinedColor
      return WinUI3.Windows.UI.Color is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Windows.UI.Color;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UndefinedColor (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_UndefinedFloatValue
      return WinUI3.Single is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Single;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UndefinedFloatValue (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_UndefinedInt32Value
      return WinUI3.Int32 is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Int32;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UndefinedInt32Value (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_UndefinedFontStretch
      return WinUI3.Windows.UI.Text.FontStretch is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStretch;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UndefinedFontStretch (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

      function get_UndefinedFontStyle
      return WinUI3.Windows.UI.Text.FontStyle is
         Hr               : WinUI3.HResult := S_OK;
         tmp              : WinUI3.HResult := S_OK;
         m_hString        : constant WinUI3.HString := To_HString ("Microsoft.UI.Text.TextConstants");
         m_Factory        : access WinUI3.Microsoft.UI.Text.ITextConstantsStatics_Interface'Class := null;
         temp             : WinUI3.UInt32 := 0;
         m_ComRetVal      : aliased WinUI3.Windows.UI.Text.FontStyle;
      begin
         Hr := RoGetActivationFactory (m_hString, IID_ITextConstantsStatics'Access , m_Factory'Address);
         if Hr = S_OK then
            Hr := m_Factory.get_UndefinedFontStyle (m_ComRetVal'Access);
            temp := m_Factory.Release;
            if Hr /= S_OK then
               raise Program_Error;
            end if;
         end if;
         tmp := WindowsDeleteString (m_hString);
         return m_ComRetVal;
      end;

   end TextConstants;

end WinUI3.Microsoft.UI.Text;
